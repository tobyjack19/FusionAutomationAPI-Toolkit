// API Version "feature--fas-gaia-2604.0_2604.90.127".

export declare namespace adsk {
  /**
     Temporarily halts the execution of the add-in or script and 
     gives Fusion 360 a chance to handle any queued up messages.
     @returns Returns True if the call was successful.
   */
  function doEvents(): boolean
  
  /**
    Serialized JSON object passed to script containing custom parameters.
   */
  let parameters: string
  
  /**
    Serialized JSON object returned to script's caller following successful execution.
   */
  let result: string
  
  /**
    Log messages returned to script's caller during execution.
   */
  function log(message: any): void
  /**
    Creates a Base64-encoded ASCII string from a binary string.
   */
  function btoa(data: string | Uint8Array, urlSafe?: boolean/* = false*/): string
  /**
    Decodes a string of data which has been encoded using Base64 encoding.
   */
  function atob(data: string | Uint8Array, urlSafe?: boolean/* = false*/): string
  /**
    Reads the text/JSON file and returns as string.
   */
  function readFileSync(path: string): string
  /**
    Reads the binary file and returns as buffer.
   */
  function readBufferSync(path: string): Uint8Array
  /**
    Writes the text Bytes contents into file.
    Supported format types: utf8, binary. Default format - utf8
   */
  function writeFileSync(path: string, data: string, format: string/* = utf8*/): void
  /**
    Writes the UTF8/Raw Bytes contents into file.
   */
  function writeBufferSync(path: string, buffer: Uint8Array): void
  /**
    Download a base64 encoded file.
    @param {object} dataFile The data file to download.
    @returns {string} The base64 encoded file.
   */
  function downloadDataFileAsBase64(dataFile: adsk.core.DataFile): string
  /**
    Report the current status of the workitem.
    @param {string} status The status of the workitem.
    @returns {boolean} 0 if the status was successfully reported.
   */
  function onProgress(progress: string): number
  /**
   Ask for additional data to be downloaded on demand.
   @param {string} Name of the onDemand input parameter as specified in the Activity
   @param {string} A query string - optional parameters that can be addded to the url defined in the WorkItem
   @param {string} HTTP call headers.
   @param {string} Tells the system the filename under which the onDemand file is saved by the http call, must start with 'file://'.
   @returns {string} 
   */
  function getOnDemandFile(name: string, suffix: string, headers: string, responseFile: string): string
}

export declare namespace adsk.core {

  /**
    Errors that every API call can return via Application::GetLastError.
    These can be augmented with class and function specific errors.
  */
  const enum GenericErrors {
    /**
      No error occurred.
    */
    Ok = 0,
    /**
      An internal error occurred - e.g. a library function throw an exception.
    */
    UnexpectedError,
    /**
      Internal API validation failed
    */
    InternalValidationError,
    /**
      The client made some sort of mistake calling the API object
    */
    BadApiCallError,
    /**
      The API object is referencing a Neutron object that has been deleted.
    */
    UnderlyingObjectDeletedError,
    /**
      The API operation failed with the supplied error message.
    */
    OperationFailed,
    /**
      e.g. Errors related to bad value expressions or units - e.g. "1 in + 1 Kg" is an invalid expression
    */
    ExpressionError,
    /**
      When creating or changing an object via reference geometry, the geometry wasn't specified correctly (e.g. an Occurrence needs to be specified).
    */
    InvalidGeometryError,
    /**
      Errors reserved for several functions in a class.
    */
    ClassSpecificError = 100,
    /**
      Errors reserved for a specific function in a class.
    */
    FunctionSpecificError = 200,
  }

  /**
    Log message level
  */
  const enum LogLevels {
    /**
      Use this type to log error message.
    */
    ErrorLogLevel = 0,
    /**
      Use this type to log warning message.
    */
    WarningLogLevel,
    /**
      Use this type to log info message.
    */
    InfoLogLevel,
  }

  /**
    Location where messages should be logged.
  */
  const enum LogTypes {
    /**
      Log information to the Fusion app log file.
    */
    FileLogType = 0,
    /**
      Log information to Fusion text command window. This logs only the
      provided message string.
    */
    ConsoleLogType,
  }

  /**
    The base class that all other classes are derived from.
  */
  abstract class Base {
    /**
      This property is supported by all objects in the API and returns a string that contains
      the full name (namespace::objecttype) describing the type of the object.
      It's often useful to use this in combination with the classType method to see if an object
      is a certain type. For example: if obj.objectType == adsk.core.Point3D.classType():
    */
    readonly objectType: string
    /**
      Static function that all classes support that returns the type of the class as a string.
      The returned string matches the string returned by the objectType property. For example if you
      have a reference to an object and you want to check if it's a SketchLine you can use
      myObject.objectType == fusion.SketchLine.classType().
      @returns Returns a string indicating the type of the object.
    */
    static classType(): string
    /**
      Indicates if this object is still valid, i.e. hasn't been deleted
      or some other action done to invalidate the reference.
    */
    readonly isValid: boolean
  }

  /**
    Objects can have several Event properties that fire when
    some 'event' occurs. Clients can attach EventHandlers
    to one or more Events and they get notified when the 'event' occurs.
    This is a base class - classes like DocumentEvent add type safety
    (i.e. only allow the correct type of handler to be added to them).
  */
  abstract class Event extends Base {
    /**
      The name of the event - e.g. "DocumentOpening"
    */
    readonly name: string
    /**
      The object that is firing the event. For example, in the case of a command
      input event this will return the command.
    */
    readonly sender: Base
  }

  /**
    When an event handler is called, it is passed
    an EventArgs object that describes the 'event'.
    This is a base class - classes like DocumentEventArgs add more information on
    the 'event'.
  */
  abstract class EventArgs extends Base {
    /**
      The event that the firing is in response to.
    */
    readonly firingEvent: Event
  }

  /**
    A client supplies an EventHandler and adds it to one or more Events in
    order to be notified when the 'event' occurs.
    The EventHandler can be explicitly removed from the Event or
    if it is deleted it is automatically removed.
    This is a base class - classes like DocumentEventHandler add type safety.
  */
  abstract class EventHandler {
  }

  /**
    The top-level object that represents the Fusion application (all of Fusion).
    This provides access to the modeler and files.
  */
  abstract class Application extends Base {
    /**
      Access to the root Application object.
      @returns Return the root Application object or null if it failed.
    */
    static get(): Application | null
    /**
      Returns the Documents collection object which supports accessing
      opened documents, opening existing documents, and creating new documents.
    */
    readonly documents: Documents
    /**
      Returns the current active document.
    */
    readonly activeDocument: Document
    /**
      Returns the current active product.
    */
    readonly activeProduct: Product
    /**
      Returns the currently active graphics view.
    */
    readonly activeViewport: Viewport
    /**
      Returns the current edit target as seen in the user interface. This edit target
      is defined as the container object that will be added to if something is created.
      For example, a component can be an edit target so that when new bodies are created they
      are added to that component. A sketch can also be an edit target.
    */
    readonly activeEditObject: core.Base
    /**
      Returns the Data object which provides access the files.
    */
    readonly data: Data
    /**
      The modeling tolerance used internally when comparing two points. The value is in centimeters.
    */
    readonly pointTolerance: number
    /**
      The modeling tolerance used when comparing vector angles. The value is in radians.
    */
    readonly vectorAngleTolerance: number
    /**
      Provides access to all of the application preferences.
    */
    readonly preferences: Preferences
    /**
      The DocumentOpening event fires at the VERY start of a document being opened.
      There is no promise that the document will be opened, hence
      a documentOpened event may not follow.
      When a document is being opened that references other documents, only the
      top-level document will cause a documentOpening event to be fired.
    */
    readonly documentOpening: DocumentEvent
    /**
      The DocumentOpened event fires at the VERY end of a document being opened so the
      Document object is available to be used.
      When a document is opened that references other documents, only the top-level
      document will cause the documentOpened event to be fired. You can access the
      referenced documents by using the documentReferences property of the Document object.
    */
    readonly documentOpened: DocumentEvent
    /**
      Provides access to functionality specific to the user interface.
    */
    readonly userInterface: UserInterface
    /**
      Returns the collection of material libraries currently available.
    */
    readonly materialLibraries: MaterialLibraries
    /**
      Returns the set of favorite materials.
    */
    readonly favoriteMaterials: FavoriteMaterials
    /**
      Returns the set of favorite appearances.
    */
    readonly favoriteAppearances: FavoriteAppearances
    /**
      Returns an array containing the names of the products types currently
      supported by Fusion. For example, the name returned for Fusion is
      "DesignProductType". These product type names are used to identify
      specific products in some other API functions such as the productType
      property on the Workspace and ToolbarPanel objects.
    */
    readonly supportedProductTypes: string[]
    /**
      Returns the ImportManager. You use the ImportManager
      to import files (of various neutral formats.) into existing components or new document.
    */
    readonly importManager: ImportManager
    /**
      Returns the user name of the Autodesk account currently logged in.
    */
    readonly userName: string
    /**
      Returns the internal name of the Autodesk account currently logged in.
      This can be used by applications sold through the Autodesk Exchange Store
      to verify that the user has in fact purchased the product.
    */
    readonly userId: string
    /**
      Gets and sets if Fusion is offline or not.
    */
    isOffLine: boolean
    /**
      Boolean property indicating whether Fusion has completed its initialization.
      This includes initialization of all the Add-ins loaded at startup.
    */
    readonly isStartupComplete: boolean
    /**
      The onlineStatusChanged event fires immediately after Fusion goes online or offline.
      This event fires whether or not the online status was changed deliberately by the user by using the Fusion
      'Work Offline' command or because of inadvertent network/Internet connectivity issues.
      You can get the isOffline property of ApplicationEventArgs to determine whether Fusion has gone Offline or
      has come back online.
      The client can add or remove ApplicationEventHandlers from the ApplicationEvent.
    */
    readonly onlineStatusChanged: ApplicationEvent
    /**
      The startupCompleted event fires after Fusion has completed its initialization.
      This includes initialization of all the Add-ins loaded at startup.
      The client can add or remove ApplicationEventHandlers from the ApplicationEvent.
    */
    readonly startupCompleted: ApplicationEvent
    /**
      Returns the User that is currently logged in.
    */
    readonly currentUser: User
    /**
      The insertingFromURL event fires when the user has clicked a link in a web
      page that uses the Fusion protocol handler to insert a file as new component.
      This event is fired at the beginning of the request but before Fusion has
      take any action so that it's still possible to cancel the operation.
    */
    readonly insertingFromURL: WebRequestEvent
    /**
      The insertedFromURL event fires after the user has clicked a link in a web
      page that uses the Fusion protocol handler to insert a file as new component
      and that operation has completed.
    */
    readonly insertedFromURL: WebRequestEvent
    /**
      The openingFromURL event fires when the user has clicked a link in a web
      page that uses the Fusion protocol handler to create a new file using an
      existing file as the initial contents. This event is fired at the beginning
      of the request but before Fusion has take any action so that it's still
      possible to cancel the operation.
    */
    readonly openingFromURL: WebRequestEvent
    /**
      The openedFromURL event fires after the user has clicked a link in a web
      page that uses the Fusion protocol handler to create a new using an existing
      file as the initial contents and that operation has completed.
    */
    readonly openedFromURL: WebRequestEvent
    /**
      Returns the current version of the Fusion application.
    */
    readonly version: string
    /**
      This registers a new CustomEvent which is intended to be primarily used
      to send an event from a worker thread you've created back to your
      add-in running in the primary thread. It's also possible that two add-ins
      could be cooperating and another add-in can fire the event to your add-in.
      @param eventId This serves as the unique ID for this event and is used by the worker thread or other
      add-in to identify which custom event to fire using the fireCustomEvent method.
      @returns Returns the registered CustomEvent or null in the case of failure, which would typically
      be because the provided eventId is not unique.
    */
    registerCustomEvent(eventId: string): CustomEvent | null
    /**
      Fires a previously registered custom event. This method is used by a worker thread or another
      add-in to fire an event to the add-in that registered the event and is running in the primary thread.
      Firing a custom event does not immediately result in the event handler being called. When a custom
      event is fired the event is put on the queue and will be handled in the main thread when Fusion is idle.
      @param eventId The ID of the custom event you want to fire.
      @param additionalInfo Any additional information you want to pass through the event to the add-in in the primary thread.
      @returns Returns true if the event was successfully added to the event queue. A value of true does not indicate
      that the event was fired and handled but only that it's been put on the primary thread's event queue to
      be fired when application is idle.
    */
    fireCustomEvent(eventId: string, additionalInfo?: string/* = ""*/): boolean
    /**
      Unregisters an existing CustomEvent.
      @param eventId Th unique ID of the custom event you want to unregister.
      @returns Returns True if the unregister succeeded.
    */
    unregisterCustomEvent(eventId: string): boolean
    /**
      The DocumentCreated event fires when a new document is created.
      @permissions desktop
    */
    readonly documentCreated: DocumentEvent
    /**
      The DocumentClosing event fires at the VERY start of a document being closed.
      User can set the isSaveCanceled property of DocumentEventArgs to true to cancel the document close.
      @permissions desktop
    */
    readonly documentClosing: DocumentEvent
    /**
      The DocumentClosed event fires at the VERY end of a document being closed. The
      Document object is not longer available because it has been closed.
      @permissions desktop
    */
    readonly documentClosed: DocumentEvent
    /**
      The DocumentSaving event fires at the VERY start of a document being saved.
      You can set the isSaveCanceled property of DocumentEventArgs to true to cancel the document save.
      @permissions desktop
    */
    readonly documentSaving: DocumentEvent
    /**
      The DocumentSaved event fires after the save operation has been completed.
      @permissions desktop
    */
    readonly documentSaved: DocumentEvent
    /**
      The DocumentActivating event fires at the VERY start of a document being activated.
      @permissions desktop
    */
    readonly documentActivating: DocumentEvent
    /**
      The DocumentActivated event fires at the VERY end of a document being activated.
      @permissions desktop
    */
    readonly documentActivated: DocumentEvent
    /**
      The DocumentDeactivating event fires at the VERY start of a document being deactivated.
      @permissions desktop
    */
    readonly documentDeactivating: DocumentEvent
    /**
      The DocumentDeactivated event fires at the VERY end of a document being deactivated.
      @permissions desktop
    */
    readonly documentDeactivated: DocumentEvent
    /**
      The cameraChanged event fires immediately after a change in the camera has been made.
      Camera changes happen when user changes the view by rotating, zooming in or out, panning,
      changing from parallel to perspective, or when the extents of the viewport changes.
      You can add or remove event handlers from the CameraEvent.
      @permissions desktop
    */
    readonly cameraChanged: CameraEvent
    /**
      Get the MeasureManager object which can be used to perform measurements of geometry.
    */
    readonly measureManager: MeasureManager
    /**
      Logs messages to either the TEXT COMMAND window or the Fusion app log file.
      @param message The message to write to the log.
      @param level The log level. Default value is InfoLogLevel. This is only used when the log type is FileLogType where the
      log message will include the log level.
      @param type The log type. The default value is ConsoleLogType to write the message to the TEXT COMMAND window. When the
      type is FileLogType, the message is written to Fusion's app log file which is the same file where Fusion writes
      all of its log messages. You can get the path and filename of the current log file by using the TEXT COMMAND window.
      In the lower-right corner you can choose "Txt", "Py", or "Js". Choose the "Txt" option and type "paths.get" in the
      input field and press return. A list of all of the various paths used by Fusion will be displayed in the TEXT COMMAND
      window. The line for "AppLogFilePath" has the full path to the log file.
      @permissions desktop
    */
    static log(message: string, level?: LogLevels/* = LogLevels.InfoLogLevel*/, type?: LogTypes/* = LogTypes.ConsoleLogType*/): void
    /**
      The dataFileComplete event fires when a data file upload has completed including any cloud side translations.
    */
    readonly dataFileComplete: DataEvent
    /**
      Gets whether there are any active jobs.
    */
    readonly hasActiveJobs: boolean
    /**
      Returns the names of all of the fonts that are available in Fusion when creating text.
    */
    readonly fontNames: string[]
    /**
      Returns the Scripts object which provides the ability to manage scripts and add-ins.
    */
    readonly scripts: Scripts
    /**
      The dataFileCopyComplete event fires when a data file copy has completed including any PIM Data copy.
    */
    readonly dataFileCopyComplete: DataEvent
    /**
      Get and sets if component colors are used when displaying the components within a design.
      This is the API equivalent of the "Display Component Colors" command.
    */
    isComponentColorsDisplayed: boolean
    /**
      Returns the ApplicationFolders object which provides access to the paths of various folders
      associated with Fusion.
    */
    readonly applicationFolders: ApplicationFolders
    /**
      The mfgdmDataReady event fires when the MFGDM data structure for a document has been updated and
      properties to IDs and structure from the data model is ready.
    */
    readonly mfgdmDataReady: MFGDMDataEvent
  }

  /**
    The ApplicationFolders object provides access to the paths of various folders associated with Fusion.
  */
  abstract class ApplicationFolders extends core.Base {
    /**
      Returns the path to the version-specific folder where Fusion is installed.
    */
    readonly rootPath: string
    /**
      Returns the path to the user-specific folder where Fusion saves various options.
    */
    readonly optionsPath: string
    /**
      Returns the path where apps from the Autodesk App Store are installed.
    */
    readonly appStoreInstallPath: string
    /**
      Gets and sets the default path for scripts and add-ins. This is the same as the
      defaultPathForScriptsAndAddIns property on the APIPreferences object.
    */
    defaultPathForScriptsAndAddIns: string
    /**
      Returns the path where some user-specific data is stored.
    */
    readonly userDataPath: string
    /**
      Returns the path where user-created material and appearance libraries are saved.
    */
    readonly materialsPath: string
    /**
      Returns the full filename for the current application log file.
    */
    readonly appLogFilePath: string
  }

  /**
    A CameraEvent represents an event that occurs in reaction to the user manipulating the view.
    Camera changes happen when user changes the view by rotating, zooming in or out, panning,
    changing from parallel to perspective, or when the extents of the viewport changes.
  */
  abstract class CameraEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: CameraEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: CameraEventHandler): boolean
  }

  /**
    The CameraEventHandler is a client implemented class that can be added as a handler to an
    CameraEvent.
  */
  abstract class CameraEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: CameraEventArgs): void
  }

  /**
    The CameraEventArgs provides information associated with a camera change.
    Camera changes happen when user changes the view by rotating, zooming in or out, panning,
    changing from parallel to perspective, or when the extents of the viewport changes.
  */
  abstract class CameraEventArgs extends EventArgs {
    /**
      Returns the viewport that the modified camera is associated with.
    */
    readonly viewport: Viewport
  }

  /**
    A URL object provides useful and easy-to-use methods for creating, modifying, and analyzing URLs.
  */
  abstract class URL extends Base {
    /**
      Create a new URL by given string.
      @param url The string is used to define the URL.
      @returns Returns the new URL object.
    */
    static create(url: string): URL
    /**
      Get the protocol scheme of the URL, including the final ':'.
      @returns Returns the protocol scheme of the URL.
    */
    readonly protocol: string
    /**
      Get the path name of the URL, including the last '/' of the protocol followed by the path of the URL.
      @returns Returns the path of the URL.
    */
    readonly pathName: string
    /**
      Get the leaf name of the URL, which is the section behind the last '/'.
      @returns Returns the leaf name of the URL.
    */
    readonly leafName: string
    /**
      Get the entire URL as string.
      @returns Returns the entire URL as string.
    */
    toString(): string
    /**
      Get the parent URL, represented by the section before the last '/'.
      @returns Returns the parent URL object.
    */
    readonly parent: URL
    /**
      Join this URL with the given path and return the resulting URL. The operation does not alter the current URL.
      Join inserts a slash '/' to properly extend the path, so that "http://foo".join("bar") will return "http://foo/bar", not "http://foobar".
      @param path The path to join to this URL.
      @returns Returns the joined URL.
    */
    join(path: string): URL
    /**
      Check whether the URL is valid. Ensures that the URL is formatted with a protocol followed by a path which can be empty.
      The check is independent of the existence of the resource the URL may point to.
    */
    readonly isURLValid: boolean
  }

  /**
    A WebRequestEvent represents an event that occurs in reaction to a Fusion protocol handler
    in a web page. For example, insertedFromURL and openedFromURL
  */
  abstract class WebRequestEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: WebRequestEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: WebRequestEventHandler): boolean
  }

  /**
    The WebRequestEventHandler is a client implemented class that can be added as a handler to an
    WebRequestEvent.
  */
  abstract class WebRequestEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: WebRequestEventArgs): void
  }

  /**
    The WebRequestEventArgs provides information associated with a web request event. These
    are events fired as a result of a Fusion protocol handler being invoked from a web page.
    Note that some properties are not available on every event.
  */
  abstract class WebRequestEventArgs extends EventArgs {
    /**
      Used during the insertingFromURL and openingFromURL events to get or set
      if the insert or open should be allowed to continue. This defaults to false,
      which will allow the operation to continue as normal.
      This property should be ignored for all events besides the insertingFromURL and
      openingFromURL events.
    */
    isCanceled: boolean
    /**
      Returns the value specified as the "file" parameter in the URL.
    */
    readonly file: string
    /**
      Returns the value specified as the "properties" parameter in the URL. This
      will be decoded and should be in JSON format if it was properly provided
      by the web page. It can be an empty string if the "properties" parameter was
      not specified in the URL.
    */
    readonly properties: string
    /**
      Returns the value specified as the "id" parameter in the URL. This
      will be decoded. It can be an empty string if the "id" parameter was
      not specified in the URL.
    */
    readonly id: string
    /**
      Returns the value specified as the "privateInfo" parameter in the URL. This
      will be decoded and can be an empty string if the "privateInfo" parameter was
      not specified in the URL.
    */
    readonly privateInfo: string
    /**
      Used during the insertedFromURL or openedFromURL events and returns the Document (openedFromURL)
      or Occurrence (insertedFromURL) that was just created.
    */
    readonly occurrenceOrDocument: core.Base
  }

  /**
    An ApplicationEvent represents a Fusion application related event. For example, startupCompleted or OnlineStatusChanged
  */
  abstract class ApplicationEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: ApplicationEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: ApplicationEventHandler): boolean
  }

  /**
    The ApplicationEventArgs provides information associated with an application event.
    Note that some properties are not available on every event
  */
  abstract class ApplicationEventArgs extends EventArgs {
    /**
      Gets and sets if Fusion is offline or not.
    */
    isOffLine: boolean
    /**
      Gets if the client computer has access to the Internet.
    */
    readonly hasInternetAccess: boolean
  }

  /**
    The ApplicationEventHandler is a client implemented class that can be added as a handler to an
    ApplicationEvent.
  */
  abstract class ApplicationEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: ApplicationEventArgs): void
  }

  /**
    A CustomEvent is primarily used to send an event from a worker thread you've created back
    to your add-in, which is running in the primary thread. It's also possible for add-ins to
    cooperate and another add-in can trigger this event in your add-in by knowing the custom
    event id.
  */
  abstract class CustomEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: CustomEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: CustomEventHandler): boolean
    /**
      Returns the id that was assigned to this event when it was registered. Each
      custom event has it's own unique id.
    */
    readonly eventId: string
  }

  /**
    The ApplicationEventArgs provides information associated with an application event.
    Note that some properties are not available on every event
  */
  abstract class CustomEventArgs extends EventArgs {
    /**
      Information being passed to the add-in in the primary thread from the worker thread
      or other add-in.
    */
    readonly additionalInfo: string
  }

  /**
    The ApplicationEventHandler is a client implemented class that can be added as a handler to an
    ApplicationEvent.
  */
  abstract class CustomEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: CustomEventArgs): void
  }

  /**
    A DocumentEvent represents a document related event. For example, DocumentOpening or DocumentOpened.
  */
  abstract class DocumentEvent extends Event {
    /**
      Add a handler to be notified when the file event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: DocumentEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: DocumentEventHandler): boolean
  }

  /**
    The DocumentEventArgs provides information associated with a document event.
    Note that some properties are not available on every event
    - for example, the Document is not available on the DocumentOpening event because
    the Document is not yet available.
  */
  abstract class DocumentEventArgs extends EventArgs {
    /**
      Provides access to the document that is open. Can be null in the case
      where the event is fired before the document has been opened or after it has been closed.
    */
    readonly document: Document
    /**
      The full path to the file.
    */
    readonly fullPath: string
    /**
      Gets and sets if the operation for this event is to be canceled.
      The description of the reason for canceling the operation can be set
      with the cancelReason property.
      This is only supported for the documentSaving event.
    */
    isOperationCancelled: boolean
    /**
      Gets and sets the description of the reason why the operation is being canceled.
      This property is only used if isOperationCancelled is set to true.
    */
    cancelReason: string
  }

  /**
    The DocumentEventHandler is a client implemented class that can be added as a handler to a
    DocumentEvent.
  */
  abstract class DocumentEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: DocumentEventArgs): void
  }

  /**
    A MFGDMDataEvent represents an event related to the state of the MFGDM data structure.
  */
  abstract class MFGDMDataEvent extends Event {
    /**
      Add a handler to be notified when the data event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: MFGDMDataEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: MFGDMDataEventHandler): boolean
  }

  /**
    The MFGDMDataEventArgs provides information associated with the MFGDM event.
  */
  abstract class MFGDMDataEventArgs extends EventArgs {
    /**
      Provides access to the document that the event is relative to.
    */
    readonly document: Document
  }

  /**
    The MFGDMDataEventHandler is a client implemented class that can be added as a handler to a MFGDMDataEvent.
  */
  abstract class MFGDMDataEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: MFGDMDataEventArgs): void
  }

  /**
    The Documents object provides access to all of the currently open documents and
    provides methods to create and open documents.
  */
  abstract class Documents extends Base {
    /**
      Creates and opens a new document of the specified type.
      @remarks
      Creating a document is not supported within any of the Command related events.
      When a command is running, a transaction is open, and creating and closing documents cannot
      be transacted and, as a result, cannot be contained within a command transaction.
      @param documentType A value from the DocumentTypes enum that specifies the type of document to create.
      @param visible Optional argument specifying is the document should be visible or not. Currently, documents can only
      be created visibly so this argument must always be true.
      @param options Various options that are supported that are specific to the document type. See the documentation
      for the DocumentTypes enum for information about the options supported for the various types.
      @returns Returns the created document
    */
    add(documentType: DocumentTypes, visible?: boolean/* = true*/, options?: NamedValues/* = null*/): Document
    /**
      Function that returns the specified document using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Document | null
    /**
      Returns the number of currently open documents. This includes documents that are
      visible and invisible.
    */
    readonly count: number /*unsigned int*/
    /**
      Opens an item that has previously been saved.
      @param dataFile The item to open.
      @param visible Specifies if the document should be opened visibly or not.
      @returns Returns the open document or null if the open failed.
    */
    open(dataFile: DataFile, visible?: boolean/* = true*/): Document | null
  }

  /**
    The types of documents that can be created.
  */
  const enum DocumentTypes {
    /**
      Fusion design document type.
    */
    FusionDesignDocumentType,
  }

  /**
    The possible errors when a document is opened.
  */
  const enum OpenDocumentError {
    /**
      Error indicating the specified file does not exist.
    */
    DocumentNotFoundError = 200,
  }

  /**
    Object that represents an open document. This is the base class for all document types.
  */
  abstract class Document extends Base {
    /**
      Causes this document to become the active document in the user interface.
      @returns Returns true if the activation was successful.
    */
    activate(): boolean
    /**
      This property gets and sets the name of the document. You can only set the
      name of a document before the document is saved for the first time. You can
      use the isSaved property to determine this. If the document has not been
      saved and the name is changed, the specified name will be the default name
      shown in the Save dialog, which the user can modify before saving the document.
      If the file has been saved, this property behaves as read-only. Setting the
      name will fail because the name is controlled by the DataFile associated
      with this document. However, you can edit the name of the DataFile, which
      you can obtain by using the dataFile property of the document.
    */
    name: string
    /**
      Closes this document.
      @remarks
      Closing a document is not supported within any of the Command related events.
      When a command is running, a transaction is open, and creating and closing documents cannot
      be transacted and, as a result, cannot be contained within a command transaction.
      @param saveChanges This argument defines what the behavior of the close is when the document
      has been modified. If the document hasn't been modified then this argument
      is ignored and the document is closed. If the document has been modified
      and this argument is false then Fusion will close the document and lose
      any changes. If the document has been modified and this argument is true then
      it will prompt the user if they want to save the changes or not, just the same
      as if the user was to interactively close the document.
      @returns Returns true if closing the document was successful.
    */
    close(saveChanges: boolean): boolean
    /**
      Property that indicates if the document has been modified since it was last saved.
    */
    readonly isModified: boolean
    /**
      Property that indicates if this document has been saved or not. The initial save of
      a document requires that the name and location be specified and requires the saveAs method
      to be used. If the document has been saved then the save method can be used to save changes made.
    */
    readonly isSaved: boolean
    /**
      Saves a version of the current document. You must use the SaveAs method the first
      time a document is saved. You can determine if a document has been saved by checking
      the value of the isSaved property.
      @remarks
      Saving a document is not supported within any of the Command related events.
      When a command is running, a transaction is open, and saving a document cannot
      be transacted and, as a result, cannot be contained within a command transaction.
      @param description The version description for this document
      @returns Returns true if saving the document was successful. This will also return true
      in the case when save is called and the document has not been modified since the
      last save. In this case nothing needs to be saved, so the call is still considered
      successful because the correct action is to do nothing.
    */
    save(description: string): boolean
    /**
      Returns the parent Application object.
    */
    readonly parent: Application
    /**
      Performs a Save As on this document. This saves the currently open document to the specified
      location and this document becomes the saved document. If this is a new document that has
      never been saved you must use the SaveAs method in order to specify the location and name. You
      can determine if the document has been saved by checking the value of the isSaved property.
      @remarks
      Saving a document is not supported within any of the Command related events.
      When a command is running, a transaction is open, and saving a document cannot
      be transacted and, as a result, cannot be contained within a command transaction.
      @param name The name to use for this document. If this is an empty string, Fusion will use the default name
      assigned when the document was created.
      @param dataFolder The data folder to save this document to.
      @param description The description string of the document. This can be an empty string.
      @param tag The tag string of the document. This can be an empty string.
      @returns Returns true if the save as was successful.
    */
    saveAs(name: string, dataFolder: DataFolder, description: string, tag: string): boolean
    /**
      Returns the products associated with this document.
    */
    readonly products: core.Products
    /**
      Gets if this document is the active document in the user interface.
    */
    readonly isActive: boolean
    /**
      Gets if a currently open document is open as visible.
    */
    readonly isVisible: boolean
    /**
      Returns the collection of attributes associated with this document.
    */
    readonly attributes: core.Attributes
    /**
      Gets the DataFile that represents this document in A360.
    */
    readonly dataFile: DataFile
    /**
      Returns the Fusion version this document was last saved with.
    */
    readonly version: string
    /**
      Returns a collection containing the documents directly referenced
      by this document.
    */
    readonly documentReferences: DocumentReferences
    /**
      Indicates if any external references in the assembly are out of date. This is the API
      equivalent to the "Out of Date" notification displayed in the Quick Access Toolbar.
    */
    readonly isUpToDate: boolean
    /**
      Returns a collection containing all of the documents referenced directly
      by this document and those referenced by all sub-assemblies.
    */
    readonly allDocumentReferences: DocumentReferences
    /**
      Returns the creation ID of this document. When a new document is created, Fusion assigns it a
      creation ID that will remain constant for the life of the document. The ID that is assigned is unique.
      However, it's possible that more than one document can have the same ID. This happens in the case
      where a document is copied. In this case a new document is created but an existing document is copied.
      It's only when a new document is created that a creation ID is generated and assigned.
      Using this ID can be useful in cases where the save of a new document is started and you can use
      this ID to match the completion of the save operation on the cloud to the original document.
    */
    readonly creationId: string
    /**
      Updates all out of date external references. This is equivalent to clicking the "Out of Date"
      button in the Quick Access Toolbar to update all out of date external references.
    */
    updateAllReferences(): boolean
    /**
      Saves the document as a new milestone. This method is not applicable when saving a document
      for the first time. In that case, you must use the SaveAs method. You can determine if a
      document has been saved by checking the value of the isSaved property.
      @remarks
      Saving a document is not supported within any of the Command related events.
      When a command is running, a transaction is open, and saving a document cannot
      be transacted and, as a result, cannot be contained within a command transaction.
      @param milestoneName The name of the milestone as seen in the data panel and Fusion web client. If an empty string
      is provided a default name will be used.
      @param versionDescription The description associated with the version. If an empty string is provided, a default description will be used.
      @returns Returns true if saving the document as a milestone was successful.
    */
    saveMilestone(milestoneName: string, versionDescription: string): boolean
  }

  /**
    Provides access to the list of documents referenced from a document.
  */
  abstract class DocumentReferences extends core.Base {
    /**
      Returns the specified DocumentReference.
      @param index The index of the object to return where the first one in the collection has an index of 0.
      @returns Returns the specified DocumentReference or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): DocumentReference | null
    /**
      The number of DocumentReference objects in this collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents a reference to a document from another document.
  */
  abstract class DocumentReference extends core.Base {
    /**
      The dataFile on A360 that this object references.
    */
    readonly dataFile: DataFile
    /**
      The document currently open in Fusion that this object references.
    */
    readonly referencedDocument: Document
    /**
      Gets and sets the version of the dataFile on A360 that this document currently represents.
      Setting this property will cause all occurrences referencing this document to update to
      that version.
    */
    version: number /*int*/
    /**
      The document that is doing the referencing and owns this reference.
    */
    readonly parentDocument: Document
    /**
      Indicates if this reference is out of date, meaning that the reference
      is not referencing the latest version.
    */
    readonly isOutOfDate: boolean
    /**
      Updates the reference to use the latest version. This is only useful
      when the isOutOfDate property is true.
      @returns Returns true if getting the latest version was successful.
    */
    getLatestVersion(): boolean
  }

  /**
    List of possible errors when closing a document.
  */
  const enum CloseError {
    /**
      The close operation was canceled by the user
    */
    CloseCancelledError = 200,
  }

  /**
    List of possible errors when saving a document locally.
  */
  const enum SaveLocalErrors {
    /**
      The save was canceled.
    */
    SaveCancelledSaveLocalError = 200,
    /**
      The disk is full.
    */
    DiskFullSaveLocalError,
    /**
      The specified file exists and is read-only.
    */
    FileReadOnlySaveLocalError,
  }

  /**
    The Products object provides access to all of the products that exist in the document.
  */
  abstract class Products extends Base {
    /**
      Function that returns the specified product using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Product | null
    /**
      Returns the specified product, if it exists within this document.
      @param productType The product type string. For example, to get the product that represents the design data
      you use "DesignProductType" or to get the product that represent the CAM data you use "CAMProductType".
      A complete list of available products can be obtained by using the Application.supportedProductTypes property.
      @returns Returns the specified item or null if the specified productType does not exist within this document.
    */
    itemByProductType(productType: string): Product | null
    /**
      Returns the number of products within the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The base class for the various product specific containers. For
    Fusion this is the Design object. For manufacturing this is a CAM object.
  */
  abstract class Product extends Base {
    /**
      Returns the parent Document object.
    */
    readonly parentDocument: Document
    /**
      Returns the UnitsManager object associated with this product.
    */
    readonly unitsManager: UnitsManager
    /**
      Returns the workspaces associated with this product.
    */
    readonly workspaces: WorkspaceList
    /**
      Returns the product type name of this product. A list of all of
      the possible product types can be obtained by using the
      Application.supportedProductTypes property.
    */
    readonly productType: string
    /**
      Find attributes attached to objects in this product that match the group and or attribute name.
      This does not find attributes attached directly to the Product or Document objects but finds the
      attributes attached to entities within the product.
      The search string for both the groupName and attributeName arguments can be either an absolute
      name value, or a regular expression. With an absolute name, the search string must match the
      entire groupName or attributeName, including case. An empty string will match everything.
      For example if you have an attribute group named "MyStuff" that contains the attribute "Length1",
      using the search string "MyStuff" as the group name and "Length1" as the attribute name will
      find the attributes with those names. Searching for "MyStuff" as the group name and "" as the
      attribute name will find all attributes that have "MyStuff" as the group name.
      Regular expressions provide a more flexible way of searching. To use a regular expression,
      prefix the input string for the groupName or attributeName arguments with "re:". The regular
      expression much match the entire group or attribute name. For example if you have a group that
      contains attributes named "Length1", "Length2", "Width1", and "Width2" and want to find any
      of the length attributes you can use a regular expression using the string "re:Length.*". For more
      information on attributes see the Attributes topic in the user manual.
      @param groupName The search string for the group name. See above for more details.
      @param attributeName The search string for the attribute name. See above for more details.
      @returns An array of Attribute objects that were found. An empty array is returned if no attributes were found.
    */
    findAttributes(groupName: string, attributeName: string): Attribute[]
    /**
      Returns the collection of attributes associated with this product.
    */
    readonly attributes: core.Attributes
    /**
      Deletes the specified set of entities that are associated with this product.
      @param entities An ObjectCollection containing the list of entities to delete.
      @returns Returns True if any of the entities provided in the list were deleted. If
      entities were specified that can't be deleted or aren't owned by this product,
      they are ignored.
    */
    deleteEntities(entities: ObjectCollection): boolean
    /**
      Returns the SelectionSets object associated with this product. If the product does
      not support selection sets, null is returned. The SelectionSets object is used to
      create and access existing selection sets.
    */
    readonly selectionSets: SelectionSets
    /**
      Returns the NamedViews object associated with this product. The NamedViews collection
      provides access to the named views defined in this product and supports the
      creation of new named views.
    */
    readonly namedViews: NamedViews
  }

  /**
    The Preferences object provides access to the various preference related objects
    for getting and setting the various preference values.
  */
  abstract class Preferences extends Base {
    /**
      Gets the GeneralPreferences object.
    */
    readonly generalPreferences: GeneralPreferences
    /**
      Gets the MaterialPreferences object.
    */
    readonly materialPreferences: MaterialPreferences
    /**
      Gets the GraphicsPreferences object.
    */
    readonly graphicsPreferences: GraphicsPreferences
    /**
      Gets the NetworkPreferences object.
    */
    readonly networkPreferences: NetworkPreferences
    /**
      Gets the UnitAndValuePreferences object.
    */
    readonly unitAndValuePreferences: UnitAndValuePreferences
    /**
      Gets the DefaultUnitsPreferences object.
    */
    readonly defaultUnitsPreferences: DefaultUnitsPreferencesCollection
    /**
      Gets the ProductPreferences object.
    */
    readonly productPreferences: ProductPreferencesCollection
    /**
      Gets the GridPreferences object.
    */
    readonly gridPreferences: GridPreferences
    /**
      Gets the ProductUsageData object.
    */
    readonly productUsageData: ProductUsageData
    /**
      Gets the APIPreferences object, which provides access to the various preferences associated with the API.
    */
    readonly apiPreferences: APIPreferences
  }

  /**
    A collection that provides access to product specific unit preference objects.
  */
  abstract class DefaultUnitsPreferencesCollection extends Base {
    /**
      Function that returns the specified DefaultUnitPreferences object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): DefaultUnitsPreferences | null
    /**
      Returns the DefaultUnitsPreference object with the specified name.
      @param name The name of the DefaultUnitsPreference to return.
      @returns Returns the DefaultUnitsPreference object or null if an invalid name was specified.
    */
    itemByName(name: string): DefaultUnitsPreferences | null
    /**
      Returns the number of DefaultUnitsPreference objects.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The base class for the default units preference. There is a derived class
    supported by each product where the specific preference values are exposed.
  */
  abstract class DefaultUnitsPreferences extends Base {
    /**
      Returns the name of this DefaultUnitPreferences object.
    */
    readonly name: string
  }

  /**
    A collection that provides access to product specific preference objects.
  */
  abstract class ProductPreferencesCollection extends Base {
    /**
      Function that returns the specified ProductPreferences object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ProductPreferences | null
    /**
      Returns the ProductPreference object with the specified name.
      @param name The name of the ProductPreferences to return.
      @returns Returns the ProductPreferences object or null if an invalid name was specified.
    */
    itemByName(name: string): ProductPreferences | null
    /**
      Returns the number of ProductPreference objects.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The base class for the general product preferences. There is a derived class
    for each product where the specific preference values are exposed.
  */
  abstract class ProductPreferences extends Base {
    /**
      Returns the name of this ProductPreferences object.
    */
    readonly name: string
  }

  /**
    Provides access to the general preferences.
  */
  abstract class GeneralPreferences extends Base {
    /**
      Gets and sets the current language. Setting the language does not
      take effect until the next time Fusion is started.
    */
    userLanguage: UserLanguages
    /**
      Gets and sets the length of time, in days, that the offline cache of a document will remain.
    */
    offlineCachePeriod: number
    /**
      Gets and sets the graphics driver used to display the graphics.
    */
    graphicsDriver: GraphicsDrivers
    /**
      Gets and sets if the file is automatically saved on close.
    */
    isAutomaticSaveOnCloseEnabled: boolean
    /**
      Gets and sets if a version of the file is automatically saved using a background thread.
    */
    isAutomaticVersioningEnabled: boolean
    /**
      Gets and sets the interval, in minutes, for automatic versioning.
    */
    automateVersioningTimeInterval: number /*int*/
    /**
      Gets and sets the default for which direction is considered "up".
    */
    defaultModelingOrientation: DefaultModelingOrientations
    /**
      Gets and sets if tooltips are shown.
    */
    areTooltipsShown: boolean
    /**
      Gets and sets if the command prompt is shown.
    */
    isCommandPromptShown: boolean
    /**
      Gets and sets if in command tips and tricks are shown.
    */
    areTipsAndTricksShown: boolean
    /**
      Gets and sets if in command errors and warnings are shown.
    */
    areInCommandErrorsAndWarningsShown: boolean
    /**
      Gets and sets if Autodesk 360 notifications are shown.
    */
    areAutodesk360NotificationsShown: boolean
    /**
      Gets and sets if gesture based view navigation is used.
    */
    isGestureBasedViewNavigationUsed: boolean
    /**
      Gets and sets if the direction of the zoom is reversed.
    */
    isZoomDirectionReversed: boolean
    /**
      Gets and sets if zoom and orbit commands use camera pivot point for transition.
    */
    isCameraPivotEnabled: boolean
    /**
      Get and sets the type of orbit.
    */
    defaultOrbit: DefaultOrbits
    /**
      Gets and sets if the creation of launch items should be skipped for live update.
    */
    isSkipCreationWhenLiveUpdate: boolean
    /**
      Gets and sets if the default measure is shown.
    */
    isDefaultMeasureShown: boolean
    /**
      Gets and sets how pan, zoom, and orbit should behave.
    */
    panZoomOrbitShortcuts: PanZoomOrbitShortcuts
    /**
      Gets and sets whether hang detection is enabled. This is a Windows only setting.
      If True, Fusion will detect when a task processes for longer than a specific time.
      A dialog is displayed if a hang is detected, allowing the user to continue processing
      or stop Fusion and send an error report.
    */
    isHangDetectionEnabled: boolean
    /**
      Gets and sets which color theme is used by the user interface.
    */
    userInterfaceTheme: UserInterfaceThemes
  }

  /**
    Defines the different color themes used by the user interface.
  */
  const enum UserInterfaceThemes {
    /**
      The Fusion classic user interface theme.
    */
    ClassicUserInterfaceTheme,
    /**
      The light gray user interface theme.
    */
    LightGrayUserInterfaceTheme,
    /**
      The dark blue user interface theme.
    */
    DarkBlueUserInterfaceTheme,
    /**
      The dark gray user interface theme.
    */
    DarkGrayUserInterfaceTheme,
  }

  /**
    A list of the different predefined keyboard shortcuts for pan, zoom, and orbit.
  */
  const enum PanZoomOrbitShortcuts {
    /**
      Use Fusion pan, zoom, and orbit keyboard shortcuts.
    */
    Fusion360PanZoomOrbitShortcut,
    /**
      Use Alias pan, zoom, and orbit keyboard shortcuts.
    */
    AliasPanZoomOrbitShortcut,
    /**
      Use Inventor pan, zoom, and orbit keyboard shortcuts.
    */
    InventorPanZoomOrbitShortcut,
    /**
      Use SolidWorks pan, zoom, and orbit keyboard shortcuts.
    */
    SolidWorksPanZoomOrbitShortcut,
    /**
      Use Tinkercad pan, zoom, and orbit keyboard shortcuts.
    */
    TinkercadPanZoomOrbitShortcut,
    /**
      Use PowerMill pan, zoom, and orbit keyboard shortcuts.
    */
    PowerMillPanZoomOrbitShortcut,
  }

  /**
    A list of the valid languages.
  */
  const enum UserLanguages {
    /**
      Peoples Republic of China Chinese
    */
    ChinesePRCLanguage,
    /**
      Taiwan Chinese
    */
    ChineseTaiwanLanguage,
    /**
      Czech
    */
    CzechLanguage,
    /**
      English
    */
    EnglishLanguage,
    /**
      French
    */
    FrenchLanguage,
    /**
      German
    */
    GermanLanguage,
    /**
      Hungarian
    */
    HungarianLanguage,
    /**
      Italian
    */
    ItalianLanguage,
    /**
      Japanese
    */
    JapaneseLanguage,
    /**
      Korean
    */
    KoreanLanguage,
    /**
      Polish
    */
    PolishLanguage,
    /**
      Brazilian Portuguese
    */
    PortugueseBrazilianLanguage,
    /**
      Russian
    */
    RussianLanguage,
    /**
      Spanish
    */
    SpanishLanguage,
    /**
      Turkish
    */
    TurkishLanguage,
  }

  /**
    A list of the valid graphics drivers.
  */
  const enum GraphicsDrivers {
    /**
      DirectX 9 Graphics Driver.
      This option only applies to Windows.
    */
    DirectX9GraphicsDriver,
    /**
      DirectX 11 Graphics Driver.
      This option only applies to Windows.
    */
    DirectX11GraphicsDriver,
    /**
      Let Fusion automatically select the Graphics Driver.
      This option applies to both Windows and Mac.
    */
    AutoSelectGraphicsDriver,
    /**
      OpenGL Core Profile Graphics Driver.
      This option only applies to Mac.
    */
    OpenGLCoreProfileGraphicsDriver,
    /**
      OpenGL Graphics Driver.
      This option only applies to Mac.
    */
    OpenGLGraphicsDriver,
  }

  /**
    A list of the valid modeling orientations.
  */
  const enum DefaultModelingOrientations {
    /**
      The model Y is the up direction.
    */
    YUpModelingOrientation,
    /**
      The model Z is the up direction.
    */
    ZUpModelingOrientation,
  }

  /**
    A list of the valid orbit modes.
  */
  const enum DefaultOrbits {
    /**
      Constrained orbit mode.
    */
    ConstrainedOrbit,
    /**
      Free orbit mode.
    */
    FreeOrbit,
  }

  /**
    Provides access to the material related preferences.
  */
  abstract class MaterialPreferences extends Base {
    /**
      Gets and sets the default material.
    */
    defaultMaterial: Material
    /**
      Gets and sets an appearance override.
      This property return null indicating that there is no override, or be set to null to remove
      the current appearance override.
    */
    appearanceOverride: Appearance
  }

  /**
    The GraphicsPreferences object provides access to the various graphics related preferences.
  */
  abstract class GraphicsPreferences extends Base {
    /**
      Gets and sets the minimum frames per second. The isDynamic property must be true for
      this to be considered.
      Setting this property is only valid when the graphics preset is set
      to "custom" and will fail if it is set to "quality" or "performance".
      The graphics preset can be determined by using the graphicsPreset
      property, as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    minimumFramesPerSecond: number
    /**
      Gets and sets the style of display to use for selections.
      Setting this property is only valid when the graphics preset is set
      to "custom" and will fail if it is set to "quality" or "performance".
      The graphics preset can be determined by using the graphicsPreset
      property, as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    selectionDisplayStyle: SelectionDisplayStyles
    /**
      Gets and sets the style of display for degraded selections.
      Setting this property is only valid when the graphics preset is set
      to "custom" and will fail if it is set to "quality" or "performance".
      The graphics preset can be determined by using the graphicsPreset
      property, as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    degradedSelectionDisplayStyle: DegradedSelectionDisplayStyles
    /**
      Gets and sets the style of display for transparency effects.
      Setting this property is only valid when the graphics preset is set
      to "custom" and will fail if it is set to "quality" or "performance".
      The graphics preset can be determined by using the graphicsPreset
      property, as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    transparencyEffects: TransparencyDisplayEffects
    /**
      This property is no longer supported and has been replaced by the isDynamic
      property which dynamically changes the effect settings to optimize graphics performance.
      @deprecated
    */
    autoThrottleEffects: boolean
    /**
      Gets and sets the dimming percentage to use for hidden edges.
      the value is a percentage expressed by a value between 0 and 100.
      Setting this property is only valid when the graphics preset is set
      to "custom" and will fail if it is set to "quality" or "performance".
      The graphics preset can be determined by using the graphicsPreset
      property, as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    hiddenEdgeDimming: number /*int*/
    /**
      Gets and sets whether the bump effect is enabled when supported by the Wood (Solid)
      and the graphics driver.
      Setting this property is only valid when the graphics preset is set
      to "custom" and will fail if it is set to "quality" or "performance".
      The graphics preset can be determined by using the graphicsPreset
      property, as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isWoodBumpEnabled: boolean
    /**
      This property is no longer supported and has been replaced by the isDynamic
      property which dynamically changes the effect settings to optimize graphics performance.
      @deprecated
    */
    isLimitEffectsDuringNavigation: boolean
    /**
      Gets and sets whether the surface normal display is disabled.
      Setting this property is only valid when the graphics preset is set
      to "custom" and will fail if it is set to "quality" or "performance".
      The graphics preset can be determined by using the graphicsPreset
      property, as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isSurfaceNormalDisplayDisabled: number /*int*/
    /**
      Gets and sets if the different graphics settings are using predefined
      settings to get the best performance, quality, or are custom to allow
      any settings. Setting this to performance or quality will result in other
      graphics settings changing to match the defined preset.
    */
    graphicsPreset: GraphicsPresets
    /**
      Gets and sets if the value defined by minimumFramesPerSecond will be considered
      when processing graphics. This is the equivalent of the "Dynamic" check box in
      Preferences dialog.
      Setting this property is only valid when the graphics preset is set
      to "custom" and will fail if it is set to "quality" or "performance".
      The graphics preset can be determined by using the graphicsPreset
      property, as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isDynamic: boolean
    /**
      Gets and sets if the camera should be animated as it transitions from
      one view to another. If true, there will be an animated transition.
      Setting this property is only valid when the graphics preset is set
      to "custom" and will fail if it is set to "quality" or "performance".
      The graphics preset can be determined by using the graphicsPreset
      property, as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isAnimateViewTransitions: boolean
    /**
      Gets and sets if high resolution canvas graphics is enabled. A value
      of true indicates it is enabled.
      Setting this property is only valid when the graphics preset is set
      to "custom" and will fail if it is set to "quality" or "performance".
      The graphics preset can be determined by using the graphicsPreset
      property, as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isHighResolutionCanvasGraphicsEnabled: boolean
    /**
      Provides access to the settings that control the canvas effects.
    */
    readonly canvasEffects: CanvasEffects
  }

  /**
    Provides access to the settings that control the canvas effects.
  */
  abstract class CanvasEffects extends Base {
    /**
      Gets and sets if the environment dome is enabled. Setting this
      property is only valid when the graphics preset is set to "custom"
      and will fail if it is set to "quality" or "performance". The
      graphics preset can be determined by using the graphicsPreset property,
      as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isEnvironmentDomeEnabled: boolean
    /**
      Gets and sets if the ground plane is enabled. Setting this
      property is only valid when the graphics preset is set to "custom"
      and will fail if it is set to "quality" or "performance". The
      graphics preset can be determined by using the graphicsPreset property,
      as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isGroundPlaneEnabled: boolean
    /**
      Gets and sets if the ground shadow is enabled. Setting this
      property is only valid when the graphics preset is set to "custom"
      and will fail if it is set to "quality" or "performance". The
      graphics preset can be determined by using the graphicsPreset property,
      as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isGroundShadowEnabled: boolean
    /**
      Gets and sets if ground reflection is enabled. Setting this
      property is only valid when the graphics preset is set to "custom"
      and will fail if it is set to "quality" or "performance". The
      graphics preset can be determined by using the graphicsPreset property,
      as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isGroundReflectionEnabled: boolean
    /**
      Gets and sets if object shadows is enabled. Setting this
      property is only valid when the graphics preset is set to "custom"
      and will fail if it is set to "quality" or "performance". The
      graphics preset can be determined by using the graphicsPreset property,
      as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isObjectShadowEnabled: boolean
    /**
      Gets and sets if ambient occlusion is enabled. Setting this
      property is only valid when the graphics preset is set to "custom"
      and will fail if it is set to "quality" or "performance". The
      graphics preset can be determined by using the graphicsPreset property,
      as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isAmbientOcclusionEnabled: boolean
    /**
      Gets and sets if antialiasing is enabled. Setting this
      property is only valid when the graphics preset is set to "custom"
      and will fail if it is set to "quality" or "performance". The
      graphics preset can be determined by using the graphicsPreset property,
      as shown below.
      Application.preferences.graphicsPreferences.graphicsPreset
    */
    isAntiAliasingEnabled: boolean
  }

  /**
    Defines the different options for preset graphic setting definitions.
  */
  const enum GraphicsPresets {
    /**
      Sets the graphics settings to get the best performance.
    */
    PerformanceGraphicsPreset,
    /**
      Sets the graphics settings to get the best quality.
    */
    QualityGraphicsPreset,
    /**
      Allows setting the graphics settings with any values.
    */
    CustomGraphicsPreset,
  }

  /**
    A list of the valid selection display styles.
  */
  const enum SelectionDisplayStyles {
    /**
      Normal selection display.
    */
    NormalDisplayStyle,
    /**
      Simple selection display.
    */
    SimpleDisplayStyle,
  }

  /**
    A list of the valid transparency display effects.
  */
  const enum TransparencyDisplayEffects {
    /**
      Better performance transparency effect.
    */
    BetterPerformanceTransparencyEffect,
    /**
      Better display transparency effect.
    */
    BetterDisplayTransparencyEffect,
  }

  /**
    A list of the valid degraded display styles.
  */
  const enum DegradedSelectionDisplayStyles {
    /**
      Normal with glow degraded selection style.
    */
    NormalWithGlowDegradedSelectionStyle,
    /**
      Simple without glow degraded selection style.
    */
    SimpleWithoutGlowDegradedSelectionStyle,
  }

  /**
    The GridPreferences object provides access to grid related preferences.
  */
  abstract class GridPreferences extends Base {
    /**
      Gets and sets if the layout grid lock is enabled.
    */
    isLayoutGridLockEnabled: boolean
  }

  /**
    The NetworkPreferences object provides access to network related preferences.
  */
  abstract class NetworkPreferences extends Base {
    /**
      Gets and sets the network proxy setting.
    */
    networkProxySetting: NetworkProxySettings
    /**
      Gets and sets the proxy host.
    */
    proxyHost: string
    /**
      Gets and sets the proxy host.
    */
    proxyPort: number /*int*/
  }

  /**
    A list of the valid network proxy settings.
  */
  const enum NetworkProxySettings {
    /**
      Automatic proxy setting.
    */
    AutomaticProxySettings,
    /**
      No proxy setting.
    */
    NoProxyProxySettings,
    /**
      Windows default proxy setting.
    */
    WindowsDefaultProxySettings,
    /**
      Override proxy setting.
    */
    OverrideProxySettings,
  }

  /**
    Provides access to the product usage data settings.
  */
  abstract class ProductUsageData extends Base {
    /**
      Gets and sets if data can be collected to help improve the products
      and services that Autodesk provides. This is the preference setting
      titled "Help develop our products and services".
    */
    isTrackingToImproveSoftwareEnabled: boolean
    /**
      Gets and sets if data can be collected to improve communications. This is
      the preferences setting titled "Customize our messaging".
    */
    isTrackingToImproveCommunicationEnabled: boolean
    /**
      Gets and sets if Google Analytics tracking is enabled.
    */
    isGoogleAnalyticsTrackingEnabled: boolean
    /**
      Gets and sets if data can be collected to enable the Learning Panel
      to show information based on the current context.
    */
    isLearningPanelContextEnabled: boolean
  }

  /**
    Provides access to the various preferences associated with the API.
  */
  abstract class APIPreferences extends Base {
    /**
      Gets and sets the preference that controls which programming language
      should be used when creating a new script. One option is to prompt the user.
    */
    defaultScriptLanguage: ProgrammingLanguages
    /**
      Gets and sets the preference that controls which programming language
      should be used when creating a new add-in. One option is to prompt the user.
    */
    defaultAddInLanguage: ProgrammingLanguages
    /**
      The default path where new scripts or add-ins will be created. Scripts will be
      created in a "Scripts" subdirectory and add-ins will be created in an "AddIns"
      subdirectory. This must be the full path to the parent folder.
      This path is also where Fusion will look for any scripts and add-ins and
      automatically display them in the "Scripts and Add-Ins" dialog.
    */
    defaultPathForScriptsAndAddIns: string
    /**
      Gets and sets the port used when connecting to Visual Studio Code.
    */
    debuggingPort: number /*int*/
    /**
      Gets and sets if access to "Developer Tools" should be enabled in pallets and
      BrowserCommandInputs.
    */
    isDeveloperToolsEnabled: boolean
  }

  /**
    The UnitAndValuePreferences object provides access to unit and value precision
    related preferences.
  */
  abstract class UnitAndValuePreferences extends Base {
    /**
      Gets and sets the general precision for distance values. This
      value specifies the number of decimals to display.
    */
    generalPrecision: number /*int*/
    /**
      Gets and sets the angular precision. This
      value specifies the number of decimals to display.
    */
    angularPrecision: number /*int*/
    /**
      Gets and sets the number scientific notation precision. This
      value specifies the number of decimals to display.
    */
    scientificNotationPrecision: number /*int*/
    /**
      Gets and sets the foot and inch display format.
    */
    footAndInchDisplayFormat: FootAndInchDisplayFormats
    /**
      Gets and sets the degree display format.
    */
    degreeDisplayFormat: DegreeDisplayFormats
    /**
      Gets and sets if the decimal is a period or comma.
    */
    isPeriodDecimalPoint: boolean
    /**
      Gets and sets if abbreviations are used for units display.
    */
    areAbbreviationsForUnitDisplayed: boolean
    /**
      Gets and sets if symbols are used for units display.
    */
    areSymbolsForUnitDisplayed: boolean
    /**
      Gets and sets if scientific notation is used when displaying numbers.
    */
    isScientificNotationUsed: boolean
    /**
      Gets and sets the number of whole digits that will be displayed before
      switching to scientific notation.
    */
    useScientficNotationAbove: number /*int*/
    /**
      Gets and sets the number of non zero decimal places that will be
      displayed before switching to scientific notation.
    */
    useScientficNotationBelow: number /*int*/
    /**
      Gets and sets if trailing zeros are hidden when displaying numbers.
    */
    areTrailingZerosHidden: boolean
    /**
      Gets and sets the minimum number of digits to the right of the decimal to display
      before hiding trailing zeros.
    */
    minimumPrecisionWhenHidingZeros: number /*int*/
    /**
      Gets and sets the units types to use when displaying values.
    */
    materialDisplayUnit: MaterialDisplayUnits
  }

  /**
    List of the valid degree display formats.
  */
  const enum DegreeDisplayFormats {
    /**
      Decimal degree display.
    */
    DecimalDegreeDisplay,
    /**
      Minutes and seconds degree display.
    */
    MinutesAndSecondsDegreeDisplay,
  }

  /**
    List of the valid foot and inch formats.
  */
  const enum FootAndInchDisplayFormats {
    /**
      Decimal foot and inch display format.
    */
    DecimalFootAndInchDisplay,
    /**
      Fractional foot and inch display format.
    */
    FractionalFootAndInchDisplay,
    /**
      Architectural foot and inch display format.
    */
    ArchitecturalFootAndInchDisplay,
  }

  /**
    List of the different types of material related units supported for displaying values.
  */
  const enum MaterialDisplayUnits {
    /**
      Metric standard
    */
    MetricStandardDisplayUnits,
    /**
      Metric mks
    */
    MetricMKSDisplayUnits,
    /**
      Metric mmNs
    */
    MetricMMNSDisplayUnits,
    /**
      Metric cgs
    */
    MetricCGSDisplayUnits,
    /**
      Metric umNsd
    */
    MetricUMNSDisplayUnits,
    /**
      English standard
    */
    EnglishStandardDisplayUnits,
    /**
      English in
    */
    EnglishInchDisplayUnits,
    /**
      English ft
    */
    EnglishFootDisplayUnits,
  }

  /**
    Generic collection used to handle lists of any object type.
  */
  abstract class ObjectCollection extends Base {
    /**
      Function that returns the specified object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Base | null
    /**
      Returns the number of occurrences in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds an object to the end of the collection.
      Duplicates can be added to the collection.
      @param item The item to add to the list.
      @returns Returns false if the item was not added.
    */
    add(item: Base): boolean
    /**
      Function that removes an item from the collection.
      @param item The object to remove from the collection.
      @returns Returns true if the removal was successful.
    */
    removeByItem(item: Base): boolean
    /**
      Function that removes an item from the list.
      Will fail if the list is read only.
      @param index The index of the item to remove from the collection. The first item has an index of 0.
      @returns Returns true if the removal was successful.
    */
    removeByIndex(index: number /*unsigned int*/): boolean
    /**
      Finds the specified component in the collection.
      @param item The item to search for within the collection.
      @param startIndex The index to begin the search.
      @returns Returns the index of the found item. If not found, -1 is returned.
    */
    find(item: Base, startIndex?: number /*unsigned int*//* = 0*/): number /*int*/
    /**
      Returns whether the specified object exists within the collection.
      @param item The item to look for in the collection.
      @returns Returns true if the specified item is found in the collection.
    */
    contains(item: Base): boolean
    /**
      Clears the entire contents of the collection.
      @returns Returns true if successful.
    */
    clear(): boolean
    /**
      Creates a new ObjectCollection object.
      @returns Returns the newly created ObjectCollection.
    */
    static create(): ObjectCollection
    /**
      Creates a new ObjectCollection that is initialized with the content of the provided array.
      @param array An array of Fusion objects that are used to populate the ObjectCollection. For this method to
      succeed, getting the input type correct is critical. The term "array" is used generically in the API
      documentation and describes different things depending on the language being used.
      When using C++, std::vector is used to input and output a list of items.However, this particular method
      requires that the content of the vector be of type core.base. If you have a vector of other types, you
      need to convert it to core.base. The sample below illustrates converting a vector of Occurrence objects
      into a vector of core.Base objects.
      <code><pre class="api-code">std::vector&ltPtr&ltadsk::fusion::Occurrence&gt&gt occArray = rootComp-&gtoccurrences()-&gtasArray()
      std::vector&ltPtr&ltadsk::core::Base&gt&gt occs{ occArray.begin(), occArray.end() }
      Ptr&ltObjectCollection&gt objColl = ObjectCollection::createWithArray(occs)</pre></code>
      When using Python, a Python List or Tuple is used as input. Something not obvious is that when an array is
      returned from a method or property it's not returned as a standard Python List but is a special API-specific
      class called "vector". Typically, you don't notice this isn't a List because it supports Python iteration
      like a List does. Because the createWithArray method requires a standard Python list as input, you need to
      convert it to a standard list before using it in the createWithArray method. For example, the
      Occurrences.asArray method returns an "array" of the occurrences, which really returns a vector object
      of the occurrences. The code below converts the vector into a standard list so it can be used to create an ObjectCollection.
      <code><pre class="api-code">occList = list(root.Occurrences.asArray())
      objColl = adsk.core.ObjectCollection.craeteWithArray(occList)</pre></code>
      @returns Returns the newly created ObjectCollection or null in the case of failure.
    */
    static createWithArray(array: core.Base[]): ObjectCollection | null
    /**
      Returns the content of the ObjectCollection as an array.
      @returns Returns an array of the Fusion objects in the ObjectCollection.
    */
    asArray(): core.Base[]
  }

  /**
    The Color class wraps all of the information that defines a simple color.
  */
  abstract class Color extends Base {
    /**
      Gets and sets the red component of the color. The value can be 0 to 255.
    */
    red: number /*unsigned int*/
    /**
      Gets and sets the green component of the color. The value can be 0 to 255.
    */
    green: number /*unsigned int*/
    /**
      Gets and sets the blue component of the color. The value can be 0 to 255.
    */
    blue: number /*unsigned int*/
    /**
      Gets and sets the opacity of the color. The value can be 0 to 255. A value
      of 0 is transparent and 255 is opaque.
    */
    opacity: number /*unsigned int*/
    /**
      Gets all of the information defining this color.
      @param red The red component of the color. The value can be 0 to 255.
      @param green The green component of the color. The value can be 0 to 255.
      @param blue The blue component of the color. The value can be 0 to 255.
      @param opacity The opacity of the color. The value can be 0 to 255. A value of 255 indicates
      it is completely opaque.
      @returns Returns true if getting the color information was successful.
    */
    getColor(): [red: number /*unsigned int*/, green: number /*unsigned int*/, blue: number /*unsigned int*/, opacity: number /*unsigned int*/]
    /**
      Sets all of the color information.
      @param red The red component of the color. The value can be 0 to 255.
      @param green The green component of the color. The value can be 0 to 255.
      @param blue The blue component of the color. The value can be 0 to 255.
      @param opacity The opacity of the color. The value can be 0 to 255. A value of 255 indicates
      it is completely opaque. Depending on where the color is used, the opacity
      value may be ignored.
      @returns Returns true if setting the color information was successful.
    */
    setColor(red: number /*unsigned int*/, green: number /*unsigned int*/, blue: number /*unsigned int*/, opacity: number /*unsigned int*/): boolean
    /**
      Creates a new color.
      @param red The red component of the color. The value can be 0 to 255.
      @param green The green component of the color. The value can be 0 to 255.
      @param blue The blue component of the color. The value can be 0 to 255.
      @param opacity The opacity of the color. The value can be 0 to 255.
      @returns Returns the newly created color or null if the creation failed.
    */
    static create(red: number /*unsigned int*/, green: number /*unsigned int*/, blue: number /*unsigned int*/, opacity: number /*unsigned int*/): Color | null
  }

  /**
    Wraps a list of named values.
  */
  abstract class NamedValues extends Base {
    /**
      Creates a transient NamedValues object.
      @returns Returns the created NamedValue object.
    */
    static create(): NamedValues
    /**
      Adds a name value pair to the NamedValues object
      @param name A name for the name value pair
      @param value A ValueInput object that defines the value of the name value pair
      @returns Returns true if the name value pair is added successfully.
    */
    add(name: string, value: ValueInput): boolean
    /**
      Returns the number of name value pairs in this object.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the name and ValueInput object of a name value pair
      by specifying an index number
      @param index The index of the name value pair to return. The first pair in the collection
      has an index of 0.
      @param name The name
      @param value The ValueInput object
      @returns Returns true if successful
    */
    getByIndex(index: number /*int*/): [name: string, value: ValueInput]
    /**
      Function that returns the ValueInput object of a name value pair
      by specifying its name
      @param name The name of the name value pair to return the ValueInput object from
      @param value The ValueInput object
      @returns Returns true if successful
    */
    getValueByName(name: string): [value: ValueInput]
  }

  /**
    Defines the different horizontal alignments that can be applied to text.
  */
  const enum HorizontalAlignments {
    /**
      Aligned to the left.
    */
    LeftHorizontalAlignment,
    /**
      Aligned along the center.
    */
    CenterHorizontalAlignment,
    /**
      Aligned to the right.
    */
    RightHorizontalAlignment,
  }

  /**
    Defines the different vertical alignments that can be applied to text.
  */
  const enum VerticalAlignments {
    /**
      Aligned to the top.
    */
    TopVerticalAlignment,
    /**
      Aligned along the middle.
    */
    MiddleVerticalAlignment,
    /**
      Aligned to the bottom.
    */
    BottomVerticalAlignment,
  }

  /**
    Utility class used to work with Values and control default units.
    Internal values are held in SI units (e.g. seconds, radians, kg for time, angle, mass)
    with the exception that all lengths are in cm rather than meter and this affects derived
    units (e.g. velocity is cm/s, volume is cm^3).
    Units are specified flexibility via strings (e.g. "cm", "in", "inch", "cm^3", "cm*cm*cm", "mph", "mps" "m/s").
    Units like length can be defaulted based on the design settings if the user does not explicitly
    specify units - so "3" can be 3 inches, mm or cm depending on what the design
    settings are.
  */
  abstract class UnitsManager extends core.Base {
    /**
      Returns the parent Product.
    */
    readonly product: Product
    /**
      Checks to see if the given expression is valid.
      @param expression The expression to validate.
      @param units The units to use when validating the expression.
      @returns Returns True if it is a valid expression.
    */
    isValidExpression(expression: string, units: string): boolean
    /**
      Gets the value (in internal units) of the expression.
      @param expression EvaluateExpression("1cm + 1in") -> 3.54
      EvaluateExpression("1") -> -> depends on the DistanceUnits, with "mm" it gives 0.1
      @param units If not supplied the units will default to the default length specified in the preferences.
      @returns Returns -1 AND GetLastError will return ExpressionError in the event of an error.
    */
    evaluateExpression(expression: string, units?: string/* = "DefaultDistance"*/): number
    /**
      Converts a value from one unit to another. The input and output unit specifiers must be compatible.
      For example, "in" (inches) and "cm" (centimeters) will work because they both define length.
      So Convert(1.5, "in", "ft") -> 0.125
      Convert(1.5, unitsManager.defaultLengthUnits, "cm") -> depends on the current default distance units, with "mm" it gives 0.15
      So Convert(1.5, "in", "kg") -> -1 and GetLastError returns ExpressionError (to denote error)
      So Convert(1, "in", "internalUnits") -> 2.54
      So Convert(1, "internalUnits", "in") -> 0.3937...
      @param valueInInputUnits The value to convert
      @param inputUnits The units of the value to convert
      @param outputUnits The units to convert the value to
      @returns Returns -1 AND GetLastError returns ExpressionError in the event of an error.
    */
    convert(valueInInputUnits: number, inputUnits: string, outputUnits: string): number
    /**
      Formats the internal value as a string. The output string is formatted using the current
      unit settings in preferences. The preferences control the number of decimal places, whether
      units are abbreviated and several other things.
      FormatInternalValue(1.5, "in") -> "0.591 in"
      FormatInternalValue(1.5, "in", false) -> "0.591"
      FormatInternalValue(1.5, "mm", true) -> "15.00 mm"
      FormatInternalValue(1.5) -> depends on DistanceUnits, might be "15.0 mm"
      @remarks
      This property has been replaced by the formatValue method. This method does not honor the
      preferences for the precision, as it's supposed to. The formatValue method provides this capability
      and the ability to override the preference settings and specify how the value should be formatted.
      @param internalValue The internal value to format.
      @param displayUnits The units to display the value in. If not supplied the units will default to the default length specified in the preferences.
      @param showUnits Specify false to exclude units from the format. The default is true.
      @returns Returns an empty string if the units are incorrectly specified.
      @deprecated
    */
    formatInternalValue(internalValue: number, displayUnits?: string/* = "DefaultDistance"*/, showUnits?: boolean/* = true*/): string
    /**
      Formats the unit according to the user preferences
      "centimeter" -> "cm"
      "inch" -> "in"
      "cm* cm *cm / s" -> , "cm^3 / s"
      @param units The unit to use when converting the value into a string.
      @returns Returns an empty string and GetLastError returns ExpressionError in the event of an error.
    */
    formatUnits(units: string): string
    /**
      Standardizes the expression in terms of spacing and user preferences.
      StandardizeExpression("1.5") -> depends on distance units, but with might be "1.5 mm"
      StandardizeExpression("1.5", "in") -> "1.5 in"
      StandardizeExpression("1.5 cm + 1.50001 centimeter") -> "1.5 cm + 1.50001 cm"
      StandardizeExpression("1.5", "m * m * m / s") -> "1.5 m^3 /s"
      @param expression The expression to standardize
      @param units The units to apply to the standardized expression. If not supplied the units will default to the default length specified in the preferences.
      @returns Returns an empty string AND GetLastError returns ExpressionError in the event of an error.
    */
    standardizeExpression(expression: string, units?: string/* = "DefaultDistance"*/): string
    /**
      Returns a string that represents internal units - i.e. "internalUnits".
      This can be used when performing conversions via Convert.
    */
    readonly internalUnits: string
    /**
      Returns the unit strings for the current default length unit as specified in preferences. - e.g. "cm" or "in"
      This is the string that is being used by Fusion to represent the current length unit and is affected
      by the preference settings that let the user choose whether abbreviations and symbols can be used. This means
      that inch length units can be returned as inch, in, or ". If you need a consistent way of determining the current
      length unit, the distanceDisplayUnits of the FusionUnitsManager object returns an enum value.
    */
    readonly defaultLengthUnits: string
    /**
      Given a floating point number this method evaluates it as a value of a specific unit type
      and returns an appropriate string. By default, the current unit settings defined
      in the user preferences is used, but you can set the method arguments to override
      the defaults to specify the formatting you want. The input value always uses internal
      units, which are centimeters for length, radians for angles, and mass is in kilograms.
      This method is useful whenever you have a value you've gotten from Fusion or computed on your
      own and need to display it to the user as a string. This method does the conversion and also
      takes into account the units and the formatting the user has specified in their preferences.
      Below are some examples of various formatting where the user preferences for general precision is
      four decimal places, and the angular precision is one decimal place. Also, trailing zeros are set to
      be hidden and the minimum precision is two decimal places when trailing zeros are turned off. The
      design units are specified to be "inch".
      Here, only the value is supplied and the default is to assume the units are the current design length unit
      and use the preference settings to format it so there are four decimal places shown and the unit
      name is included.
      formatValue(1.5) -> "0.5906 in"
      In this example, an angle is specified by using "deg" as the unit, and the result showing
      one decimal place, which is what's defined in the user preference, and it shows the unit name.
      formatValue(0.7853981633974483096, "deg") -> "45.0 deg"
      This example converts the input value of 1.5 cm to mm where eight decimal places are shown,
      trailing zeros are shown, and the unit name is shown. The fourth argument of minimum precision is
      ignored, since it is only used when showTrailing zeros is False.
      formatValue(1.5, "mm", 8, BooleanOptions.TrueBooleanOption, 0, True) - > "15.00000000 mm"
      @param value A floating point value that is assumed to use the internal unit type, which are centimeters for length, radians for angles, and mass is in kilograms.
      @param units The units the value represents. The default value for this argument is "DefaultDistance" which means it will
      use the default distance units defined for the active design.
      @param precision This specifies the number of decimal places to display. The default value is -1 which indicates the
      precision specified in preferences should be used. A maximum of 9 can be used and any larger numbers
      will be forced to 9.
      @param showTrailingZeros Specifies if trailing zeros should be shown or not. The default value is to use the preference setting.
      @param minimumPrecision When trailing zeros are not displayed, this specifies a minimum precision where some trailing zeros are
      still shown. The default value is -1 which indicates the minimum precision specified in preferences
      should be used. A maximum of 8 can be used, and any larger numbers will be forced to 8.
      @param showUnits This specifies whether the unit name or symbol should be included in the result.
      @returns Returns the formatted string or an empty string in case of an error.
    */
    formatValue(value: number, units?: string/* = "DefaultDistance"*/, precision?: number /*int*//* = -1*/, showTrailingZeros?: BooleanOptions/* = BooleanOptions.DefaultBooleanOption*/, minimumPrecision?: number /*int*//* = -1*/, showUnits?: boolean/* = true*/): string
  }

  /**
    The different values that can be used when specifying whether an item
    should use a default, or be true or false.
  */
  const enum BooleanOptions {
    /**
      Specifies that the default value should be used.
    */
    DefaultBooleanOption,
    /**
      Specifies the value is True.
    */
    TrueBooleanOption,
    /**
      Specifies the value is False.
    */
    FalseBooleanOption,
  }

  /**
    A ValueInput provides a flexible way of specifying a string, a double, a boolean, or object reference.
    No semantics are associated with a ValueInput (e.g. is the string valid, can the string
    be converted to a double) - it is merely a way of supplying information in
    either string, double, boolean or object reference form as a function parameter.
    ValueInput objects are typically used to specify things like an extrude depth, or hole diameter, etc.
  */
  abstract class ValueInput extends Base {
    /**
      Creates a new ValueInput object using a double. For example, if you create a value using
      the double value 2 and use it as input for a length, it will be interpreted as 2 cm because
      centimeters are the internal unit for length. Values defined by a real are always
      interpreted to be in the appropriate internal unit.
      For example, if the value 2 is used to define the depth of an extrusion (a length value),
      it will be 2 cm because cm is the internal unit for lengths. If the value 2 is used
      to define the angle of the extrude, it will be 2 radians because radians are the internal
      unit for angles.
      @param realValue a double value
      @returns Returns the newly created ValueInput object or null if the creation failed.
    */
    static createByReal(realValue: number): ValueInput | null
    /**
      When a string is used to create a value it needs to be evaluated as an expression so
      its value can be determined using the UnitsManager class.
      The units of an expression can be explicitly defined or will default to the current default
      units.
      For example, if you create an expression with the string "6" and specify it as a length,
      it will use the current active units. If the current active units are defined as inches
      the expression will be interpreted as 6 inches.
      You can specify the units as part of the string (i.e. "6 mm").
      You can also use equations in the string (i.e. "6 + 5mm")
      In order for an expression to be valid, its units must be compatible with the value it
      represents. For example if you specify "5 in + 3 cm" as an expression to supply the value
      of an angle, it will fail because the units of the expression define a length.
      @param stringValue The expression string
      @returns Returns the newly created ValueInput object or null if the creation failed.
    */
    static createByString(stringValue: string): ValueInput | null
    /**
      Gets the real value, if there is one.
      Returns -1 AND GetLastError returns ValueNotOfType if there is no real value.
      You can use the valueType property to determine which value type is currently used.
    */
    readonly realValue: number
    /**
      Gets the string value, if there is one.
      Returns an empty string AND GetLastError returns ValueNotOfType if there is no string value.
      You can use the valueType property to determine which value type is currently used.
    */
    readonly stringValue: string
    /**
      Creates a new ValueInput object that contains a reference to any Fusion object.
      @param objectReference The Fusion object that you want to create the ValueInput for.
      @returns Returns the newly created ValueInput object or null if the creation failed.
    */
    static createByObject(objectReference: Base): ValueInput | null
    /**
      Gets the object being referenced, if there is one.
      Returns null AND GetLastError returns ValueNotOfType if there is no object reference.
      You can use the valueType property to determine which value type is currently used.
    */
    readonly objectReference: Base
    /**
      Returns the type of value this ValueInput currently represents.
    */
    readonly valueType: ValueTypes
    /**
      Creates a new ValueInput object that contains a boolean value.
      @param booleanValue Boolean value.
      @returns Returns the newly created ValueInput object or null if the creation failed.
    */
    static createByBoolean(booleanValue: boolean): ValueInput | null
    /**
      Gets the boolean value, if there is one.
      Returns false AND GetLastError returns ValueNotOfType if there is no boolean value.
      You can use the valueType property to determine which value type is currently used.
    */
    readonly booleanValue: boolean
  }

  /**
    The different types of values that a ValueInput can be.
  */
  const enum ValueTypes {
    /**
      Indicates the ValueInput is a string value.
    */
    StringValueType,
    /**
      Indicates the ValueInput is a real value.
    */
    RealValueType,
    /**
      Indicates the ValueInput is a reference to an object.
    */
    ObjectValueType,
    /**
      Indicates the ValueInput is a boolean value.
    */
    BooleanValueType,
  }

  /**
    Errors that can occur when using the ValueInput object.
  */
  const enum ValueInputError {
    /**
      Returned when the RealValue or StringValue properties of the ValueInput are called
      and there is no data to return of that type.
    */
    ValueNotOfTypeError = 100,
  }

  /**
    API object that provides equivalent functionality of the "Scripts and Add-Ins" dialog.
    Provides access to the scripts and add-ins that Fusion is aware of. It also
    supports loading other unknown scripts and add-ins, and creating new scripts and add-ins.
  */
  abstract class Scripts extends Base {
    /**
      Returns the number of scripts and add-ins.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new ScriptInput object. Logically, this object is equivalent to the
      dialog that is shown when you click the "Create" button in the "Scripts and Add-Ins"
      command dialog. It collects the information needed to create a new script or
      add-in. To create the script or add-in, call the addNew method, passing in the
      ScriptInput object.
      @param name The name of the script or add-in to create. By default, it will be created in the
      folder specified by the "Default Path for Scripts and Add-Ins" preference, but a
      different path can be specified using the returned ScriptInput object. Regardless of
      where it is created, the name must be unique with respect to the other scripts and
      add-ins in that folder. If it's not unique the creation of the script or add-in will fail.
      @param programmingLanguage The programming language to use for the new script or add-in.
      @param isAddIn Specifies if a script or add-in is to be created. If true, an add-in is created.
      @returns Returns a ScriptInput object or null in the case of failure.
    */
    createScriptInput(name: string, programmingLanguage: ProgrammingLanguages, isAddIn: boolean): ScriptInput | null
  }

  /**
    Used when creating a new script or add-in to specify all of the required
    and optional settings needed. This is created using the createScriptInput method
    on the Scripts object.
  */
  abstract class ScriptInput extends Base {
    /**
      Specifies if a script or add-in is to be created. A value of true
      indicates an add-in will be created.
    */
    isAddIn: boolean
    /**
      Gets and sets which programming language the new script or add-in will use.
    */
    programmingLanguage: ProgrammingLanguages
    /**
      Gets and sets the name of the script or add-in to create. This name must
      be unique with respect to the other scripts and add-ins in the folder
      specified by the targetFolder property.
    */
    name: string
    /**
      The description of the add-in that is displayed in the "Scripts and Add-Ins"
      dialog. This defaults to an empty string.
    */
    description: string
    /**
      The author of the add-in that is displayed in the "Scripts and Add-Ins"
      dialog. This defaults to an empty string.
    */
    author: string
    /**
      The version of the add-in that is displayed in the "Scripts and Add-Ins"
      dialog. This defaults to an empty string.
    */
    version: string
    /**
      Specifies the operating systems this script or add-in will be displayed
      in the "Scripts and Add-Ins" dialog and where it will be automatically
      run on startup, if that option is specified. Defaults to WindowsAndMacOperatingSystem
    */
    targetOperatingSystem: OperatingSystems
    /**
      The full path to the folder where the script or add-in will be created. By default,
      this is an empty string which uses the default folder specified by the "Default Path for Scripts and Add-Ins" preference.
      Specifying a path overrides the default and will create the script or add-in in the specified location.
      No "Scripts" or "AddIns" sub-folder is created.
    */
    targetFolder: string
    /**
      If this Script represents an add-in and isAddIn is True, this specifies if the
      add-in should be automatically started when Fusion starts up.
    */
    runOnStartup: boolean
  }

  /**
    Defines the different locations where Fusion looks for scripts and add-ins.
  */
  const enum ScriptSourceLocations {
    /**
      The location where add-ins are installed from the Autodesk App Store.
      Windows - %appdata%\Autodesk\ApplicationPlugins
      Mac - ~/Library/Application Support/Autodesk/ApplicationPlugins
    */
    AppStoreScriptSourceLocation,
    /**
      The folder where non-App Store add-ins are installed.
      Windows - %appdata%\Autodesk\FusionAddins
      Mac - ~/Library/Application Support/Autodesk/FusionAddins
    */
    OtherInstalledScriptSourceLocation,
    /**
      The folder defined in the API tab of the Preferences dialog.
    */
    UserDefinedScriptSourceLocation,
    /**
      One of the internal folders where add-ins are installed with Fusion.
    */
    InternalScriptSourceLocation,
    /**
      One of the sample folders where sample scripts and add-ins are installed with Fusion.
    */
    SamplesScriptSourceLocation,
    /**
      The script or add-in can be located anywhere and has been manually added
      to the known list of scripts and add-ins as a link.
    */
    LinkedScriptSourceLocation,
  }

  /**
    Defines the various languages supported for Fusion scripts and add-ins.
  */
  const enum ProgrammingLanguages {
    /**
      Used with the APIPreferences object to specify the user should be prompted
      when creating a new script or add-in.
    */
    PromptForLanguage,
    /**
      Specifies a script or add-in written using the Python programming language.
    */
    PythonProgrammingLanguage,
    /**
      Specifies a script or add-in written using the C++ programming language.
    */
    CPPProgramminglanguage,
  }

  /**
    Defines the various operating systems that a script or add-in can run on.
  */
  const enum OperatingSystems {
    /**
      Specifies the script or add-in will only run on Windows.
    */
    WindowsOperatingSystem,
    /**
      Specifies the script or add-in will only run on Mac.
    */
    MacOperatingSystem,
    /**
      Specifies the script or add-in will run on Windows and Mac.
    */
    WindowsAndMacOperatingSystem,
  }

  /**
    A viewport within Fusion. A viewport is the window where the model is displayed.
  */
  abstract class Viewport extends Base {
    /**
      Forces the view to refresh. It is sometimes useful to force a refresh to
      be able to see edits that have been made using the API.
      @returns Returns true if the operation was successful.
    */
    refresh(): boolean
    /**
      Gets and sets the camera associated with the view.
      The camera returned is a copy of the current camera
      settings of the view. Editing the properties of the
      camera will have no affect on the viewport until the
      camera is assigned back to the viewport.
    */
    camera: Camera
    /**
      Returns the height of the viewport in pixels.
    */
    readonly height: number /*int*/
    /**
      Returns the width of the viewport in pixels.
    */
    readonly width: number /*int*/
    /**
      Gets and sets if the view is in full screen mode.
    */
    isFullScreen: boolean
    /**
      Gets and sets the current visual style being used.
    */
    visualStyle: VisualStyles
    /**
      Forces a camera change so that all of the graphics are visible in the viewport.
      @returns Returns true if the fit was successful.
    */
    fit(): boolean
    /**
      A specified point in model space returns the equivalent point in view space.
      @param modelCoordinate A coordinate in model space.
      @returns Returns the equivalent point in view space.
    */
    modelToViewSpace(modelCoordinate: core.Point3D): core.Point2D
    /**
      A specified point in view space returns the equivalent point in model space.
      Because view space is 2D and model space is 3D, the depth of the point is
      returned is somewhat arbitrary along the eye to target point direction.
      @param viewCoordinate A coordinate in view space.
      @returns Returns the equivalent point in model space.
    */
    viewToModelSpace(viewCoordinate: core.Point2D): core.Point3D
    /**
      Converts a 2D screen point into the equivalent viewport coordinate.
      @param screenCoordinate A 2D coordinate in screen space.
      (0,0) indicates the upper-left corner of the entire screen.
      @returns Returns the equivalent point in the viewport. This can return null in the case
      where the input screen point does not lie within the viewport.
    */
    screenToView(screenCoordinate: core.Point2D): core.Point2D | null
    /**
      Converts a 2D viewPort point into the equivalent screen coordinate.
      @param viewCoordinate A 2D coordinate in the viewport.
      (0,0) indicates the upper-left corner of the viewport.
      @returns Returns the equivalent point in the screen. This can return null in the case where
      the input point is outside the bounds of the screen, which also means it's outside
      any viewport.
    */
    viewToScreen(viewCoordinate: core.Point2D): core.Point2D | null
    /**
      Returns the parent document of this viewport.
    */
    readonly parentDocument: Document
    /**
      Sets the "front" view to be the current view orientation.
      @returns Returns true if setting the view orientation was successful.
    */
    setCurrentAsFront(): boolean
    /**
      Sets the "top" view to be the current view orientation.
      @returns Returns true if setting the view orientation was successful.
    */
    setCurrentAsTop(): boolean
    /**
      Sets the "home" view to be the current view orientation.
      @param isFitToView Specifies if when the view goes "home" if the view should be fit to the model
      or not. True indicates the view will be fit to the model.
      @returns Returns true if setting the view orientation was successful.
    */
    setCurrentAsHome(isFitToView: boolean): boolean
    /**
      Sets the camera of the viewport to the defined "home" position.
      @param transition If this is true it will do a smooth transition from
      the current camera position to the home position. If false, the view will jump
      to the home position with no intermediate steps.
      @returns Returns true if setting the view orientation was successful.
    */
    goHome(transition?: boolean/* = true*/): boolean
    /**
      Resets the front view to be the default front view orientation.
      @returns Returns true if resetting to front was successful.
    */
    resetFront(): boolean
    /**
      Returns the direction of the front view as defined by the view cube.
      This vector defines the direction from the eye to the target for the front view.
    */
    readonly frontEyeDirection: core.Vector3D
    /**
      Returns the up direction of the front view as defined by the view cube.
    */
    readonly frontUpDirection: core.Vector3D
    /**
      Returns a transformation matrix that defines the transform from model to viewport space.
    */
    readonly modelToViewSpaceTransform: core.Matrix3D
  }

  /**
    Class that defines the various options that can be used when saving a viewport as an image. This
    object is created by using the static create method on the class and is then used as input to the
    Viewport.saveAsImageFileWithOptions method.
  */
  abstract class SaveImageFileOptions extends Base {
    /**
      Creates a new SaveImageFileOptions object. The returned object can be used to define
      the various options to use when saving a viewport as an image. The object is passed
      into the ViewPort.saveAsImageFileWithOptions method to create an image of the viewport.
      @param filename The full filename, including the path, of the image file.
      The type of image file to be created is inferred from the extension of the filename.
      @returns Returns a SaveImageFileOptions object.
    */
    static create(filename: string): SaveImageFileOptions
    /**
      Gets and sets the full filename, including the path, of the image file.
      The type of image file to be created is inferred from the extension of the filename.
    */
    filename: string
    /**
      Gets and set the height of the image to be created in pixels. A value of zero
      is valid and indicates the current height of the viewport is to be used. When
      the SaveImageFileOptions object is initially created, this is initialized to 0.
    */
    height: number /*int*/
    /**
      Gets and set the width of the image to be created in pixels. A value of zero
      is valid and indicates the current width of the viewport is to be used. When
      the SaveImageFileOptions object is initially created, this is initialized to 0.
    */
    width: number /*int*/
    /**
      Gets and sets if the background should be rendered as transparent. If false, the background will be the same as seen in Fusion.
      When the SaveImageFileOptions object is initially created, this is initialized to false.
    */
    isBackgroundTransparent: boolean
    /**
      Gets and sets if the rendered image should be anti-aliased or not. If false, there is no anti-aliasing.
      When the SaveImageFileOptions object is initially created, this is initialized to true.
    */
    isAntiAliased: boolean
  }

  /**
    A list of the support visual styles that Fusion uses when rendering the model.
  */
  const enum VisualStyles {
    /**
      Shaded display style.
    */
    ShadedVisualStyle,
    /**
      Shaded with hidden edges displayed.
    */
    ShadedWithHiddenEdgesVisualStyle,
    /**
      Shaded with only the visible edges displayed.
    */
    ShadedWithVisibleEdgesOnlyVisualStyle,
    /**
      Wireframe display style.
    */
    WireframeVisualStyle,
    /**
      Wireframe with hidden edges displayed.
    */
    WireframeWithHiddenEdgesVisualStyle,
    /**
      Wireframe with only the visible edges displayed.
    */
    WireframeWithVisibleEdgesOnlyVisualStyle,
  }

  /**
    The Camera class represents the information that specifies how a model is
    displayed within a viewport. It's analogous to a real camera, which has a
    position in space, is pointed towards a specific point, is oriented
    in a particular way, and has a specific type of lens.
    Whether a camera is created statically using the Camera.create() method or
    obtained from a Viewport, a Camera object is always temporary and not associated
    with anything. This means when you get it from a Viewport, the Camera object
    captures the current state of the Viewport and stores it but doesn't save
    where it came from, so it is completely independent.
    To update the camera settings associated with a Viewport, get a Camera object from
    a Viewport or create a new Camera using Camera.create(), modify the Camera object
    to define the view you want, and assign it to the Viewport.
  */
  abstract class Camera extends Base {
    /**
      Gets and sets the position of the eye in world space.
    */
    eye: Point3D
    /**
      Gets and sets the camera target point in world space.
    */
    target: Point3D
    /**
      Gets and sets the current camera type.
    */
    cameraType: CameraTypes
    /**
      Gets and sets the perspective angle of the camera. This
      property is only valid when the CameraType property is
      either Perspective or PerspectiveWithOrthoFaces.
    */
    perspectiveAngle: number
    /**
      Defines the "up" direction for the camera which controls the orientation of the camera around the line
      defined between the eye and target points.
    */
    upVector: Vector3D
    /**
      Defines the area that's visible by the camera. This
      value is the radius of a sphere centered at the target point.
      The camera will display everything within that sphere and
      everything in front of and behind the sphere. Additional
      geometry outside of the sphere will also be visible depending
      on the shape of the window. Setting this
      value can cause the eye and/or perspective angle to be
      modified when the camera type is perspective.
      @remarks
      This property has been replaced by the getExtents and setExtents methods.
      @deprecated
    */
    viewExtents: number
    /**
      If this property is true, when this camera is applied to a viewport it
      will modify the camera such that the entire model is displayed in the viewport.
      When getting a camera from a viewport or creating a camera using Camera.create(),
      this property defaults to false.
    */
    isFitView: boolean
    /**
      This property controls if Fusion will perform a smooth transition animation from the
      current camera position to the new position. If this property is set to true, it will
      smoothly transition. If false, the camera will jump to the position defined by the
      camera without any animated transition.
      When a camera is obtained from a Viewport or created using the Camera.create() method,
      this property defaults to false.
    */
    isSmoothTransition: boolean
    /**
      Sets the camera to a standard orientation. If this is set, it will result in resetting
      all the camera values except the camera type. The orientation is based on the current
      orientation defined by the ViewCube. This means, that the view orientations cannot be
      expected to be consistent from one view to another.
    */
    viewOrientation: ViewOrientations
    /**
      Creates a new Camera object that is independent of any viewport. This can be used
      to construct a camera to be used as input to modify a viewport, and create or
      update a named view.
      @returns Returns the created camera.
    */
    static create(): Camera
    /**
      Gets the extents of the camera. This is only used for orthographic cameras.
      The extents of a perspective camera is defined by a combination of the position
      of the eye point (how close the eye is to the model) and the perspective angle.
      @param width The width of the extent in centimeters.
      @param height The height of the extent in centimeters.
      @returns Returns true if successful. This will fail in the case it is used for a perspective camera.
    */
    getExtents(): [width: number, height: number]
    /**
      Sets the extents of the camera. This is only used for orthographic cameras.
      The extents of a perspective camera is defined by a combination of the position
      of the eye point (how close the eye is to the model) and the perspective angle.
      When the camera is assigned to a viewport, typically only the width or the
      height is used depending on the aspect ratio of the viewport. For example,
      if the width and height are both 10, but the viewport is twice as wide as
      it is tall (2:1 aspect ratio). The height extent will be 10 and the width
      extent will be recomputed to be 20 to match the viewport.
      @param width The width of the extent in centimeters.
      @param height The height of the extent in centimeters.
      @returns Returns true if successful. This will fail in the case it is used for a perspective camera.
    */
    setExtents(width: number, height: number): boolean
  }

  /**
    The different types of cameras.
  */
  const enum CameraTypes {
    /**
      An orthographic camera. Things are the same size in the view regardless of there distance from the eye.
    */
    OrthographicCameraType,
    /**
      An perspective camera. Things are smaller the further they are away from the eye.
    */
    PerspectiveCameraType,
    /**
      An perspective camera. Things are smaller the further they are away from the eye.
    */
    PerspectiveWithOrthoFacesCameraType,
  }

  /**
    Common view orientations.
  */
  const enum ViewOrientations {
    /**
      The view is oriented in an orientation other than one of the predefined orientations.
    */
    ArbitraryViewOrientation,
    /**
      The view is oriented to see the back of the model.
    */
    BackViewOrientation,
    /**
      The view is oriented to see the bottom of the model.
    */
    BottomViewOrientation,
    /**
      The view is oriented to see the front of the model.
    */
    FrontViewOrientation,
    /**
      The view is oriented to see the bottom left corner of the model.
    */
    IsoBottomLeftViewOrientation,
    /**
      The view is oriented to see the bottom right corner of the model.
    */
    IsoBottomRightViewOrientation,
    /**
      The view is oriented to see the top left corner of the model.
    */
    IsoTopLeftViewOrientation,
    /**
      The view is oriented to see the top right corner of the model.
    */
    IsoTopRightViewOrientation,
    /**
      The view is oriented to see the left of the model.
    */
    LeftViewOrientation,
    /**
      The view is oriented to see the right of the model.
    */
    RightViewOrientation,
    /**
      The view is oriented to see the top of the model.
    */
    TopViewOrientation,
  }

  /**
    Collection that provides access to all of the existing named views associated
    with a Product and supports the creation of new named views.
  */
  abstract class NamedViews extends Base {
    /**
      Returns the number of named views associated with the product. The four
      standard named views ("TOP", "FRONT", "RIGHT", and "HOME") are not included
      in this count. Only user-created named view are counted.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified named view using an index into the collection. The four
      standard named views ("TOP", "FRONT", "RIGHT", and "HOME") are not accessible
      through this method. For the predefined view use the properties on this
      collection that provide direct access to the specific named view.
      @param index The index of the named view within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified named view or an error if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): NamedView
    /**
      Returns the specified named view using the name of the named view. The four
      standard named views ("TOP", "FRONT", "RIGHT", and "HOME") are not accessible
      through this method. For the predefined view use the properties on this
      collection that provide direct access to the specific named view.
      @param name The name of the named view within the collection to return.
      @returns Returns null if the specified name was not found.
    */
    itemByName(name: string): NamedView | null
    /**
      Creates a new named view.
      @param camera The camera that defines the view. To create a named view for the active viewport
      you can get a camera from the active viewport and provide it as input to this method.
      @param name The name of the named view. This must be unique with respect
      to other named views in the product. This is optional and if
      not provided a default unique name will be generated.
      @returns Returns the newly created NamedView object or fails if invalid input was provided.
    */
    add(camera: Camera, name?: string/* = ""*/): NamedView
    /**
      Returns the standard named view called "TOP".
    */
    readonly topNamedView: NamedView
    /**
      Returns the standard named view called "FRONT".
    */
    readonly frontNamedView: NamedView
    /**
      Returns the standard named view called "RIGHT".
    */
    readonly rightNamedView: NamedView
    /**
      Returns the standard named view called "HOME".
    */
    readonly homeNamedView: NamedView
  }

  /**
    Represents a named view as seen in the browser.
  */
  abstract class NamedView extends Base {
    /**
      Returns the parent product of this named view.
    */
    readonly parentProduct: Product
    /**
      Indicates if this named view is one of the four standard
      named views ("TOP", "FRONT", "RIGHT", and "HOME"). There
      is limited functionality with the four standard named views.
    */
    readonly isBuiltIn: boolean
    /**
      Gets and sets the name of this named view. This property
      acts as read-only for the four standard named views.
      This can be determined by checking to see if the isBuiltIn property is true.
    */
    name: string
    /**
      Gets and sets the camera associated with this named view. This property
      acts as read-only for the four standard named views.
      This can be determined by checking to see if the isBuiltIn property is true.
    */
    camera: Camera
    /**
      Deletes this named view. This method will fail for any of the four standard named views.
      This can be determined by checking to see if the isBuiltIn property is true.
    */
    deleteMe(): boolean
    /**
      This updates the active viewport to use the camera associated with this named view.
      @returns Returns true if the operation was successful.
    */
    apply(): boolean
  }

  /**
    Provides access to functionality to support importing various modeling formats into Fusion.
  */
  abstract class ImportManager extends core.Base {
    /**
      Creates an IGESImportOptions object that is used to import a design from IGES format. Creation
      of the IGESImportOptions object does not perform the import. You must pass this object to one of the
      ImportManager import methods to perform the import. The IGESImportOptions supports any available
      options when importing from IGES format.
      @param filename The filename or URL of the IGES file to be imported.
      @returns The created IGESImportOptions object or null if the creation failed.
    */
    createIGESImportOptions(filename: string): IGESImportOptions | null
    /**
      Creates an STEPImportOptions object that's used to import a design from STEP format. Creation
      of the STEPImportOptions object does not perform the import. You must pass this object to one of the
      ImportManager import methods to perform the import. The STEPImportOptions supports any available
      options when importing from STEP format.
      @param filename The filename or URL of the STEP file to be imported.
      @returns The created STEPImportOptions object or null if the creation failed.
    */
    createSTEPImportOptions(filename: string): STEPImportOptions | null
    /**
      Creates an SATImportOptions object that's used to import a design from SAT format. Creation
      of the SATImportOptions object does not perform the import. You must pass this object to one of the
      ImportManager import methods to perform the import. The SATImportOptions supports any available
      options when importing from SAT format.
      @param filename The filename or URL of the SAT file to be imported.
      @returns The created SATImportOptions object or null if the creation failed.
    */
    createSATImportOptions(filename: string): SATImportOptions | null
    /**
      Creates an SMTImportOptions object that's used to import a design from SMT format. Creation
      of the SMTImportOptions object does not perform the import. You must pass this object to one of the
      ImportManager import methods to perform the import. The SMTImportOptions supports any available
      options when importing from SMT format.
      @param filename The filename or URL of the SMT file to be imported.
      @returns The created SMTImportOptions object or null if the creation failed.
    */
    createSMTImportOptions(filename: string): SMTImportOptions | null
    /**
      Creates a FusionArchiveImportOptions object that imports a design from a Fusion archive format.
      The creation of the FusionArchiveImportOptions object does not perform the import. You must pass
      this object to one of the ImportManager import methods to perform the import. The FusionArchiveImportOptions
      object supports the available options when importing from a Fusion archive format. This method only supports
      f3d files. For f3z files, you should use the DataFolder.uploadFile method.
      @param filename The filename or URL of the Fusion archive file to be imported. Only f3d files can be imported.
      For f3z files, you should use the DataFolder.uploadFile method.
      @returns The created FusionArchiveImportOptions object or null if the creation failed.
    */
    createFusionArchiveImportOptions(filename: string): FusionArchiveImportOptions | null
    /**
      Executes the import operation to import a file (of the format specified by the input ImportOptions object)
      to a new document.
      This method does not support the DXF2DImportOptions or SVGImportOptions objects. Use ImportToTarget or
      ImportToTarget2 for those types.
      @param importOptions An ImportOptions object that is created using one of the create methods on the ImportManager object. This
      defines the type of file and any available options supported for that file type.
      @returns Returns the newly created Document object or null if the creation failed.
      A new unnamed, unsaved document will be opened in Fusion as a result.
    */
    importToNewDocument(importOptions: ImportOptions): core.Document | null
    /**
      Executes the import operation to import a file (of the format specified by the input ImportOptions object)
      into an existing component in an existing design.
      @remarks
      There is currently a limitation with this method where it cannot be used within any of the Command
      related events.
      @param importOptions An ImportOptions object that is created using one of the create methods on the ImportManager object. This
      defines the type of file and any available options supported for that file type.
      Supplying a DXF2DImportOptions object will result in the creation of one or more sketches
      (depending on the layers in the DXF file) in the target component.
      @param target For most import types this will be a Component. For SVGImportOptions this is the sketch you want to
      import the SVG data into.
      @returns Returns true if the import was successful.
    */
    importToTarget(importOptions: ImportOptions, target: core.Base): boolean
    /**
      Creates a DXF2DImportOptions object that is used to import 2D data to create sketches. Creation
      of the createDXF2DImportOptions object does not perform the import. You must pass this object to the
      ImportManager.importToTarget method to perform the import. The sketches created as a result of
      the import are available through the 'results' property of the DXF2DImportOptions.
      @param filename The filename of the DXF file to be imported.
      @param planarEntity The construction plane or planar face that defines the plane that the resulting sketches will
      be created on.
      @returns The created DXF2DImportOptions object or null if the creation failed.
    */
    createDXF2DImportOptions(filename: string, planarEntity: core.Base): DXF2DImportOptions | null
    /**
      Executes the import operation to import a file (of the format specified by the input ImportOptions object)
      into an existing component in an existing design and returns the imported objects.
      @remarks
      There is currently a limitation with this method where it cannot be used within any of the Command
      related events.
      @param importOptions An ImportOptions object that is created using one of the create methods on the ImportManager object. This
      defines the type of file and any available options supported for that file type.
      Supplying a DXF2DImportOptions object will result in the creation of one or more sketches
      (depending on the layers in the DXF file) in the target component.
      @param target For most import types this will be a Component. For SVGImportOptions this is the sketch you want to
      import the SVG data into.
      @returns Returns an ObjectCollection containing the results of whatever was created as a result of the import.
      null is returned in the case of failure.
    */
    importToTarget2(importOptions: ImportOptions, target: core.Base): ObjectCollection
    /**
      Creates a SVGImportOptions object that is used to import SVG data into a sketch. Creation
      of the SVGImportOptions object does not perform the import. You must pass this object to the
      importToTarget or importToTarget2 methods to perform the import and provide the sketch you want
      to import to as the target.
      @param fullFilename The full filename, including the path, of the SVG file.
      @returns The created SVGImportOptions object or null if the creation failed.
    */
    createSVGImportOptions(fullFilename: string): SVGImportOptions | null
  }

  /**
    The base class for the different import types. This class is never directly used
    in an import because you need the specific import type to specify the type of
    import to be performed.
  */
  abstract class ImportOptions extends core.Base {
    /**
      Gets and sets the filename or URL of the file to be imported.
    */
    filename: string
    /**
      Specifies if the camera should be adjusted to fit the geometry of the import.
      This defaults to true, which will cause a change in the current view. Setting this
      to false will leave the view as-is and just import the geometry.
    */
    isViewFit: boolean
  }

  /**
    Defines that an IGES import is to be done and specifies the various options.
  */
  abstract class IGESImportOptions extends ImportOptions {
  }

  /**
    Defines that a STEP import is to be done and specifies the various options.
  */
  abstract class STEPImportOptions extends ImportOptions {
  }

  /**
    Defines that a SAT import is to be done and specifies the various options.
  */
  abstract class SATImportOptions extends ImportOptions {
  }

  /**
    Defines that an SMT import is to be done and specifies the various options.
  */
  abstract class SMTImportOptions extends ImportOptions {
  }

  /**
    Defines that a Fusion Archive import is to be done and specifies the various options.
  */
  abstract class FusionArchiveImportOptions extends ImportOptions {
  }

  /**
    Defines that a 2D DXF Import to create sketches (based on layers in the DXF file) is to be performed and
    specifies the various options.
  */
  abstract class DXF2DImportOptions extends ImportOptions {
    /**
      Gets and sets the construction plane or planar face that defines the plane that the resulting sketches will
      be created on.
    */
    planarEntity: core.Base
    /**
      Gets and sets the X,Y offset position for the origin of the imported DXF data relative to the sketch origin.
      This defaults to (0,0) in a newly created DXF2DImportOptions object.
    */
    position: core.Point2D
    /**
      Returns a collection of Sketch objects. A sketch is created for each layer in the DXF file
      that contains 2D geometry. Any 3D geometry contained in the DXF file is ignored.
      The names of the resulting sketches correspond to the layer names in the DXF file.
      Currently, the only way to get a single sketch as a result is to supply a DXF file that only has 2D geometry
      on a single layer.
    */
    readonly results: core.ObjectCollection
    /**
      Gets and sets if importing the DXF file should create a new sketch for each layer or
      if the entire contents of the DXF file should be merged into a single layer. If true
      a single sketch will be created. If false a new sketch for each layer will be created
      where the sketch name will be the name of the layer. The default value for this
      property is false, resulting in a sketch for each layer.
    */
    isSingleSketchResult: boolean
    /**
      Gets and sets the names of the layers that will be imported. When the DXF2DImportOptions
      object is first created, the array returned is a list of all the layers in the DXF file.
      By default, all layers will be imported. You can set the property using a new array that
      contains the names of only those layers you want to import.
    */
    layers: string[]
    /**
      When set to true, if there are any splines in the DXF they will be created as control
      point splines. Otherwise they will be created as fixed splines that cannot be edited.
      The default for this property is false, to create fixed splines.
    */
    isCreateControlPointSplines: boolean
  }

  /**
    Defines that an SVG import is to be done and specifies the various options.
  */
  abstract class SVGImportOptions extends ImportOptions {
    /**
      Gets and sets the transformation matrix that defines the position, orientation, scale, and
      mirroring of the imported SVG data relative to the sketch coordinate system.
      This property defaults to an identity matrix in a newly created SVGImportOptions object.
      You can define mirroring (the equivalent of horizontal or vertical flip) in the matrix. Doing
      this gives you more explicit control over the results. You can also use the isHorizontalFlip
      and isVerticalFlop properties to define the flip. These result in flipping the geometry along
      the center of the geometry's bounding box.
    */
    transform: core.Matrix3D
    /**
      Gets and sets if the SVG is flipped along the sketch X axis.
      This property defaults to false in a newly created SVGImportOptions object.
    */
    isHorizontalFlip: boolean
    /**
      Gets and sets if the SVG is flipped along the sketch Y axis.
      This property defaults to false in a newly created SVGImportOptions object.
    */
    isVerticalFlip: boolean
    /**
      Gets and sets if any spline curves in the SVG should be drawn with their control
      point frames. This property defaults to false in a newly created SVGImportOptions object.
    */
    isControlPointFrameDisplayed: boolean
  }

  /**
    A class that represents a Fusion User
  */
  abstract class User extends Base {
    /**
      Returns the user name associated with this user's Autodesk account
    */
    readonly userName: string
    /**
      Returns display name of the user. (i.e. the name that shows up in the Fusion UI)
    */
    readonly displayName: string
    /**
      Returns the user's internal Autodesk account name.
      This can be used by applications sold through the Autodesk Exchange Store to verify that the user has in
      fact purchased the product.
    */
    readonly userId: string
    /**
      Get the email associated with this users Fusion account
    */
    readonly email: string
  }

  /**
    Provides access to attributes associated with a specific entity,
    Product, or Document. Also supports the creation of new attributes.
  */
  abstract class Attributes extends Base {
    /**
      Returns the number of attributes in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified attribute using an index into the collection.
      @param index The index of the attribute within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified attribute or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Attribute | null
    /**
      Returns the specified attribute using the name of the attribute.
      @param groupName The name of the attribute group this attribute will belong to.
      @param name The name of the attribute.
      @returns Returns the specified attribute or null if no attribute exists with the specified name.
    */
    itemByName(groupName: string, name: string): Attribute | null
    /**
      Adds a new attribute to the parent entity. If an attribute already exists on the entity with the
      same groupName and name already exists, this will update the existing attribute with the new value.
      @param groupName The name of the attribute group to create this attribute within.
      @param name The name of the attribute. This must be unique with respect to other attributes in the group.
      @param value The value of the attribute. The size of an attribute value is limited to 2MB (2097152 bytes). If
      you need to save data that is larger than 2MB you'll need to break it into pieces and save it in
      multiple attributes.
      @returns Returns the newly created attribute or null if the creation failed. If an attribute with the
      same groupName and name already exists, it will return the existing attribute.
    */
    add(groupName: string, name: string, value: string): Attribute | null
    /**
      Returns an array of all of the attributes that belong to the specified group.
      @param groupName The name of the group.
      @returns Returns an array of attributes or will fail in the case where an invalid group name is specified.
    */
    itemsByGroup(groupName: string): Attribute[]
    /**
      Returns an array of strings that are all of the name of attribute groups that exist on this entity.
      An empty array can be returns if there are no attributes on the entity.
    */
    readonly groupNames: string[]
  }

  /**
    Represents an attribute associated with a specific entity, Product, or Document.
    An attribute is a named value.
  */
  abstract class Attribute extends Base {
    /**
      Gets the name of the group this attribute is a part of.
    */
    readonly groupName: string
    /**
      Gets the name of the attribute.
    */
    readonly name: string
    /**
      Gets and sets the value of this attribute.
      The size of an attribute value is limited to 2MB (2097152 bytes). If you need to
      save data that is larger than 2MB you'll need to break the data into pieces and
      save it in multiple attributes.
    */
    value: string
    /**
      Returns the parent entity this attribute is associated with. This can return null
      in some cases. For example a BRepEdge might have been consumed by a fillet
      feature but can come back if the model is rolled back or the fillet is deleted.
      It's possible that the original parent that an attribute was placed on has been
      split. For example, if an attribute is placed on a face and then a slot is created
      that cuts the face into two pieces and the attribute is available from each face.
      In this case the parent property will return the "primary" face, which in most cases
      is somewhat arbitrary. You can get the other entities the attribute is associated
      with by using the otherParents property.
    */
    readonly parent: core.Base
    /**
      Deletes this attribute.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      In the case where the entity the attribute was originally placed on has been split,
      this property will return the other entities the attribute is associated with.
      For example, if an attribute is placed on a face and then a slot is created
      that cuts the face into two pieces and the attribute is available from both faces.
      The parent property returns the "primary" entity and this property returns any other
      entities, if any. If there aren't any other associated entities the ObjectCollection
      returned will be empty.
    */
    readonly otherParents: core.ObjectCollection
  }

  /**
    The MeasurementManager class provides some generic measurement utilities that
    can be used for most entity types.
  */
  abstract class MeasureManager extends core.Base {
    /**
      Calculates an oriented bounding box for the input geometry. The bounding box is tight fitting
      to the input geometry and is particularly useful when you want to calculate a bounding box that
      is not oriented to be parallel to the model x-y-z plane.
      The height direction is automatically determined using the length and width directions.
      @param geometry The geometry to calculate the bounding box for. This can be any of the B-Rep related entities.
      @param lengthVector The direction the length of the oriented bounding box will be measured in. The magnitude of the vector
      is ignored and only the direction is used.
      @param widthVector The direction the width of the oriented bounding box will be measured in. The magnitude of the vector
      is ignored and only the direction is used. This must be perpendicular to the length vector.
      @returns Returns an OrientedBoundingBox3D object which provides the information that defines an oriented bounding box.
    */
    getOrientedBoundingBox(geometry: core.Base, lengthVector: core.Vector3D, widthVector: core.Vector3D): OrientedBoundingBox3D
    /**
      Measures the minimum distance between the two input geometries.
      @param geometryOne The first geometry to measure from. This can be an Occurrence, BRepBody, BRepFace, BRepEdge, BRepVertex,
      ConstructionPlane, ConstructionAxis, ConstructionPoint, and any sketch entity. The only temporary geometry supported is the Plane object.
      @param geometryTwo The first geometry to measure from. This can be an Occurrence, BRepBody, BRepFace, BRepEdge, BRepVertex,
      ConstructionPlane, ConstructionAxis, ConstructionPoint, and any sketch entity. The only temporary geometry supported is the Plane object.
      @returns A MeasureResults object that contains the distance and the two points on the geometry that the distance that
      was measured between them in centimeters.
    */
    measureMinimumDistance(geometryOne: core.Base, geometryTwo: core.Base): MeasureResults
    /**
      Measures the angle between the input geometry.
      @param geometryOne The first geometry to measure the angle to. This can be any 3D point geometry (Construction Point, Vertex, SketchPoint, or Point3D),
      any 3D linear geometry (Construction Axis, linear BRepEdge, SketchLine, Line3D, or InfiniteLine3D), or any planar geometry (Construction Plane, planar BRepFace, or Plane).
      @param geometryTwo The second geometry to measure the angle to. This can be any 3D point geometry (Construction Point, Vertex, SketchPoint, or Point3D),
      any 3D linear geometry (Construction Axis, linear BRepEdge, SketchLine, Line3D, or InfiniteLine3D), or any planar geometry (Construction Plane, planar BRepFace, or Plane).
      @param geometryThree The optional third geometry to measure the angle to. This is only used when the first two geometries
      are points and this defines the third point. When three points define a triangle, the apex of the
      triangle is defined by the second point. A point can be defined by a Construction Point, Vertex, SketchPoint, or Point3D object.
      @returns A MeasureResults object that contains the angle and the two points on the geometry that the angle
      that was measured between them in radians.
    */
    measureAngle(geometryOne: core.Base, geometryTwo: core.Base, geometryThree?: core.Base/* = null*/): MeasureResults
  }

  /**
    Provides measurement results from the various measurement methods available on the MeasureManager object.
  */
  abstract class MeasureResults extends core.Base {
    /**
      The measurement value. If the measurement is a distance this value will be in centimeters.
      If it's an angle then it will be in radians.
    */
    readonly value: number
    /**
      For a distance measurement, this is the point on the first entity where the measurement was made from.
      For an angle measurement this is one of the three points defining the angle.
    */
    readonly positionOne: Point3D
    /**
      For a distance measurement, this is the point on the second entity where the measurement was made to.
      For an angle measurement this is one of the three points defining the angle.
    */
    readonly positionTwo: Point3D
    /**
      This point is only used for angle measurements and is one of the three points defining the angle.
    */
    readonly positionThree: Point3D
  }

  /**
    Used to communicate the current status of an object or operation. This provides the status
    and any error messages that might accompany an error or warning.
  */
  abstract class Status extends Base {
    /**
      If true, An error occurred that has prevented the operation from successfully completing.
      This takes into account all of the child status messages.
    */
    readonly isError: boolean
    /**
      If true, the operation has succeeded but with an unusual result.
      This takes into account all of the child status messages.
    */
    readonly isWarning: boolean
    /**
      If true, the operation was successful without any warnings or errors.
      This takes into account all of the child status messages.
    */
    readonly isOK: boolean
    /**
      the status messages associated with this status. These messages are displayed to
      the user in the alert dialog. Each status message can have children status
      messages that will be displayed as a tree structure in the alert dialog.
    */
    readonly statusMessages: StatusMessages
  }

  /**
    A collection of status messages associated with a Status object. The primary purpose of the messages is to
    describe the reason for a warning or failure and display the messages in the alert dialog.
  */
  abstract class StatusMessages extends Base {
    /**
      Returns the number of status messages in this collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified status message using an index into the collection.
      @param index The index of the status message within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified StatusMessage or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): StatusMessage | null
    /**
      Adds a new error status message to the list of warning and error messages.
      @param messageId The ID of a predefined message or if an empty string is provided, the
      default error message will be used. The displayed message is localized based on the
      current default language in Fusion. Below is a list of some valid message ID's and
      the corresponding English message.
      <br/><br/>
      "API_COMPUTE_ERROR" - "Cannot compute this feature."<br />
      "API_COMPUTE_WARNING" - "This feature computed with warnings."<br />
      "CFLANGE_INVALID_GEOM" - "Invalid input sketch curve."<br />
      "DRAFT_MISSING_FACE_REFERENCES" - "Missing face references"<br />
      "DRAFT_MISSING_REFERENCE_PLANE" - "Missing reference plane"<br />
      "FEATURE_ENTITY_TYPE_INVALID" - "Entity type is invalid"<br />
      "FEATURE_FAILED_TO_CREATE" - "Failed to create feature"<br />
      "FEATURE_MISSING_INPUTS" - "Missing inputs"<br />
      "FEATURE_REFERENCE_LOST" - "Reference is lost"<br />
      "Feature_Compute_Error" - "Compute Failed"<br />
      "Feature_Input_Compute_Error" - "Reference Failures"<br />
      "InvalidWPntInput" - "Invalid input"<br />
      "NO_TARGET_BODY" - "No target body!"<br />
      "ORIGIN_SELECTION_MISSING" - "Origin geometry is missing."<br />
      "DRPOINT_COMPUTE_FAILED" - "Failed to evaluate the point due to the invalid input"<br />
      @param message This is not currently supported for custom feature compute errors and will be ignored.
      @returns Returns true if the error message was successfully added.
    */
    addError(messageId?: string/* = ""*/, message?: string/* = ""*/): StatusMessage
    /**
      Adds a new warning status message to the list of warning and error messages.
      @param messageId The ID of a predefined message or if an empty string is provided, the
      default error message will be used. The displayed message is localized based on the
      current default language in Fusion. Below is a list of some valid message ID's and
      the corresponding English message.
      <br/><br/>
      "API_COMPUTE_ERROR" - "Cannot compute this feature."<br />
      "API_COMPUTE_WARNING" - "This feature computed with warnings."<br />
      "CFLANGE_INVALID_GEOM" - "Invalid input sketch curve."<br />
      "DRAFT_MISSING_FACE_REFERENCES" - "Missing face references"<br />
      "DRAFT_MISSING_REFERENCE_PLANE" - "Missing reference plane"<br />
      "FEATURE_ENTITY_TYPE_INVALID" - "Entity type is invalid"<br />
      "FEATURE_FAILED_TO_CREATE" - "Failed to create feature"<br />
      "FEATURE_MISSING_INPUTS" - "Missing inputs"<br />
      "FEATURE_REFERENCE_LOST" - "Reference is lost"<br />
      "Feature_Compute_Error" - "Compute Failed"<br />
      "Feature_Input_Compute_Error" - "Reference Failures"<br />
      "InvalidWPntInput" - "Invalid input"<br />
      "NO_TARGET_BODY" - "No target body!"<br />
      "ORIGIN_SELECTION_MISSING" - "Origin geometry is missing."<br />
      "DRPOINT_COMPUTE_FAILED" - "Failed to evaluate the point due to the invalid input"<br />
      @param message This is not currently supported for custom feature compute errors and will be ignored.
      @returns Returns true if the warning message was successfully added.
    */
    addWarning(messageId?: string/* = ""*/, message?: string/* = ""*/): StatusMessage
  }

  /**
    Defines the message associated with a Status object.
  */
  abstract class StatusMessage extends Base {
    /**
      Gets and sets the ID of the message being used. This is a predefined ID within the Fusion message
      string table.
    */
    messageId: string
    /**
      The user visible message being used. Setting this message for custom feature errors or warnings is
      currently ignored.
    */
    message: string
    /**
      Returns the type of message this StatusMessage represents.
    */
    readonly statusMessageType: StatusMessageTypes
    /**
      Returns the collection of status codes that are children of
      this status message.
    */
    readonly childStatusMessages: StatusMessages
  }

  /**
    The different types of status messages that can be used with the StatusCode object.
  */
  const enum StatusMessageTypes {
    /**
      No error or warning is associated with the status code.
    */
    StatusMessageNoneType,
    /**
      An error that prevents the operation from succeeding.
    */
    StatusMessageErrorType,
    /**
      A warning that the operation has succeeded but without expected results.
    */
    StatusMessageWarningType,
  }

  /**
    The SelectionSets object is used to create and access existing selection sets.
    In the user interface, selection sets are created by selecting geometry and then
    running the "Create Selection Set" command from the context menu. All existing
    selection sets are shown in a "Selection Sets" folder in the browser.
  */
  abstract class SelectionSets extends Base {
    /**
      Returns the number of SelectionSet objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified SelectionSet object using an index into the collection.
      @param index The index of the SelectionSet within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified SelectionSet or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SelectionSet | null
    /**
      Returns the specified SelectionSet object using the name of the selection set.
      @param name The name of the SelectionSet object to return.
      @returns Returns the specified SelectionSet object or null if no SelectionSet object exists with the specified name.
    */
    itemByName(name: string): SelectionSet | null
    /**
      Adds a new SelectionSet to the parent product.
      @param entities An array of entities that will be in the created selection set. All entities must be in the
      context of the root component. This means if the entity isn't directly owned by the root
      component, it must be a proxy.
      @param name The name of the selection set. This is an optional argument is if not specified, or an empty string is
      provided, Fusion will create a name for the selection set. If provided, the name should be unique with
      respect to other selection sets in the product. If a name is provided that is the same as an existing
      selection set, Fusion will append a counter to the name to make the name unique.
      @returns Returns the created selection set or null in the case the selection set couldn't be created. This method
      can fail in the case where no entities are provided or if any of the provided entities are not selectable.
    */
    add(entities: core.Base[], name?: string/* = ""*/): SelectionSet | null
  }

  /**
    The SelectionSet object represents a Selection Set as seen in the user interface. Using a SelectionSet,
    you can access all the associated data, activate, and delete a selection set.
    In the user interface, selection sets are created by selecting geometry and then running the
    "Create Selection Set" command from the context menu. All existing selection sets are shown
    in a "Selection Sets" folder in the browser where they can be activated and deleted.
  */
  abstract class SelectionSet extends Base {
    /**
      Gets and sets the name of the SelectionSet object. If a name is assigned that is already
      used, Fusion will append a counter to the name to make it unique.
    */
    name: string
    /**
      Gets and sets the entities in the selection set. Setting this property is the equivalent
      of using the "Update" option for a selection set in the user-interface.
      Setting the entities can fail in the case where you provide an entity that is not valid
      for selection. All entities must be in the context of the root component. This means if
      the entity isn't directly owned by the root component, it must be a proxy.
    */
    entities: core.Base[]
    /**
      Causes the entities in this SelectionSet object to be the active selection.
      @returns Returns true if the selection was successful.
    */
    select(): boolean
    /**
      Deletes this SelectionSet object.
      @returns Returns true if the deletion was successful.
    */
    deleteMe(): boolean
  }

  /**
    A collection of PropertyGroup objects.
  */
  abstract class PropertyGroups extends Base {
    /**
      Returns the specified property group from the collection using an index into the collection.
      @param index The index of the property within the collection where the first item is 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*int*/): PropertyGroup | null
    /**
      Returns the specified property group from the collection using the unique ID of the property group.
      The ID is consistent and can't be modified by the user and isn't affected by localization.
      @param id The unique ID of the property group.
      @returns Returns the specified PropertyGroup or null if the ID doesn't match a group within the collection.
    */
    itemById(id: string): PropertyGroup | null
    /**
      Returns the specified PropertyGroup using the name of the group.
      @param name The name of the group to return. This is the name as seen in the user interface. Not all groups have a name.
      @returns Returns the specified group or null if the name doesn't match a group within the collection.
    */
    itemByName(name: string): PropertyGroup | null
    /**
      Returns the number of properties within the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents a group of properties and provides access to the properties.
  */
  abstract class PropertyGroup extends Base {
    /**
      Returns the name of this group as seen in the user interface. This name is localized
      and can change based on the current language
    */
    name: string
    /**
      Returns the unique ID of this property.
    */
    readonly id: string
    /**
      Returns the parent of this group. Typically this will be a Component.
    */
    readonly parent: core.Base
    /**
      Returns the specified property from the group using an index into the group.
      @param index The index of the property within the group where the first item is 0.
      @returns Returns the specified group or null if an invalid index was specified.
    */
    item(index: number /*int*/): Property | null
    /**
      Returns the specified property from the group using the unique ID of the property.
      The ID is consistent and can't be modified by the user and isn't affected by localization.
      @param id The unique ID of the property.
      @returns Returns the specified Property or null if the ID doesn't match a property within the collection.
    */
    itemById(id: string): Property | null
    /**
      Returns the specified Property using the name of the property.
      @param name The name of the property to return. This is the name as seen in the user interface and may be localized.
      @returns Returns the specified property or null if the name doesn't match a property within the group.
    */
    itemByName(name: string): Property | null
    /**
      Returns the number of properties within the group.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A collection of properties that are associated with a material or appearance.
  */
  abstract class Properties extends Base {
    /**
      Returns the specified property from the collection using an index into the collection.
      @param index The index of the property within the collection where the first item is 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*int*/): Property | null
    /**
      Returns the specified property from the collection using the unique ID of the property.
      @param id The unique ID of the property.
      @returns Returns the specified property or null if the ID doesn't match a property within the collection.
    */
    itemById(id: string): Property | null
    /**
      Returns the specified Property using the name of the property.
      @param name The name of the property to return. This is the name as seen in the user interface.
      @returns Returns the specified property or null if the name doesn't match a property within the collection.
    */
    itemByName(name: string): Property | null
    /**
      Returns the number of properties within the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The base class for the specific property types used by materials and appearances.
  */
  abstract class Property extends Base {
    /**
      Returns the name of this property as seen in the user interface. This name is localized
      and can change based on the current language
    */
    readonly name: string
    /**
      Indicates if this property is read-only. If True any attempted edits will fail.
    */
    readonly isReadOnly: boolean
    /**
      Returns the unique ID of this property.
    */
    readonly id: string
    /**
      Returns the parent of this property.For properties associated with an appearance this
      will return the parent Appearance. For properties associated with a material, this
      will return the parent Material. For other types of properties, this will return the
      PropertyGroup it is in.
    */
    readonly parent: Base
  }

  /**
    A property that is a Boolean value.
  */
  abstract class BooleanProperty extends Property {
    /**
      Gets and sets the value of this property.
    */
    value: boolean
  }

  /**
    A property that is a predefined list of choices.
    This is most commonly used for properties associated with materials and appearances.
  */
  abstract class ChoiceProperty extends Property {
    /**
      Method that returns the list of available choices.
      @param names An array of the names of the choices. These coincide with the array of choices returned by the choices argument.
      @param choices An array of the choices. These coincide with the array of names returned by the names argument.
      @returns Returns true if the call was successful.
    */
    getChoices(): [names: string[], choices: string[]]
    /**
      Gets and sets the which choice is selected from the set of choices.
      The value is a string that matches one of the predefined choices.
      The names of the available choices can be obtained using GetChoices method.
    */
    value: string
  }

  /**
    A property that defines a color.
    This is most commonly used for properties associated with materials and appearances.
  */
  abstract class ColorProperty extends Property {
    /**
      Used for appearances and gets the associated texture, if one exists.
      The HasConnectedTexture property controls if there is an associated texture or not.
      If the parent is writable you can edit the texture. If no texture exists, this property will return null.
    */
    readonly connectedTexture: AppearanceTexture
    /**
      Specifies if this color is specified using a simple color or a texture. If this returns true
      the color is defined using a texture. If the parent is writable, this property can be set to
      true to change the definition from a simple color to a texture. You can then use the ConnectedTexture
      property to get the associated texture and modify it.
    */
    hasConnectedTexture: boolean
    /**
      Indicates if this property has multiple values or not.
    */
    readonly hasMultipleValues: boolean
    /**
      Gets and sets this property value if there is a color and not a texture defining
      this color. If a texture is used, this property returns null. Setting this property
      when a texture is used removes the texture and changes the color definition to a simple color.
    */
    value: Color
    /**
      Gets and sets the values associated with this property. The HasMultipleValues property
      indicates if this property will be returning more than one value.
    */
    values: Color[]
  }

  /**
    A property that defines a filename.
    This is most commonly used for properties associated with materials and appearances.
  */
  abstract class FilenameProperty extends Property {
    /**
      Gets the boolean flag that indicates if this property has multiple values or not.
    */
    readonly hasMultipleValues: boolean
    /**
      Gets and sets the value of this property.
    */
    value: string
    /**
      Gets and sets the values associated with this property. HasMultipleValues
      property indicates if this property will be returning more than one value.
    */
    values: string[]
  }

  /**
    A float or real value property.
  */
  abstract class FloatProperty extends Property {
    /**
      When the property is associated with an appearance this indicates if the float value has
      been overridden using a texture. Setting this property to False will remove the texture so
      that a float value is used. Setting this property to True will connect a texture to this float value.
      For properties not associated with an appearance, this acts as read-only and always returns false.
    */
    hasConnectedTexture: boolean
    /**
      When the property is associated with an appearance, this gets the associated texture, if one exists.
      The HasConnectedTexture property controls if there is an associated texture or not. If it's parent
      writable you can edit the texture. If no texture exists, this property will return null.
    */
    readonly connectedTexture: AppearanceTexture
    /**
      Method that returns any limits for the value of this property. The HasLimits property can
      be used to see if there are any limits or not.
      This is most commonly used for properties associated with materials and appearances.
      @param hasLowLimit Output Boolean that indicates if there is a low limit or not.
      @param lowLimit If the hasLowLimit argument is true, this argument returns the low limit.
      @param hasHighLimit Output Boolean that indicates if there is a high limit or not.
      @param highLimit If the hasHighLimit argument is true, this argument returns the high limit.
      @returns Returns true if the method call was successful.
    */
    getLimits(): [hasLowLimit: boolean, lowLimit: number, hasHighLimit: boolean, highLimit: number]
    /**
      Gets the boolean flag that indicates if the value of this property has any limits it must be within to
      be valid. If True, use the GetLimits method to get the limit values.
      This is most commonly used for properties associated with materials and appearances and in most cases will return false.
    */
    readonly hasLimits: boolean
    /**
      Gets the boolean flag that indicates if this property has multiple values or not.
      This is most commonly used for properties associated with materials and appearances.
    */
    readonly hasMultipleValues: boolean
    /**
      Gets the boolean flag that indicates that this property represents a percentage value so
      the valid values must be in the range of 0.0 to 1.0 unless theyre further limited by
      additional limits which can be determined with the HasLimits property.
      This is most commonly used for properties associated with materials and appearances.
    */
    readonly isPercentage: boolean
    /**
      Gets the units that the value of this property is returned in. The String returned is a
      valid Fusion unit string. An empty string indicates a unitless value.
    */
    readonly units: string
    /**
      Gets and sets this property value. The value of this property should be ignored
      if the HasConnectedTexture property is true. Setting this will remove any
      associated texture, if there is one.
    */
    value: number
    /**
      Gets and sets the values associated with this property. HasMultipleValues property
      indicates if this property will be returning more than one value.
      This is most commonly used for properties associated with materials and appearances.
    */
    values: number[]
  }

  /**
    An integer value property.
  */
  abstract class IntegerProperty extends Property {
    /**
      Method that returns any limits for the value of this property. The HasLimits property can
      be used to see if there are any limits or not.
      This is most commonly used for properties associated with materials and appearances.
      @param hasLowLimit Output Boolean that indicates if there is a low limit or not.
      @param lowLimit If the hasLowLimit argument is true, this argument returns the low limit.
      @param hasHighLimit Output Boolean that indicates if there is a high limit or not.
      @param highLimit If the hasHighLimit argument is true, this argument returns the high limit.
      @returns Returns true if the method call was successful.
    */
    getLimits(): [hasLowLimit: boolean, lowLimit: number /*int*/, hasHighLimit: boolean, highLimit: number /*int*/]
    /**
      Gets the boolean flag that indicates if the value of this property has any limits it must
      be within to be valid. If True, use the GetLimits method to get the limit values.
      This is most commonly used for properties associated with materials and appearances.
    */
    readonly hasLimits: boolean
    /**
      Gets the boolean flag that indicates if this property has multiple values or not.
      This is most commonly used for properties associated with materials and appearances.
    */
    readonly hasMultipleValues: boolean
    /**
      Gets and sets this property value. The value of this property should be ignored
      if the HasConnectedTexture property is true. Setting this will remove any
      associated texture, if there is one.
    */
    value: number /*int*/
    /**
      Gets and sets the values associated with this property. HasMultipleValues property
      indicates if this property will be returning more than one value.
      This is most commonly used for properties associated with materials and appearances.
    */
    values: number[] /*int[]*/
  }

  /**
    A string value property.
  */
  abstract class StringProperty extends Property {
    /**
      Gets and sets the property value.
    */
    value: string
  }

  /**
    Supports the ability to make HTTP requests.
  */
  abstract class HttpRequest extends Base {
    /**
      Creates a new HttpRequest object.
      @param url The URL to make the request to.
      @param method The method to use for the request. The default is GetMethod.
      @returns Returns the new HttpRequest object.
    */
    static create(url: string, method?: HttpMethods/* = HttpMethods.GetMethod*/): HttpRequest
    /**
      Gets and sets the URL to make the request to.
    */
    url: string
    /**
      Gets and sets the method to use for the request.
    */
    method: HttpMethods
    /**
      Gets and sets the body data to send with this request.
    */
    data: string
    /**
      Sets a header for the request.
      @param name The name of the header value.
      @param value The header's value.
      @returns Returns true if setting the header succeeds.
    */
    setHeader(name: string, value: string): boolean
    /**
      Gets the value of the specified header and returns the value.
      @param name The case insensitive name of the header.
      @returns Returns the value of the header, or empty if the header was not found.
      You can use the hasHeader method to determine if the header exists before
      getting it. This is especially useful in the case where the header exists
      but has an empty string value.
    */
    getHeader(name: string): string
    /**
      Gets if the request has a header with the given name. This is useful to distinguish between
      the case where a header is not set and the case where a header is set to an empty string.
      @param name The case insensitive name of the header.
      @returns Returns true if a header with this name was set in the response.
    */
    hasHeader(name: string): boolean
    /**
      Removes a header from the request.
      @param name The case insensitive name of the header.
      @returns Returns true if the header was found and removed.
    */
    removeHeader(name: string): boolean
    /**
      Get the request headers.
      @param names An array of all the header key names.
      @param values An array of all the header values.
      @returns Returns true on success or false on error.
    */
    headers(): [names: string[], values: string[]]
    /**
      The completed event fires when the request has completed. This event will fire on successful or failure.
    */
    readonly completed: HttpEvent
    /**
      Execute this request asynchronously. The response will be sent to the completed event.
      @returns Returns true if the request was successfully started.
    */
    execute(): boolean
    /**
      Execute this request synchronously. This will block the thread until the request completes.
      @returns Returns the response from making this request, or null if an error prevents the request from starting.
    */
    executeSync(): HttpResponse | null
  }

  /**
    An object that provides the data associated with an HTTP response.
  */
  abstract class HttpResponse extends Base {
    /**
      Gets the status code of the response.
    */
    readonly statusCode: number /*int*/
    /**
      Gets the response body data.
    */
    readonly data: string
    /**
      Gets the value of a header.
      @param name The case insensitive name of the header.
      @returns Returns the value of the header, or empty if the header was not found.
      You can use the hasHeader method to determine if the header exists before
      getting it. This is especially useful in the case where the header exists
      but has an empty string value.
    */
    getHeader(name: string): string
    /**
      Gets if the response has a header with the given name. This is useful to distinguish between
      the case where a header is not set and the case where a header is set to an empty string.
      @param name The case insensitive name of the header.
      @returns True if a header with this name was set in the response.
    */
    hasHeader(name: string): boolean
    /**
      Get the response headers.
      @param names An array of all the header key names.
      @param values An array of all the header values.
      @returns Returns true on success or false on error.
    */
    headers(): [names: string[], values: string[]]
    /**
      Gets the request that generated this response.
    */
    readonly request: HttpRequest
  }

  /**
    A HttpEvent represents an event that occurs in reaction to a http request.
  */
  abstract class HttpEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: HttpEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: HttpEventHandler): boolean
  }

  /**
    The HttpEventHandler is a client implemented class that can be added as a handler to an
    HttpEvent.
  */
  abstract class HttpEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: HttpEventArgs): void
  }

  /**
    The HttpEventArgs provides information associated with a http request.
  */
  abstract class HttpEventArgs extends EventArgs {
    /**
      Returns the response from an http request.
    */
    readonly response: HttpResponse
  }

  /**
    The HTTP methods supported by the HttpRequest object.
  */
  const enum HttpMethods {
    /**
      GET HTTP method.
    */
    GetMethod,
    /**
      POST HTTP method.
    */
    PostMethod,
    /**
      PUT HTTP method.
    */
    PutMethod,
    /**
      DELETE HTTP method.
    */
    DeleteMethod,
    /**
      PATCH HTTP method.
    */
    PatchMethod,
  }

  /**
    The base class for futures.
  */
  abstract class Future extends Base {
    /**
      Returns the current state of the process associated with this future.
    */
    readonly state: FutureStates
  }

  /**
    The different states of a future.
  */
  const enum FutureStates {
    /**
      The process associated with the future is still processing.
    */
    ProcessingFutureState,
    /**
      The process associated with the future has successfully finished.
    */
    FinishedFutureState,
    /**
      The process associated with the future has failed.
    */
    FailedFutureState,
  }

  /**
    The Data class provides access to data files
  */
  abstract class Data extends Base {
    /**
      Gets and sets the active DataProject. This is the project currently displayed in the Fusion Data Panel.
    */
    activeProject: DataProject
    /**
      Gets the collection of DataProjects associated with the active Hub.
    */
    readonly dataProjects: DataProjects
    /**
      Returns a collection of accessible hubs for the current user. A DataHub represents an A360 Team or Personal hub.
    */
    readonly dataHubs: DataHubs
    /**
      Gets the active DataHub.
      @remarks
      Setting the active hub is not supported within any of the Command related events.
      When a command is running, a transaction is open, and changing the active hub cannot
      be transacted and, as a result, cannot be contained within a command transaction.
    */
    activeHub: DataHub
    /**
      Refreshes the contents of the data panel to ensure what is displayed reflects the latest state.
      @returns Returns true if the refresh was successful.
    */
    refreshDataPanel(): boolean
    /**
      Gets and sets if the data panel is visible within Fusion.
      @remarks
      Setting if the data panel is visible is not supported within any of the Command related events.
      When a command is running, a transaction is open, and changing the visibility of the data panel cannot
      be transacted and, as a result, cannot be contained within a command transaction.
    */
    isDataPanelVisible: boolean
    /**
      Returns the DataFile identified by the input id. This can fail is there isn't a DataFile identified
      with the specified id or if the current user doesn't have privileges to access the file.
      @param id The full id of the file will be something similar to that shown below. The version argument can be
      omitted which will result in getting the latest version.
      urn:adsk.wipprod:fs.file:vf.NazykCYLRWKZ5tpzJtEQ1A?version=3
      This is also the same id that you'll obtain if you use the APS Data Management API.
      @returns Returns a DataFile if one was found matching the input id or null if one was not found or you don't
      have privileges to access it.
    */
    findFileById(id: string): DataFile | null
    /**
      If the user is running with a "Fusion for Personal Use license", this property
      will return a peronalUseLimits object which provides information about
      file limits associated with the license. If the user is running with any other
      license type, this property will return null.
    */
    readonly personalUseLimits: PersonalUseLimits
    /**
      Gets the active DataFolder as seen in the Fusion Data Panel.
    */
    readonly activeFolder: DataFolder
    /**
      Returns the DataFolder identified by the input id. This can fail if there isn't a DataFolder identified
      with the specified id or if the current user doesn't have privileges to access the folder.
      @param id The full id of the folder will be something similar to that shown below.
      urn:adsk.wipprod:fs.folder:co.BdMZ64GqTAie4w3NShw23C
      This is also the same id that you'll obtain if you use the APS Data Management API.
      @returns Returns a DataFolder if one is found matching the input id or null if one is not found or you don't
      have privileges to access it.
    */
    findFolderById(id: string): DataFolder | null
  }

  /**
    Object that provides information about file limits associated with a "Fusion for Personal Use license".
  */
  abstract class PersonalUseLimits extends Base {
    /**
      Returns the maximum number of documents that can be set by the user
      to be editable.
    */
    readonly maxEditableFileCount: number /*int*/
    /**
      Returns the current number of documents that are set by the user to be editable.
    */
    readonly editableFileCount: number /*int*/
    /**
      Returns a list of the DataFile objects that have been set by the user to be editable.
    */
    readonly editableFiles: DataFile[]
  }

  /**
    Collection object that provides a list of all available hubs.
  */
  abstract class DataHubs extends Base {
    /**
      Returns the specified hub.
      @param index The index of the hub to return. The first hub in the list has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): DataHub | null
    /**
      The number of hubs in this collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the hub specified using the ID of the hub.
      @param id The ID of the hub to return. This is the same ID used by
      the APS Data Management API.
      @returns Returns the hub or null if a hub with the specified ID is not found.
    */
    itemById(id: string): DataHub | null
    /**
      Get the current list of all hubs.
      @returns Returns the current list of all hubs.
    */
    asArray(): DataHub[]
  }

  /**
    Represents a hub within the data.
  */
  abstract class DataHub extends Base {
    /**
      Returns the name of the hub.
    */
    readonly name: string
    /**
      Returns the projects within this hub.
    */
    readonly dataProjects: DataProjects
    /**
      Gets if this hub is a Personal (PersonalHubType) or Team (TeamHubType) type hub.
    */
    readonly hubType: HubTypes
    /**
      Returns the unique ID for this hub. This is the same id used in the
      APS Data Management API in an unencoded form and will look something like
      this: "a.45637".
    */
    readonly id: string
    /**
      Returns a URL that can be used to access the Fusion Web interface for this hub within a browser.
      The person using the URL must have an Autodesk account and have authority to access the hub.
    */
    readonly fusionWebURL: string
    /**
      Returns the version of the hub.
    */
    readonly version: string
    /**
      Returns true if Concurrent Editing is enabled.
    */
    readonly isCollaborativeEditingEnabled: boolean
    /**
      Get the MFGDM ID for this hub.
      @experimental
    */
    readonly mfgdmId: string
  }

  /**
    The different types of hubs.
  */
  const enum HubTypes {
    /**
      A personal hub.
    */
    PersonalHubType,
    /**
      An A360 team hub.
    */
    TeamHubType,
  }

  /**
    Collection object that provides a list of all available projects.
  */
  abstract class DataProjects extends Base {
    /**
      Returns the specified project.
      @param index The index of the project to return. The first project in the list has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): DataProject | null
    /**
      The number of projects in this collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new project in the parent hub.
      @param name The name of the project. This is the name visible to the user.
      @param purpose Optional description of the purpose of the project. An empty string can be used to not specify a purpose.
      @param contributors Optional list of contributors where the list consists of email addresses separated by a comma.
      An empty string can be used to not specify any contributors.
      @returns Returns the created DataProject object or null if the creation failed.
    */
    add(name: string, purpose?: string/* = ""*/, contributors?: string/* = ""*/): DataProject | null
    /**
      Returns the project specified using the ID of the project.
      @param id The ID of the project to return. This is the same ID used by
      the APS Data Management API.
      @returns Returns the project or null if a project with the specified ID is not found.
    */
    itemById(id: string): DataProject | null
    /**
      Get the current list of all projects.
      @returns Returns the current list of all projects.
    */
    asArray(): DataProject[]
  }

  /**
    Represents the master branch project within a hub.
  */
  abstract class DataProject extends Base {
    /**
      Gets and sets the name of the project.
    */
    name: string
    /**
      Returns the project's root folder. This provides access to all of the
      folders and the files in the top level of the project.
    */
    readonly rootFolder: DataFolder
    /**
      Returns the unique ID for this project. This is the same id used in the
      APS Data Management API in an unencoded form and will look something like
      this: "a.45637".
    */
    readonly id: string
    /**
      Returns the parent DataHub of this project.
    */
    readonly parentHub: DataHub
  }

  /**
    Collection object the provides a list of data folders.
  */
  abstract class DataFolders extends Base {
    /**
      Returns the specified folder.
      @param index The index of the folder to return. The first folder in the list has an index of 0.
      @returns Returns the item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): DataFolder | null
    /**
      Returns the folder specified using the name of the folder.
      @param name The name of the folder to return.
      @returns Returns the folder or null if a folder of the specified name is not found.
    */
    itemByName(name: string): DataFolder | null
    /**
      The number of folders in this collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the folder specified using the ID of the folder.
      @param id The ID of the folder to return. This is the same ID used by
      the APS Data Management API.
      @returns Returns the folder or null if a folder with the specified ID is not found.
    */
    itemById(id: string): DataFolder | null
    /**
      Creates a new folder within the parent folder.
      @param name The name of the folder. This must be unique with respect to the other folders within the parent folder.
      @returns Returns the created DataFolder or null if the creation failed.
    */
    add(name: string): DataFolder | null
    /**
      Get the current list of all folders.
      @returns Returns the current list of all folders.
    */
    asArray(): DataFolder[]
  }

  /**
    A data folder that contains a collection of data items.
  */
  abstract class DataFolder extends Base {
    /**
      Gets and sets the displayed name of this folder.
    */
    name: string
    /**
      Returns a collection containing all of the items within this folder, excluding folders.
      Use the dataFolders property to get the folders.
    */
    readonly dataFiles: DataFiles
    /**
      Returns a collection containing all of the folders within this folder.
    */
    readonly dataFolders: DataFolders
    /**
      Returns the parent folder this folder is contained within. Returns null
      if this is the project's root folder.
    */
    readonly parentFolder: DataFolder
    /**
      Returns the parent project that owns this folder.
    */
    readonly parentProject: DataProject
    /**
      Indicates if this folder is the root folder within the parent project.
    */
    readonly isRoot: boolean
    /**
      Uploads a single file to this directory.
      @remarks
      Uploading a file is not supported within any of the Command related events.
      When a command is running, a transaction is open, and uploading files cannot
      be transacted and, as a result, cannot be contained within a command transaction.
      @param filename The full filename of the file to upload.
      @returns The upload process is asynchronous which means that this method
      will return before the upload process had completed. The returned
      DataFileFuture object can be used to check on the current state of the
      upload to determine if it is still uploading, is complete, or has failed.
      If it is complete the final DataFinal can be retrieved through the
      DataFileFuture object.
    */
    uploadFile(filename: string): DataFileFuture
    /**
      Uploads a set of files that represent an assembly There should only
      be a single top-level assembly file but there can be any number of other
      files that represent sub-assemblies.
      @remarks
      Uploading an assembly is not supported within any of the Command related events.
      When a command is running, a transaction is open, and uploading files cannot
      be transacted and, as a result, cannot be contained within a command transaction.
      @param filenames An array of strings that contains the list of all of the files that
      are part of the assembly. The name of the top-level assembly file
      must be the first file in the array.
      @returns The upload process is asynchronous which means that this method
      will return before the upload process had completed. The returned
      DataFileFuture object can be used to check on the current state of the
      upload to determine if it is still uploading, is complete, or has failed.
      If it is complete the final DataFinal can be retrieved through the
      DataFileFuture object.
    */
    uploadAssembly(filenames: string[]): DataFileFuture
    /**
      Deletes this folder item.
      @returns Returns true if the deletion was successful.
    */
    deleteMe(): boolean
    /**
      Returns the unique ID for this folder. This is the same id used in the
      APS Data Management API.
    */
    readonly id: string
  }

  /**
    Used to check the state and get back the results of a file upload.
  */
  abstract class DataFileFuture extends Base {
    /**
      Returns the DataFile when the upload is complete (uplodeState returns UploadFinished).
      Returns null if the upload is still running or has failed.
    */
    readonly dataFile: DataFile
    /**
      Returns the current state of the upload.
    */
    readonly uploadState: UploadStates
  }

  /**
    The different states of a file upload process.
  */
  const enum UploadStates {
    /**
      The upload is still processing.
    */
    UploadProcessing,
    /**
      The upload has completed.
    */
    UploadFinished,
    /**
      The upload has failed.
    */
    UploadFailed,
  }

  /**
    Used to check the state of getting data associated with an object where the associated data
    typically exists on the cloud.
  */
  abstract class DataObjectFuture extends Future {
    /**
      Returns the DataObject when the data has become available, (state returns FinishedFutureState).
      Returns null if the operation is still running or has failed.
    */
    readonly dataObject: DataObject
  }

  /**
    Returns the items within a folder. This includes everything in a folder except for other folders.
  */
  abstract class DataFiles extends Base {
    /**
      Returns the specified data file.
      @param index The index of the file to return. The first file in the list has an index of 0.
      @returns Returns the specified file or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): DataFile | null
    /**
      The number of data items in this collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the file specified using the ID or version ID of the file.
      @param id The ID or version ID of the file to return. This is the same ID used by
      the APS Data Management API.
      @returns Returns the file or null if a file with the specified ID is not found.
    */
    itemById(id: string): DataFile | null
    /**
      Get the current list of all files.
      @returns Returns the current list of all files.
    */
    asArray(): DataFile[]
  }

  /**
    A data file in a data folder.
  */
  abstract class DataFile extends core.Base {
    /**
      Gets and sets the displayed name of this item.
    */
    name: string
    /**
      Gets and sets the description information associated with this item.
    */
    readonly description: string
    /**
      Returns the parent folder this item is contained within.
    */
    readonly parentFolder: DataFolder
    /**
      Returns the parent project that this item is in.
    */
    readonly parentProject: DataProject
    /**
      Returns the unique ID for this DataFile. This is the same id used in the
      APS Data Management API for an Item and is in the unencoded form and will
      look similar to this: "urn:adsk.wipprod:dm.lineage:hC6k4hndRWaeIVhIjvHu8w"
    */
    readonly id: string
    /**
      Gets the version number of this DataFile.
    */
    readonly versionNumber: number /*int*/
    /**
      Gets the other version of this item.
    */
    readonly versions: DataFiles
    /**
      Gets the latest version number for this DataFile.
    */
    readonly latestVersionNumber: number /*int*/
    /**
      Returns the latest version of the DataFile. It can return a reference
      to the same DataFile is this DataFile is the latest version.
    */
    readonly latestVersion: DataFile
    /**
      Deletes this DataFile. This can fail if this file is referenced by another file or is currently open.
      @returns Returns true if the deletion was successful.
    */
    deleteMe(): boolean
    /**
      Moves this DataFile to the specified folder.
      @param targetFolder The folder to move this DataFile to.
      @returns Returns true if the move was successful.
    */
    move(targetFolder: DataFolder): boolean
    /**
      Copies this DataFile to the specified folder.
      @param targetFolder The folder to copy this DataFile to.
      @returns Returns the copied DataFile if the copy was successful.
    */
    copy(targetFolder: DataFolder): DataFile
    /**
      Promotes this version to be the latest version. If this is the latest version, nothing happens.
      @returns Returns true if successful.
    */
    promote(): boolean
    /**
      Gets the file extension for this data file. The file type can be inferred from this.
    */
    readonly fileExtension: string
    /**
      Gets if this DataFile is currently in use (opened for edit) by any other user.
    */
    readonly isInUse: boolean
    /**
      Returns the array of users that are currently using (have open for edit) this data file.
    */
    readonly inUseBy: User[]
    /**
      Returns the User that created this data file.
    */
    readonly createdBy: User
    /**
      Returns the User that last updated this data file
    */
    readonly lastUpdatedBy: User
    /**
      Gets if this datafile has Children (referenced components) that are out of date (not the latest version).
    */
    readonly hasOutofDateChildReferences: boolean
    /**
      Gets if this datafile has children, (i.e. a Fusion Design containing referenced components).
    */
    readonly hasChildReferences: boolean
    /**
      Gets if this datafile has parents, (i.e. this is a child being referenced in another Fusion design).
    */
    readonly hasParentReferences: boolean
    /**
      Returns a collection of DataFiles that are the children (referenced designs) this datafile references.
    */
    readonly childReferences: DataFiles
    /**
      Returns a collection DataFiles collection that are the parents (designs that reference) this datafile.
    */
    readonly parentReferences: DataFiles
    /**
      Returns a short URL of this data file which can be shared with others.
      @remarks
      This method has been retired and replaced by the functionality on the SharedLink object which
      can be obtained using the DataFile.sharedLink property. The behavior of this property has changed
      so it can return an empty string if a public link has not been generated.
      @deprecated
    */
    readonly publicLink: string
    /**
      Returns the date when this data file was created as UNIX epoch time. UNIX epoch time
      is the number of seconds since January 1, 1970 (midnight UTC/GMT).
      In Python you can import the standard time module to work with UNIX epoch time.
      In C++ you can use functions in time.h and std::chrono to work with UNIX epoch time.
    */
    readonly dateCreated: number /*unsigned int*/
    /**
      Returns the version ID for this DataFile. This is the same id used in the
      APS Data Management API for an Item and is in the unencoded form and will
      look similar to this: "urn:adsk.wipqa:fs.file:vf.W3syIw1lQAW-5vWObMdYnA?version=2"
    */
    readonly versionId: string
    /**
      Gets if this file is currently read-only or not. A file can be read-only for various
      reasons. For example, if you are running with a "Fusion for Personal Use license" and
      have not designate the file to be editable or if someone else is editing the file.
    */
    readonly isReadOnly: boolean
    /**
      Performs a synchronous or asynchronous download of this DataFile. Only DataFiles that represent
      non-Fusion data can be downloaded. For example, this will work for TXT or XLS files but will
      fail for F3D files.
      When using this in its synchronous mode, Fusion is frozen during the download and the call will not
      return until the download is complete or has failed. When using this in its asynchronous mode,
      calling this method will start the download process and the call return before the download is
      complete. The event on the provided handler will be called notifying you when the download is complete.
      @param path The full path and optionally the filename used on the local file system for the file. If the path
      doesn't exist it will be created. If only a path is specified, the name and file extension associated
      with the DataFile is used for the filename. You can also specify the full path, including the filename.
      @param handler If you want to do an asynchronous download, provide the handler object to be called when this operation
      is complete. To call the method synchronously, set this argument to null/None.
      @returns Returns True in synchronous mode if successful. Returns True in asynchronous mode if the download was successfully started.
    */
    download(path: string, handler: DataEventHandler): boolean
    /**
      Refreshes the data associated with a DataFile object to be up to date with the associated cloud data.
      The DataFile returned by the API reflects the local representation of the DataFile as used by the Data Panel.
      This is method is only useful in very limited cases and should rarely be used. In most cases the local
      representation will match the actual data on the cloud. In rare occasions where Fusion was off-line while
      the cloud processing of DataFile is completed or the DataFile is not in the folder shown in the Data Panel.
      Getting a DataFileFolder contents forces an update of the local data for all of the data files it contains
      so they will all be up to date.
      @param handler If you want to do an asynchronous refresh, provide the handler object to be called when this operation
      is complete. To call the method synchronously, set this argument to null/None.
      @returns Returns True in synchronous mode if successful. Returns True in asynchronous mode if the refresh was successfully started.
    */
    refresh(handler: DataEventHandler): boolean
    /**
      Returns if the DataFile is fully processed. This is especially useful when a new file is being saved or uploaded.
      The initial call to save or upload the file returns when the process has started but processing continues on the cloud.
      This property will return true when all of the processing has been completed and all information related to
      the Datafile is now available.
    */
    readonly isComplete: boolean
    /**
      Returns the date when this data file was modified. Most changes to a
      file result in a new version which means a new DataFile is created and will have a new
      creation date. There are a few changes, like rename, that modify a DataFile without
      creating a new version and the date of that change is returned by this property.
      The date is returned as UNIX epoch time, which is the number of seconds since January 1, 1970 (midnight UTC/GMT).
      In Python you can import the standard time module to work with UNIX epoch time.
      In C++ you can use functions in time.h and std::chrono to work with UNIX epoch time.
    */
    readonly dateModified: number /*unsigned int*/
    /**
      Gets if this file represents a configured design. This is a design where
      a configuration table is defined. Use the configurationTable property to get
      the associated table.
      @experimental
    */
    readonly isConfiguredDesign: boolean
    /**
      If this file is a configured design or a configuration, this property returns the associated
      ConfigTable object. If this is not a configured design or configuration, this property
      returns null.
      This property is typed as core.Base because the adsk.core library does not reference
      the fusion library where the ConfigurationTable object is defined. At runtime, this property
      will return a ConfigurationTable object.
      @experimental
    */
    readonly configurationTable: core.Base
    /**
      Gets if this file is a configuration of a configuration table. If this returns true,
      the configurationRowId can be used to get the row used to define this configuration.
      Also, when this is true, the design is essentially read-only and edits are either
      blocked from taking place or cannot be saved.
      @experimental
    */
    readonly isConfiguration: boolean
    /**
      Returns the ID of the row that defines this configuration. Use the
      isCongiguration property to determine if this Design is a configuration
      or not. If this is not a configuration, this property returns an
      empty string.
      @experimental
    */
    readonly configurationRowId: string
    /**
      Returns a collection of Milestones associated with all versions of this DataFile.
    */
    readonly milestones: Milestones
    /**
      If the version this DataFile represents is a milestone, a Milestone object will
      be returned. If it's not a milestone, null is returned.
    */
    readonly milestone: Milestone
    /**
      Returns if the version this Datafile represents is a milestone. Returns true if it
      is a milestone.
    */
    readonly isMilestone: boolean
    /**
      Makes the version this DataFile represents a milestone.
      @param milestoneName The name of the milestone as seen in the data panel and Fusion web client. If an empty string
      is provided, a default name will be used.
      @returns Returns the created Milestone object or null in the case of failure. One case of failure is
      if a milestone already exists for this version.
    */
    createMilestone(milestoneName: string): Milestone | null
    /**
      Returns the SharedLink object associated with this DataFile. You can use the SharedLink
      object to enable a shared link and set its behavior and to get the shared link URL.
    */
    readonly sharedLink: SharedLink
    /**
      Creates a new CopyDesignFileInput object that is used to create a copy of a
      DataFile that represents a Fusion design. You set options on the CopyDesignFileInput
      object to define the behavior of the copy and call the copyWithInput method
      passing in the input object to create the copy.
      @param folder The folder where the copied files will be created.
      @returns Returns the created CopyDesignFileInput object or null in the case of failure.
      @experimental
    */
    createCopyDesignFileInput(folder: DataFolder): CopyDesignFileInput | null
    /**
      Creates a new CopyFileInput object that is used to create a copy of any DataFile.
      @param folder The folder where the copied file will be created.
      @returns Returns the created CopyFileInput object or null in the case of failure.
      @experimental
    */
    createCopyFileInput(folder: DataFolder): CopyFileInput | null
    /**
      Executes the copy using the information defined by the provided CopyFileInput.
      @param input The input object is of CopyFileInput object type, based on which our copy behavior will be defined. A
      CopyDesignFileInput object is created using the DataFile.createCopyDesignFileInput.
      @returns The copy process is asynchronous which means that this method
      will return before the copy process has completed. The returned
      DataFileFuture object can be used to check on the current state of the
      copy to determine if it is still copying, is complete, or has failed.
      If it is complete the new DataFile that was created as a result of the copy
      can be retrieved through the DataFileFuture object.
      @experimental
    */
    copyWithInput(input: CopyFileInput): DataFileFuture
    /**
      <p>Returns a URL that can be used to access the Fusion Web interface for this file within a browser.
      The person using the URL must have an Autodesk account and have authority to access the hub
      this file is owned by.</p>
      <p>You can also use this URL to directly open the file in Fusion using the Fusion protocol handler
      as discussed in the <a href="OpeningFilesFromWebPage_UM.htm">Opening Files from a Web Page</a> topic in the API user manual.</p>
    */
    readonly fusionWebURL: string
    /**
      Starts the process to get the raw binary data associated with this DataFile. Because the data exists
      on the cloud, a DataObjectFuture is returned that you can use to monitor the state of downloading the
      data and then getting the raw data once it is available.
      Only DataFiles that represent non-Fusion data can accessed. For example, this will work for TXT or XLS files but will
      fail for F3D files.
    */
    readonly dataObject: DataObjectFuture
  }

  /**
    Returns the milestones associated with a DataFile.
  */
  abstract class Milestones extends Base {
    /**
      Returns the specified milestone.
      @param index The index of the milestone to return. The first milestone in the list has an index of 0.
      @returns Returns the specified file or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Milestone | null
    /**
      The number of data items in this collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the milestone specified using its name..
      @param name The name of the milestone to return.
      @returns Returns the Milestone object or null if a milestone with the specified name is not found.
    */
    itemByName(name: string): Milestone | null
    /**
      Get the current list of all milestones.
      @returns Returns the current list of all milestones.
    */
    asArray(): Milestone[]
  }

  /**
    An object that represents a milestone.
  */
  abstract class Milestone extends core.Base {
    /**
      Gets and sets the name of the milestone.
    */
    name: string
    /**
      Returns the file version associated with this milestone.
    */
    readonly version: DataFile
  }

  /**
    Provides access to the URL that can be used to share this DataFile with others. This object
    also provides access to the various settings that control the link's behavior.
  */
  abstract class SharedLink extends Base {
    /**
      Gets and sets if a shared link should be made available for this DataFile. This property
      defaults to false for a new DataFile. Setting it to true will allow the URL for the file
      to be obtained. Setting it to false will restrict access to the URL and block access for
      anyone currently using it. In other words, this is a dynamic setting and doesn't just
      control getting the link URL.
    */
    isShared: boolean
    /**
      Returns the URL of the shared link. Returns an empty string in the case where isShared
      is False.
    */
    readonly linkURL: string
    /**
      Specifies if the user with the shared link can download the file or only view it.
      Changing this setting changes the behavior of the existing link. When a DataFile
      is shared, and a link is created, this defaults to true, allowing anyone with the
      link to download the file.
    */
    isDownloadAllowed: boolean
    /**
      Sets the password to access the web page to view the file. Setting a password makes
      using the password required to access the page. The password takes effect immediately
      for anyone using the URL. To turn off the password requirement, set the isPasswordRequired
      property to false.
      @param password The password to use.
      @returns Returns true if setting the password was successful.
    */
    setPassword(password: string): boolean
    /**
      Gets if a password is required to access the file's web page using the link URL. This
      property can be set to false to turn off the password requirement. It cannot be set
      to true. To enable a password, use the setPassword method, which sets the password
      and has the side effect of setting this property to true.
    */
    isPasswordRequired: boolean
  }

  /**
    The base class for any copy file input objects.
    @experimental
  */
  abstract class CopyFileInput extends core.Base {
    /**
      Gets and sets the target DataFolder where the design will be copied to.
    */
    readonly targetFolder: DataFolder
  }

  /**
    Input object that defines the various settings that apply when copying a design file,
    including whether associated drawings and/or references external components are also
    copied.
    @experimental
  */
  abstract class CopyDesignFileInput extends CopyFileInput {
    /**
      Gets and sets if any drawings associated with the design should also be copied.
    */
    isCopyDrawings: boolean
    /**
      Gets and sets if any external reference components associated with the design should also be copied.
    */
    isCopyReferencedExternalComponents: boolean
  }

  /**
    The types of copy operations that can be performed when copy DesignDataFile.
    @hidden
  */
  const enum DataFileCopyTypes {
    /**
      Copy a design and the associated drawings.
    */
    CopyDrawingsDataFileCopyType,
  }

  /**
    A Data event is an event associated with operations on Data items.
  */
  abstract class DataEvent extends core.Event {
    /**
      Add a handler to be notified when the data event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: DataEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: DataEventHandler): boolean
  }

  /**
    The DataEventArgs provides information associated with a data event.
    Note that some properties are not available on every event.
  */
  abstract class DataEventArgs extends EventArgs {
    /**
      Gets the filename associated with the operation. If there isn't an associated
      filename, an empty string is returned. For a download operation, this will
      be the full filename of the downloaded file.
    */
    readonly filename: string
    /**
      Gets the DataFile object associated with this event. If there isn't
      a DataFile associated with the event, this property will return null.
    */
    readonly file: DataFile
    /**
      Returns a Status object that provides additional information about the
      success or failure of the operation.
    */
    readonly status: Status
  }

  /**
    The DataEventHandler is a client implemented class that can be added as a handler to a
    DataEvent.
  */
  abstract class DataEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: DataEventArgs): void
  }

  /**
    The DataObject provides access to the raw data that represents a logical entity. Typically,
    it is the bytes of a stored file, but it can also be something like the image data that
    could be stored within another file.
  */
  abstract class DataObject extends core.Base {
    /**
      Gets the binary data represented by the DataObject as a Base64 encoded string.
      @returns Returns the binary data represented by the DataObject as a standard Base64 encoded string. Fails
      with an appropriate error in the case where the data cannot be provided.
    */
    getAsBase64String(): string
    /**
      Gets the file as a string (UTF-8). This is convenient when the saved file contains string data.
      For example, if the file contains JSON data. This eliminates the need to convert the Base64 string
      into a standard string.
      @returns Returns the data as a standard (UTF-8) string. Fails with an appropriate error in the case where
      the data cannot be provided.
    */
    asString(): string
    /**
      Saves the data represented by the DataObject to a file.
      @param filename The full filename to save the file to. This includes the full path and the filename.
      The folder must already exist and you are responsible for specifying the correct
      extension to match the file type.
      @returns Returns true if the save was successful.
    */
    saveToFile(filename: string): boolean
  }

  /**
    An object that provides ID's that can be used to access the component using MFG DM API.
    These ID's are generated by the MFG DM API when a file is saved. For that reason, they
    are not available from a component before its parent file is saved.
    @experimental
  */
  abstract class DataComponent extends core.Base {
    /**
      Gets the unique ID of this DataComponent. This ID can be used within the MFG DM API.
      This ID is created by the MFG DM API when the component is first saved.
    */
    readonly id: string
    /**
      Returns the unique ID of this file version of the DataComponent. This ID is updated
      whenever the document the component exists within is saved.
    */
    readonly versionId: string
    /**
      Get the MFGDM model Id.
    */
    readonly mfgdmModelId: string
    /**
      Get the resolution timestamp.
    */
    readonly timestamp: string
    /**
      Get the fusion.Component that corresponds to this data component.
    */
    readonly component: Base
  }

  /**
    The base class for all 2D transient geometry classes.
  */
  abstract class Curve2D extends Base {
    /**
      Returns the type of geometry this curve represents.
    */
    readonly curveType: Curve2DTypes
    /**
      Returns an evaluator object that lets you perform additional evaluations on the curve.
    */
    readonly evaluator: CurveEvaluator2D
    /**
      Transforms this curve in 2D space.
      @param matrix A 2D matrix that defines the transform to apply to the curve.
      @returns Return true if the transform was successful.
    */
    transformBy(matrix: Matrix2D): boolean
  }

  /**
    The different types of 2D curves.
  */
  const enum Curve2DTypes {
    /**
      Transient 2D line segment.
    */
    Line2DCurveType,
    /**
      Transient 2D arc.
    */
    Arc2DCurveType,
    /**
      Transient 2D circle.
    */
    Circle2DCurveType,
    /**
      Transient 2D ellipse.
    */
    Ellipse2DCurveType,
    /**
      Transient 2D elliptical arc.
    */
    EllipticalArc2DCurveType,
    /**
      Transient 2D infinite line.
    */
    InfiniteLine2DCurveType,
    /**
      Transient 2D NURBS curve.
    */
    NurbsCurve2DCurveType,
    /**
      Transient 2D polyline.
    */
    Polyline2DCurveType,
  }

  /**
    Transient 2D arc. A transient arc is not displayed or saved in a document.
    Transient arcs are used as a wrapper to work with raw 2D arc information. They
    are created statically using one of the create methods supported by the Arc2D class.
  */
  abstract class Arc2D extends Curve2D {
    /**
      Creates a transient 2D arc object specifying the center, radius and start and end angles.
      A transient arc is not displayed or saved in a document. Transient arcs are used as
      a wrapper to work with raw 2D arc information.
      @param center A Point2D object that defines the center position of the arc in 2D space.
      @param radius The radius of the arc.
      @param startAngle The start angle in radians, where 0 is along the X-axis.
      @param endAngle The end angle in radians, where 0 is along the X-axis.
      @param isClockwise Specifies if the sweep of the arc is clockwise or counterclockwise from the start to end angle.
      @returns Returns the newly created arc or null if the creation failed.
    */
    static createByCenter(center: Point2D, radius: number, startAngle: number, endAngle: number, isClockwise?: boolean/* = false*/): Arc2D | null
    /**
      Creates a transient 2D arc by specifying 3 points.
      A transient arc is not displayed or saved in a document. Transient arcs are used as
      a wrapper to work with raw 2D arc information.
      @param startPoint The start point of the arc.
      @param point A point along the arc.
      @param endPoint The end point of the arc.
      @returns Returns the newly created arc or null if the creation failed.
    */
    static createByThreePoints(startPoint: Point2D, point: Point2D, endPoint: Point2D): Arc2D | null
    /**
      Gets and sets the center position of the arc.
    */
    center: Point2D
    /**
      Gets and sets the radius of the arc.
    */
    radius: number
    /**
      Gets and sets the start angle of the arc in radians, where 0 is along the x axis.
    */
    startAngle: number
    /**
      Gets and sets the end angle of the arc in radians, where 0 is along the x axis.
    */
    endAngle: number
    /**
      Gets if the sweep direction of the arc is clockwise or counterclockwise.
    */
    readonly isClockwise: boolean
    /**
      Gets the position of the start point of the arc.
    */
    readonly startPoint: Point2D
    /**
      Gets the position of the end point of the arc.
    */
    readonly endPoint: Point2D
    /**
      Creates and returns an independent copy of this Arc2D object.
      @returns Returns a new Arc2D object that is a copy of this Arc2D object.
    */
    copy(): Arc2D
    /**
      Gets all of the data defining the arc.
      @param center The output center point of the arc.
      @param radius The output radius of the arc.
      @param startAngle The output start angle of the arc in radians, where 0 is along the x axis.
      @param endAngle The output end angle of the arc in radians, where 0 is along the x axis.
      @param isClockwise The output value that indicates if the sweep direction is clockwise or counterclockwise.
      @returns Returns true if successful
    */
    getData(): [center: Point2D, radius: number, startAngle: number, endAngle: number, isClockwise: boolean]
    /**
      Sets all of the data defining the arc.
      @param center A Point2D object defining the center position of the arc.
      @param radius The radius of the arc.
      @param startAngle The start angle of the arc in radians, where 0 is along the x axis.
      @param endAngle The end angle of the arc in radians, where 0 is along the x axis.
      @param isClockwise Indicates if the sweep direction is clockwise or counterclockwise.
      @returns Returns true if redefining the arc is successful
    */
    set(center: Point2D, radius: number, startAngle: number, endAngle: number, isClockwise: boolean): boolean
    /**
      Returns a NURBS curve that is geometrically identical to the arc.
    */
    readonly asNurbsCurve: NurbsCurve2D
  }

  /**
    Transient 2D circle. A transient circle is not displayed or saved in a document.
    Transient circles are used as a wrapper to work with raw 2D arc information. They
    are created statically using one of the create methods of the Circle2D class.
  */
  abstract class Circle2D extends Curve2D {
    /**
      Creates a transient 2D circle object by specifying a center and radius.
      @param center A Point2D object that defines the center of the circle.
      @param radius The radius of the circle.
      @returns Returns the new Circle2D object or null if the creation failed.
    */
    static createByCenter(center: Point2D, radius: number): Circle2D | null
    /**
      Creates a transient 2D circle through three points.
      @param pointOne The first point on the circle.
      @param pointTwo The second point on the circle.
      @param pointThree The third point on the circle.
      @returns Returns the new Circle2D object or null if the creation failed.
    */
    static createByThreePoints(pointOne: Point2D, pointTwo: Point2D, pointThree: Point2D): Circle2D | null
    /**
      Gets and sets the center position of the circle.
    */
    center: Point2D
    /**
      Gets and sets the radius of the circle.
    */
    radius: number
    /**
      Creates and returns an independent copy of this Circle2D object.
      @returns Returns an independent copy of this Circle2D object.
    */
    copy(): Circle2D
    /**
      Gets all of the data defining the circle.
      @param center The output point defining the center position of the circle.
      @param radius The output radius of the circle.
      @returns Returns true if successful.
    */
    getData(): [center: Point2D, radius: number]
    /**
      Sets all of the data defining the circle.
      @param center A point that defines the center position of the circle.
      @param radius The radius of the circle.
      @returns Returns true if redefining the circle is successful
    */
    set(center: Point2D, radius: number): boolean
    /**
      Returns a NURBS curve that is geometrically identical to the circle.
    */
    readonly asNurbsCurve: NurbsCurve2D
  }

  /**
    Transient 2D ellipse. A transient ellipse is not displayed or saved in a document.
    Transient 2D ellipses are used as a wrapper to work with raw 2D ellipse information.
    They are created statically using the create method of the Ellipse2D class.
  */
  abstract class Ellipse2D extends Curve2D {
    /**
      Creates a transient 2D ellipse by specifying a center position, major and minor axes,
      and major and minor radii.
      @param center A Point2D object that defines the center of the ellipse.
      @param majorAxis The major axis of the ellipse
      @param majorRadius The major radius of the of the ellipse.
      @param minorRadius The minor radius of the of the ellipse.
      @returns Returns the new Ellipse 2D object or null if the creation failed.
    */
    static create(center: Point2D, majorAxis: Vector2D, majorRadius: number, minorRadius: number): Ellipse2D | null
    /**
      Gets and sets the center position of the ellipse.
    */
    center: Point2D
    /**
      Gets and sets the major axis of the ellipse.
    */
    majorAxis: Vector2D
    /**
      Gets and sets the major radius of the ellipse.
    */
    majorRadius: number
    /**
      Gets and sets the minor radius of the ellipse.
    */
    minorRadius: number
    /**
      Creates and returns a copy of this Ellipse2D object.
      @returns Returns a new Ellipse2D object that is a copy of this Ellipse2D object.
    */
    copy(): Ellipse2D
    /**
      Gets all of the data defining the ellipse.
      @param center The output center point of the ellipse.
      @param majorAxis The output major axis of the ellipse.
      @param majorRadius The output major radius of the of the ellipse.
      @param minorRadius The output minor radius of the of the ellipse.
      @returns Returns true if successful.
    */
    getData(): [center: Point2D, majorAxis: Vector2D, majorRadius: number, minorRadius: number]
    /**
      Sets all of the data defining the ellipse.
      @param center A Point2D object that defines the center of the ellipse.
      @param majorAxis The major axis of the ellipse.
      @param majorRadius The major radius of the of the ellipse.
      @param minorRadius The minor radius of the of the ellipse.
      @returns Returns true if redefining the ellipse is successful.
    */
    set(center: Point2D, majorAxis: Vector2D, majorRadius: number, minorRadius: number): boolean
    /**
      Returns a NURBS curve that is geometrically identical to the ellipse.
    */
    readonly asNurbsCurve: NurbsCurve2D
  }

  /**
    Transient 2D elliptical arc. A transient elliptical arc is not displayed or saved in a document.
    Transient 2D elliptical arcs are used as a wrapper to work with raw 2D elliptical arc information.
    They are created statically using the create method of the EllipticalArc2D class.
  */
  abstract class EllipticalArc2D extends Curve2D {
    /**
      Creates a transient 2D elliptical arc
      @param center A Point2D object that defines the center of the elliptical arc.
      @param majorAxis The major axis of the elliptical arc
      @param majorRadius The major radius of the of the elliptical arc.
      @param minorRadius The minor radius of the of the elliptical arc.
      @param startAngle The start angle of the elliptical arc in radians, where 0 is along the major axis.
      @param endAngle The end angle of the elliptical arc in radians, where 0 is along the major axis.
      @returns Returns the newly created elliptical arc or null if the creation failed.
    */
    static create(center: Point2D, majorAxis: Vector2D, majorRadius: number, minorRadius: number, startAngle: number, endAngle: number): EllipticalArc2D | null
    /**
      Gets and sets the center position of the elliptical arc.
    */
    center: Point2D
    /**
      Gets and sets the major axis of the elliptical arc.
    */
    majorAxis: Vector2D
    /**
      Gets and sets the major radius of the elliptical arc.
    */
    majorRadius: number
    /**
      Gets and sets the minor radius of the elliptical arc.
    */
    minorRadius: number
    /**
      Gets and sets the start angle of the elliptical arc in radians, where 0 is along the major axis.
    */
    startAngle: number
    /**
      Gets and sets the end angle of the elliptical arc in radians, where 0 is along the major axis.
    */
    endAngle: number
    /**
      Gets if the sweep direction of the elliptical arc is clockwise or counterclockwise.
    */
    readonly isClockwise: boolean
    /**
      Gets if the elliptical arc is the geometric equivalent of a circular arc
    */
    readonly isCircular: boolean
    /**
      Gets the position of the start point of the elliptical arc.
    */
    readonly startPoint: Point2D
    /**
      Gets the position of the end point of the elliptical arc.
    */
    readonly endPoint: Point2D
    /**
      Creates and returns a copy of this EllipticalArc2D object.
      @returns Returns a new EllipticalArc2D object that is a copy of this Arc2D object.
    */
    copy(): EllipticalArc2D
    /**
      Gets all of the data defining the elliptical arc.
      @param center The output center point of the elliptical arc.
      @param majorAxis The output major axis of the elliptical arc.
      @param majorRadius The output major radius of the of the elliptical arc.
      @param minorRadius The output minor radius of the of the elliptical arc.
      @param startAngle The output start angle of the elliptical arc in radians, where 0 is along the major axis.
      @param endAngle The output end angle of the elliptical arc in radians, where 0 is along the major axis.
      @returns Returns true if successful
    */
    getData(): [center: Point2D, majorAxis: Vector2D, majorRadius: number, minorRadius: number, startAngle: number, endAngle: number]
    /**
      Sets all of the data defining the elliptical arc.
      @param center A Point2D object that defines the center of the elliptical arc.
      @param majorAxis The major axis of the elliptical arc.
      @param majorRadius The major radius of the of the elliptical arc.
      @param minorRadius The minor radius of the of the elliptical arc.
      @param startAngle The start angle of the elliptical arc in radians, where 0 is along the major axis.
      @param endAngle The end angle of the elliptical arc in radians, where 0 is along the major axis.
      @returns Returns true if redefining the elliptical arc is successful
    */
    set(center: Point2D, majorAxis: Vector2D, majorRadius: number, minorRadius: number, startAngle: number, endAngle: number): boolean
    /**
      Returns a NURBS curve that is geometrically identical to the elliptical arc.
    */
    readonly asNurbsCurve: NurbsCurve2D
  }

  /**
    Transient 2D line. A transient line is not displayed or saved in a document.
    Transient 2D lines are used as a wrapper to work with raw 2D line information.
    They are created statically using the create method of the Line2D class.
  */
  abstract class Line2D extends Curve2D {
    /**
      Creates a transient line.
      @param startPoint The start point of the line
      @param endPoint The end point of the line
      @returns Returns the new Line2D object or null if the creation failed.
    */
    static create(startPoint: Point2D, endPoint: Point2D): Line2D | null
    /**
      Gets and sets the start point of the line.
    */
    startPoint: Point2D
    /**
      Gets and sets the end point of the line.
    */
    endPoint: Point2D
    /**
      Creates and returns a copy of this line object.
      @returns Returns an independent copy of this line object.
    */
    copy(): Line2D
    /**
      Gets all of the data defining the line segment.
      @param startPoint The output start point of the line.
      @param endPoint The output end point of the line.
      @returns Returns true if successful.
    */
    getData(): [startPoint: Point2D, endPoint: Point2D]
    /**
      Sets all of the data defining the line segment.
      @param startPoint The start point of the line
      @param endPoint The end point of the line
      @returns Returns true if redefining the line is successful
    */
    set(startPoint: Point2D, endPoint: Point2D): boolean
    /**
      Returns a NURBS curve that is geometrically identical to the line.
    */
    readonly asNurbsCurve: NurbsCurve2D
  }

  /**
    Transient 2D NURBS curve. A transient NURBS curve is not displayed or saved in a document.
    Transient 2D NURBS curves are used as a wrapper to work with raw 2D NURBS curve information.
    They are created statically using one of the create methods of the NurbsCurve2D class.
  */
  abstract class NurbsCurve2D extends Curve2D {
    /**
      Creates a transient 2D NURBS non-rational b-spline object.
      @param controlPoints An array of control point that define the path of the spline
      @param degree The degree of curvature of the spline
      @param knots An array of numbers that define the knot vector of the spline. The knots is an array of (>=degree + N + 1) numbers, where N is the number of control points.
      @param isPeriodic A bool specifying if the spline is to be Periodic. A periodic spline has a start point and
      end point that meet forming a closed loop.
      @returns Returns the new NurbsCurve2D object or null if the creation failed.
    */
    static createNonRational(controlPoints: Point2D[], degree: number /*int*/, knots: number[], isPeriodic: boolean): NurbsCurve2D | null
    /**
      Creates a transient 2D NURBS rational b-spline object.
      @param controlPoints An array of control point that define the path of the spline
      @param degree The degree of curvature of the spline
      @param knots An array of numbers that define the knot vector of the spline. The knots is an array of (>=degree + N + 1) numbers, where N is the number of control points.
      @param weights An array of numbers that define the weights for the spline.
      @param isPeriodic A bool specifying if the spline is to be Periodic. A periodic curve has a start point and
      end point that meet (with curvature continuity) forming a closed loop.
      @returns Returns the new NurbsCurve2D object or null if the creation failed.
    */
    static createRational(controlPoints: Point2D[], degree: number /*int*/, knots: number[], weights: number[], isPeriodic: boolean): NurbsCurve2D | null
    /**
      Gets the number of control points that define the curve
    */
    readonly controlPointCount: number /*int*/
    /**
      Creates and returns an independent copy of this NurbsCurve2D object.
      @returns Returns an independent copy of this NurbsCurve2D.
    */
    copy(): NurbsCurve2D
    /**
      Returns the degree of the curve
    */
    readonly degree: number /*int*/
    /**
      Returns the knot count of the curve
    */
    readonly knotCount: number /*int*/
    /**
      Returns if the curve is rational or non-rational type
    */
    readonly isRational: boolean
    /**
      Returns if the curve is closed
    */
    readonly isClosed: boolean
    /**
      Returns if the curve is periodic.
    */
    readonly isPeriodic: boolean
    /**
      Returns an array of Point2D objects that define the control points of the curve.
    */
    readonly controlPoints: Point2D[]
    /**
      Returns an array of numbers that define the Knots of the curve.
    */
    readonly knots: number[]
    /**
      Gets the data that defines a transient 2D NURBS rational b-spline object.
      @param controlPoints The output array of control point that define the path of the spline.
      @param degree The output degree of curvature of the spline.
      @param knots The output array of numbers that define the knots of the spline.
      @param isRational The output value indicating if the spline is rational. A rational spline will have a weight value
      for each control point.
      @param weights The output array of numbers that define the weights for the spline.
      @param isPeriodic The output value indicating if the spline is Periodic. A periodic curve has a start point and
      end point that meet (with curvature continuity) forming a closed loop.
      @returns Returns true if successful.
    */
    getData(): [controlPoints: Point2D[], degree: number /*int*/, knots: number[], isRational: boolean, weights: number[], isPeriodic: boolean]
    /**
      Sets the data that defines a transient 2D NURBS rational b-spline object.
      @param controlPoints The array of control point that define the path of the spline
      @param degree The degree of curvature of the spline
      @param knots An array of numbers that define the knots of the spline.
      @param isRational A bool indicating if the spline is rational. A rational spline must have a weight value
      for each control point.
      @param weights An array of numbers that define the weights for the spline.
      @param isPeriodic A bool specifying if the spline is to be Periodic. A periodic curve has a start point and
      end point that meet (with curvature continuity) forming a closed loop.
      @returns Returns true if successful
    */
    set(controlPoints: Point2D[], degree: number /*int*/, knots: number[], isRational: boolean, weights: number[], isPeriodic: boolean): boolean
    /**
      Defines a new NURBS curve that is the subset of this NURBS curve in the parameter
      range of [startParam, endParam]
      @param startParam The parameter position of the start of the subset.
      @param endParam The parameter position of the end of the subset.
      @returns Returns a new NurbsCurve2D object.
    */
    extract(startParam: number, endParam: number): NurbsCurve2D
    /**
      Define a new NURBS curve that is the result of combining this NURBS curve with
      another NURBS curve. The curves are merged with the end point of the current
      curve merging with the start point of the other curve. The curves are forced
      to join even if they are not physically touching so you will typically want
      to make sure the end and start points of the curves are where you expect them to be.
      @param nurbsCurve The NURBS curve to combine with
      @returns Returns a new NurbsCurve2D object.
    */
    merge(nurbsCurve: NurbsCurve2D): NurbsCurve2D
    /**
      Reverses the orientation of the curve so the start and end points
      are swapped. The shape of the curve remains unchanged. This is
      especially useful to prepare the curves to use with the merge
      method.
    */
    reverse(): boolean
  }

  /**
    Represents a single curve composed of a series of connected lines in 2D space.
  */
  abstract class Polyline2D extends Curve2D {
    /**
      Creates a transient 2D polyline using an array of Point2D objects that defines
      the position of the polyline vertices.
      @param points An array of Point2D objects that define the coordinates of the curve.
      @returns Returns the created Polyline2D object.
    */
    static create(points: Point2D[]): Polyline2D
    /**
      Creates a transient 2D polyline using an array of floating point values that
      specify the X, Y coordinates for each point.
      @param pointCoordinates An array of floating point values that define the X, Y coordinates of each
      point in the polyline.
      @returns Returns the created Polyline2D object.
    */
    static createByArray(pointCoordinates: number[]): Polyline2D
    /**
      Returns the number of points defining the polyline.
    */
    readonly pointCount: number /*int*/
    /**
      Gets and sets the points that define the coordinates of the polyline.
    */
    points: Point2D[]
    /**
      Returns a NURBS curve that is geometrically identical to the polyline.
    */
    readonly asNurbsCurve: NurbsCurve2D
  }

  /**
    Transient 2D point. A transient point is not displayed or saved in a document.
    Transient 2D points are used as a wrapper to work with raw 2D point information.
    They are created statically using the create methods of the Point2D class.
  */
  abstract class Point2D extends Base {
    /**
      Creates a transient 2D point object.
      @param x The x coordinate of the point
      @param y The y coordinate of the point
      @returns Returns the new Point2D object or null if the creation failed.
    */
    static create(x?: number/* = 0.0*/, y?: number/* = 0.0*/): Point2D | null
    /**
      Gets and sets the X coordinate of the point.
    */
    x: number
    /**
      Gets and sets the Y coordinate of the point.
    */
    y: number
    /**
      Creates and returns a copy of this point object.
      @returns Returns an independent copy of this point object.
    */
    copy(): Point2D
    /**
      Gets the data defining the point.
      @param x The output x coordinate of the point.
      @param y The output y coordinate of the point.
      @returns Returns true if successful.
    */
    getData(): [x: number, y: number]
    /**
      Returns the distance from this point to another point.
      @param point The point to measure the distance to
      @returns Returns the distance to the point.
    */
    distanceTo(point: Point2D): number
    /**
      Get coordinate data of the point
      @returns Returns the coordinate data of the point as an array
    */
    asArray(): number[]
    /**
      Checks to see if this point and another point are equal (have identical coordinates).
      The comparison is done within the modeling tolerance which can be found with the
      Application.pointTolerance property. If you want to compare two points with any other
      tolerance you can use the isEqualToByTolerance method.
      @param point The point to compare for equality
      @returns Returns true if the points are equal. (have identical coordinates)
    */
    isEqualTo(point: Point2D): boolean
    /**
      Sets the coordinates of the point using an array as input.
      @param coordinates An array that defines the coordinates of the point
      @returns Returns true if successful
    */
    setWithArray(coordinates: number[]): boolean
    /**
      Sets the coordinates of the point by specifying the x, y coordinates.
      @param x The x coordinate of the point.
      @param y The y coordinate of the point.
      @returns Returns true if successful
    */
    set(x: number, y: number): boolean
    /**
      Transforms the point using the provided matrix.
      @param matrix The Matrix2D object that defines the transformation
      @returns Returns true if successful
    */
    transformBy(matrix: Matrix2D): boolean
    /**
      Defines a vector using the coordinates of the point.
      @returns Returns a Vector2D object
    */
    asVector(): Vector2D
    /**
      Translates the point using the provided vector.
      @param vector The vector to use to translate the point
      @returns Returns true if successful
    */
    translateBy(vector: Vector2D): boolean
    /**
      Returns a vector from this point to another point.
      @param point The other point to use to create the vector
      @returns Returns a Vector2D object
    */
    vectorTo(point: Point2D): Vector2D
    /**
      Checks to see if this point and another point are equal within the specified tolerance.
      @param point The point to compare for equality.
      @param tolerance The tolerance, in centimeters, to use when comparing the two points.
      @returns Returns true if the points are equal (have identical coordinates).
    */
    isEqualToByTolerance(point: Point2D, tolerance: number): boolean
  }

  /**
    2D curve evaluator that is obtained from a transient curve and allows you to perform
    various evaluations on the curve.
  */
  abstract class CurveEvaluator2D extends Base {
    /**
      Get the curvature values at a number of parameter positions on the curve.
      @param parameters The array of parameter positions to return curvature information at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param directions The output array of the direction of the curvature at each position on the curve.
      The length of this array will be the same as the length of the parameters array provided.
      @param curvatures The output array of the magnitude of the curvature at the position on the curve.
      The length of this array will be the same as the length of the parameters array provided.
      @returns Returns true if the curvatures were successfully returned.
    */
    getCurvatures(parameters: number[]): [directions: Vector2D[], curvatures: number[]]
    /**
      Get the curvature value at a parameter position on the curve.
      @param parameter The parameter position to return the curvature information at.
      This value must be within the range of the parameter extents as provided by getParameterExtents.
      @param direction The output direction of the curvature at the position on the curve.
      @param curvature The output magnitude of the curvature at the position on the curve.
      @returns Returns true if the curvature was successfully returned.
    */
    getCurvature(parameter: number): [direction: Vector2D, curvature: number]
    /**
      Get the tangent to the curve at a number of parameter positions on the curve.
      @param parameters The array of parameter positions to return the tangent at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param tangents The output array of tangent vectors for each position on the curve.
      The length of this array will be the same as the length of the parameters array provided.
      @returns Returns true if the tangents were successfully returned.
    */
    getTangents(parameters: number[]): [tangents: Vector2D[]]
    /**
      Get the tangent to the curve at a parameter position on the curve.
      @param parameter The parameter position to return the tangent at.
      This value must be within the range of the parameter extents as provided by getParameterExtents.
      @param tangent The output tangent vector at the curve position.
      @returns Returns true if the tangent was successfully returned.
    */
    getTangent(parameter: number): [tangent: Vector2D]
    /**
      Get the end points of the curve.
      @param startPoint The output start point of the curve. If the curve is unbounded at the start, this value will be null.
      @param endPoint The output end point of the curve. If the curve is unbounded at the end, this value will be null.
      @returns Returns true if the end points were successfully returned.
    */
    getEndPoints(): [startPoint: Point2D, endPoint: Point2D]
    /**
      Get the length of the curve between two parameter positions on the curve.
      @param fromParameter The parameter position to measure the curve length from.
      This value must be within the range of the parameter extents as provided by getParameterExtents.
      @param toParameter The parameter position to measure the curve length to.
      This value must be within the range of the parameter extents as provided by getParameterExtents.
      @param length The output curve length between the from and to parameter positions on the curve.
      @returns Returns true if the length was successfully returned.
    */
    getLengthAtParameter(fromParameter: number, toParameter: number): [length: number]
    /**
      Get the parameter position on the curve that is the specified curve length from the specified starting parameter position.
      @param fromParameter The parameter position to start measuring the curve length from.
      This value must be within the range of the parameter extents as provided by getParameterExtents.
      @param length The curve length to offset the from parameter by.
      A negative length value will offset in the negative parameter direction.
      @param parameter The output parameter value that is the specified curve length from the starting parameter position.
      @returns Returns true if the parameter was successfully returned.
    */
    getParameterAtLength(fromParameter: number, length: number): [parameter: number]
    /**
      Get the parameter positions that correspond to a set of points on the curve.
      For reliable results, the points should lie on the curve within model tolerance.
      If the points do not lie on the curve, the parameter of the nearest point on the curve will generally be returned.
      @param points An array of points to get the curve parameter values at.
      @param parameters The output array of parameter positions corresponding to the set of points.
      The length of this array will be equal to the length of the points array specified.
      @returns Returns true if the parameters were successfully returned.
    */
    getParametersAtPoints(points: Point2D[]): [parameters: number[]]
    /**
      Get the parameter position that correspond to a point on the curve.
      For reliable results, the point should lie on the curve within model tolerance.
      If the point does not lie on the curve, the parameter of the nearest point on the curve will generally be returned.
      @param point The point to get the curve parameter value at.
      @param parameter The output parameter position corresponding to the point.
      @returns Returns true of the parameter was successfully returned.
    */
    getParameterAtPoint(point: Point2D): [parameter: number]
    /**
      Get the parametric range of the curve.
      @param startParameter The output lower bound of the parameter range.
      @param endParameter The output upper bound of the parameter range.
      @returns Returns true if the curve is bounded and the parameter extents were successfully returned.
    */
    getParameterExtents(): [startParameter: number, endParameter: number]
    /**
      Get the points on the curve that correspond to evaluating a set of parameter positions on the curve.
      @param parameters The array of parameter positions to evaluate the curve position at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param points The output array of curve positions corresponding to evaluating the curve at that parameter position.
      The length of this array will be equal to the length of the parameters array specified.
      @returns Returns true if the points were successfully returned.
    */
    getPointsAtParameters(parameters: number[]): [points: Point2D[]]
    /**
      Get the point on the curve that corresponds to evaluating a parameter position on the curve.
      @param parameter The parameter position to evaluate the curve position at.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param point The output curve position corresponding to evaluating the curve at that parameter position.
      @returns Returns true if the point was successfully returned.
    */
    getPointAtParameter(parameter: number): [point: Point2D]
    /**
      Get the first derivatives of the curve at the specified parameter positions.
      @param parameters The array of parameter positions to get the curve first derivative at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param firstDerivatives The output array of first derivative vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @returns Returns true if the first derivatives were successfully returned.
    */
    getFirstDerivatives(parameters: number[]): [firstDerivatives: Vector2D[]]
    /**
      Get the first derivative of the curve at the specified parameter position.
      @param parameter The parameter position to get the curve first derivative at.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param firstDerivative The output first derivative vector at the parameter position specified.
      @returns Returns true if the first derivative was successfully returned.
    */
    getFirstDerivative(parameter: number): [firstDerivative: Vector2D]
    /**
      Get the second derivatives of the curve at the specified parameter positions.
      @param parameters The array of parameter positions to get the curve second derivative at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param secondDerivatives The output array of second derivative vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @returns Returns true if the second derivatives were successfully returned.
    */
    getSecondDerivatives(parameters: number[]): [secondDerivatives: Vector2D[]]
    /**
      Get the second derivative of the curve at the specified parameter position.
      @param parameter The parameter position to get the curve second derivative at.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param secondDerivative The output second derivative vector at the parameter position specified.
      @returns Returns true if the second derivative was successfully returned.
    */
    getSecondDerivative(parameter: number): [secondDerivative: Vector2D]
    /**
      Get the third derivatives of the curve at the specified parameter positions.
      @param parameters The array of parameter positions to get the curve third derivative at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param thirdDerivatives The output array of third derivative vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @returns Returns true if the third derivatives were successfully returned.
    */
    getThirdDerivatives(parameters: number[]): [thirdDerivatives: Vector2D[]]
    /**
      Get the third derivative of the curve at the specified parameter position.
      @param parameter The parameter position to get the curve third derivative at.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param thirdDerivative The output third derivative vector at the parameter position specified.
      @returns Returns true if the third derivative was successfully returned.
    */
    getThirdDerivative(parameter: number): [thirdDerivative: Vector2D]
    /**
      Get a sequence of points between two curve parameter positions.
      The points will be a linear interpolation along the curve between these two
      parameter positions where the maximum deviation between the curve and each line
      segment will not exceed the specified tolerance value.
      @param fromParameter The starting parameter position to interpolate points from.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param toParameter The ending parameter position to interpolate points to.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param tolerance The maximum distance tolerance between the curve and the linear interpolation.
      @param vertexCoordinates The output array of linear interpolation points.
      @returns Returns true if the interpolation points were successfully returned.
    */
    getStrokes(fromParameter: number, toParameter: number, tolerance: number): [vertexCoordinates: Point2D[]]
  }

  /**
    The base class for all 3D transient geometry classes.
  */
  abstract class Curve3D extends Base {
    /**
      Returns the type of geometry this curve represents.
    */
    readonly curveType: Curve3DTypes
    /**
      Returns an evaluator object that lets you perform additional evaluations on the curve.
    */
    readonly evaluator: CurveEvaluator3D
    /**
      Transforms this curve in 3D space.
      @param matrix A 3D matrix that defines the transform to apply to the curve.
      @returns Return true if the transform was successful.
    */
    transformBy(matrix: Matrix3D): boolean
  }

  /**
    Object that represents a collection of connected Curve3D objects.
    @experimental
  */
  abstract class Curve3DPath extends core.Base {
    /**
      Returns the Curve3D at the specified index from this collection of Curve3D objects.
      @param index The index of the Curve3D within this Curve3D collection to return. The first Curve3D in this collection has an index of 0.
    */
    item(index: number /*unsigned int*/): Curve3D
    /**
      Returns the number of Curve3D objects contained in this Curve3D collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The different types of 3D curves.
  */
  const enum Curve3DTypes {
    /**
      Transient 3D line segment.
    */
    Line3DCurveType,
    /**
      Transient 3D arc.
    */
    Arc3DCurveType,
    /**
      Transient 3D circle.
    */
    Circle3DCurveType,
    /**
      Transient 3D ellipse.
    */
    Ellipse3DCurveType,
    /**
      Transient 3D elliptical arc.
    */
    EllipticalArc3DCurveType,
    /**
      Transient 3D infinite line.
    */
    InfiniteLine3DCurveType,
    /**
      Transient 3D NURBS curve.
    */
    NurbsCurve3DCurveType,
    /**
      Transient 3D polyline.
    */
    Polyline3DCurveType,
  }

  /**
    Transient 3D arc. A transient arc is not displayed or saved in a document.
    Transient 3D arcs are used as a wrapper to work with raw 3D arc information.
    They are created statically using one of the create methods of the Arc3D class.
  */
  abstract class Arc3D extends Curve3D {
    /**
      Creates a transient 3D arc object by specifying a center point and radius.
      @param center The center point of the arc.
      @param normal The normal vector of the arc.
      The plane perpendicular to this normal at the center point is the plane of the arc.
      @param referenceVector A reference vector from which the start and end angles are measured from.
      This vector must be perpendicular to the normal vector.
      @param radius The radius of the arc.
      @param startAngle The start angle in radians.
      This angle is measured from the reference vector using the right hand rule around the normal vector.
      @param endAngle The end angle in radians.
      This angle is measured from the reference vector using the right hand rule around the normal vector.
      @returns Returns the newly created arc or null if the creation failed.
    */
    static createByCenter(center: Point3D, normal: Vector3D, referenceVector: Vector3D, radius: number, startAngle: number, endAngle: number): Arc3D | null
    /**
      Creates a transient 3D arc by specifying 3 points.
      A transient arc is not displayed or saved in a document. Transient arcs are used as
      a wrapper to work with raw 3D arc information.
      @param pointOne The start point of the arc.
      @param pointTwo A point along the arc.
      This point must not be coincident with the first or third points.
      This point must not lie on the line between the first and third points.
      @param pointThree The end point of the arc.
      This point must not be coincident with the first or second points.
      @returns Returns the newly created arc or null if the creation failed.
    */
    static createByThreePoints(pointOne: Point3D, pointTwo: Point3D, pointThree: Point3D): Arc3D | null
    /**
      Gets and sets the center position of the arc.
    */
    center: Point3D
    /**
      Gets the normal of the arc.
    */
    readonly normal: Vector3D
    /**
      Gets the reference vector of the arc.
    */
    readonly referenceVector: Vector3D
    /**
      Sets the normal and reference vectors of the arc.
      @param normal The new normal vector.
      @param referenceVector The new reference vector from which the start and end angles are measured from.
      The reference vector must be perpendicular to the normal vector.
      @returns Returns true if successful
    */
    setAxes(normal: Vector3D, referenceVector: Vector3D): boolean
    /**
      Gets and sets the radius of the arc.
    */
    radius: number
    /**
      Gets and sets the start angle of the arc in radians.
      This angle is measured from the reference vector using the right hand rule around the normal vector.
    */
    startAngle: number
    /**
      Gets and sets the end angle of the arc in radians.
      This angle is measured from the reference vector using the right hand rule around the normal vector.
    */
    endAngle: number
    /**
      Gets the start point of the arc.
    */
    readonly startPoint: Point3D
    /**
      Gets the end point of the arc.
    */
    readonly endPoint: Point3D
    /**
      Creates and returns an independent copy of this Arc3D object.
      @returns Returns a new Arc3D object that is a copy of this Arc3D object.
    */
    copy(): Arc3D
    /**
      Gets all of the data defining the arc.
      @param center The output center point of the arc.
      @param normal The output normal vector.
      @param referenceVector The output reference vector.
      @param radius The output radius of the arc.
      @param startAngle The output start angle in radians.
      This angle is measured from the reference vector using the right hand rule around the normal vector.
      @param endAngle The output end angle in radians.
      This angle is measured from the reference vector using the right hand rule around the normal vector.
      @returns Returns true if successful
    */
    getData(): [center: Point3D, normal: Vector3D, referenceVector: Vector3D, radius: number, startAngle: number, endAngle: number]
    /**
      Sets all of the data defining the arc.
      @param center The center point of the arc.
      @param normal The normal vector of the arc.
      The plane perpendicular to this normal at the center point is the plane of the arc.
      @param referenceVector A reference vector from which the start and end angles are measured from.
      This vector must be perpendicular to the normal vector.
      @param radius The radius of the arc.
      @param startAngle The start angle in radians.
      This angle is measured from the reference vector using the right hand rule around the normal vector.
      @param endAngle The end angle in radians.
      This angle is measured from the reference vector using the right hand rule around the normal vector.
      @returns Returns true if successful
    */
    set(center: Point3D, normal: Vector3D, referenceVector: Vector3D, radius: number, startAngle: number, endAngle: number): boolean
    /**
      Returns a NURBS curve that is geometrically identical to the arc.
    */
    readonly asNurbsCurve: NurbsCurve3D
  }

  /**
    Transient 3D circle. A transient circle is not displayed or saved in a document.
    Transient 3D circles are used as a wrapper to work with raw 3D circle information.
    They are created statically using one of the create methods of the Circle3D class.
  */
  abstract class Circle3D extends Curve3D {
    /**
      Creates a transient 3D circle object by specifying a center and radius.
      @param center The center point of the circle.
      @param normal The normal vector of the circle.
      The plane through the center point and perpendicular to the normal vector defines the plane of the circle.
      @param radius The radius of the circle.
      @returns Returns the new Circle3D object or null if the creation failed.
    */
    static createByCenter(center: Point3D, normal: Vector3D, radius: number): Circle3D | null
    /**
      Creates a transient 3D circle through three points.
      @param pointOne The first point on the circle.
      @param pointTwo The second point on the circle.
      This point cannot be coincident with pointOne or pointThree.
      This point cannot lie on the line defined by pointOne and pointThree.
      @param pointThree The third point on the circle.
      This point cannot be coincident with pointOne or pointThree.
      @returns Returns the new Circle3D object or null if the creation failed.
    */
    static createByThreePoints(pointOne: Point3D, pointTwo: Point3D, pointThree: Point3D): Circle3D | null
    /**
      Gets and sets the center position of the circle.
    */
    center: Point3D
    /**
      Gets and sets the normal of the circle.
    */
    normal: Vector3D
    /**
      Gets and sets the radius of the circle.
    */
    radius: number
    /**
      Creates and returns an independent copy of this Circle3D object.
      @returns Returns an independent copy of this Circle3D object.
    */
    copy(): Circle3D
    /**
      Gets all of the data defining the circle.
      @param center The output center point of the circle.
      @param normal The output normal vector.
      @param radius The output radius of the circle.
      @returns Returns true if successful
    */
    getData(): [center: Point3D, normal: Vector3D, radius: number]
    /**
      Sets all of the data defining the circle.
      @param center The center point of the circle.
      @param normal The normal vector of the circle.
      The plane through the center point and perpendicular to the normal vector defines the plane of the circle.
      @param radius The radius of the circle.
      @returns Returns true if successful
    */
    set(center: Point3D, normal: Vector3D, radius: number): boolean
    /**
      Returns a NURBS curve that is geometrically identical to the circle.
    */
    readonly asNurbsCurve: NurbsCurve3D
  }

  /**
    Transient 3D ellipse. A transient ellipse is n0t displayed or saved in a document.
    Transient 3D ellipses are used as a wrapper to work with raw 3D ellipse information.
    They are created statically using the create method of the Ellipse3D class.
  */
  abstract class Ellipse3D extends Curve3D {
    /**
      Creates a transient 3D ellipse object.
      @param center The center point of the ellipse.
      @param normal The normal vector of the ellipse.
      The plane through the center point and perpendicular to the normal vector defines the plane of the ellipse.
      @param majorAxis The major axis of the ellipse
      @param majorRadius The major radius of the of the ellipse.
      @param minorRadius The minor radius of the of the ellipse.
      @returns Returns the new Ellipse 3D object or null if the creation failed.
    */
    static create(center: Point3D, normal: Vector3D, majorAxis: Vector3D, majorRadius: number, minorRadius: number): Ellipse3D | null
    /**
      Gets and sets the center position of the ellipse.
    */
    center: Point3D
    /**
      Gets the normal of the ellipse.
    */
    readonly normal: Vector3D
    /**
      Gets and sets the major axis of the ellipse.
    */
    majorAxis: Vector3D
    /**
      Gets and sets the major radius of the ellipse.
    */
    majorRadius: number
    /**
      Gets and sets the minor radius of the ellipse.
    */
    minorRadius: number
    /**
      Creates a copy of this Ellipse3D object.
      @returns Returns the independent copy of the ellipse.
    */
    copy(): Ellipse3D
    /**
      Gets all of the data defining the ellipse.
      @param center The output center point of the ellipse.
      @param normal The output normal vector of the ellipse.
      @param majorAxis The output major axis of the ellipse
      @param majorRadius The output major radius of the of the ellipse.
      @param minorRadius The output minor radius of the of the ellipse.
      @returns Returns true if successful.
    */
    getData(): [center: Point3D, normal: Vector3D, majorAxis: Vector3D, majorRadius: number, minorRadius: number]
    /**
      Sets all of the data defining the ellipse.
      @param center The center point of the ellipse.
      @param normal The normal vector of the ellipse.
      The plane through the center point and perpendicular to the normal vector defines the plane of the ellipse.
      @param majorAxis The major axis of the ellipse.
      @param majorRadius The major radius of the of the ellipse.
      @param minorRadius The minor radius of the of the ellipse.
      @returns Returns true if successful.
    */
    set(center: Point3D, normal: Vector3D, majorAxis: Vector3D, majorRadius: number, minorRadius: number): boolean
    /**
      Returns a NURBS curve that is geometrically identical to the ellipse.
    */
    readonly asNurbsCurve: NurbsCurve3D
  }

  /**
    Transient 3D elliptical arc. A transient elliptical arc is not displayed or saved in a document.
    Transient 3D elliptical arcs are used as a wrapper to work with raw 3D elliptical arc information.
    They are created statically using the create method of the EllipticalArc3D class.
  */
  abstract class EllipticalArc3D extends Curve3D {
    /**
      Creates a transient 3D elliptical arc.
      @param center The center point of the elliptical arc.
      @param normal The normal vector of the elliptical arc.
      @param majorAxis The major axis of the elliptical arc.
      @param majorRadius The major radius of the of the elliptical arc.
      @param minorRadius The minor radius of the of the elliptical arc.
      @param startAngle The start angle of the elliptical arc in radians, where 0 is along the major axis.
      @param endAngle The end angle of the elliptical arc in radians, where 0 is along the major axis.
      @returns Returns the newly created elliptical arc or null if the creation failed.
    */
    static create(center: Point3D, normal: Vector3D, majorAxis: Vector3D, majorRadius: number, minorRadius: number, startAngle: number, endAngle: number): EllipticalArc3D | null
    /**
      Gets and sets the center point of the elliptical arc.
    */
    center: Point3D
    /**
      Gets the normal of the elliptical arc.
    */
    readonly normal: Vector3D
    /**
      Gets and sets the major axis of the elliptical arc.
    */
    majorAxis: Vector3D
    /**
      Gets and sets the major radius of the elliptical arc.
    */
    majorRadius: number
    /**
      Gets and sets the minor radius of the elliptical arc.
    */
    minorRadius: number
    /**
      Gets and sets the start angle of the elliptical arc.
    */
    startAngle: number
    /**
      Gets and sets the end angle of the elliptical arc.
    */
    endAngle: number
    /**
      Creates and returns a copy of this EllipticalArc3D object.
      @returns Returns a new EllipticalArc3D object that is a copy of this Arc3D object.
    */
    copy(): EllipticalArc3D
    /**
      Gets all of the data defining the elliptical arc.
      @param center The output center point of the elliptical arc.
      @param normal The output normal vector of the elliptical arc.
      @param majorAxis The output major axis of the elliptical arc.
      @param majorRadius The output major radius of the of the elliptical arc.
      @param minorRadius The output minor radius of the of the elliptical arc.
      @param startAngle The output start angle of the elliptical arc in radians, where 0 is along the major axis.
      @param endAngle The output end angle of the elliptical arc in radians, where 0 is along the major axis.
      @returns Returns true if successful.
    */
    getData(): [center: Point3D, normal: Vector3D, majorAxis: Vector3D, majorRadius: number, minorRadius: number, startAngle: number, endAngle: number]
    /**
      Sets all of the data defining the elliptical arc.
      @param center The center point of the elliptical arc.
      @param normal The normal vector of the elliptical arc.
      @param majorAxis The major axis of the elliptical arc.
      @param majorRadius The major radius of the of the elliptical arc.
      @param minorRadius The minor radius of the of the elliptical arc.
      @param startAngle The start angle of the elliptical arc in radians, where 0 is along the major axis.
      @param endAngle The end angle of the elliptical arc in radians, where 0 is along the major axis.
      @returns Returns true if successful.
    */
    set(center: Point3D, normal: Vector3D, majorAxis: Vector3D, majorRadius: number, minorRadius: number, startAngle: number, endAngle: number): boolean
    /**
      Returns a NURBS curve that is geometrically identical to the elliptical arc.
    */
    readonly asNurbsCurve: NurbsCurve3D
  }

  /**
    Transient 3D line. A transient line is not displayed or saved in a document.
    Transient 3D lines are used as a wrapper to work with raw 3D line information.
    They are created statically using the create method of the Line3D class.
  */
  abstract class Line3D extends Curve3D {
    /**
      Creates a transient line.
      @param startPoint The start point of the line.
      @param endPoint The end point of the line.
      @returns Returns the new Line3D object or null if the creation failed.
    */
    static create(startPoint: Point3D, endPoint: Point3D): Line3D | null
    /**
      Gets and sets the start point of the line.
    */
    startPoint: Point3D
    /**
      Gets and sets the end point of the line.
    */
    endPoint: Point3D
    /**
      Creates and returns a copy of this line object.
      @returns Returns an independent copy of this line object.
    */
    copy(): Line3D
    /**
      Creates an equivalent InfiniteLine3D.
      @returns Returns an equivalent InfiniteLine3D
    */
    asInfiniteLine(): InfiniteLine3D
    /**
      Compare this line with another to check for collinearity
      @param line The line to compare with for collinearity
      @returns Returns true if the two lines are collinear
    */
    isColinearTo(line: Line3D): boolean
    /**
      Intersect this line with a curve to get the intersection point(s).
      @param curve The intersecting curve.
      The curve can be a Line3D, InfininteLine3D, Circle3D, Arc3D, EllipticalArc3D, Ellipse3D,
      or NurbsCurve3D.
      @returns Returns a collection of the intersection points
    */
    intersectWithCurve(curve: Curve3D): ObjectCollection
    /**
      Intersect this line with a surface to get the intersection point(s).
      @param surface The intersecting surface.
      The surface can be a Plane, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Sphere,
      Torus or a NurbsSurface.
      @returns Returns a collection of the intersection points.
    */
    intersectWithSurface(surface: Surface): ObjectCollection
    /**
      Gets all of the data defining the line segment.
      @param startPoint The output start point of the line.
      @param endPoint The output end point of the line.
      @returns Returns true if successful.
    */
    getData(): [startPoint: Point3D, endPoint: Point3D]
    /**
      Sets all of the data defining the line segment.
      @param startPoint The start point of the line.
      @param endPoint The end point of the line.
      @returns Returns true if successful.
    */
    set(startPoint: Point3D, endPoint: Point3D): boolean
    /**
      Returns a NURBS curve that is geometrically identical to the line.
    */
    readonly asNurbsCurve: NurbsCurve3D
  }

  /**
    Transient 3D infinite line. An infinite line is defined by a position and direction in space
    and has no start or end points.
    They are created statically using the create method of the InfiniteLine3D class.
  */
  abstract class InfiniteLine3D extends Curve3D {
    /**
      Creates a transient 3D infinite line.
      @param origin The origin point of the line.
      @param direction The direction of the line.
      @returns Returns the new InfiniteLine3D object or null if the creation failed.
    */
    static create(origin: Point3D, direction: Vector3D): InfiniteLine3D | null
    /**
      Gets and sets the origin point of the line.
    */
    origin: Point3D
    /**
      Gets and sets the direction of the line.
    */
    direction: Vector3D
    /**
      Compare this line with another to check for collinearity.
      @param line The line to compare with for collinearity.
      @returns Returns true if the two lines are collinear.
    */
    isColinearTo(line: InfiniteLine3D): boolean
    /**
      Creates and returns a copy of this line object.
      @returns Returns an independent copy of this line object.
    */
    copy(): InfiniteLine3D
    /**
      Intersect this line with a curve to get the intersection point(s).
      @param curve The intersecting curve.
      The curve can be a Line3D, InfininteLine3D, Circle3D, Arc3D, EllipticalArc3D, Ellipse3D,
      or NurbsCurve3D.
      @returns Returns a collection of the intersection points.
    */
    intersectWithCurve(curve: Curve3D): ObjectCollection
    /**
      Intersect this line with a surface to get the intersection point(s).
      @param surface The intersecting surface.
      The surface can be a Plane, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Sphere,
      Torus, or a NurbsSurface.
      @returns Returns a collection of the intersection points.
    */
    intersectWithSurface(surface: Surface): ObjectCollection
    /**
      Gets all of the data defining the infinite line.
      @param origin The output origin point of the line.
      @param direction The output direction of the line.
      @returns Returns true if successful.
    */
    getData(): [origin: Point3D, direction: Vector3D]
    /**
      Sets all of the data defining the infinite line.
      @param origin The origin point of the line.
      @param direction The direction of the line.
      @returns Returns true if successful.
    */
    set(origin: Point3D, direction: Vector3D): boolean
  }

  /**
    Transient 3D NURBS curve. A transient NURBS curve is not displayed or saved in a document.
    Transient 3D NURBS curves are used as a wrapper to work with raw 3D NURBS curve information.
    They are created statically using one of the create methods of the NurbsCurve3D class.
  */
  abstract class NurbsCurve3D extends Curve3D {
    /**
      Creates a transient 3D NURBS non-rational b-spline object.
      @param controlPoints An array of control point that define the path of the spline.
      @param degree The degree of curvature of the spline.
      @param knots An array of numbers that define the knot vector of the spline. The knots is an array of (>=degree + N + 1) numbers, where N is the number of control points.
      @param isPeriodic A bool specifying if the spline is to be Periodic. A periodic spline has a start point and
      end point that meet forming a closed loop.
      @returns Returns the new NurbsCurve3D object or null if the creation failed.
    */
    static createNonRational(controlPoints: Point3D[], degree: number /*int*/, knots: number[], isPeriodic: boolean): NurbsCurve3D | null
    /**
      Creates a transient 3D NURBS rational b-spline object.
      @param controlPoints An array of control point that define the path of the spline.
      @param degree The degree of curvature of the spline.
      @param knots An array of numbers that define the knot vector of the spline. The knots is an array of (>=degree + N + 1) numbers, where N is the number of control points.
      @param weights An array of numbers that define the weight at each control point.
      @param isPeriodic A bool specifying if the spline is to be Periodic. A periodic curve has a start point and
      end point that meet (with curvature continuity) forming a closed loop.
      @returns Returns the new NurbsCurve3D object or null if the creation failed.
    */
    static createRational(controlPoints: Point3D[], degree: number /*int*/, knots: number[], weights: number[], isPeriodic: boolean): NurbsCurve3D | null
    /**
      Gets the number of control points that define the curve.
    */
    readonly controlPointCount: number /*int*/
    /**
      Returns the degree of the curve.
    */
    readonly degree: number /*int*/
    /**
      Returns the knot count of the curve.
    */
    readonly knotCount: number /*int*/
    /**
      Gets if the curve is rational or non-rational type.
    */
    readonly isRational: boolean
    /**
      Gets if the curve is closed.
    */
    readonly isClosed: boolean
    /**
      Gets if the curve is periodic.
    */
    readonly isPeriodic: boolean
    /**
      Returns an array of Point3D objects that define the control points of the curve.
    */
    readonly controlPoints: Point3D[]
    /**
      Returns an array of numbers that define the knot vector of the curve.
    */
    readonly knots: number[]
    /**
      Gets the data that defines a transient 3D NURBS rational b-spline object.
      @param controlPoints The output array of control point that define the path of the spline.
      @param degree The output degree of curvature of the spline.
      @param knots The output array of numbers that define the knot vector of the spline.
      @param isRational The output value indicating if the spline is rational. A rational spline will have a weight value
      for each control point.
      @param weights The output array of numbers that define the weights for the spline.
      @param isPeriodic The output value indicating if the spline is Periodic. A periodic curve has a start point and
      end point that meet (with curvature continuity) forming a closed loop.
      @returns Returns true if successful.
    */
    getData(): [controlPoints: Point3D[], degree: number /*int*/, knots: number[], isRational: boolean, weights: number[], isPeriodic: boolean]
    /**
      Sets the data that defines a transient 3D NURBS rational b-spline object.
      @param controlPoints The array of control point that define the path of the spline.
      @param degree The degree of curvature of the spline.
      @param knots An array of numbers that define the knot vector of the spline.
      @param isRational A bool value indicating if the spline is rational. A rational spline must have a weight value
      for each control point.
      @param weights An array of numbers that define the weights for the spline.
      @param isPeriodic A bool indicating if the spline is Periodic. A periodic curve has a start point and
      end point that meet (with curvature continuity) forming a closed loop.
      @returns Returns true if successful.
    */
    set(controlPoints: Point3D[], degree: number /*int*/, knots: number[], isRational: boolean, weights: number[], isPeriodic: boolean): boolean
    /**
      Defines a new NURBS curve that is the subset of this NURBS curve in the parameter
      range of [startParam, endParam]
      @param startParam The parameter position that defines the start of the subset.
      @param endParam The parameter position that defines the end of the subset.
      @returns Returns a new NurbsCurve3D object.
    */
    extract(startParam: number, endParam: number): NurbsCurve3D
    /**
      Define a new NURBS curve that is the result of combining this NURBS curve with
      another NURBS curve.
      @param nurbsCurve The NURBS curve to combine with.
      @returns Returns a new NurbsCurve3D object.
    */
    merge(nurbsCurve: NurbsCurve3D): NurbsCurve3D
    /**
      Creates and returns an independent copy of this NurbsCurve3D object.
      @returns Returns an independent copy of this NurbsCurve3D.
    */
    copy(): NurbsCurve3D
    /**
      Reverses the orientation of the curve so the start and end points
      are swapped. The shape of the curve remains unchanged. This is
      especially useful to prepare the curves to use with the merge
      method.
    */
    reverse(): boolean
  }

  /**
    Represents a single piecewise linear curve. This is a single curve that
    consists of a series of connected lines in 3D space.
  */
  abstract class Polyline3D extends Curve3D {
    /**
      Creates a transient 3D polyline using an array of Point3D objects that defines
      the position of the polyline vertices.
      @param points An array of Point3D objects that define the coordinates of the curve.
      @returns Returns the created Polyline3D object or null if the creation failed.
    */
    static create(points: Point3D[]): Polyline3D | null
    /**
      Creates a transient 3D polyline using an array of floating point values that
      specify the X, Y, Z coordinates for each point.
      @param pointCoordinates An array of floating point values that define the X, Y, Z coordinates of each
      point in the polyline.
      @returns Returns the created Polyline3D object or null if the creation failed
    */
    static createByArray(pointCoordinates: number[]): Polyline3D | null
    /**
      Returns the number of points defining the polyline.
    */
    readonly pointCount: number /*int*/
    /**
      Gets and sets the points that define the coordinates of the polyline.
    */
    points: Point3D[]
    /**
      Returns a NURBS curve that is geometrically identical to the polyline.
    */
    readonly asNurbsCurve: NurbsCurve3D
  }

  /**
    Transient 3D point. A transient point is not displayed or saved in a document.
    Transient 3D points are used as a wrapper to work with raw 3D point information.
    They are created statically using the create method of the Point3D class.
  */
  abstract class Point3D extends Base {
    /**
      Creates a transient 3D point object.
      @param x The x coordinate of the point
      @param y The y coordinate of the point
      @param z The z coordinate of the point
      @returns Returns the new Point3D object or null if the creation failed.
    */
    static create(x?: number/* = 0.0*/, y?: number/* = 0.0*/, z?: number/* = 0.0*/): Point3D | null
    /**
      Returns the distance from this point to another point.
      @param point The point to measure the distance to.
      @returns Returns the distance to the point.
    */
    distanceTo(point: Point3D): number
    /**
      Creates and returns a copy of this point object.
      @returns Returns an independent copy of this point object.
    */
    copy(): Point3D
    /**
      Get coordinate data of the point.
      @returns Returns the coordinate data of the point as an array [x, y, z].
    */
    asArray(): number[]
    /**
      Checks to see if this point and another point are equal (have identical coordinates).
      The comparison is done within the modeling tolerance which can be found with the
      Application.pointTolerance property. If you want to compare two points with any other
      tolerance you can use the isEqualToByTolerance method.
      @param point The point to compare for equality.
      @returns Returns true if the points are equal (have identical coordinates).
    */
    isEqualTo(point: Point3D): boolean
    /**
      Sets the coordinates of the point using an array as input.
      @param coordinates An array that defines the coordinates of the point [x, y, z].
      @returns Returns true if successful.
    */
    setWithArray(coordinates: number[]): boolean
    /**
      Transforms the point using the provided matrix.
      @param matrix The Matrix3D object that defines the transformation.
      @returns Returns true if successful.
    */
    transformBy(matrix: Matrix3D): boolean
    /**
      Gets and sets the X coordinate of the point.
    */
    x: number
    /**
      Gets and sets the Y coordinate of the point.
    */
    y: number
    /**
      Gets and sets the Z coordinate of the point.
    */
    z: number
    /**
      Defines a vector using the coordinates of the point.
      @returns Returns a Vector2D object.
    */
    asVector(): Vector3D
    /**
      Translates the point using the provided vector.
      @param vector The vector to use to translate the point.
      @returns Returns true if successful.
    */
    translateBy(vector: Vector3D): boolean
    /**
      Gets the data defining the point.
      @param x The output x coordinate of the point.
      @param y The output y coordinate of the point.
      @param z The output z coordinate of the point.
      @returns Returns true if successful.
    */
    getData(): [x: number, y: number, z: number]
    /**
      Sets the data defining the point.
      @param x The x coordinate of the point.
      @param y The y coordinate of the point.
      @param z The z coordinate of the point.
      @returns Returns true if successful.
    */
    set(x: number, y: number, z: number): boolean
    /**
      Returns a vector from this point to another point.
      @param point The other point to use to create the vector.
      @returns Returns a Vector3D object.
    */
    vectorTo(point: Point3D): Vector3D
    /**
      Checks to see if this point and another point are equal within the specified tolerance.
      @param point The point to compare for equality.
      @param tolerance The tolerance, in centimeters, to use when comparing the two points.
      @returns Returns true if the points are equal (have identical coordinates).
    */
    isEqualToByTolerance(point: Point3D, tolerance: number): boolean
  }

  /**
    3D curve evaluator that is obtained from a transient curve and allows you to perform
    various evaluations on the curve.
  */
  abstract class CurveEvaluator3D extends Base {
    /**
      Get the curvature values at a number of parameter positions on the curve.
      @param parameters The array of parameter positions to return curvature information at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param directions The output array of the direction of the curvature at each position on the curve.
      The length of this array will be the same as the length of the parameters array provided.
      @param curvatures The output array of the magnitude of the curvature at the position on the curve.
      The length of this array will be the same as the length of the parameters array provided.
      @returns Returns true if the curvatures were successfully returned.
    */
    getCurvatures(parameters: number[]): [directions: Vector3D[], curvatures: number[]]
    /**
      Get the curvature value at a parameter position on the curve.
      @param parameter The parameter position to return the curvature information at.
      This value must be within the range of the parameter extents as provided by getParameterExtents.
      @param direction The output direction of the curvature at the position on the curve.
      @param curvature The output magnitude of the curvature at the position on the curve.
      @returns Returns true if the curvature was successfully returned.
    */
    getCurvature(parameter: number): [direction: Vector3D, curvature: number]
    /**
      Get the end points of the curve.
      @param startPoint The output start point of the curve. If the curve is unbounded at the start, this value will be null.
      @param endPoint The output end point of the curve. If the curve is unbounded at the end, this value will be null.
      @returns Returns true if the end points were successfully returned.
    */
    getEndPoints(): [startPoint: Point3D, endPoint: Point3D]
    /**
      Get the length of the curve between two parameter positions on the curve.
      @param fromParameter The parameter position to measure the curve length from.
      This value must be within the range of the parameter extents as provided by getParameterExtents.
      @param toParameter The parameter position to measure the curve length to.
      This value must be within the range of the parameter extents as provided by getParameterExtents.
      @param length The output curve length between the from and to parameter positions on the curve.
      @returns Returns true if the length was successfully returned.
    */
    getLengthAtParameter(fromParameter: number, toParameter: number): [length: number]
    /**
      Get the parameter position on the curve that is the specified curve length from the specified starting parameter position.
      @param fromParameter The parameter position to start measuring the curve length from.
      This value must be within the range of the parameter extents as provided by getParameterExtents.
      @param length The curve length to offset the from parameter by.
      A negative length value will offset in the negative parameter direction.
      @param parameter The output parameter value that is the specified curve length from the starting parameter position.
      @returns Returns true if the parameter was successfully returned.
    */
    getParameterAtLength(fromParameter: number, length: number): [parameter: number]
    /**
      Get the parameter positions that correspond to a set of points on the curve.
      For reliable results, the points should lie on the curve within model tolerance.
      If the points do not lie on the curve, the parameter of the nearest point on the curve will generally be returned.
      @param points An array of points to get the curve parameter values at.
      @param parameters The output array of parameter positions corresponding to the set of points.
      The length of this array will be equal to the length of the points array specified.
      @returns Returns true if the parameters were successfully returned.
    */
    getParametersAtPoints(points: Point3D[]): [parameters: number[]]
    /**
      Get the parameter position that correspond to a point on the curve.
      For reliable results, the point should lie on the curve within model tolerance.
      If the point does not lie on the curve, the parameter of the nearest point on the curve will generally be returned.
      @param point The point to get the curve parameter value at.
      @param parameter The output parameter position corresponding to the point.
      @returns Returns true of the parameter was successfully returned.
    */
    getParameterAtPoint(point: Point3D): [parameter: number]
    /**
      Get the parametric range of the curve.
      @param startParameter The output lower bound of the parameter range.
      @param endParameter The output upper bound of the parameter range.
      @returns Returns true if the curve is bounded and the parameter extents were successfully returned.
    */
    getParameterExtents(): [startParameter: number, endParameter: number]
    /**
      Get the points on the curve that correspond to evaluating a set of parameter positions on the curve.
      @param parameters The array of parameter positions to evaluate the curve position at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param points The output array of curve positions corresponding to evaluating the curve at that parameter position.
      The length of this array will be equal to the length of the parameters array specified.
      @returns Returns true if the points were successfully returned.
    */
    getPointsAtParameters(parameters: number[]): [points: Point3D[]]
    /**
      Get the point on the curve that corresponds to evaluating a parameter position on the curve.
      @param parameter The parameter position to evaluate the curve position at.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param point The output curve position corresponding to evaluating the curve at that parameter position.
      @returns Returns true if the point was successfully returned.
    */
    getPointAtParameter(parameter: number): [point: Point3D]
    /**
      Get the first derivatives of the curve at the specified parameter positions.
      @param parameters The array of parameter positions to get the curve first derivative at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param firstDerivatives The output array of first derivative vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @returns Returns true if the first derivatives were successfully returned.
    */
    getFirstDerivatives(parameters: number[]): [firstDerivatives: Vector3D[]]
    /**
      Get the first derivative of the curve at the specified parameter position.
      @param parameter The parameter position to get the curve first derivative at.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param firstDerivative The output first derivative vector at the parameter position specified.
      @returns Returns true if the first derivative was successfully returned.
    */
    getFirstDerivative(parameter: number): [firstDerivative: Vector3D]
    /**
      Get the second derivatives of the curve at the specified parameter positions.
      @param parameters The array of parameter positions to get the curve second derivative at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param secondDerivatives The output array of second derivative vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @returns Returns true if the second derivatives were successfully returned.
    */
    getSecondDerivatives(parameters: number[]): [secondDerivatives: Vector3D[]]
    /**
      Get the second derivative of the curve at the specified parameter position.
      @param parameter The parameter position to get the curve second derivative at.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param secondDerivative The output second derivative vector at the parameter position specified.
      @returns Returns true if the second derivative was successfully returned.
    */
    getSecondDerivative(parameter: number): [secondDerivative: Vector3D]
    /**
      Get the third derivatives of the curve at the specified parameter positions.
      @param parameters The array of parameter positions to get the curve third derivative at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param thirdDerivatives The output array of third derivative vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @returns Returns true if the third derivatives were successfully returned.
    */
    getThirdDerivatives(parameters: number[]): [thirdDerivatives: Vector3D[]]
    /**
      Get the third derivative of the curve at the specified parameter position.
      @param parameter The parameter position to get the curve third derivative at.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param thirdDerivative The output third derivative vector at the parameter position specified.
      @returns Returns true if the third derivative was successfully returned.
    */
    getThirdDerivative(parameter: number): [thirdDerivative: Vector3D]
    /**
      Get a sequence of points between two curve parameter positions.
      The points will be a linear interpolation along the curve between these two
      parameter positions where the maximum deviation between the curve and each line
      segment will not exceed the specified tolerance value.
      @param fromParameter The starting parameter position to interpolate points from.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param toParameter The ending parameter position to interpolate points to.
      The parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param tolerance The maximum distance tolerance between the curve and the linear interpolation.
      @param vertexCoordinates The output array of linear interpolation points.
      @returns Returns true if the interpolation points were successfully returned.
    */
    getStrokes(fromParameter: number, toParameter: number, tolerance: number): [vertexCoordinates: Point3D[]]
    /**
      Get the tangent to the curve at a number of parameter positions on the curve.
      @param parameters The array of parameter positions to return the tangent at.
      Each parameter value must be within the range of the parameter extents as provided by getParameterExtents.
      @param tangents The output array of tangent vectors for each position on the curve.
      The length of this array will be the same as the length of the parameters array provided.
      @returns Returns true if the tangents were successfully returned.
    */
    getTangents(parameters: number[]): [tangents: Vector3D[]]
    /**
      Get the tangent to the curve at a parameter position on the curve.
      @param parameter The parameter position to return the tangent at.
      This value must be within the range of the parameter extents as provided by getParameterExtents.
      @param tangent The output tangent vector at the curve position.
      @returns Returns true if the tangent was successfully returned.
    */
    getTangent(parameter: number): [tangent: Vector3D]
  }

  /**
    Describes a two-dimensional topological, manifold in three-dimensional space.
    It is used as the underlying geometry for a BRepFace.
  */
  abstract class Surface extends Base {
    /**
      Returns the surface type.
    */
    readonly surfaceType: SurfaceTypes
    /**
      Returns the surface evaluator.
    */
    readonly evaluator: SurfaceEvaluator
    /**
      Updates this surface by transforming it with a given input matrix.
      @param matrix A 3D matrix that defines the transform to apply to the surface.
      @returns Returns true if the transform was successful.
    */
    transformBy(matrix: Matrix3D): boolean
  }

  /**
    The different types of surfaces.
  */
  const enum SurfaceTypes {
    /**
      A planar surface.
    */
    PlaneSurfaceType,
    /**
      A cylindrical surface.
    */
    CylinderSurfaceType,
    /**
      A cone surface.
    */
    ConeSurfaceType,
    /**
      A spherical surface.
    */
    SphereSurfaceType,
    /**
      A torus surface.
    */
    TorusSurfaceType,
    /**
      An elliptical cylinder surface.
    */
    EllipticalCylinderSurfaceType,
    /**
      An elliptical cone surface.
    */
    EllipticalConeSurfaceType,
    /**
      A NURBS surface.
    */
    NurbsSurfaceType,
  }

  /**
    Transient plane. A transient plane is not displayed or saved in a document.
    Transient planes are used as a wrapper to work with raw plane information.
    A transient plane has no boundaries or size, but is infinite and is represented
    by a position, a normal, and an orientation in space.
    They are created statically using the create method of the Plane class.
  */
  abstract class Plane extends Surface {
    /**
      Creates a transient plane object by specifying an origin and a normal direction.
      @param origin The origin point of the plane.
      @param normal The normal direction of the plane.
      @returns Returns the new plane object or null if the creation failed.
    */
    static create(origin: Point3D, normal: Vector3D): Plane | null
    /**
      Creates a transient plane object by specifying an origin along with U and V directions.
      @param origin The origin point of the plane.
      @param uDirection The U direction for the plane.
      @param vDirection The V direction for the plane.
      @returns Returns the new plane object or null if the creation failed.
    */
    static createUsingDirections(origin: Point3D, uDirection: Vector3D, vDirection: Vector3D): Plane | null
    /**
      Gets and sets the origin point of the plane.
    */
    origin: Point3D
    /**
      Gets and sets the normal of the plane.
    */
    normal: Vector3D
    /**
      Gets the U Direction of the plane.
    */
    readonly uDirection: Vector3D
    /**
      Gets the V Direction of the plane.
    */
    readonly vDirection: Vector3D
    /**
      Sets the U and V directions of the plane.
      @param uDirection The U direction for the plane.
      @param vDirection The V direction for the plane.
      @returns Returns true if successful.
    */
    setUVDirections(uDirection: Vector3D, vDirection: Vector3D): boolean
    /**
      Checks if this plane is parallel to another plane.
      @param plane The plane to compare with for parallelism.
      @returns Returns true if the planes are parallel.
    */
    isParallelToPlane(plane: Plane): boolean
    /**
      Checks if this plane is parallel to a line.
      @param line The line to compare with for parallelism.
      @returns Returns true if the plane and line are parallel.
    */
    isParallelToLine(line: Line3D): boolean
    /**
      Checks if this plane is perpendicular to another plane.
      @param plane The plane to compare with for perpendicularity.
      @returns Returns true if the planes are perpendicular.
    */
    isPerpendicularToPlane(plane: Plane): boolean
    /**
      Checks if this plane is perpendicular to a line.
      @param line The line to compare with for perpendicularity.
      @returns Returns true if the plane and line are perpendicular.
    */
    isPerpendicularToLine(line: Line3D): boolean
    /**
      Checks if this plane is coplanar with another plane.
      @param plane The plane to compare with for co-planarity.
      @returns Returns true if the planes are coplanar.
    */
    isCoPlanarTo(plane: Plane): boolean
    /**
      Creates an infinite line at the intersection of this plane with another plane.
      @param plane The plane to intersect with.
      @returns Returns an InfiniteLine3D object or null if the planes do not intersect (are parallel).
    */
    intersectWithPlane(plane: Plane): InfiniteLine3D | null
    /**
      Creates a 3D point at the intersection of this plane and a line.
      @param line The line to intersect with.
      @returns Returns a Point3D object or null if the plane and line do not intersect (are parallel).
    */
    intersectWithLine(line: InfiniteLine3D): Point3D | null
    /**
      Intersect this plane with a curve to get the intersection point(s).
      @param curve The intersecting curve.
      The curve can be a Line3D, InfininteLine3D, Circle3D, Arc3D, EllipticalArc3D, Ellipse3D,
      or NurbsCurve3D.
      @returns Returns a collection of the intersection points.
    */
    intersectWithCurve(curve: Curve3D): ObjectCollection
    /**
      Intersect this plane with a surface to get the intersection point(s).
      @param surface The intersecting surface.
      The surface can be a Plane, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Sphere,
      Torus, or a NurbsSurface.
      @returns Returns a collection of the intersection points.
    */
    intersectWithSurface(surface: Surface): ObjectCollection
    /**
      Creates and returns an independent copy of this Plane object.
      @returns Returns a new Plane object that is a copy of this Plane object.
    */
    copy(): Plane
  }

  /**
    Transient sphere. A transient sphere is not displayed or saved in a document.
    Transient spheres are used as a wrapper to work with raw sphere information.
    A transient sphere is a full sphere defined by a point and a radius.
    They are created statically using the create method of the Sphere class.
  */
  abstract class Sphere extends Surface {
    /**
      Creates a transient sphere object.
      @param origin The origin point (center) of the sphere.
      @param radius The radius of the sphere.
      @returns Returns the new Sphere object or null if the creation failed.
    */
    static create(origin: Point3D, radius: number): Sphere | null
    /**
      Gets and sets the origin point (center) of the sphere.
    */
    origin: Point3D
    /**
      Gets and sets the radius of the sphere.
    */
    radius: number
    /**
      Gets all of the data defining the sphere.
      @param origin The output origin point (center) of the sphere.
      @param radius The output radius of the sphere.
      @returns Returns true if successful.
    */
    getData(): [origin: Point3D, radius: number]
    /**
      Sets all of the data defining the sphere.
      @param origin The origin point (center) of the sphere.
      @param radius The radius of the sphere.
      @returns Returns true if successful.
    */
    set(origin: Point3D, radius: number): boolean
    /**
      Creates and returns an independent copy of this Sphere object.
      @returns Returns a new Sphere object that is a copy of this Sphere object.
    */
    copy(): Sphere
  }

  /**
    Transient torus. A transient torus is not displayed or saved in a document.
    A transient torus is used as a wrapper to work with raw torus information.
    A transient torus is a full torus with no boundaries.
    They are created statically using the create method of the Torus class.
  */
  abstract class Torus extends Surface {
    /**
      Creates a transient torus object.
      @param origin The origin point (center) of the torus.
      @param axis The center axis of the torus.
      @param majorRadius The major radius of the torus.
      @param minorRadius The minor radius of the torus.
      @returns Returns the new Torus object or null if the creation failed.
    */
    static create(origin: Point3D, axis: Vector3D, majorRadius: number, minorRadius: number): Torus | null
    /**
      Gets and sets the origin point (center) of the torus.
    */
    origin: Point3D
    /**
      Gets and sets the center axis of the torus.
    */
    axis: Vector3D
    /**
      Gets and sets the major radius of the torus.
    */
    majorRadius: number
    /**
      Gets and sets the minor radius of the torus.
    */
    minorRadius: number
    /**
      Gets all of the data defining the torus.
      @param origin The output origin point (center) of the torus.
      @param axis The output center axis of the torus.
      @param majorRadius The output major radius of the torus.
      @param minorRadius The output minor radius of the torus.
      @returns Returns true if successful.
    */
    getData(): [origin: Point3D, axis: Vector3D, majorRadius: number, minorRadius: number]
    /**
      Sets all of the data defining the torus.
      @param origin The origin point (center) of the torus.
      @param axis The center axis of the torus.
      @param majorRadius The major radius of the torus.
      @param minorRadius The minor radius of the torus.
      @returns Returns true if successful.
    */
    set(origin: Point3D, axis: Vector3D, majorRadius: number, minorRadius: number): boolean
    /**
      Creates and returns an independent copy of this Torus object.
      @returns Returns a new Torus object that is a copy of this Torus object.
    */
    copy(): Torus
  }

  /**
    Transient cylinder. A transient cylinder is not displayed or saved in a document.
    A transient cylinder is but is used as a wrapper to work with raw cylinder information.
    A transient cylinder has no boundaries and is infinite in length.
    They are created statically using the create method of the Cylinder class.
  */
  abstract class Cylinder extends Surface {
    /**
      Creates a transient cylinder object.
      @param origin The origin point (center) of the base of the cylinder.
      @param axis The center axis (along the length) of the cylinder that defines its normal direction.
      @param radius The radius of the cylinder.
      @returns Returns the new Cylinder object or null if the creation failed.
    */
    static create(origin: Point3D, axis: Vector3D, radius: number): Cylinder | null
    /**
      The origin point (center) of the base of the cylinder.
    */
    origin: Point3D
    /**
      The center axis (along the length) of the cylinder that defines its normal direction.
    */
    axis: Vector3D
    /**
      The radius of the cylinder.
    */
    radius: number
    /**
      Gets the data that defines the cylinder.
      @param origin The output origin point (center) of the base of the cylinder.
      @param axis The output center axis (along the length) of the cylinder that defines its normal direction.
      @param radius The output radius of the cylinder.
      @returns Returns true if successful.
    */
    getData(): [origin: Point3D, axis: Vector3D, radius: number]
    /**
      Sets the data that defines the cylinder.
      @param origin The origin point (center) of the base of the cylinder.
      @param axis The center axis (along the length) of the cylinder that defines its normal direction.
      @param radius The radius of the cylinder.
      @returns Returns true if successful.
    */
    set(origin: Point3D, axis: Vector3D, radius: number): boolean
    /**
      Creates and returns an independent copy of this Cylinder object.
      @returns Returns a new Cylinder object that is a copy of this Cylinder object.
    */
    copy(): Cylinder
  }

  /**
    Transient cone. A transient cone is not displayed or saved in a document.
    A transient cone is used as a wrapper to work with raw cone information.
    A transient cone has no boundaries.
    The cone always goes to a point in its narrowing direction, and is infinite in its
    widening direction.
    They are created statically using the create method of the Cone class.
  */
  abstract class Cone extends Surface {
    /**
      Creates a transient cone object.
      @param origin The origin point (center) of the base of the cone.
      @param axis The center axis (along the length) of the cone that defines its normal direction.
      @param radius The radius of the cone.
      @param halfAngle The taper half-angle of the cone.
      @returns Returns the new Cone object or null if the creation failed.
    */
    static create(origin: Point3D, axis: Vector3D, radius: number, halfAngle: number): Cone | null
    /**
      Gets and sets the origin point (center) of the base of the cone.
    */
    origin: Point3D
    /**
      Gets and sets the center axis (along the length) of the cone that defines its
      normal direction.
    */
    axis: Vector3D
    /**
      Gets and sets the radius of the cone.
    */
    radius: number
    /**
      Gets and sets the taper half-angle of the cone in radians.
      A negative value indicates that the cone is narrowing in the direction of the
      axis vector, whereas a positive value indicates that it is expanding in the direction of
      the axis vector.
    */
    halfAngle: number
    /**
      Gets the data that defines the cone.
      @param origin The output origin point (center) of the base of the cone.
      @param axis The output center axis (along the length) of the cone that defines its normal direction.
      @param radius The output radius of the cone.
      @param halfAngle The output taper half-angle of the cone.
      @returns Returns true if successful.
    */
    getData(): [origin: Point3D, axis: Vector3D, radius: number, halfAngle: number]
    /**
      Sets the data that defines the cone.
      @param origin The origin point (center) of the base of the cone.
      @param axis The center axis (along the length) of the cone that defines its normal direction.
      @param radius The radius of the cone.
      @param halfAngle The taper half-angle of the cone.
      @returns Returns true if successful.
    */
    set(origin: Point3D, axis: Vector3D, radius: number, halfAngle: number): boolean
    /**
      Creates and returns an independent copy of this Cone object.
      @returns Returns a new Cone object that is a copy of this Cone object.
    */
    copy(): Cone
  }

  /**
    Transient elliptical cone. A transient elliptical cone is not displayed or saved in a document.
    A transient elliptical cone is used as a wrapper to work with raw elliptical cone information.
    A transient elliptical cone has no boundaries.
    The cone always goes to a point in its narrowing direction, and is infinite in its
    widening direction.
    They are created statically using the create method of the EllipticalCone class.
  */
  abstract class EllipticalCone extends Surface {
    /**
      Creates a transient elliptical cone object.
      @param origin The origin point (center) of the base of the cone.
      @param axis The center axis (along the length) of the cone that defines its normal direction.
      @param majorAxisDirection The direction of the major axis of the ellipse that defines the cone.
      @param majorRadius The major radius of the ellipse that defines the cone.
      @param minorRadius The minor radius of the ellipse that defines the cone.
      @param halfAngle The taper half-angle of the cone.
      @returns Returns the new EllipticalCone object or null if the creation failed.
    */
    static create(origin: Point3D, axis: Vector3D, majorAxisDirection: Vector3D, majorRadius: number, minorRadius: number, halfAngle: number): EllipticalCone | null
    /**
      Gets and sets the origin point (center) of the base of the cone.
    */
    origin: Point3D
    /**
      Gets the center axis of the cone that defines its normal direction and the major axis
      direction of the ellipse that defines it.
      @param axis The output center axis (along the length) of the cone that defines its normal direction.
      @param majorAxisDirection The output direction of the major axis of the ellipse that defines the cone.
    */
    getAxes(): [axis: Vector3D, majorAxisDirection: Vector3D]
    /**
      Sets the center axis of the cone and the major axis direction of the ellipse that defines it.
      @param axis The center axis (along the length) of the cone that defines its normal direction.
      @param majorAxisDirection The direction of the major axis of the ellipse that defines the cone.
      @returns Returns true if successful.
    */
    setAxes(axis: Vector3D, majorAxisDirection: Vector3D): boolean
    /**
      Gets and sets the major radius of the ellipse that defines the cone.
    */
    majorRadius: number
    /**
      Gets and sets the minor radius of the ellipse that defines the cone.
    */
    minorRadius: number
    /**
      Gets and sets the taper half-angle of the elliptical cone.
      A negative value indicates that the cone is narrowing in the direction of the axis vector,
      whereas a positive values indicates that it is expanding in the direction of the axis vector.
    */
    halfAngle: number
    /**
      Gets the data that defines the Elliptical Cone.
      @param origin The output origin point (center) of the base of the cone.
      @param axis The output center axis (along the length) of the cone that defines its normal direction.
      @param majorAxisDirection The output direction of the major axis of the ellipse that defines the cone.
      @param majorRadius The output major radius of the ellipse that defines the cone.
      @param minorRadius The output minor radius of the ellipse that defines the cone.
      @param halfAngle The output taper half-angle of the cone.
      @returns Returns true if successful.
    */
    getData(): [origin: Point3D, axis: Vector3D, majorAxisDirection: Vector3D, majorRadius: number, minorRadius: number, halfAngle: number]
    /**
      Sets the data that defines the Elliptical Cone.
      @param origin The origin point (center) of the base of the cone.
      @param axis The center axis (along the length) of the cone that defines its normal direction.
      @param majorAxisDirection The direction of the major axis of the ellipse that defines the cone.
      @param majorRadius The major radius of the ellipse that defines the cone.
      @param minorRadius The minor radius of the ellipse that defines the cone.
      @param halfAngle The taper half-angle of the cone.
      @returns Returns true if successful.
    */
    set(origin: Point3D, axis: Vector3D, majorAxisDirection: Vector3D, majorRadius: number, minorRadius: number, halfAngle: number): boolean
    /**
      Creates and returns an independent copy of this EllipticalCone object.
      @returns Returns a new EllipticalCone object that is a copy of this EllipticalCone object.
    */
    copy(): EllipticalCone
  }

  /**
    Transient elliptical cylinder. A transient elliptical cylinder is not displayed or saved
    in a document.
    A transient elliptical cylinder is used as a wrapper to work with raw elliptical cylinder
    information.
    A transient elliptical cylinder has no boundaries and is infinite in length.
    They are created statically using the create method of the EllipticalCylinder class.
  */
  abstract class EllipticalCylinder extends Surface {
    /**
      Creates a transient 3D elliptical cylinder object.
      @param origin The origin point (center) of the base of the cylinder.
      @param axis The center axis (along the length) of the cylinder that defines its normal direction.
      @param majorAxis The direction of the major axis of the ellipse that defines the cylinder.
      @param majorRadius The major radius of the ellipse that defines the cylinder.
      @param minorRadius The minor radius of the ellipse that defines the cylinder.
      @returns Returns the new EllipticalCylinder object or null if the creation failed.
    */
    static create(origin: Point3D, axis: Vector3D, majorAxis: Vector3D, majorRadius: number, minorRadius: number): EllipticalCylinder | null
    /**
      Gets and sets the origin point (center) of the base of the cylinder.
    */
    origin: Point3D
    /**
      Gets and set the center axis (along the length) of the cylinder that defines
      its normal direction.
    */
    axis: Vector3D
    /**
      Gets and sets the direction of the major axis of the ellipse that defines the cylinder.
    */
    majorAxis: Vector3D
    /**
      Gets and sets the major radius of the ellipse that defines the cylinder.
    */
    majorRadius: number
    /**
      Gets and sets the minor radius of the ellipse that defines the cylinder.
    */
    minorRadius: number
    /**
      Gets the data defining the elliptical cylinder.
      @param origin The output origin point (center) of the base of the cylinder.
      @param axis The output center axis (along the length) of the cylinder that defines its normal direction.
      @param majorAxis The output direction of the major axis of the ellipse that defines the cylinder.
      @param majorRadius The output major radius of the ellipse that defines the cylinder.
      @param minorRadius The output minor radius of the ellipse that defines the cylinder.
      @returns Returns true if successful.
    */
    getData(): [origin: Point3D, axis: Vector3D, majorAxis: Vector3D, majorRadius: number, minorRadius: number]
    /**
      Sets the data defining the elliptical cylinder.
      @param origin The origin point (center) of the base of the cylinder.
      @param axis The center axis (along the length) of the cylinder that defines its normal direction.
      @param majorAxis The direction of the major axis of the ellipse that defines the cylinder.
      @param majorRadius The major radius of the ellipse that defines the cylinder.
      @param minorRadius The minor radius of the ellipse that defines the cylinder.
      @returns Returns true if successful.
    */
    set(origin: Point3D, axis: Vector3D, majorAxis: Vector3D, majorRadius: number, minorRadius: number): boolean
    /**
      Creates and returns an independent copy of this EllipticalCylinder object.
      @returns Returns a new EllipticalCylinder object that is a copy of this EllipticalCylinder object.
    */
    copy(): EllipticalCylinder
  }

  /**
    Transient NURBS surface. A transient NURBS surface is not displayed or saved in a document.
    A transient NURBS surface is used as a wrapper to work with raw NURBS surface information.
    A transient NURBS surface is bounded by it's natural boundaries and does not support the
    definition of arbitrary boundaries.
    A NURBS surface is typically obtained from a BREPFace object, which does have boundary information.
    They are created statically using the create method of the NurbsSurface class.
  */
  abstract class NurbsSurface extends Surface {
    /**
      Creates a transient NURBS surface object.
      @param degreeU The degree in the U direction.
      @param degreeV The degree in the V direction.
      @param controlPointCountU The number of control points in the U direction.
      @param controlPointCountV The number of control points in the V direction.
      @param controlPoints An array of surface control points.
      The length of this array must be controlPointCountU * controlPointCountV.
      @param knotsU The knot vector for the U direction.
      @param knotsV The knot vector for the V direction.
      @param weights An array of weights that corresponds to the control points of the surface.
      @param propertiesU The properties (NurbsSurfaceProperties) of the surface in the U direction.
      @param propertiesV The properties (NurbsSurfaceProperties) of the surface in the V direction.
      @returns Returns the new NurbsSurface object or null if the creation failed.
    */
    static create(degreeU: number /*int*/, degreeV: number /*int*/, controlPointCountU: number /*int*/, controlPointCountV: number /*int*/, controlPoints: Point3D[], knotsU: number[], knotsV: number[], weights: number[], propertiesU: NurbsSurfaceProperties, propertiesV: NurbsSurfaceProperties): NurbsSurface | null
    /**
      Gets the number of control points in the U direction.
    */
    readonly controlPointCountU: number /*int*/
    /**
      Gets the number of control points in the V direction.
    */
    readonly controlPointCountV: number /*int*/
    /**
      Gets the degree in the U direction.
    */
    readonly degreeU: number /*int*/
    /**
      Gets the degree in the V direction.
    */
    readonly degreeV: number /*int*/
    /**
      Gets the knot count in the U direction.
    */
    readonly knotCountU: number /*int*/
    /**
      Gets thekKnot count in the V direction.
    */
    readonly knotCountV: number /*int*/
    /**
      Gets the properties (NurbsSurfaceProperties) of the surface in the U direction.
    */
    readonly propertiesU: NurbsSurfaceProperties
    /**
      Gets the properties (NurbsSurfaceProperties) of the surface in the V direction.
    */
    readonly propertiesV: NurbsSurfaceProperties
    /**
      Gets an array of control points from the surface.
    */
    readonly controlPoints: Point3D[]
    /**
      Get the knot vector from the U direction.
    */
    readonly knotsU: number[]
    /**
      Get the knot vector from the V direction
    */
    readonly knotsV: number[]
    /**
      Gets the data that defines the NURBS surface.
      @param degreeU The output degree in the U direction.
      @param degreeV The output degree in the V direction.
      @param controlPointCountU The output number of control points in the U direction.
      @param controlPointCountV The output number of control points in the V direction.
      @param controlPoints An output array of surface control points.
      @param knotsU The output knot vector for the U direction.
      @param knotsV The output knot vector for the V direction.
      @param weights An output array of weights that corresponds to the control points of the surface.
      @param propertiesU The output properties (NurbsSurfaceProperties) of the surface in the U direction.
      @param propertiesV The output properties (NurbsSurfaceProperties) of the surface in the V direction.
      @returns Returns true if successful.
    */
    getData(): [degreeU: number /*int*/, degreeV: number /*int*/, controlPointCountU: number /*int*/, controlPointCountV: number /*int*/, controlPoints: Point3D[], knotsU: number[], knotsV: number[], weights: number[], propertiesU: NurbsSurfaceProperties, propertiesV: NurbsSurfaceProperties]
    /**
      Sets the data that defines the NURBS surface.
      @param degreeU The degree in the U direction.
      @param degreeV The degree in the V direction.
      @param controlPointCountU The number of control points in the U direction.
      @param controlPointCountV The number of control points in the V direction.
      @param controlPoints An array of surface control points.
      @param knotsU The knot vector for the U direction.
      @param knotsV The knot vector for the V direction.
      @param weights An array of weights that corresponds to the control points of the surface.
      @param propertiesU The properties (NurbsSurfaceProperties) of the surface in the U direction.
      @param propertiesV The properties (NurbsSurfaceProperties) of the surface in the V direction.
      @returns Returns true if successful
    */
    set(degreeU: number /*int*/, degreeV: number /*int*/, controlPointCountU: number /*int*/, controlPointCountV: number /*int*/, controlPoints: Point3D[], knotsU: number[], knotsV: number[], weights: number[], propertiesU: NurbsSurfaceProperties, propertiesV: NurbsSurfaceProperties): boolean
    /**
      Creates and returns an independent copy of this NurbsSurface object.
      @returns Returns a new NurbsSurface object that is a copy of this NurbsSurface object.
    */
    copy(): NurbsSurface
  }

  /**
    The different surface property types.
  */
  const enum NurbsSurfaceProperties {
    /**
      Open
    */
    OpenNurbsSurface = 0x01,
    /**
      Closed
    */
    ClosedNurbsSurface = 0x02,
    /**
      Periodic
    */
    PeriodicNurbsSurface = 0x04,
    /**
      Rational
    */
    RationalNurbsSurface = 0x08,
  }

  /**
    Surface evaluator that is obtained from a transient surface and allows you to perform
    various evaluations on the surface.
  */
  abstract class SurfaceEvaluator extends Base {
    /**
      Returns if the surface is closed (forms a loop) in the U direction
    */
    readonly isClosedInU: boolean
    /**
      Returns if the surface is closed (forms a loop) in the V direction
    */
    readonly isClosedInV: boolean
    /**
      Creates the 3D equivalent curve in model space, of a 2D curve defined in the
      parametric space of the surface.
      @param parametricCurve The parameter space curve to map into this surface's parameter space.
      @returns Returns an ObjectCollection containing one or more curves.
      When the SufaceEvaluatior is obtained from a face, and the curve cuts across internal
      boundaries of the face, multiple curves are returned. The returned curves are trimmed
      to the boundaries of the face.
      If the SurfaceEvaluator is obtained from a geometry object, a single curve returned
      because there are no boundaries with which to trim the curve.
      The type of curve(s) returned depends on the shape of the input curve and surface.
    */
    getModelCurveFromParametricCurve(parametricCurve: Curve2D): ObjectCollection
    /**
      Gets (by extraction) a curve that follows a constant u or v parameter along the surface.
      The curve will have the same properties as the surface in the direction of the extraction.
      For example, when a curve is extracted from the periodic direction of a surface, the extracted
      curve will also be periodic. The type of curve returned is dependent on the shape the surface.
      Getting an iso curve is limited to a SurfaceEvaluator that is obtained from a BRepFace. It will
      fail when the SurfaceEvaluator is obtained from a geometry object (Plane, Sphere, Torus,
      Cylinder, Cone, EllipticalCone, EllipticalCylinder, or NurbsSurface).
      @param parameter The parameter at which to extract the curve
      @param isUDirection A bool that indicates whether to extract the curve from the U or V direction
      @returns Returns an ObjectCollection that contains one or more curves.
      Multiple curves are returned when the SurfaceEvaluator is obtained from a Face
      and the curve cuts across internal boundaries. The resulting curves are trimmed to the
      boundaries of the Face.
      When the SurfaceEvaluator is obtained from a geometry object, a single curve is returned
      because there are no boundaries to trim the curve.
      The type of curve(s) returned is dependent on the shape of the surface.
    */
    getIsoCurve(parameter: number, isUDirection: boolean): ObjectCollection
    /**
      Get the curvature values at a number of parameter positions on the surface.
      @param parameters The array of parameter positions to return curvature information at.
      Each parameter position must be with the range of the parameter extents as verified by isParameterOnFace.
      @param maxTangents The output array of directions of maximum curvature at each position on the surface.
      The length of this array will be the same as the length of the parameters array provided.
      @param maxCurvatures The output array of the magnitude of the maximum curvature at each position on the surface.
      The length of this array will be the same as the length of the parameters array provided.
      @param minCurvatures The output array of the magnitude of the minimum curvature at each position on the surface.
      The minimum curvature direction is perpendicular to the maximum curvature tangent directions.
      The length of this array will be the same as the length of the parameters array provided.
      @returns Returns true if the curvatures were successfully returned.
    */
    getCurvatures(parameters: Point2D[]): [maxTangents: Vector3D[], maxCurvatures: number[], minCurvatures: number[]]
    /**
      Get the curvature values at a parameter positions on the surface.
      @param parameter The parameter positions to return curvature information at.
      @param maxTangent The output directions of maximum curvature at the position on the surface.
      @param maxCurvature The output magnitude of the maximum curvature at the position on the surface.
      @param minCurvature The output magnitude of the minimum curvature at the position on the surface.
      The minimum curvature direction is perpendicular to the maximum curvature tangent directions.
      @returns Returns true if the curvature was successfully returned.
    */
    getCurvature(parameter: Point2D): [maxTangent: Vector3D, maxCurvature: number, minCurvature: number]
    /**
      Gets the surface normal at a number of parameter positions on the surface.
      @param parameters The array of parameter positions to return the normal at.
      Each parameter position must be with the range of the parameter extents as verified by isParameterOnFace.
      @param normals The output array of normals for each parameter position on the surface.
      The length of this array will be the same as the length of the parameters array provided.
      @returns Returns true if the normals were successfully returned.
    */
    getNormalsAtParameters(parameters: Point2D[]): [normals: Vector3D[]]
    /**
      Gets the surface normal at a parameter position on the surface.
      @param parameter The parameter position to return the normal at.
      The parameter position must be with the range of the parameter extents as verified by isParameterOnFace.
      @param normal The output normal for the parameter position on the surface.
      @returns Returns true if the normal was successfully returned.
    */
    getNormalAtParameter(parameter: Point2D): [normal: Vector3D]
    /**
      Gets the surface normal at a number of positions on the surface.
      @param points The array of points to return the normal at.
      For reliable results each point should lie on the surface.
      @param normals The output array of normals for each point on the surface.
      The length of this array will be the same as the length of the points array provided.
      @returns Returns true if the normals were successfully returned.
    */
    getNormalsAtPoints(points: Point3D[]): [normals: Vector3D[]]
    /**
      Gets the surface normal at a point on the surface.
      @param point The point to return the normal at.
      For reliable results the point should lie on the surface.
      @param normal The output normal for the point on the surface.
      @returns Returns true if the normal was successfully returned.
    */
    getNormalAtPoint(point: Point3D): [normal: Vector3D]
    /**
      Get the parameter positions that correspond to a set of points on the surface.
      For reliable results, the points should lie on the surface within model tolerance.
      If the points do not lie on the surface, the parameter of the nearest point on the surface will generally be returned.
      @param points An array of points to get the surface parameter values at.
      @param parameters The output array of parameter positions corresponding to the set of points.
      The length of this array will be equal to the length of the points array specified.
      @returns Returns true if the parameters were successfully returned.
    */
    getParametersAtPoints(points: Point3D[]): [parameters: Point2D[]]
    /**
      Get the parameter position that correspond to a point on the surface.
      For reliable results, the point should lie on the surface within model tolerance.
      If the point does not lie on the surface, the parameter of the nearest point on the surface will generally be returned.
      @param point The point to get the curve parameter value at.
      @param parameter The output parameter position corresponding to the point.
      @returns Returns true of the parameter was successfully returned.
    */
    getParameterAtPoint(point: Point3D): [parameter: Point2D]
    /**
      Get the points on the surface that correspond to evaluating a set of parameter positions on the surface.
      @param parameters The array of parameter positions to evaluate the surface position at.
      Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace.
      @param points The output array of points corresponding to evaluating the curve at that parameter position.
      The length of this array will be equal to the length of the parameters array specified.
      @returns Returns true if the points were successfully returned.
    */
    getPointsAtParameters(parameters: Point2D[]): [points: Point3D[]]
    /**
      Get the point on the surface that correspond to evaluating a parameter position on the surface.
      @param parameter The parameter positions to evaluate the surface position at.
      The parameter position must be within the range of the parameter extents as verified by isParameterOnFace.
      @param point The output point corresponding to evaluating the curve at that parameter position.
      @returns Returns true if the point was successfully returned.
    */
    getPointAtParameter(parameter: Point2D): [point: Point3D]
    /**
      Gets details about anomalies in parameter space of the surface.
      This includes information about periodic intervals, singularities, or unbounded parameter ranges.
      @param periodicityU The output array with information about the period of the surface in U.
      periodicityU[0] will contain the period of the surface in U.
      If periodicityU[0] is 0, the surface is not periodic in U.
      If the surface is periodic in U, peridocityU[1] will contain the parameter value at the start of the principle period.
      @param periodicityV The output array with information about the period of the surface in V.
      periodicityV[0] will contain the period of the surface in V.
      If periodicityV[0] is 0, the surface is not periodic in V.
      If the surface is periodic in V, peridocityV[1] will contain the parameter value at the start of the principle period.
      @param singularitiesU The output array parameter values of singularities in U.
      If this array is empty, there are no singularities in U.
      @param singularitiesV The output array parameter values of singularities in V.
      If this array is empty, there are no singularities in V.
      @param unboundedParameters The output array that indicates if the parameter range is unbounded in U or V.
      unboundedParameters[0] will be true if U is unbounded.
      unboundedParameters[1] will be true if V is unbounded.
      @returns Returns true if the parameter anomalies were successfully returned.
    */
    getParamAnomaly(): [periodicityU: number[], periodicityV: number[], singularitiesU: number[], singularitiesV: number[], unboundedParameters: boolean[]]
    /**
      Get the first derivatives of the surface at the specified parameter positions.
      @param parameters The array of parameter positions to get the surface first derivative at.
      Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace.
      @param partialsU The output array of first derivative U partial vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @param partialsV The output array of first derivative V partial vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @returns Returns true if the first derivatives were successfully returned.
    */
    getFirstDerivatives(parameters: Point2D[]): [partialsU: Vector3D[], partialsV: Vector3D[]]
    /**
      Get the first derivative of the surface at the specified parameter position.
      @param parameter The parameter positions to get the surface first derivative at.
      The parameter position must be within the range of the parameter extents as verified by isParameterOnFace.
      @param partialU The output first derivative U partial vector at the parameter position specified.
      @param partialV The output first derivative V partial vector at the parameter position specified.
      @returns Returns true if the first derivative was successfully returned.
    */
    getFirstDerivative(parameter: Point2D): [partialU: Vector3D, partialV: Vector3D]
    /**
      Get the second derivatives of the surface at the specified parameter positions.
      @param parameters The array of parameter positions to get the surface second derivative at.
      Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace.
      @param partialsUU The output array of second derivative UU partial vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @param partialsUV The output array of second derivative UV mixed partial vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @param partialsVV The output array of second derivative VV partial vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @returns Returns true if the second derivatives were successfully returned.
    */
    getSecondDerivatives(parameters: Point2D[]): [partialsUU: Vector3D[], partialsUV: Vector3D[], partialsVV: Vector3D[]]
    /**
      Get the second derivative of the surface at the specified parameter position.
      @param parameter The parameter position to get the surface second derivative at.
      The parameter position must be within the range of the parameter extents as verified by isParameterOnFace.
      @param partialUU The output second derivative UU partial vector at each parameter position specified.
      @param partialUV The output second derivative UV mixed partial vector at each parameter position specified.
      @param partialVV The output second derivative VV partial vector at each parameter position specified.
      @returns Returns true if the second derivative was successfully returned.
    */
    getSecondDerivative(parameter: Point2D): [partialUU: Vector3D, partialUV: Vector3D, partialVV: Vector3D]
    /**
      Get the third derivatives of the surface at the specified parameter positions.
      @param parameters The array of parameter positions to get the surface third derivative at.
      Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace.
      @param partialsUUU The output array of third derivative UUU partial vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @param partialsVVV The output array of third derivative VVV partial vectors at each parameter position specified.
      The length of this array is equal to the length of the parameters array specified.
      @returns Returns true if the third derivatives were successfully returned.
    */
    getThirdDerivatives(parameters: Point2D[]): [partialsUUU: Vector3D[], partialsVVV: Vector3D[]]
    /**
      Get the third derivative of the surface at the specified parameter position.
      @param parameter The parameter position to get the surface third derivative at.
      The parameter position must be within the range of the parameter extents as verified by isParameterOnFace.
      @param partialUUU The output third derivative UUU partial vector at each parameter position specified.
      @param partialVVV The output third derivative VVV partial vector at each parameter position specified.
      @returns Returns true if the third derivative was successfully returned.
    */
    getThirdDerivative(parameter: Point2D): [partialUUU: Vector3D, partialVVV: Vector3D]
    /**
      Determines if the specified parameter position lies within the surface. When the SurfaceEvaluator
      is obtained from a BRepFace object, this will respect the boundaries of the face and return true
      when point is on the visible portion of the surface. When obtained from surface geometry it returns
      true if the point is within the parametric range of surface.
      @param parameter The parameter position to test.
      @returns Returns true if the parameter position lies within the surface.
    */
    isParameterOnFace(parameter: Point2D): boolean
    /**
      Returns the parametric range of the surface.
      If the surface is periodic in a direction, the range is set to the principle period's range.
      If the surface is only upper bounded in a direction, the lower bound is set to -double-max.
      If the surface is only lower bounded in a direction, the upper bound is set to double-max.
      If the surface is unbounded in a direction, the lower bound and upper bound of the range will both be zero.
      @returns Returns the bounding box with the parameter extents, with the X value being the U range, and the Y value being the V range.
    */
    parametricRange(): BoundingBox2D
    /**
      Returns the area of the surface. This is typically used when the SurfaceEvaluator is associated
      with a BRepFace object where it is always valid. This can fail in the case where the SurfaceEvaluator is
      associated with one of the geometry classes, (Plane, Cylinder, Cone, EllipticalCone, or EllipticalCylinder
      object), because these surfaces are unbounded. A BRepFace, even one of these shapes, is bounded by its
      edges and has a well-defined area.
    */
    readonly area: number
  }

  /**
    Transient 2D vector. This object is a wrapper for 2D vector data and is used to
    pass vector data in and out of the API.
    They are created statically using the create method of the Vector2D class.
  */
  abstract class Vector2D extends Base {
    /**
      Creates a 2D vector object.
      @param x The x coordinate of the vector.
      @param y The y coordinate of the vector.
      @returns Returns the new Vector2D object or null if the creation failed.
    */
    static create(x?: number/* = 0.0*/, y?: number/* = 0.0*/): Vector2D | null
    /**
      Add a vector to this vector.
      @param vector The vector to add to this vector.
      @returns Returns true if successful.
    */
    add(vector: Vector2D): boolean
    /**
      Gets the angle between this vector and another vector.
      @param vector The vector to measure the angle to.
      @returns Returns the angle in radians.
    */
    angleTo(vector: Vector2D): number
    /**
      Creates and returns an independent copy of this Vector2D object.
      @returns Returns a new Vector2D object that is a copy of this Vector2D object.
    */
    copy(): Vector2D
    /**
      Calculates the Dot Product of this vector and an input vector.
      @param vector The vector to use in the dot product calculation.
      @returns Returns the dot product of the two vectors.
    */
    dotProduct(vector: Vector2D): number
    /**
      Returns the vector values as an array [x, y].
      @returns Returns an array of the vector's values [x, y].
    */
    asArray(): number[]
    /**
      Compare this vector with another to check for equality.
      @param vector The vector to compare with for equality.
      @returns Returns true if the vectors are equal.
    */
    isEqualTo(vector: Vector2D): boolean
    /**
      Compare this vector with another to check for parallelism.
      @param vector The vector to compare with for parallelism.
      @returns Returns true if the vectors are parallel.
    */
    isParallelTo(vector: Vector2D): boolean
    /**
      Compare this vector with another to check for perpendicularity.
      @param vector The vector to compare with for perpendicularity.
      @returns Returns true if the vectors are perpendicular.
    */
    isPerpendicularTo(vector: Vector2D): boolean
    /**
      Gets the length of the vector.
    */
    readonly length: number
    /**
      Normalizes the vector.
      Normalization makes the vector length equal to one.
      The vector should not be zero length.
      @returns Returns true if successful.
    */
    normalize(): boolean
    /**
      Sets the definition of the vector by specifying an array containing the x and y coordinates.
      @param coordinates An array that specifies the values for the x and y coordinates of the vector.
      @returns Returns true if successful
    */
    setWithArray(coordinates: number[]): boolean
    /**
      Scales the vector by specifying a scaling factor.
      @param scale The scale factor to multiple the vector by (i.e. 1.5).
      @returns Returns true if successful.
    */
    scaleBy(scale: number): boolean
    /**
      Subtract a vector from this vector.
      @param vector The vector to subtract from this vector.
      @returns Returns true if successful.
    */
    subtract(vector: Vector2D): boolean
    /**
      Transforms the vector by specifying a 2D transformation matrix.
      @param matrix The Matrix2D object that defines the transformation.
      @returns Returns true if successful.
    */
    transformBy(matrix: Matrix2D): boolean
    /**
      Return a point with the same x and y values as this vector.
      @returns Returns the new point.
    */
    asPoint(): Point2D
    /**
      Gets and sets the X coordinate of the vector.
    */
    x: number
    /**
      Gets and sets the Y coordinate of the vector.
    */
    y: number
  }

  /**
    Error values for various vector operations.
  */
  const enum VectorError {
    /**
      Zero length vector is not allowed. Various vector ops - e.g. IsParallel - don't work with zero length vectors
    */
    ZeroLengthVectorError = 100,
  }

  /**
    Transient 2D 3x3 matrix. This object is a wrapper over 2D matrix data and is used as way to pass matrix data
    in and out of the API and as a convenience when operating on matrix data.
    They are created statically using the create method of the Matrix2D class.
  */
  abstract class Matrix2D extends Base {
    /**
      Creates a transient 2D matrix (3x3) object. It is initialized as an identity matrix.
      @returns Returns the new matrix.
    */
    static create(): Matrix2D
    /**
      Resets this matrix to be an identity matrix.
      @returns Returns true if successful.
    */
    setToIdentity(): boolean
    /**
      Invert this matrix.
      @returns Returns true if successful.
    */
    invert(): boolean
    /**
      Creates an independent copy of this matrix.
      @returns Returns the new matrix copy.
    */
    copy(): Matrix2D
    /**
      Returns the determinant of the matrix.
    */
    readonly determinant: number
    /**
      Transforms this matrix using the input matrix.
      @param matrix The transformation matrix.
      @returns Returns true if successful.
    */
    transformBy(matrix: Matrix2D): boolean
    /**
      Gets the value of the specified cell in the 3x3 matrix.
      @param row The index of the row. The first row has in index of 0
      @param column The index of the column. The first column has an index of 0
      @returns Returns the value at [row][column].
    */
    getCell(row: number /*int*/, column: number /*int*/): number
    /**
      Sets the specified cell in the 3x3 matrix to the specified value.
      @param row The index of the row. The first row has in index of 0
      @param column The index of the column. The first column has an index of 0
      @param value The new value of the cell.
      @returns Returns true if successful.
    */
    setCell(row: number /*int*/, column: number /*int*/, value: number): boolean
    /**
      Gets the matrix data as the components that define a coordinate system.
      @param origin The output origin point of the coordinate system.
      @param xAxis The output x axis direction of the coordinate system.
      @param yAxis The output y axis direction of the coordinate system.
    */
    getAsCoordinateSystem(): [origin: Point2D, xAxis: Vector2D, yAxis: Vector2D]
    /**
      Returns the contents of the matrix as a 9 element array.
      @returns Returns the array of matrix values.
    */
    asArray(): number[]
    /**
      Reset this matrix to align with a specific coordinate system.
      @param origin The origin point of the coordinate system.
      @param xAxis The x axis direction of the coordinate system.
      @param yAxis The y axis direction of the coordinate system.
      @returns Returns true if successful.
    */
    setWithCoordinateSystem(origin: Point2D, xAxis: Vector2D, yAxis: Vector2D): boolean
    /**
      Sets the contents of the array using a 9 element array.
      @param cells The array of cell values.
      @returns Returns true if successful.
    */
    setWithArray(cells: number[]): boolean
    /**
      Compares this matrix with another matrix and returns True if they're identical.
      @param matrix The matrix to compare to.
      @returns Returns true if the matrix is equal to this matrix.
    */
    isEqualTo(matrix: Matrix2D): boolean
    /**
      Sets this matrix to be the matrix that maps from the 'from' coordinate system to the 'to' coordinate system.
      @param fromOrigin The origin point of the from coordinate system.
      @param fromXAxis The x axis direction of the from coordinate system.
      @param fromYAxis The y axis direction of the from coordinate system.
      @param toOrigin The origin point of the to coordinate system.
      @param toXAxis The x axis direction of the to coordinate system.
      @param toYAxis The y axis direction of the to coordinate system.
      @returns Returns true if successful.
    */
    setToAlignCoordinateSystems(fromOrigin: Point2D, fromXAxis: Vector2D, fromYAxis: Vector2D, toOrigin: Point2D, toXAxis: Vector2D, toYAxis: Vector2D): boolean
    /**
      Sets to the matrix of rotation that would align the 'from' vector with the 'to' vector.
      @param from The from vector.
      @param to The to vector.
      @returns Returns true if successful.
    */
    setToRotateTo(from: Vector2D, to: Vector2D): boolean
    /**
      Sets this matrix to the matrix of rotation by the specified angle, through the specified origin.
      @param angle The rotation angle in radians.
      @param origin The origin point of the rotation.
      @returns Returns true if successful.
    */
    setToRotation(angle: number, origin: Point2D): boolean
  }

  /**
    Transient object that represents a 2D bounding box. A 2D bounding box is a rectangle box that is parallel
    to the x and y axes. The box is defined by a minimum point (smallest x-y values) and maximum point (largest x-y values).
    This object is a wrapper for these points and serves as a way to pass bounding box information
    in and out of functions. It also provides some convenience function when working with the bounding box data.
    They are created statically using the create method of the BoundingBox2D class.
  */
  abstract class BoundingBox2D extends Base {
    /**
      Creates a transient bounding box object.
      @param minPoint The minimum point of the box.
      @param maxPoint The maximum point of the box.
      @returns Returns the new bounding box.
    */
    static create(minPoint: Point2D, maxPoint: Point2D): BoundingBox2D
    /**
      Gets and sets the minimum point of the box.
    */
    minPoint: Point2D
    /**
      Gets and sets the maximum point of the box.
    */
    maxPoint: Point2D
    /**
      Determines if the specified point lies within the bounding box.
      @param point The point to test containment with.
      @returns Returns true if the point lies within the bounding box.
    */
    contains(point: Point2D): boolean
    /**
      Expand this bounding box to contain the specified point.
      @param point The point to expand the box to.
      @returns Returns true if successful.
    */
    expand(point: Point2D): boolean
    /**
      Test if this bounding box intersects with the specified bounding box.
      @param boundingBox The bounding box to test intersection with.
      @returns Returns true if the bounding boxes intersect.
    */
    intersects(boundingBox: BoundingBox2D): boolean
    /**
      Create a copy of this bounding box.
      @returns Returns the new bounding box copy.
    */
    copy(): BoundingBox2D
    /**
      Combines this bounding box with the input bounding box. If the input
      bounding box extends outside this bounding box then this bounding box will
      be extended to encompass both of the original bounding boxes.
      @param boundingBox The other bounding box. It is not edited but is used to extend the boundaries
      of the bounding box the method is being called on.
      @returns Returns true if the combine was successful.
    */
    combine(boundingBox: BoundingBox2D): boolean
  }

  /**
    Transient 3D vector. This object is a wrapper over 3D vector data and is used as way to pass vector data
    in and out of the API and as a convenience when operating on vector data.
    They are created statically using the create method of the Vector3D class.
  */
  abstract class Vector3D extends Base {
    /**
      Creates a 3D vector object. This object is created statically using the Vector3D.create method.
      @param x The optional x value.
      @param y The optional y value.
      @param z The optional z value.
      @returns Returns the new vector.
    */
    static create(x?: number/* = 0.0*/, y?: number/* = 0.0*/, z?: number/* = 0.0*/): Vector3D
    /**
      Adds a vector to this vector.
      @param vector The vector to add to this vector.
      @returns Returns true if successful.
    */
    add(vector: Vector3D): boolean
    /**
      Determines the angle between this vector and the specified vector.
      @param vector The vector to measure the angle to.
      @returns The angle in radians between this vector and the specified vector.
    */
    angleTo(vector: Vector3D): number
    /**
      Returns a new point with the same coordinate values as this vector.
      @returns Return the new point.
    */
    asPoint(): Point3D
    /**
      Creates a copy of this vector.
      @returns Returns the new vector copy.
    */
    copy(): Vector3D
    /**
      Returns the cross product between this vector and the specified vector.
      @param vector The vector to take the cross product to.
      @returns Returns the vector cross product.
    */
    crossProduct(vector: Vector3D): Vector3D
    /**
      Returns the dot product between this vector and the specified vector.
      @param vector The vector to take the dot product to.
      @returns Returns the dot product value.
    */
    dotProduct(vector: Vector3D): number
    /**
      Returns the vector coordinates as an array [x, y, z].
      @returns Returns the array of vector coordinates [x, y, z].
    */
    asArray(): number[]
    /**
      Determines if this vector is equal to the specified vector.
      @param vector The vector to test equality to.
      @returns Returns true if the vectors are equal.
    */
    isEqualTo(vector: Vector3D): boolean
    /**
      Determines if the input vector is parallel with this vector.
      @param vector The vector to test parallelism to.
      @returns Returns true if the vectors are parallel.
    */
    isParallelTo(vector: Vector3D): boolean
    /**
      Determines if the input vector is perpendicular to this vector.
      @param vector The vector to test perpendicularity to.
      @returns Returns true if the vectors are perpendicular.
    */
    isPerpendicularTo(vector: Vector3D): boolean
    /**
      Get the length of this vector.
    */
    readonly length: number
    /**
      Makes this vector of unit length.
      This vector should not be zero length.
      @returns Returns true if successful.
    */
    normalize(): boolean
    /**
      Reset this vector with the coordinate values in an array [x, y, z].
      @param coordinates The array of coordinate values.
      @returns Returns true if successful.
    */
    setWithArray(coordinates: number[]): boolean
    /**
      Scale this vector by the specified product.
      @param scale The scale value.
      @returns Returns true if successful.
    */
    scaleBy(scale: number): boolean
    /**
      Subtract a vector from this vector.
      @param vector The vector to subtract.
      @returns Returns true if successful.
    */
    subtract(vector: Vector3D): boolean
    /**
      Transform this vector by the specified matrix.
      @param matrix The transformation matrix.
      @returns Returns true if successful.
    */
    transformBy(matrix: Matrix3D): boolean
    /**
      The x value.
    */
    x: number
    /**
      The y value.
    */
    y: number
    /**
      The z value.
    */
    z: number
  }

  /**
    Transient 3D 4x4 matrix. This object is a wrapper over 3D matrix data and is used as way to pass matrix data
    in and out of the API and as a convenience when operating on matrix data.
    They are created statically using the create method of the Matrix3D class.
  */
  abstract class Matrix3D extends Base {
    /**
      Creates a transient 3d matrix object. It is initialized as an identity matrix and
      is created statically using the Matrix3D.create method.
      @returns Returns the new matrix.
    */
    static create(): Matrix3D
    /**
      Resets this matrix to an identify matrix.
      @returns Returns true if successful.
    */
    setToIdentity(): boolean
    /**
      Inverts this matrix.
      @returns Returns true if successful.
    */
    invert(): boolean
    /**
      Creates an independent copy of this matrix.
      @returns Returns the new matrix copy.
    */
    copy(): Matrix3D
    /**
      Returns the determinant of the matrix.
    */
    readonly determinant: number
    /**
      Transforms this matrix using the input matrix.
      @param matrix The transformation matrix.
      @returns Returns true if successful.
    */
    transformBy(matrix: Matrix3D): boolean
    /**
      Gets the matrix data as the components that define a coordinate system.
      @param origin The output origin point of the coordinate system.
      @param xAxis The output x axis direction of the coordinate system.
      @param yAxis The output y axis direction of the coordinate system.
      @param zAxis The output z axis direction of the coordinate system.
    */
    getAsCoordinateSystem(): [origin: Point3D, xAxis: Vector3D, yAxis: Vector3D, zAxis: Vector3D]
    /**
      Sets the matrix based on the components of a coordinate system.
      @param origin The origin point of the coordinate system.
      @param xAxis The x axis direction of the coordinate system.
      @param yAxis The y axis direction of the coordinate system.
      @param zAxis The z axis direction of the coordinate system.
      @returns Returns true if successful.
    */
    setWithCoordinateSystem(origin: Point3D, xAxis: Vector3D, yAxis: Vector3D, zAxis: Vector3D): boolean
    /**
      Gets the value of the specified cell in the 4x4 matrix.
      @param row The index of the row. The first row has in index of 0
      @param column The index of the column. The first column has an index of 0
      @returns The cell value at [row][column].
    */
    getCell(row: number /*int*/, column: number /*int*/): number
    /**
      Sets the specified cell in the 4x4 matrix to the specified value.
      @param row The index of the row. The first row has in index of 0
      @param column The index of the column. The first column has an index of 0
      @param value The new cell value.
      @returns Returns true if successful.
    */
    setCell(row: number /*int*/, column: number /*int*/, value: number): boolean
    /**
      Returns the contents of the matrix as a 16 element array.
      @returns Returns the array of cell values.
    */
    asArray(): number[]
    /**
      Sets the contents of the array using a 16 element array.
      @param cells The array of cell values.
      @returns Returns true if successful.
    */
    setWithArray(cells: number[]): boolean
    /**
      Compares this matrix with another matrix and returns True if they're identical.
      @param matrix The matrix to compare this matrix to.
      @returns Returns true if the matrices are equal.
    */
    isEqualTo(matrix: Matrix3D): boolean
    /**
      Gets and sets the translation component of the matrix.
    */
    translation: Vector3D
    /**
      Sets this matrix to be the matrix that maps from the 'from' coordinate system to the 'to' coordinate system.
      @param fromOrigin The origin point of the from coordinate system.
      @param fromXAxis The x axis direction of the from coordinate system.
      @param fromYAxis The y axis direction of the from coordinate system.
      @param fromZAxis The z axis direction of the from coordinate system.
      @param toOrigin The origin point of the to coordinate system.
      @param toXAxis The x axis direction of the to coordinate system.
      @param toYAxis The y axis direction of the to coordinate system.
      @param toZAxis The z axis direction of the to coordinate system.
      @returns Returns true if successful.
    */
    setToAlignCoordinateSystems(fromOrigin: Point3D, fromXAxis: Vector3D, fromYAxis: Vector3D, fromZAxis: Vector3D, toOrigin: Point3D, toXAxis: Vector3D, toYAxis: Vector3D, toZAxis: Vector3D): boolean
    /**
      Sets to the matrix of rotation that would align the 'from' vector with the 'to' vector. The optional
      axis argument may be used when the two vectors are perpendicular and in opposite directions to
      specify a specific solution, but is otherwise ignored
      @param from The vector to rotate from.
      @param to The vector to rotate to.
      @param axis The optional axis vector to disambiguate the rotation axis.
      @returns Returns true if successful.
    */
    setToRotateTo(from: Vector3D, to: Vector3D, axis?: Vector3D/* = null*/): boolean
    /**
      Sets this matrix to the matrix of rotation by the specified angle, through the specified origin, around the specified axis
      @param angle The rotation angle in radians.
      @param axis The axis of rotation.
      @param origin The origin point of the axis of rotation.
      @returns Returns true if successful.
    */
    setToRotation(angle: number, axis: Vector3D, origin: Point3D): boolean
  }

  /**
    Transient object that represents a 3D bounding box.
    It defines a rectangular box whose sides are parallel to the model space x, y, and z
    planes. Because of the fixed orientation of the box it can be fully defined
    by two points at opposing corners the min and max points. This object is usually
    used to provide a rough approximation of the volume in space that an entity occupies.
    It also provides some convenience function when working with the bounding box data.
    They are created statically using the create method of the BoundingBox3D class.
  */
  abstract class BoundingBox3D extends Base {
    /**
      Creates a transient bounding box object. This object is created statically using the BoundingBox3D.create method.
      @param minPoint The point that defines the minimum corner of the bounding box.
      @param maxPoint The point that defines the maximum corner of the bounding box.
      @returns Returns the newly created bounding box or null if the creation failed.
    */
    static create(minPoint: Point3D, maxPoint: Point3D): BoundingBox3D | null
    /**
      Gets and sets the minimum point corner of the box.
    */
    minPoint: Point3D
    /**
      Gets and sets the maximum point corner of the box.
    */
    maxPoint: Point3D
    /**
      Determines if the specified point is within the bound box.
      @param point The point you want to check to see if it's in the bounding box.
      @returns Returns true if the point is within the bounding box.
    */
    contains(point: Point3D): boolean
    /**
      Expands the size of bounding box to include the specified point.
      @param point The point to include within the bounding box.
      @returns Returns true if the expansion was successful.
    */
    expand(point: Point3D): boolean
    /**
      Determines if the two bounding boxes intersect.
      @param boundingBox The other bounding box to check for intersection with.
      @returns Returns true if the two boxes intersect.
    */
    intersects(boundingBox: BoundingBox3D): boolean
    /**
      Creates an independent copy of this bounding box.
      @returns Returns the new bounding box or null if the copy failed.
    */
    copy(): BoundingBox3D | null
    /**
      Combines this bounding box with the input bounding box. If the input
      bounding box extends outside this bounding box then this bounding box will
      be extended to encompass both of the original bounding boxes.
      @param boundingBox The other bounding box. It is not edited but is used to extend the boundaries
      of the bounding box the method is being called on.
      @returns Returns true if the combine was successful.
    */
    combine(boundingBox: BoundingBox3D): boolean
  }

  /**
    Transient object that represents an oriented 3D bounding box. An oriented 3D bounding box is a rectangular box that
    can be in any orientation in model space. They are created statically using the create method of the OrientedBoundingBox3D class
    and are used by some functions to return oriented box information.
  */
  abstract class OrientedBoundingBox3D extends Base {
    /**
      Creates a transient oriented bounding box object.
      @param centerPoint The center point of the oriented box.
      @param lengthDirection A Vector3D object that defines the direction of the length of the oriented bounding box. The magnitude of
      the vector is ignored and just the direction is used.
      @param widthDirection A Vector3D object that defines the direction of the width of the oriented bounding box. The magnitude of
      the vector is ignored and just the direction is used. The width direction must be perpendicular to
      the length direction.
      @param length The length of the oriented bounding box in centimeters.
      @param width The width of the oriented bounding box in centimeters. The width of the box is always perpendicular to the length.
      @param height The height of the oriented bounding box in centimeters. The height of the box is perpendicular to the length-width plane
      using the right-hand rule where you cross the length into the width.
      @returns Returns the new oriented bounding box.
    */
    static create(centerPoint: Point3D, lengthDirection: Vector3D, widthDirection: Vector3D, length: number, width: number, height: number): OrientedBoundingBox3D
    /**
      Gets and sets the centerPoint point of the oriented box.
    */
    centerPoint: Point3D
    /**
      Sets the orientation of the oriented bounding box.
      @param lengthDirection A Vector3D object that defines the direction of the length of the oriented bounding box. The magnitude of
      the vector is ignored and just the direction is used.
      @param widthDirection A Vector3D object that defines the direction of the width of the oriented bounding box. The magnitude of
      the vector is ignored and just the direction is used. The width direction must be perpendicular to
      the length direction.
    */
    setOrientation(lengthDirection: Vector3D, widthDirection: Vector3D): boolean
    /**
      Gets the direction of the length of the oriented bounding box.
      A unit vector is always returned.
    */
    readonly lengthDirection: Vector3D
    /**
      Gets and sets the length of the oriented bounding box in centimeters.
    */
    length: number
    /**
      Gets the direction of the width of the oriented bounding box.
      A unit vector is always returned.
    */
    readonly widthDirection: Vector3D
    /**
      Gets and sets the width of the oriented bounding box in centimeters.
    */
    width: number
    /**
      Gets the direction of the height of the oriented bounding box.
      A unit vector is always returned.
    */
    readonly heightDirection: Vector3D
    /**
      Gets and sets the height of the oriented bounding box in centimeters.
    */
    height: number
    /**
      Determines if the specified point lies within the oriented bounding box.
      @param point The point to test containment with.
      @returns Returns true if the point lies within the bounding box.
    */
    contains(point: Point3D): boolean
    /**
      Create a copy of this oriented bounding box.
      @returns Returns the new oriented bounding box copy.
    */
    copy(): OrientedBoundingBox3D
  }

  /**
    The MaterialLibraries collection object provides access to
    currently loaded Material and Appearance libraries
  */
  abstract class MaterialLibraries extends Base {
    /**
      Method that returns the specified Material Library using an index into the collection.
      @param index The index of the item within the collection. The first item has an index of 0.
      @returns Returns the specified material library or null if an invalid index was specified.
    */
    item(index: number /*int*/): MaterialLibrary | null
    /**
      The number of Material Libraries in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified Material Library using the name as seen in the user interface.
      @param name The name of the library to return.
      @returns Returns the specified material library or null if there's no match on the name.
    */
    itemByName(name: string): MaterialLibrary | null
    /**
      Returns the Material Library at the specified ID.
      @param id The ID of the library to return.
      @returns Returns the specified material library or null if there's no match on the ID.
    */
    itemById(id: string): MaterialLibrary | null
    /**
      Loads the specified existing local material library. Fusion remembers which libraries have
      been loaded from one session to the next so you should check to see if the local library
      is already loaded or not before loading it again.
      @param filename The full filename of the .adsklib material file.
      @returns Returns the MaterialLibrary object representing the opened library or null in the case of failure.
    */
    load(filename: string): MaterialLibrary | null
  }

  /**
    A material library.
  */
  abstract class MaterialLibrary extends Base {
    /**
      Property that gets the name of this Library. This is the localized name
      shown in the user interface.
    */
    readonly name: string
    /**
      The unique internal ID of this Library.
    */
    readonly id: string
    /**
      Returns the appearances defined within this library.
    */
    readonly appearances: Appearances
    /**
      Returns the materials defined within this library.
    */
    readonly materials: Materials
    /**
      Gets if this is a native material library. Native libraries are
      those that are delivered with Fusion and are always available. And
      non-native libraries are user created. If This returns True then there
      are some limitations to what can be done with the library. For example,
      if this is a native material library it cannot be unloaded.
    */
    readonly isNative: boolean
    /**
      Unloads this material from Fusion. Only non-native material libraries
      can be unloaded. You can determine this by checking the isNative property.
      @returns Returns True if the library was successfully unloaded.
    */
    unload(): boolean
  }

  /**
    Collection of materials within a Library or Design.
  */
  abstract class Materials extends Base {
    /**
      Returns the specified Material using an index into the collection.
      @param index The index of the material to return where the first item in the collection is 0.
      @returns Returns the specified material or null if an invalid index is specified.
    */
    item(index: number /*int*/): Material | null
    /**
      The number of Materials in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified Material using the name as seen in the user interface. This often isn't
      a reliable way of accessing a specific material because materials are not required to be unique.
      @param name The name of the material to return,.
      @returns Returns the specified material or null if there isn't a matching name.
    */
    itemByName(name: string): Material | null
    /**
      Returns the Material by it's internal unique ID.
      @param id The ID of the material to return.
      @returns Returns the specified material or null if there isn't a matching ID.
    */
    itemById(id: string): Material | null
    /**
      Add a Material to a Design by copying an existing Material from Favorites, a Library or from the
      Materials stored in the Design. This method currently only applies to the Materials collection from a Design and
      cannot be used to copy a Material to a library.
      @param materialToCopy The Material you want to copy. The Material to copy can be from Favorites, a Library or from the
      materials stored in the Design.
      @param name The Material name to apply to the copy.
      @returns Returns the newly created Material or null if the copy operation failed.
    */
    addByCopy(materialToCopy: Material, name: string): Material | null
  }

  /**
    Collection of the favorite materials.
  */
  abstract class FavoriteMaterials extends Base {
    /**
      Returns the specified Material using an index into the collection.
      @param index The index of the material to return where the first item in the collection is 0.
      @returns Returns the specified material or null if an invalid index is specified.
    */
    item(index: number /*int*/): Material | null
    /**
      The number of Materials in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified Material using the name as seen in the user interface. This often isn't
      a reliable way of accessing a specific material because materials are not required to be unique.
      @param name The name of the material to return,.
      @returns Returns the specified material or null if there isn't a matching name.
    */
    itemByName(name: string): Material | null
    /**
      Returns the Material by it's internal unique ID.
      @param id The ID of the material to return.
      @returns Returns the specified material or null if there isn't a matching ID.
    */
    itemById(id: string): Material | null
    /**
      Adds an existing material to the Favorites list
      @param material The material to be added to the favorites list. This can come from a Library or from a Design.
      @returns Returns the Material added to the favorites list or null if the operation failed.
    */
    add(material: Material): Material | null
  }

  /**
    A material.
  */
  abstract class Material extends Base {
    /**
      Gets the Appearance of this material.
    */
    readonly appearance: Appearance
    /**
      Returns the unique internal ID of this material.
    */
    readonly id: string
    /**
      Returns true if this material is used in the Design
    */
    readonly isUsed: boolean
    /**
      Returns the collection of material properties associated with this material.
    */
    readonly materialProperties: Properties
    /**
      Returns the name of this Material. This is the name of the material as seen in the user interface.
      The name can only be edited if the material is in a Design or the favorites list.
    */
    name: string
    /**
      Returns the Parent object (a Library or a Design).
    */
    readonly parent: Base
    /**
      Deletes the material from the Design. This method only applies to materials
      in a Design that are unused
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Copies this material to the specified target.
      @remarks
      This method has been retired and replaced by the addByCopyMethod on the Materials object.
      @param target The target can be a Design or MaterialFavorites object.
      @returns Returns the new copy of the material or null if the copy failed.
      @deprecated
    */
    copyTo(target: core.Base): Material | null
    /**
      Gets and sets the description associated with this material.
      Setting the description is only valid for materials in a document or the favorites list.
    */
    description: string
  }

  /**
    A collection of appearances.
  */
  abstract class Appearances extends Base {
    /**
      Returns the specified Appearance using an index into the collection.
      @param index The index of the appearance to return where the first item in the collection is 0.
      @returns Returns the specified appearance or null if an invalid index is specified.
    */
    item(index: number /*int*/): Appearance | null
    /**
      The number of Materials in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified Appearance using the name as seen in the user interface. This often isn't
      a reliable way of accessing a specific appearance because appearances are not required to be unique.
      @param name The name of the appearance to return,.
      @returns Returns the specified appearance or null if there isn't a matching name.
    */
    itemByName(name: string): Appearance | null
    /**
      Returns the Appearance by it's internal unique ID.
      @param id The ID of the appearance to return.
      @returns Returns the specified appearance or null if there isn't a matching ID.
    */
    itemById(id: string): Appearance | null
    /**
      Add an Appearance to a Design by copying an existing Appearance from Favorites, a Library or from the
      appearances stored in the Design. This method currently only applies to the Appearances collection from a Design and
      cannot be used to copy an Appearance to a library.
      @param appearanceToCopy The Appearance you want to copy. The Appearance to copy can be from Favorites, a Library or from the
      appearances stored in the Design.
      @param name The Appearance name to apply to the copy.
      @returns Returns the newly created Appearance or null if the copy operation failed.
    */
    addByCopy(appearanceToCopy: Appearance, name: string): Appearance | null
  }

  /**
    Collection of the favorite appearances.
  */
  abstract class FavoriteAppearances extends Base {
    /**
      Returns the specified Appearance using an index into the collection.
      @param index The index of the appearance to return where the first item in the collection is 0.
      @returns Returns the specified appearance or null if an invalid index is specified.
    */
    item(index: number /*int*/): Appearance | null
    /**
      The number of Appearances in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified appearance using the name as seen in the user interface. This often isn't
      a reliable way of accessing a specific appearance because appearances are not required to be unique.
      @param name The name of the appearance to return,.
      @returns Returns the specified appearance or null if there isn't a matching name.
    */
    itemByName(name: string): Appearance | null
    /**
      Returns the Appearance by it's internal unique ID.
      @param id The ID of the appearance to return.
      @returns Returns the specified appearance or null if there isn't a matching ID.
    */
    itemById(id: string): Appearance | null
    /**
      Adds an existing appearance to the Favorites list
      @param appearance The appearance to be added to the favorites list. This can come from a Library or from a Design.
      @returns Returns the Appearance added to the favorites list or null if the operation failed.
    */
    add(appearance: Appearance): Appearance | null
  }

  /**
    An appearance.
  */
  abstract class Appearance extends Base {
    /**
      The unique internal ID of this Appearance.
    */
    readonly id: string
    /**
      Returns true if this Appearance is used in the Design.
    */
    readonly isUsed: boolean
    /**
      Returns a collection of the entities currently using this appearance. This
      property is only valid for an appearance in a Design and where the IsUsed
      property returns true. The collection returned can contain
    */
    readonly usedBy: ObjectCollection
    /**
      Returns the name of this Appearance. This is the localized name
      shown in the UI.
    */
    name: string
    /**
      Property that returns the Parent object of this Appearance (a MaterialLibrary, Design, or AppearanceFavorites collection).
    */
    readonly parent: Base
    /**
      Property that indicates if this appearance has a texture associated with it.
    */
    readonly hasTexture: boolean
    /**
      returns the collection of Properties that define this appearance
    */
    readonly appearanceProperties: Properties
    /**
      Deletes the Appearance from the Design. This method is only valid for appearances
      that are in a Design and are unused.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Copies this appearance to the specified target.
      @remarks
      This method has been retired and replaced by the addByCopyMethod on the Appearances object.
      @param target The target can be a Design or FavoriteAppearances object.
      @returns Returns true if the copy was successful.
      @deprecated
    */
    copyTo(target: core.Base): boolean
  }

  /**
    A texture value property associated with a material or appearance.
  */
  abstract class AppearanceTextureProperty extends Property {
    /**
      Gets and sets this property value.
    */
    value: AppearanceTexture
    /**
      Specifies if this AppearanceTexture is being used. This is the equivalent of the
      check box in the Appearance dialog to enable the use of a text for an appearance or not.
      if this is False, then the value property should not be used because there isn't an associated.
      AppearanceTexture.
    */
    readonly isUsed: boolean
  }

  /**
    Provides access to a list of properties that define a texture.
  */
  abstract class AppearanceTexture extends Base {
    /**
      Changes the image of this texture.
      @param imageFilename Input String specifying the full filename of the texture file to use.
      @returns Returns true if the change was successful.
    */
    changeTextureImage(imageFilename: string): boolean
    /**
      Returns a collection of the properties associated with this texture.
    */
    readonly properties: Properties
    /**
      Gets the type of texture this appearance currently is.
    */
    readonly textureType: TextureTypes
  }

  /**
    The different types of textures.
  */
  const enum TextureTypes {
    /**
      Unknown texture type.
    */
    UnknownTexture,
    /**
      A texture defined by an image.
    */
    ImageTexture,
    /**
      A procedural checkered texture.
    */
    CheckerTexture,
    /**
      A procedural gradient texture.
    */
    GradientTexture,
    /**
      A procedural marble texture.
    */
    MarbleTexture,
    /**
      A procedural noise texture.
    */
    NoiseTexture,
    /**
      A procedural speckle texture.
    */
    SpeckleTexture,
    /**
      A procedural tile texture.
    */
    TileTexture,
    /**
      A procedural wave texture.
    */
    WaveTexture,
    /**
      A procedural wood texture.
    */
    WoodTexture,
  }

  /**
    The different types of sources for an appearance.
  */
  const enum AppearanceSourceTypes {
    /**
      Then entity is its current appearance because of the appearance associated with the material assigned to a component or body.
    */
    MaterialAppearanceSource,
    /**
      The entity is its current appearance because of an appearance assigned to the body.
    */
    BodyAppearanceSource,
    /**
      The entity is its current appearance because of an appearance assigned to the occurrence.
    */
    OccurrenceAppearanceSource,
    /**
      The entity is its current appearance because of an appearance assigned to the face.
    */
    FaceAppearanceSource,
    /**
      The entity is its current appearance because of an override that's been applied.
    */
    OverrideAppearanceSource,
  }

  /**
    Provides access to the various settings that control how a texture is applied to a body or mesh.
    This is the base class for the various texture mapping techniques.
  */
  abstract class TextureMapControl extends core.Base {
    /**
      Resets the texture map back to its original default settings.
      @returns Returns true if the reset was successful.
    */
    reset(): boolean
  }

  /**
    Provides access to the various settings that control how a projected texture is applied to a body.
  */
  abstract class ProjectedTextureMapControl extends TextureMapControl {
    /**
      Gets and sets how the texture map is being applied onto the body.
    */
    projectedTextureMapType: ProjectedTextureMapTypes
    /**
      When a cylindrical projected texture map is being used this property gets and sets if
      a cap is use for the cylindrical projection. This property is only valid in the case
      when the projectedTextureMapType returns CylindricalTextureMapProjection. The value of
      this property should be ignored in all other cases and setting the property will have no effect.
    */
    isCapped: boolean
    /**
      Gets and sets the transform that defines the position and orientation of how the texture
      is projected onto the body. The Z axis of the transform corresponds to the axis that is
      specified in the user-interface and is the primary direction of the texture.
    */
    transform: core.Matrix3D
  }

  /**
    The different types of projected texture maps.
  */
  const enum ProjectedTextureMapTypes {
    /**
      The default projection that is determined automatically.
    */
    AutomaticTextureMapProjection,
    /**
      A texture map that is projected onto the body along a single direction.
    */
    PlanarTextureMapProjection,
    /**
      A texture map that is projected from six orthogonal planes as if the body was in a
      box and each plane of the box is projected onto the body.
    */
    BoxTextureMapProjection,
    /**
      A texture map that is projected as a sphere onto the body.
    */
    SphericalTextureMapProjection,
    /**
      A texture map that is projected as a cylinder onto the body.
    */
    CylindricalTextureMapProjection,
  }

  /**
    Provides access to the various settings that control how a 3D texture is applied to a body.
  */
  abstract class TextureMapControl3D extends TextureMapControl {
    /**
      Gets and sets the transform that defines the position and orientation of how the texture
      is applied to the body. For wood grain, the Z direction of the defined coordinate system is
      the direction of the grain.
    */
    transform: core.Matrix3D
    /**
      Reorients the transform to best fit the geometry of the body.
      @returns Returns true if the best fit was successful.
    */
    bestFit(): boolean
  }

  /**
    Provides access to the user-interface related objects and functionality.
    @permissions ui
  */
  abstract class UserInterface extends Base {
    /**
      Display a modal message box with the provided text.
      @param text The message text to display in the dialog.
      @param title If the optional title argument is provided, it sets the title for the dialog, otherwise the script or add-in name is used.
      @param buttons The optional buttons array can be used to specify which buttons to display on the dialog.
      The first button provided is the default action.
      If buttons are not specified, the dialog will default to a single OK button.
      @param icon The optional icon argument can be used to specify which icon to display, otherwise the default of no icon is used.
      @returns The button pressed to dismiss the dialog is returned.
    */
    messageBox(text: string, title?: string/* = ""*/, buttons?: MessageBoxButtonTypes/* = MessageBoxButtonTypes.OKButtonType*/, icon?: MessageBoxIconTypes/* = MessageBoxIconTypes.NoIconIconType*/): DialogResults
    /**
      Displays a modal dialog to get string input from the user.
      @param prompt The message text to display in the dialog.
      @param cancelled Indicates if the dialog was canceled.
      @param title Sets the title for the dialog if specified, otherwise the script or add-in name is used.
      @param defaultValue The default string that's shown when the dialog is initially displayed, otherwise the input box is empty.
      @returns Returns the string entered by the user but because the user can click Cancel, the canceled argument should be tested before using the string.
    */
    inputBox(prompt: string, title?: string/* = ""*/, defaultValue?: string/* = ""*/): [cancelled: boolean]
    /**
      Supports the selection of a single entity. This provides a simple way to prompt the user for
      for a selection in a script. If you need more control over the selection a command should be
      created and a SelectionCommandInput used.
      @remarks
      The selectEntity method is not supported within any of the Command related events.
      @param prompt The prompt displayed to the user during the selection.
      @param filter A string defining the types of entities valid for selection. The valid list of selection filters can be found here: <a href="SelectionFilters_UM.htm">Selection Filters</a>.
      You can combine multiple types by using a comma delimiter. For example, the string "PlanarFaces,ConstructionPlanes" will allow the selection of either a planar face or a construction plane.
      @returns Returns a Selection object that provides access the selected entity through it's "entity" property
      along with the location in space where the entity was selected. Asserts if the selection is aborted.
    */
    selectEntity(prompt: string, filter: string): Selection
    /**
      Creates a new FileDialog object which provides the ability to show a standard file selection dialog
      to the user.
      @returns Returns the created FileDialog object that you can use to define the contents of and display a standard file dialog.
    */
    createFileDialog(): FileDialog
    /**
      Gets the current set of selected objects.
    */
    readonly activeSelections: Selections
    /**
      Gets the active workspace. The active workspace is the one currently active in the user interface.
      This can be null if there is no active product.
    */
    readonly activeWorkspace: Workspace
    /**
      Gets all of the command definitions currently defined. This is all
      command definitions both internal and those defined through the API.
    */
    readonly commandDefinitions: CommandDefinitions
    /**
      Gets a collection that provides access to the toolbars. This includes
      the left and right QAT, and the Navbar.
    */
    readonly toolbars: Toolbars
    /**
      Gets all of the workspaces currently available.
    */
    readonly workspaces: Workspaces
    /**
      Returns all of the workspaces associated with the specified product.
      @param productType The name of the product that you want the associated workspaces for. The full list
      of available products can be obtained by using the Application.supportedProductTypes property.
      @returns Returns a list of the associated work spaces.
    */
    workspacesByProductType(productType: string): WorkspaceList
    /**
      Gets all of the toolbar panels. This returns all of the panels
      available, regardless of which workspace or product they're associated with.
    */
    readonly allToolbarPanels: ToolbarPanelList
    /**
      The workspacePreActivate event fires at the VERY start of a workspace being activated.
      The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
    */
    readonly workspacePreActivate: WorkspaceEvent
    /**
      The workspaceActivated event fires at the VERY end of a workspace being activated.
      The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
    */
    readonly workspaceActivated: WorkspaceEvent
    /**
      The workspacePreDeactivate event fires at the VERY start of a workspace being deactivated.
      The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
    */
    readonly workspacePreDeactivate: WorkspaceEvent
    /**
      The workspaceDeactivated event fires at the VERY end of a workspace being deactivated.
      The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
    */
    readonly workspaceDeactivated: WorkspaceEvent
    /**
      Gets all of the toolbar panels associated with the specified product.
      @param productType The name of the product that you want the associated workspaces for. The full list
      of available products can be obtained by using the Application.supportedProductTypes property.
      @returns Returns a list of the toolbars associated with the specified product.
    */
    toolbarPanelsByProductType(productType: string): ToolbarPanelList
    /**
      Gets the id of the command definition from the active command (the one that is currently running)
    */
    readonly activeCommand: string
    /**
      Method that causes the currently active (running) command to be terminated
      @remarks
      The terminateActiveCommand method is not supported within any of the Command related events because it
      results in the termination of the current command, which is your running command.
      @returns Returns true if terminating the active command was successful.
    */
    terminateActiveCommand(): boolean
    /**
      The commandStarting event fires when a request for a command to be executed has been
      received but before the command is executed. Through this event, it's possible to
      cancel the command from being executed.
    */
    readonly commandStarting: ApplicationCommandEvent
    /**
      The commandCreated event fires immediately after the command is created.
    */
    readonly commandCreated: ApplicationCommandEvent
    /**
      Gets an event that is fired when a command is terminated.
    */
    readonly commandTerminated: ApplicationCommandEvent
    /**
      Creates a new ProgressDialog object that you can use to display and control a progress dialog.
      @returns Returns the created ProgressDialog object that you can use to define the contents of and display a progress dialog.
    */
    createProgressDialog(): ProgressDialog
    /**
      The markingMenuDisplaying event fires just before the marking menu and context menus are displayed. The
      marking menu is the round menu displayed when the user right-clicks the mouse within Fusion. The context
      menu is the vertical menu displayed. The event provides both the marking menu and the context menu so you
      can examine and edit the contents of either one or both of them before they are displayed. Fusion will then
      display the marking and context menu that you've customized. If either one is empty it will not be displayed.
    */
    readonly markingMenuDisplaying: MarkingMenuEvent
    /**
      Returns the collection object that provides access to all of the existing
      palettes and provides the functionality to create new custom palettes.
    */
    readonly palettes: Palettes
    /**
      Creates a new FolderDialog object which provides the ability to show a standard folder selection dialog
      to the user.
      @returns Returns the created FolderDialog object that you can use to define the contents of and display a standard folder dialog.
    */
    createFolderDialog(): FolderDialog
    /**
      Gets all of the toolbar tabs. This returns all of the tabs
      available, regardless of which workspace or product they're associated with.
    */
    readonly allToolbarTabs: ToolbarTabList
    /**
      Gets all of the toolbar tabs associated with the specified product.
      @param productType The name of the product that you want the associated tabs for. The full list
      of available products can be obtained by using the Application.supportedProductTypes property.
      @returns Returns a list of the tabs associated with the specified product.
    */
    toolbarTabsByProductType(productType: string): ToolbarTabList
    /**
      Returns true if Tabbed Toolbars are being used.
      @returns Returns true if using Tabbed Toolbars.
    */
    readonly isTabbedToolbarUI: boolean
    /**
      This event fires whenever the contents of the active selection changes. This occurs as the user
      selects or unselects entities while using the Fusion Select command. The Select command
      is the default command that is always running if no other command is active. Pressing Escape
      terminates the currently active command and starts the Select command. If the Select command is
      running and you press Escape, it terminates the current Select command and starts a new one.
      This event is only associated with the selection associated with the Select command and does not
      fire when any other command is running. The event fires when there is any change to the active
      selection, including when the selection is cleared when the Select command is terminated. It is
      also fired when the user clicks in an open area of the canvas to clear the current selection.
      @permissions desktop
    */
    readonly activeSelectionChanged: ActiveSelectionEvent
    /**
      Get the localized text for a specific application text string. The strings used by Fusion are
      stored in localized XML files that are installed with Fusion. On Windows, you can find them here:
      %LocalAppData%\Autodesk\webdeploy\production\VERSION_CODE\StringTable
      And on Mac, you can find them here:
      ~/Library/Application Support/Autodesk/webdeploy/production/VERSION_CODE/Autodesk Fusion.app/Contents/Libraries/Neutron/StringTable
      There is a folder for each language that Fusion supports, and the strings for that language are defined
      in files within that folder. Fusion will use the language specified by the user in their preferences.
      @param module The module name. This is the same as the StringTable .xml filename without the .xml extension and
      without the version number. For example, the file NaFusionUI10.xml contains many of the strings used
      for Fusion's modeling commands. When specifying the module, this is specified as "NaFusionUI".
      @param id The id of the text. This is the same as the 'commandName' field in the StringTable .xml file.
      @param defaultValue A default string value to return if the module or string id is not found in the current locale.
      @returns The localized string or the defaultValue if one is not found.
    */
    getText(module: string, id: string, defaultValue: string): string
    /**
      Creates a new CloudFileDialog object which provides the ability to show a file selection dialog
      to the user that allows them to choose a file from Fusion web client.
      @returns Returns the created CloudFileDialog object that you can use to define the contents of and display a standard file dialog.
    */
    createCloudFileDialog(): CloudFileDialog
    /**
      Retrieve the active Toolbar being displayed in the user interface.
    */
    readonly activeToolbar: Toolbar
    /**
      Retrieve the active ToolbarTab being displayed in the user interface. This may be null.
    */
    readonly activeToolbarTab: ToolbarTab
    /**
      Gets and sets the current message displayed in the lower-right corner of the Fusion window.
      This is useful when displaying progress information to the user for the current process.
      Set the value to an empty string to remove the message. The lifetime of your message is
      indeterminant because Fusion uses the same field to display messages.
      If your process is running in the main thread of Fusion, you will need to call adsk.doEvents
      to give control back to Fusion, so it can update the UI.
      The ProgressBar can also be used as a way to communicate to the user the current progress
      of a running process.
    */
    statusMessage: string
    /**
      Gets the ProgressBar object that can be used to display a progress bar in the lower-right
      corner of the Fusion window.
    */
    readonly progressBar: ProgressBar
    /**
      Gets and sets if the Fusion user interface is enabled or not. By default it
      is enabled allowing the user to interact with Fusion. When set to false, the
      UI is disabled which blocks all interaction, including running commands,
      manipulating the view and interacting with the browser.
    */
    isUIEnabled: boolean
  }

  /**
    This event fires whenever the contents of the active selection changes. This occurs as the user
    selects or unselects entities while using the Fusion Select command. The Select command
    is the default command that is always running if no other command is active. Pressing Escape
    terminates the currently active command and starts the Select command. If the Select command is
    running and you press Escape, it terminates the current Select command and starts a new one.
    This event is only associated with the selection associated with the Select command and does not
    fire when any other command is running. The event fires when there is any change to the active
    selection, including when the selection is cleared when the Select command is terminated. It is
    also fired when the user clicks in an open area of the canvas to clear the current selection.
    @permissions ui
  */
  abstract class ActiveSelectionEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: ActiveSelectionEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: ActiveSelectionEventHandler): boolean
  }

  /**
    The ActiveSelectionEventHandler is a client implemented class that can be added as a handler to a
    ActiveSelectionEvent.
    @permissions ui
  */
  abstract class ActiveSelectionEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: ActiveSelectionEventArgs): void
  }

  /**
    The ActiveSelectionEventArgs provides information associated with the active selection changing.
    The event fires whenever the contents of the active selection changes. This occurs as the user
    selects or unselects entities while using the Fusion Select command. The Select command
    is the default command that is always running if no other command is active. Pressing Escape
    terminates the currently active command and starts the Select command. If the Select command is
    running and you press Escape, it terminates the current Select command and starts a new one.
    An array or list of all the currently selected entities is returned. This is the same set of
    entities accessed through the UserInterface.activeSelection object. An empty array can be returned
    in the case where the selection has been cleared which can occur by the user unselecting and entity,
    terminating the select command pressing Escape or running another command or clicking the mouse in
    an open area of the canvas.
    @permissions ui
  */
  abstract class ActiveSelectionEventArgs extends EventArgs {
    /**
      The list of all of the current selections. This is the same set of selections accessed through
      the UserInterface.activeSelection object. An empty array can be returned
      in the case where the selection has been cleared which can occur by the user unselecting and entity,
      terminating the select command pressing Escape or running another command or clicking the mouse in
      an open area of the canvas.
    */
    readonly currentSelection: core.Selection[]
  }

  /**
    A MarkingMenuEvent is fired when the marking menu and context menu are displayed. For example, in response to the
    markingMenuDisplaying event.
    @permissions ui
  */
  abstract class MarkingMenuEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: MarkingMenuEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: MarkingMenuEventHandler): boolean
  }

  /**
    The MarkingMenuEventArgs provides information associated with the marking and context
    menu being displayed.
    @permissions ui
  */
  abstract class MarkingMenuEventArgs extends EventArgs {
    /**
      Provides access to the radial marking menu.
    */
    readonly radialMarkingMenu: RadialMarkingMenu
    /**
      Provides access to the linear marking menu.
    */
    readonly linearMarkingMenu: LinearMarkingMenu
    /**
      Returns the currently selected entities that the user left-clicked over.
      These provide the "context" of what should be displayed in the menu. This
      can be an empty array in the case where they clicked in a open area within
      the graphics window.
    */
    readonly selectedEntities: core.Base[]
  }

  /**
    The MarkingMenuEventHandler is a client implemented class that can be added as a handler to a
    MarkingMenuEvent.
    @permissions ui
  */
  abstract class MarkingMenuEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: MarkingMenuEventArgs): void
  }

  /**
    Defines the valid return types from a message box.
    @permissions ui
  */
  const enum MessageBoxButtonTypes {
    /**
      The message box contains an OK button.
    */
    OKButtonType,
    /**
      The message box contains OK and Cancel buttons.
    */
    OKCancelButtonType,
    /**
      The message box contains Retry and Cancel buttons.
    */
    RetryCancelButtonType,
    /**
      The message box contains Yes and No buttons.
    */
    YesNoButtonType,
    /**
      The message box contains Yes, No, and Cancel buttons.
    */
    YesNoCancelButtonType,
  }

  /**
    Defines the different icons that can be used in a message box.
    @permissions ui
  */
  const enum MessageBoxIconTypes {
    /**
      No icon is to be used.
    */
    NoIconIconType,
    /**
      An icon indicating that a question is being asked.
    */
    QuestionIconType,
    /**
      An icon indicating that informational message is being displayed.
    */
    InformationIconType,
    /**
      An icon indicating that a warning message is being displayed.
    */
    WarningIconType,
    /**
      An icon indicating that a critical problem message is being displayed.
    */
    CriticalIconType,
  }

  /**
    Defines the valid return types from a dialog.
    @permissions ui
  */
  const enum DialogResults {
    /**
      An unexpected error occurred.
    */
    DialogError = -1,
    /**
      The dialog box return value is OK (usually sent from a button labeled OK).
    */
    DialogOK,
    /**
      The dialog box return value is Cancel (usually sent from a button labeled Cancel).
    */
    DialogCancel,
    /**
      The dialog box return value is Yes (usually sent from a buttons labeled Yes and Retry).
    */
    DialogYes,
    /**
      The dialog box return value is No (usually sent from a button labeled No).
    */
    DialogNo,
  }

  /**
    Provides access to a file dialog. A file dialog can be used to prompt the user
    for file names to open or save to.
    @permissions ui
  */
  abstract class FileDialog extends Base {
    /**
      Gets or sets the title displayed on the dialog.
    */
    title: string
    /**
      Gets the filename specified by the user in the dialog. This property is
      used after the ShowOpen or ShowSave methods have been called to retrieve
      the filename specified by the user. The file name includes both the
      file path and the extension.
      If ShowOpen was used and IsMultiSelectEnabled is true, then this property will
      only display the first filename selected and the Filenames property should be
      used instead to retrieved the full list. Is ShowSave was used, then only a
      single file name is ever returned.
    */
    readonly filename: string
    /**
      Gets the filenames specified by the user in the dialog. This property is
      used after the ShowOpen or ShowSave methods have been called to retrieve
      the filenames specified by the user. Each file name includes both the
      file path and the extension.
      If ShowOpen is used and IsMultiSelectEnabled is true, the user is able to select
      more than one file. This property returns all of the files that were selected. If
      ShowSave is used or IsMultiSelectEnabled is false then this array will contain
      the single file name.
    */
    readonly filenames: string[]
    /**
      Gets or sets the current file name filter string, which determines the choices
      that appear in the "Save as file type" or "Files of type" box in the dialog box.
      For each filtering option, the filter string contains a description of the filter
      and the filter pattern as specified in parentheses and separated by semi-colons. Multiple
      filters are separated by a double semi-colon. These are illustrated below.
      The following is an example of a filter string:
         Text files (*.txt)All files (*.*)
      You can add several filter patterns to a filter by separating the file types with semicolons, for example:
         Image Files (*.BMP*.JPG*.GIF)All files (*.*)
    */
    filter: string
    /**
      Gets or sets the index of the filter currently selected in the file dialog box. Use the FilterIndex
      property to set which filtering option is shown first to the user. You can also use the value of
      FilterIndex after showing the file dialog to perform special file operations depending upon the filter chosen.
      The first item in the filter list is index 0.
    */
    filterIndex: number /*int*/
    /**
      Gets or sets the initial directory displayed by the file dialog box.
    */
    initialDirectory: string
    /**
      Gets or sets a value indicating whether the dialog box allows multiple files to be selected.
    */
    isMultiSelectEnabled: boolean
    /**
      Displays a modal open dialog, allowing the user to select one or more files. The return value
      can be used to determine if the dialog was canceled without selecting a file. The Filename
      and Filenames properties can be used to get the selected files.
      @returns Returns an enum value indicating which button was clicked on the dialog.
    */
    showOpen(): DialogResults
    /**
      Displays a modal save dialog, allowing the user to specify a file. The return value
      can be used to determine if the dialog was canceled without selecting a file. The Filename
      and Filenames properties can be used to get the selected files.
      @returns Returns an enum value indicating which button was clicked on the dialog.
    */
    showSave(): DialogResults
    /**
      Gets or sets the initial filename displayed when the dialog is first displayed.
      When a new FileDialog object is created this defaults to an empty string so no
      initial filename is specified.
      If the showOpen option is used, the file must
      already exist in the directory specified by the initialDirectory property. If
      it doesn't exist, the initial filename will not be used.
    */
    initialFilename: string
  }

  /**
    Provides access to a cloud file dialog. A cloud file dialog can be used to prompt the user
    to select a location and file on Fusion web client.
    @permissions ui
  */
  abstract class CloudFileDialog extends Base {
    /**
      Gets or sets the title displayed on the dialog.
    */
    title: string
    /**
      Gets the DataFile selected by the user in the dialog. This property is
      used after the ShowOpen method has been called to retrieve
      the filename specified by the user.
      If ShowOpen was used and isMultiSelectEnabled is true, then this property will
      only display the first DataFile selected and the dataFiles property should be
      used instead to retrieved the full list. If ShowSave was used, then only a
      single DataFile is ever returned.
    */
    readonly dataFile: DataFile
    /**
      Gets the DataFiles specified by the user in the dialog. This property is
      used after the ShowOpen method has been called to retrieve the DataFiles
      specified by the user.
      If ShowOpen is used and isMultiSelectEnabled is true, the user is able to select
      more than one file. This property returns all of the files that were selected.
    */
    readonly dataFiles: DataFile[]
    /**
      Gets or sets the current file type filter. This controls the types of files displayed in
      the dialog. The filter consists of file extensions separated by a semi-colon. The string
      below is an example of the filter used by Fusion for the Open command.
      "f3df2df2tfbrdfschflbrfprjprtparsldprtsldasmiptiamstpstestep"
      An empty string indicates that no filter should be used and all files in the current
      DataFolder should be displayed.
    */
    filter: string
    /**
      Gets or sets the initial DataFolder displayed in the dialog. The DataFolder should be in current project.
      If null, this defaults to the DataFolder that is currently active in the Data Panel.
      When using the showSave method, use this property to get the DataFolder that the user specified.
    */
    dataFolder: DataFolder
    /**
      Gets and sets the filename when using the showSave method. If you set this value before using the
      showSave method, this will display the filename as the default in the dialog, but the user can
      change it. The default is an empty string, which indicates there is not an initial filename.
      After calling the showSave method, use this property to get the filename the user specified. You
      can use this in combination with the dataFolder property to know where the user has specified
      to save the file.
    */
    filename: string
    /**
      Gets or sets a value indicating whether the dialog allows multiple files to be selected. This
      defaults to False when a new CloudFileDialog is created. It is only used when using the showOpen method.
    */
    isMultiSelectEnabled: boolean
    /**
      Displays a modal open dialog, allowing the user to select one or more files. The return value
      can be used to determine if the dialog was canceled without selecting a file. The dataFile
      and dataFiles properties can be used to get the selected files.
      @returns Returns an enum value indicating which button was clicked on the dialog.
    */
    showOpen(): DialogResults
    /**
      Displays a modal save dialog, allowing the user to specify a file. The return value
      can be used to determine if the dialog was canceled without giving a filename. The filename
      property can be used to get that file.
      @returns Returns an enum value indicating which button was clicked on the dialog.
    */
    showSave(): DialogResults
  }

  /**
    Provides access to a folder selection dialog to allow the user to select a folder.
    @permissions ui
  */
  abstract class FolderDialog extends Base {
    /**
      Gets or sets the title displayed on the dialog.
    */
    title: string
    /**
      Gets the folder selected by the user in the dialog. This property is
      used after the ShowDialog method has been called to retrieve the folder
      specified by the user.
    */
    readonly folder: string
    /**
      Gets or sets the initial directory displayed by the file dialog box.
    */
    initialDirectory: string
    /**
      Displays a modal dialog allowing the user to select a folder. The return value
      can be used to determine if the dialog was canceled without selecting a folder.
      the folder property can be used to get the selected folder.
      @returns Returns an enum value indicating which button was clicked on the dialog.
    */
    showDialog(): DialogResults
  }

  /**
    Provides access to the progress bar.
    @permissions ui
  */
  abstract class ProgressBar extends Base {
    /**
      This method displays a message in the progress bar in the lower-right corner of the Fusion window.
      The progress bar can be used to display a continually updated message indicating the progress of a process.
      The progress is determined by comparing the current progress value with the minimum and maximum values.
      @param message Specifies the message that will be displayed in the progress bar. The following symbols can be used to
      display values. "%p" is replaced by the percentage completed. "%v" is replaced by the current value.
      "%m" is replaced by the total number of steps. For example, the message "Processing section %v of %m."
      will result in the message "Processing section 1 of 10." to be displayed if the maximum value is 10
      and the current value is 1.
      An empty string can be specified if you don't want a message and use only the progress meter.
      @param minimumValue Specifies the minimum value of the progress. This value and the maximum and progress values to compute
      the current percentage complete. This is the initial progress value when the progress bar is first displayed.
      @param maximumValue Specifies the maximum value of the progress. This value and the minimum and progress values are
      used to compute the current percentage completion.
      @param isModal Specifies if the progress bar should be modal or not. If modal, the progress bar takes over the UI of
      Fusion, and the user cannot interact with any of the Fusion user interface. You need to be careful when
      using a modal dialog to make sure you hide the progress bar when you're finished or have an error
      condition that causes you to abort because otherwise, the user will need to kill the Fusion process.
      @returns Returns true if successful.
    */
    show(message: string, minimumValue: number /*int*/, maximumValue: number /*int*/, isModal?: boolean/* = false*/): boolean
    /**
      This method displays a message in the busy bar in the lower-right corner of the Fusion window.
      The busy bar can be used to display a continually updated message indicating the progress of a process.
      The busy bar is different from the progress bar, because it does not show a meter indicating the current
      progress. Instead is shows a continually moving bar to indicate processing without showing the current
      progress. This is useful in cases where the length of the process is unknown.
      @param message Specifies the message that will be displayed in the busy bar. An empty string can be specified if
      you don't want a message and use only the busy meter.
      @param isModal Specifies if the busy bar should be modal or not. If modal, the busy bar takes over the UI of
      Fusion, and the user cannot interact with any of the Fusion user interface. You need to be careful when
      using a modal dialog to make sure you hide the busy bar when you're finished or have an error
      condition that causes you to abort because otherwise, the user will need to kill the Fusion process.
      @returns Returns true if successful.
    */
    showBusy(message: string, isModal?: boolean/* = false*/): boolean
    /**
      Gets and sets the current progress value. This value determines the progress based on this value relative to
      the minimum and maximum values specified when the progress bar was created. This will also update the values displayed
      in the message string.
      If your process is running in the main thread of Fusion, you will need to call adsk.doEvents
      to give control back to Fusion, so it can update the UI.
      This value is ignored when a busy bar is displayed.
    */
    progressValue: number /*int*/
    /**
      Gets and sets the message to display in the progress bar. The following symbols can be used
      to display values. "%p" is replaced by the percentage completed. "%v" is replaced
      by the current value. %m is replaced by the total number of steps. For example, the
      message "Processing section %v of %m." will result in the message "Processing section
      1 of 10." to be displayed if the maximum value is 10 and the current value is 1.
      When a busy bar is displayed, only a simple message is supported and symbols are not supported.
      If your process is running in the main thread of Fusion, you will need to call adsk.doEvents
      to give control back to Fusion, so it can update the UI.
    */
    message: string
    /**
      Hides the progress or busy bar. This should be used when the process has completed.
      @returns Returns true if successful.
    */
    hide(): boolean
  }

  /**
    Provides access to the progress dialog.
    @permissions ui
  */
  abstract class ProgressDialog extends Base {
    /**
      Displays the progress dialog that includes a progress bar that can be used to display a continually updated
      message indicating the progress of a process that will take more than a few seconds.
      The progress is determined by comparing the current progress value with the minimum and maximum values.
      @param title Sets the title for the progress dialog
      @param message The message to display along with the progress bar. The following symbols can be used
      to display values. "%p" is replaced by the percentage completed. "%v" is replaced
      by the current value. %m is replaced by the total number of steps. For example, the
      message "Processing section %v of %m." will result in the message "Processing section
      1 of 10." to be displayed if the maximum value is 10 and the current value is 1.
      @param minimumValue The minimum value of the progress bar. This is used along with the maximum value and the
      progress value to compute the current percentage complete. This is also the initial
      progress value when the progress bar is first displayed.
      @param maximumValue The maximum value of the progress bar. This is used along with the minimum value and the
      progress value to compute the current percentage complete.
      @param delay Specifies the time interval in seconds to delay displaying the Progress Dialog. This provides a way to hide
      the progress dialog before it actually gets displayed, which is useful for cases where the progress of the
      operation being tracked completes quickly and there is no need to indicate progress to the user.
      @returns Returns true if successful.
    */
    show(title: string, message: string, minimumValue: number /*int*/, maximumValue: number /*int*/, delay?: number /*int*//* = 0*/): boolean
    /**
      Hides the progress dialog. This should be used when the process has completed.
      @returns Returns true if successful.
    */
    hide(): boolean
    /**
      Gets and sets the title of the progress dialog
    */
    title: string
    /**
      Gets and sets the message to display along with the progress bar. The following symbols can be used
      to display values. "%p" is replaced by the percentage completed. "%v" is replaced
      by the current value. %m is replaced by the total number of steps. For example, the
      message "Processing section %v of %m." will result in the message "Processing section
      1 of 10." to be displayed if the maximum value is 10 and the current value is 1.
      Specify an empty string ("") for no message to appear along with the progress panel.
    */
    message: string
    /**
      The minimum value of the progress bar. This is used along with the maximum value and the
      progress value to compute the current percentage complete. This is also the initial
      progress value when the progress bar is first displayed.
    */
    minimumValue: number /*int*/
    /**
      The maximum value of the progress bar. This is used along with the minimum value and the
      progress value to compute the current percentage complete.
    */
    maximumValue: number /*int*/
    /**
      Gets and sets the current progress bar value. Progress is determined based on this value relative to
      the minimum and maximum values. This will update the values displayed
      in the message string.
    */
    progressValue: number /*int*/
    /**
      Gets and sets if the cancel button is included in the dialog. This is false by default.
    */
    isCancelButtonShown: boolean
    /**
      Indicates if the cancel button was selected the last time the Progress Dialog was shown.
    */
    readonly wasCancelled: boolean
    /**
      Sets the text label on the Cancel button. The default text label is "Cancel".
    */
    cancelButtonText: string
    /**
      Gets and sets if the dialog background is translucent. This is false by default
    */
    isBackgroundTranslucent: boolean
    /**
      Gets if the Progress Dialog is currently being displayed
    */
    readonly isShowing: boolean
    /**
      Method that resets the progress bar. The progress bar "rewinds" and shows no progress.
      This is the same as setting the progress value to the minimum value.
      @returns Returns true if successful
    */
    reset(): boolean
  }

  /**
    Provides access to all of the existing workspaces.
    @permissions ui
  */
  abstract class Workspaces extends Base {
    /**
      Returns the specified work space using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Workspace | null
    /**
      Returns the Workspace of the specified ID.
      @param id The ID of the workspace to get.
      @returns Returns the specified workspace or null in the case where there isn't a workspace with the specified ID.
    */
    itemById(id: string): Workspace | null
    /**
      Gets the number of workspaces in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A WorkspaceList is a list of Workspaces - e.g. the Workspaces for a given product.
    @permissions ui
  */
  abstract class WorkspaceList extends Base {
    /**
      Returns the specified work space using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Workspace | null
    /**
      Returns the Workspace of the specified ID.
      @param id The ID of the workspace to get.
      @returns Returns the specified workspace or null in the case where there isn't a workspace with the specified ID.
    */
    itemById(id: string): Workspace | null
    /**
      Gets the number of workspaces in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A Workspace provides access to a set of panels, which contain commands that
    are relevant for that particular workspace. The user can switch from one
    workspace to another in a product (e.g. switch from Model to Sculpt in Fusion).
    @permissions ui
  */
  abstract class Workspace extends Base {
    /**
      Gets the unique Id of the workspace that can be used programmatically
      to find a specific workspace. It is not affected by the current
      language.
    */
    readonly id: string
    /**
      Gets if the workspace is currently active - i.e. displayed
    */
    readonly isActive: boolean
    /**
      Gets if this workspace is native to Fusion or was created via the API.
    */
    readonly isNative: boolean
    /**
      Gets the visible name of the workspace as seen in the user interface.
      This is the localized name.
    */
    readonly name: string
    /**
      Gets the collection containing the panels associated with this workspace.
      It's through this collection that you can add new toolbar panels.
    */
    readonly toolbarPanels: ToolbarPanels
    /**
      Gets or sets the resource folder.
    */
    resourceFolder: string
    /**
      Activate the workspace (assuming it is valid to do so - a SIM workspace can't
      be activated if Fusion is the active product).
      @returns Boolean return that indicates if the activation was successful or not.
    */
    activate(): boolean
    /**
      Deletes this workspace. Only a workspace added by the API can be deleted, (IsNative is false).
      @returns Boolean return that indicates if the deletion was successful or not.
    */
    deleteMe(): boolean
    /**
      Returns the name of the product this workspace is associated with.
    */
    readonly productType: string
    /**
      Gets or sets the full filename of the image file (PNG) used for the tool clip.
      the tool clip is the image shown when the user hovers the mouse over the workspace name in the workspace drop-down.
    */
    toolClipFilename: string
    /**
      Gets or sets the tooltip text displayed for the workspace. This is the first line of text shown when the
      user hovers over the workspace name in the Fusion toolbar drop-down. This is typically the name of the
      workspace. This is different from the name in the that the name is a short name shown in the drop-down.
      The tooltip is only shown when the user hovers over the name and box appears providing more information
      about the workspace. For example, the name of the model workspace is "Model" and the tooltip is "Model Workspace".
    */
    tooltip: string
    /**
      Gets or sets the tooltip description displayed for the workspace. The tooltip description is a longer
      description of the workspace and is only displayed when the user hovers over the workspace name in
      the Fusion toolbar drop-down. The pop-up dialog that appears contains the tooltip, the tooltip
      description, and the tool clip which is a picture.
    */
    tooltipDescription: string
    /**
      Gets the collection containing the tabs associated with this workspace.
    */
    readonly toolbarTabs: ToolbarTabs
  }

  /**
    A WorkspaceEvent represents a workspace related event. For example, workspaceActivate or workspaceDeactivate.
    @permissions ui
  */
  abstract class WorkspaceEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: WorkspaceEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: WorkspaceEventHandler): boolean
  }

  /**
    The WorkspaceEventArgs provides information associated with a workspace event.
    @permissions ui
  */
  abstract class WorkspaceEventArgs extends EventArgs {
    /**
      Provides access to the workspace.
    */
    readonly workspace: Workspace
  }

  /**
    The WorkspaceEventHandler is a client implemented class that can be added as a handler to a
    WorkspaceEvent.
    @permissions ui
  */
  abstract class WorkspaceEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: WorkspaceEventArgs): void
  }

  /**
    Provides access to the toolbars. These are currently the right and left QAT's and the NavBar.
    @permissions ui
  */
  abstract class Toolbars extends Base {
    /**
      Returns the specified toolbar using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Toolbar | null
    /**
      Returns the Toolbar of the specified ID.
      @param id The Id of the toolbar to return.
      @returns Returns the toolbar with the specified ID or null if there's not a toolbar with the specified ID.
    */
    itemById(id: string): Toolbar | null
    /**
      Gets the number of Toolbar objects in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Provides access to a toolbar in the user interface. A toolbar is a collection of toolbar controls.
    @permissions ui
  */
  abstract class Toolbar extends Base {
    /**
      Gets the unique ID of the toolbar that can be used programmatically
      to find a specific toolbar.
    */
    readonly id: string
    /**
      Gets the owning UserInterface object.
    */
    readonly parentUserInterface: UserInterface
    /**
      Gets the controls in this toolbar.
    */
    readonly controls: ToolbarControls
  }

  /**
    Provides access to a set of toolbar panels. Many toolbar panels exist and their
    visibility is determined by the active workspace. A panel can be associated with one
    or more workspaces and when the associated workspace is active, the panel is made visible.
    This collection is associated with a workspace and possibly a tab in the toolbar for that workspace.
    If this collection is from a toolbar tab, the collection order is the left-to-right order
    of panels in the toolbar tab.
    @permissions ui
  */
  abstract class ToolbarPanels extends Base {
    /**
      Creates a new ToolbarPanel. The panel is initially empty.
      Use the associated ToolbarControls collection to add buttons.
      If this collection is associated with a tab, the new panel will be added to that tab.
      If this collection is not associated with a tab, the new panel will be added to the end of the "Tools" Tab.
      A "Tools" tab will be created for you if it does not currently exist for this collection's workspace.
      @param id The unique id for this panel. The id must be unique with respect to all of the panels.
      @param name The displayed name of this panel. This is the name visible in the user interface.
      @param positionID Specifies the id of the panel to position this panel relative to.
      Not setting this value indicates that the panel will be created at the end of all other panels. The isBefore
      parameter specifies whether to place the panel before or after this panel.
      @param isBefore Specifies whether to place the panel before or after the panel specified by the positionID argument.
      This argument is ignored is positionID is not specified
      @returns Returns the newly created panel or null in the case the creation failed.
    */
    add(id: string, name: string, positionID?: string/* = ""*/, isBefore?: boolean/* = true*/): ToolbarPanel | null
    /**
      Returns the specified toolbar panel using an index into the collection.
      When iterating by index, the panels are returned in the same order as they are shown in the user interface.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ToolbarPanel | null
    /**
      Returns the ToolbarPanel at the specified ID.
      @param id The Id of the panel within the collection to return.
      @returns Returns the ToolbarPanel of the specified id or null no panel has the specified id.
    */
    itemById(id: string): ToolbarPanel | null
    /**
      Gets the number of ToolbarPanels.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A ToolbarPanelList is a list of ToolbarPanel objects.
    @permissions ui
  */
  abstract class ToolbarPanelList extends Base {
    /**
      Returns the specified work space using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ToolbarPanel | null
    /**
      Returns the ToolbarPanel of the specified ID.
      @param id The ID of the ToolbarPanel to get.
      @returns Returns the specified ToolbarPanel or null in the case where there isn't a ToolbarPanel with the specified ID.
    */
    itemById(id: string): ToolbarPanel | null
    /**
      Gets the number of toolbar panels in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Toolbar panels are the panels shown in the command toolbar.
    @permissions ui
  */
  abstract class ToolbarPanel extends Base {
    /**
      Gets The unique, language independent, ID of this panel.
    */
    readonly id: string
    /**
      Gets the position this panel is in within the toolbar.
      The first panel is at position 0. This value is with respect
      to the complete list of panels so this value could be outside
      of the expected range if you have a collection of panels
      associated with a workspace, which is a subset of the entire
      list of panels.
    */
    readonly index: number /*unsigned int*/
    /**
      Gets or sets whether this panel is currently being displayed in the user interface.
      Visibility of a panel is controlled by it being associated with the currently
      active workspace. Setting it here will override that default behavior.
    */
    isVisible: boolean
    /**
      Gets or sets the name of the panel as seen in the user interface.
    */
    name: string
    /**
      Deletes this toolbar panel.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Gets the controls associated with this panel. These are all in the panel's
      drop-down (assuming their visible property is true) and are selectively shown
      within the panel.
    */
    readonly controls: ToolbarControls
    /**
      Gets the parent UserInterface object.
    */
    readonly parentUserInterface: UserInterface
    /**
      Gets the controls in the panel that have been promoted. Promoted
      controls are the controls that are displayed within the panel.
    */
    readonly promotedControls: ToolbarControlList
    /**
      Gets or sets the set of workspaces that this panel is displayed for.
    */
    relatedWorkspaces: ObjectCollection
    /**
      Returns the name of the product this toolbar panel is associated with.
    */
    readonly productType: string
    /**
      Gets the position this panel is in within the toolbar tab.
      The first panel in the tab is at position 0.
      @returns Returns the index value of the panel within the tab.
    */
    indexWithinTab(tabId: string): number /*unsigned int*/
  }

  /**
    Provides access to a set of toolbar tabs.
    @permissions ui
  */
  abstract class ToolbarTabs extends Base {
    /**
      Returns the specified toolbar tab using an index into the collection.
      When iterating by index, the tabs are returned in the same order as they are shown in the user interface.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ToolbarTab | null
    /**
      Returns the ToolbarTab at the specified ID.
      @param id The Id of the tab within the collection to return.
      @returns Returns the ToolbarTab of the specified id or null if no tab has the specified id.
    */
    itemById(id: string): ToolbarTab | null
    /**
      Gets the number of ToolbarTabs.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new ToolbarTab. The tab is initially empty.
      This method appends the tab to the end of the collection.
      @param id The unique id for this tab. The id must be unique with respect to all of the tabs.
      @param name The displayed name of this tab. This is the name visible in the user interface.
      @returns Returns the newly created tab or null in the case the creation failed.
    */
    add(id: string, name: string): ToolbarTab | null
  }

  /**
    A ToolbarTabList is a list of ToolbarTab objects.
    @permissions ui
  */
  abstract class ToolbarTabList extends Base {
    /**
      Returns the specified tab using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ToolbarTab | null
    /**
      Returns the ToolbarTab of the specified ID.
      @param id The ID of the ToolbarTab to get.
      @returns Returns the specified ToolbarTab or null in the case where there isn't a ToolbarTab with the specified ID.
    */
    itemById(id: string): ToolbarTab | null
    /**
      Gets the number of toolbar tabs in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Toolbar tabs are the tabs shown in the command toolbar.
    @permissions ui
  */
  abstract class ToolbarTab extends Base {
    /**
      Gets The unique, language independent, ID of this tab.
    */
    readonly id: string
    /**
      Gets the position this tab is in within the toolbar.
      The first tab is at position 0. This value is with respect
      to the complete list of tabs so this value could be outside
      of the expected range if you have a collection of tabs
      associated with a workspace, which is a subset of the entire
      list of tabs.
    */
    readonly index: number /*unsigned int*/
    /**
      Gets or sets whether this tab is currently being displayed in the user interface.
      By default, a tab is made visible if it is associated with the active workspace and hidden
      otherwise. Setting it here will override that default behavior.
    */
    isVisible: boolean
    /**
      Gets or sets the name of the tab as seen in the user interface.
    */
    name: string
    /**
      Gets the collection containing the panels associated with this tab.
      It's through this collection that you can add new toolbar panels.
    */
    readonly toolbarPanels: ToolbarPanels
    /**
      Gets the parent UserInterface object.
    */
    readonly parentUserInterface: UserInterface
    /**
      Returns the name of the product this toolbar tab is associated with.
    */
    readonly productType: string
    /**
      Gets if this toolbar tab is currently active - i.e. displayed.
    */
    readonly isActive: boolean
    /**
      Activate this toolbar tab.
      @returns Boolean return that indicates if the activation was successful or not.
    */
    activate(): boolean
    /**
      Gets if this tab is native to Fusion or was created via the API.
    */
    readonly isNative: boolean
    /**
      Deletes this tab. Fusion native tabs cannot be deleted. Use the
      isNative property to determine if this is a native or API created tab.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Move this tab to a different position in the Toolbar in the user interface.
      @param positionId The ID of another ToolbarTab in the same Toolbar that is used to position this tab. This tab
      will be positioned either directly before or after it.
      @param isBefore If true, then this tab will be positioned directly before the tab indicated by positionID. If
      false, then this tab will be positioned after it.
      @returns Returns true if it was successful.
    */
    move(positionId: string, isBefore: boolean): boolean
  }

  /**
    Provides access to a list of toolbar controls.
    @permissions ui
  */
  abstract class ToolbarControlList extends Base {
    /**
      Returns the ToolbarControl at the specified index.
      When iterating by index, the controls are returned
      in the same order as they are shown in the user interface.
      @param index The index of the control within the collection to return. The first item in the
      collection has in index of 0.
      @returns Returns the ToolbarControl at the specified index or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ToolbarControl | null
    /**
      Returns the ToolbarControl at the specified ID.
      @param id The ID of the control within the collection to return.
      @returns Returns the ToolbarControl with the specified ID or null if no control has this ID.
    */
    itemById(id: string): ToolbarControl | null
    /**
      Gets the number of toolbar controls.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    ToolbarControls is a collection of ToolbarControl objects displayed in a toolbar or menu.
    @permissions ui
  */
  abstract class ToolbarControls extends Base {
    /**
      Gets the number of controls in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the ToolbarControl at the specified index.
      When iterating by index, the controls are returned
      in the same order as they are shown in the user interface.
      @param index The index of the control within the collection to return. The first item in the
      collection has in index of 0.
      @returns Returns the ToolbarControl at the specified index or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ToolbarControl | null
    /**
      Returns the ToolbarControl at the specified ID.
      @param id The ID of the control within the collection to return.
      @returns Returns the ToolbarControl with the specified ID or null if no control has this ID.
    */
    itemById(id: string): ToolbarControl | null
    /**
      Adds a button to the controls in the toolbar, panel, or drop-down. The ID of the created
      command control is inherited from the associated command definition.
      @param commandDefinition The associated CommandDefinition that defines the resources and receives events related to this control.
      @param positionID Specifies the reference id of the control to position this control relative to.
      Not setting this value indicates that the control will be created at the end of all other controls in toolbar. The isBefore
      parameter specifies whether to place the control before or after the reference control.
      @param isBefore Specifies whether to place the control before or after the reference control specified by the positionID parameter.
      This argument is ignored is positionID is not specified.
      @returns Returns the newly created CommandControl object or null if the creation fails.
    */
    addCommand(commandDefinition: CommandDefinition, positionID?: string/* = ""*/, isBefore?: boolean/* = true*/): CommandControl | null
    /**
      Adds a drop-down to the controls in the toolbar, panel, or drop-down. When the drop-down is initially created it will be empty.
      you can get the associated ToolbarControls object from the DropDownControl to add additional controls to the drop-down.
      @param text The text displayed for the drop-down in a menu. For a drop-down in a toolbar this argument is ignored
      because an icon is used.
      @param resourceFolder This argument defines the resource folder that contains the images used for the icon when the drop-down is in a toolbar.
      Icons can be defined using either PNG or SVG files. More information about icons can be found in the user manual
      topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
      @param id Optional unique ID for the control. It must be unique with respect to other controls in this collection.
      If the default empty string is provided, Fusion will create a unique ID.
      @param positionID Specifies the reference id of the control to position this control relative to.
      Not setting this value indicates that the control will be created at the end of all other controls in toolbar. The isBefore
      parameter specifies whether to place the control before or after the reference control.
      @param isBefore Specifies whether to place the control before or after the reference control specified by the positionID parameter.
      This argument is ignored is positionID is not specified.
      @returns Returns the newly created DropDownControl object or null if the creation fails.
    */
    addDropDown(text: string, resourceFolder: string, id?: string/* = ""*/, positionID?: string/* = ""*/, isBefore?: boolean/* = true*/): DropDownControl | null
    /**
      Adds a separator to the controls in the toolbar, panel, or drop-down.
      @param id Optional unique ID for the control. It must be unique with respect to other controls in this collection.
      If the default empty string is provided, Fusion will create a unique ID.
      @param positionID Specifies the reference id of the control to position this separator control relative to.
      Not setting this value indicates that the separator control will be created at the end of all other controls in toolbar.
      The isBefore parameter specifies whether to place the control before or after the reference control.
      @param isBefore Specifies whether to place the separator control before or after the reference control specified by the positionID parameter.
      This argument is ignored is positionID is not specified.
      @returns Returns the newly created separator controls or null if the creation fails.
    */
    addSeparator(id?: string/* = ""*/, positionID?: string/* = ""*/, isBefore?: boolean/* = true*/): SeparatorControl | null
    /**
      Adds a split button to the controls in a toolbar. A split button has two active areas that the user can click
      the main button portion and the drop-down arrow. Clicking the main button, executes the displayed command.
      Clicking the drop-down displays the drop-down with additional commands.
      The split button itself does not fire any events, but the buttons within it will fire events to their associated
      command definitions.
      @param defaultDefinition A command definition that will be used to create the main button. A button will also be created in the drop-down
      for this definition.
      @param additionalDefinitions An array of command definitions that will be used to create the buttons on the drop-down.
      @param showLastUsed Specifies if the split button should have the behavior where the command shown on the main button changes
      to the last executed command.
      @param id Optional unique ID for the control. It must be unique with respect to other controls in this collection.
      If the default empty string is provided, Fusion will create a unique ID.
      @param positionID Specifies the reference id of the control to position this control relative to.
      Not setting this value indicates that the control will be created at the end of all other controls in toolbar. The isBefore
      parameter specifies whether to place the control before or after the reference control.
      @param isBefore Specifies whether to place the control before or after the reference control specified by the positionID parameter.
      This argument is ignored is positionID is not specified
      @returns Returns the newly created SplitButtonControl object or null if the creation fails.
    */
    addSplitButton(defaultDefinition: CommandDefinition, additionalDefinitions: CommandDefinition[], showLastUsed: boolean, id?: string/* = ""*/, positionID?: string/* = ""*/, isBefore?: boolean/* = true*/): SplitButtonControl | null
  }

  /**
    The base class for all toolbar controls.
    @permissions ui
  */
  abstract class ToolbarControl extends Base {
    /**
      Gets the unique ID of this control. The ID is unique with respect to the other
      controls within the same panel, toolbar, or drop-down control.
    */
    readonly id: string
    /**
      Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control.
    */
    readonly index: number /*unsigned int*/
    /**
      Gets or sets if this control is currently visible.
    */
    isVisible: boolean
    /**
      Gets the Parent object. When associated with a toolbar (right or left QAT or the NavBar) this
      returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
      When associated with a control (DropDownControl) it returns the parent control.
    */
    readonly parent: core.Base
    /**
      Deletes the ToolbarControl
      @returns Returns a boolean indicating if the deletion was successful.
    */
    deleteMe(): boolean
  }

  /**
    Represents a separator within a panel, toolbar, or drop-down control.
    @permissions ui
  */
  abstract class SeparatorControl extends ToolbarControl {
  }

  /**
    Represents a button, check box, or radio control list in a panel, toolbar, or drop-down.
    @permissions ui
  */
  abstract class CommandControl extends ToolbarControl {
    /**
      Gets the command definition associated with this button. The command definition defines
      all of the resource information used to display this button and receives the event when the button is clicked.
    */
    readonly commandDefinition: CommandDefinition
    /**
      Gets or sets if this command has been promoted to the parent panel.
      This property is ignored in the case where this control isn't in a panel.
      The promote method provides more options over how the control is promoted.
    */
    isPromoted: boolean
    /**
      Gets or sets if this command is a default command in the panel.
      This defines the default state of the panel if the UI is reset.
      This property is ignored in the case where this control isn't in a panel.
      The promote method provides more options over how the control is promoted.
    */
    isPromotedByDefault: boolean
    /**
      Promote the command to the parent panel and optionally position it relative to an already-
      promoted control.
      @param byDefault If true, then the control will be promoted in the panel by default if the UI is reset. If
      false, then the promotion is cleared on reset.
      @param positionID If provided, then when this control is promoted, it will be positioned in the panel relative
      to the already-promoted control with this ID.
      @param isBefore If a positionID is provided, then this specifies whether the promoted control is placed before
      or after the control referenced by the positionID parameter.
      @returns True if this control was successfully promoted or was already promoted. False if promotion
      failed, which may happen if the control is not in a panel.
    */
    promote(byDefault?: boolean/* = false*/, positionID?: string/* = ""*/, isBefore?: boolean/* = true*/): boolean
  }

  /**
    A split button has two active areas that the user can click
    the main button portion and the drop-down arrow. Clicking the main button, executes the displayed command.
    Clicking the drop-down displays the drop-down with additional commands.
    @permissions ui
  */
  abstract class SplitButtonControl extends ToolbarControl {
    /**
      Gets the command definition that is used as the default command on the main portion of the split button.
    */
    readonly defaultCommandDefinition: CommandDefinition
    /**
      Gets if this button behaves where the last executed command becomes the command on the main portion of the split button.
    */
    readonly isLastUsedShown: boolean
    /**
      Gets or sets the command definitions used to define the buttons associated with the split button.
    */
    additionalDefinitions: CommandDefinition[]
  }

  /**
    Represents a drop-down control.
    @permissions ui
  */
  abstract class DropDownControl extends ToolbarControl {
    /**
      Gets the associated ToolbarControls collection. Through this you can add additional controls to the drop-down.
    */
    readonly controls: ToolbarControls
    /**
      This argument defines the resource folder that contains the images used for the icon when icons are used
      in the drop-down. Icons can be defined using either PNG or SVG files. More information about icons can be found
      in the user manual topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
    */
    resourceFolder: string
    /**
      Gets or sets the Name displayed for this drop down. This isn't used when the drop-down is in a toolbar because an icon is used in that case.
    */
    name: string
  }

  /**
    Represents the marking menu which is the round menu that's displayed when the user right-clicks
    within Fusion. This supports customizing the contents of the marking menu.
    @permissions ui
  */
  abstract class RadialMarkingMenu extends core.Base {
    /**
      This is used to create a sub-menu in a marking menu. This method creates a new,
      empty marking menu which can then be assigned to a position in the displayed
      marking menu to define the sub-menu.
      @param text The text that will be displayed in the parent menu to access this menu.
      @returns Returns the newly created marking menu or null in the case of a failure.
    */
    create(text: string): RadialMarkingMenu | null
    /**
      Gets and sets the text that is displayed in the parent marking menu to access a
      sub marking menu. This property is not used for the main marking menu and will
      return an empty string and setting it will have no effect.
    */
    text: string
    /**
      Completely clears the contents of the marking menu. If left in this state, the
      marking menu will not be displayed.
      @returns Returns true if the clear was successful.
    */
    clear(): boolean
    /**
      Gets and sets the command definition that's displayed in the East position (right) of
      the marking menu. Setting this to null indicates that the East position should be empty.
      This can also return or be set with a MarkingMenu object which is used to have a sub-menu.
      New marking menus can be created using the create method and then assigned
      to the desired position in the marking menu.
    */
    eastCommand: core.Base
    /**
      Gets and sets the command definition that's displayed in the North position (top) of the
      marking menu. Setting this to null indicates that the North position should be empty.
      This can also return or be set with a MarkingMenu object which is used to have a sub-menu.
      New marking menus can be created using the create method and then assigned
      to the desired position in the marking menu.
    */
    northCommand: core.Base
    /**
      Gets and sets the command definition that's displayed in the Northeast position (top-right) of
      the marking menu. Setting this to null indicates that the Northeast position should be empty.
      This can also return or be set with a MarkingMenu object which is used to have a sub-menu.
      New marking menus can be created using the create method and then assigned
      to the desired position in the marking menu.
    */
    northeastCommand: core.Base
    /**
      Gets and sets the command definition that's displayed in the West position (left) of
      the marking menu. Setting this to null indicates that the West position should be empty.
      This can also return or be set with a MarkingMenu object which is used to have a sub-menu.
      New marking menus can be created using the create method and then assigned
      to the desired position in the marking menu.
    */
    westCommand: core.Base
    /**
      Gets and sets the command definition that's displayed in the Northwest position (upper-left) of
      the marking menu. Setting this to null indicates that the Northwest position should be empty.
      This can also return or be set with a MarkingMenu object which is used to have a sub-menu.
      New marking menus can be created using the create method and then assigned
      to the desired position in the marking menu.
    */
    northwestCommand: core.Base
    /**
      Gets and sets the command definition that's displayed in the Southwest position (bottom-left) of
      the marking menu. Setting this to null indicates that the Southwest position should be empty.
      This can also return or be set with a MarkingMenu object which is used to have a sub-menu.
      New marking menus can be created using the create method and then assigned
      to the desired position in the marking menu.
    */
    southwestCommand: core.Base
    /**
      Gets and sets the command definition that's displayed in the South position (bottom) of
      the marking menu. Setting this to null indicates that the South position should be empty.
      This can also return or be set with a MarkingMenu object which is used to have a sub-menu.
      New marking menus can be created using the create method and then assigned
      to the desired position in the marking menu.
    */
    southCommand: core.Base
    /**
      Gets and sets the command definition that's displayed in the Southeast position (bottom-right) of
      the marking menu. Setting this to null indicates that the Southeast position should be empty.
      This can also return or be set with a MarkingMenu object which is used to have a sub-menu.
      New marking menus can be created using the create method and then assigned
      to the desired position in the marking menu.
    */
    southeastCommand: core.Base
  }

  /**
    Represents the linear marking menu which is the vertical menu that's displayed when the user right-clicks
    within Fusion. This supports customizing the contents of the context menu.
    @permissions ui
  */
  abstract class LinearMarkingMenu extends core.Base {
    /**
      Return the collection of top-level controls in the context menu. It's possible to have
      drop-down controls (fly-outs) that provide access to additional controls. You can
      remove and add controls to customize the contents of the context menu.
    */
    readonly controls: ToolbarControls
    /**
      Completely clears the contents of the context menu. If left in this state, the
      context menu will not be displayed.
      @returns Returns true if the clear was successful.
    */
    clear(): boolean
  }

  /**
    Provides access to a set of palettes, which are docked or floating windows that display HTML.
    @permissions ui
  */
  abstract class Palettes extends Base {
    /**
      Creates a new Palette.
      @param id The unique id for this palette. The id must be unique with respect to all of the palettes.
      @param name The displayed name of this palette. This is the name visible in the user interface.
      @param htmlFileURL Specifies the URL to the HTML file that will be displayed in the palette. This can be a local file or on the web.
      @param isVisible Specifies if the palette is initially visible or not. It's useful to create it invisibly, change other desired
      properties and then use the isVisible property to finally make it visible to the user.
      @param showCloseButton Specifies if a "Close" button should be displayed on the palette to allow the user to easily close it.
      @param isResizable Specifies if the palette can be resized by the user or not.
      @param width Specifies the width of the palette in pixels. If no width is specified a default width will be used.
      @param height Specifies the height of the palette in pixels. If no height is specified a default height will be used.
      @param useNewWebBrowser Specifies if you want to use the old or new web browser. A palette is essentially a dialog that hosts
      a web browser. To support this type of functionality, Fusion has used CEF (Chromium Embedded Framework).
      Fusion is in the process of switching to the Qt Web Browser wherever an embedded browser is needed in the product.
      As this transition occurs, Fusion is supporting both web browsers. This argument is optional and defaults
      to False, which means the palette will behave as before and use the CEF browser. Setting the argument to
      True will cause the palette to use the new QT Web Browser.
      When Fusion completes the transition to the QT Web Browser, support for the CEF browser will be removed from Fusion,
      and you will always get a QT Web Browser regardless of how the argument is set. Because of this, it is highly
      recommended you set this argument to true to use the new browser because when support for the CEF browser is removed
      you will automatically be forced to use the QT Web Browser.
      This argument is no longer used because the new QT Web Browser is always used regardless of this parameter's value.
      @returns Returns the newly created palette or null in the case the creation failed.
    */
    add(id: string, name: string, htmlFileURL: string, isVisible: boolean, showCloseButton: boolean, isResizable: boolean, width?: number /*int*//* = 200*/, height?: number /*int*//* = 200*/, useNewWebBrowser?: boolean/* = true*/): Palette | null
    /**
      Returns the specified palette using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Palette | null
    /**
      Returns the palette at the specified ID.
      @param id The Id of the palette within the collection to return.
      @returns Returns the palette of the specified id or null if no palette has the specified id.
    */
    itemById(id: string): Palette | null
    /**
      Gets the number of Palettes.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new Palette.
      @param id The unique id for this palette. The id must be unique with respect to all of the palettes.
      @param name The displayed name of this palette. This is the name visible in the user interface.
      @param htmlFileURL Specifies the URL to the HTML file that will be displayed in the palette. This can be a local file or a URL on the web
      where the HTML will be read. To avoid reading a file, this can also be the full HTML definition as a string.
      If you are providing the HTML content as a string, it should begin with the <html> element. Any references made
      in the HTML should be to URL's and not local files since the local path is ambiguous.
      @param isVisible Specifies if the palette is initially visible or not. It's useful to create it invisibly, change other desired
      properties and then use the isVisible property to finally make it visible to the user.
      @param showCloseButton Specifies if a "Close" button should be displayed on the palette to allow the user to easily close it.
      @param isResizable Specifies if the palette can be resized by the user or not.
      @param width Specifies the width of the palette in pixels. If no width is specified a default width will be used.
      @param height Specifies the height of the palette in pixels. If no height is specified a default height will be used.
      @returns Returns the newly created palette or null in the case the creation failed.
    */
    add2(id: string, name: string, htmlFileURL: string, isVisible: boolean, showCloseButton: boolean, isResizable: boolean, width?: number /*int*//* = 200*/, height?: number /*int*//* = 200*/): Palette | null
    /**
      Creates a new transparent Palette.
      @param id The unique id for this palette. The id must be unique with respect to all of the palettes.
      @param name The displayed name of this palette. This is the name visible in the user interface.
      @param htmlFileURL Specifies the URL to the HTML file that will be displayed in the palette. This can be a local file or on the web.
      @param isVisible Specifies if the palette is initially visible or not. It's useful to create it invisibly, change other desired
      properties and then use the isVisible property to finally make it visible to the user.
      @param showCloseButton Specifies if a "Close" button should be displayed on the palette to allow the user to easily close it.
      @param isResizable Specifies if the palette can be resized by the user or not.
      @param isOpaqueWhenUndocked Specifies if the palette will be transparent when docked and opaque when undocked.
      @param width Specifies the width of the palette in pixels. If no width is specified a default width will be used.
      @param height Specifies the height of the palette in pixels. If no height is specified a default height will be used.
      @returns Returns the newly created palette or null in the case the creation failed.
    */
    addTransparent(id: string, name: string, htmlFileURL: string, isVisible: boolean, showCloseButton: boolean, isResizable: boolean, isOpaqueWhenUndocked?: boolean/* = false*/, width?: number /*int*//* = 200*/, height?: number /*int*//* = 200*/): Palette | null
  }

  /**
    Defines the different options available when docking a palette to the Fusion main window area.
    @permissions ui
  */
  const enum PaletteDockingOptions {
    /**
      Specifies the palette cannot be docked to the Fusion main window area.
    */
    PaletteDockOptionsNone,
    /**
      Specifies that the palette can only be docked to the sides of the Fusion main window area.
    */
    PaletteDockOptionsToVerticalOnly,
    /**
      Specifies that the palette can only be docked to the top and bottom of the Fusion main window area.
    */
    PaletteDockOptionsToHorizontalOnly,
    /**
      Specifies that the palette can be docked to the sides, top, or bottom of the Fusion main window area.
    */
    PaletteDockOptionsToVerticalAndHorizontal,
  }

  /**
    Defines the various docking states that a palette can be in.
    @permissions ui
  */
  const enum PaletteDockingStates {
    /**
      The palette is not docked but is floating.
    */
    PaletteDockStateFloating,
    /**
      The palette is docked to the top of the main window area.
    */
    PaletteDockStateTop,
    /**
      The palette is docked to the bottom of the main window area.
    */
    PaletteDockStateBottom,
    /**
      The palette is docked to the left of the main window area.
    */
    PaletteDockStateLeft,
    /**
      The palette is docked to the right of the main window area.
    */
    PaletteDockStateRight,
  }

  /**
    Defines the various positions that a palette can be snapped to another palette.
    @permissions ui
  */
  const enum PaletteSnapOptions {
    /**
      Specifies the palette is snapped to the top of another palette.
    */
    PaletteSnapOptionsTop,
    /**
      Specifies the palette is snapped to the left of another palette.
    */
    PaletteSnapOptionsLeft,
    /**
      Specifies the palette is snapped to the right of another palette.
    */
    PaletteSnapOptionsRight,
    /**
      Specifies the palette is snapped to the bottom of another palette.
    */
    PaletteSnapOptionsBottom,
  }

  /**
    A Palette is a floating or docked dialog in Fusion. The browser is an
    example of a built-in palette. The contents of a custom palette are
    created by displaying an HTML file.
    @permissions ui
  */
  abstract class Palette extends Base {
    /**
      Gets The unique, language independent, ID of this palette.
    */
    readonly id: string
    /**
      Gets and sets whether this palette is currently being displayed in the user interface.
    */
    isVisible: boolean
    /**
      Gets and sets the URL to the HTML file that will be displayed in the palette. This can be a local file or a URL on the web
      where the HTML will be read. To avoid reading a file, this can also be the full HTML definition as a string.
      If you are providing the HTML content as a string, it should begin with the <html> element. Any references made
      in the HTML should be to URL's and not local files since the local path is ambiguous.
    */
    htmlFileURL: string
    /**
      Sends the string to the JavaScript associated with the loaded HTML.
      @remarks
      A variation of the event handler below should be implemented in the JavaScript associated
      with the HTML to receive the data. The event will be triggered by Fusion whenever the
      sendInfoToHTML method is called.
      ```
      window.fusionJavaScriptHandler = {
          handle: function(actionString, dataString){
              confirm('Action from Fusion: ' + actionString)
              confirm('Data from Fusion: ' + dataString)
              // Build up JSON return string.
              var result = {}
              result.status = 'OK'
              var response = JSON.stringify(result)
              return response
          }
      }
      ```
      Your JavaScript code should always return something in response because an empty string
      response is assumed to be a failure.
      @param action The "action" string to pass to the JavaScript associated with the HTML. This string can be
      anything but will typically be JSON formatted information.
      @param data The "data" string to pass to the JavaScript associated with the HTML. This string can be
      anything but will typically be JSON formatted information.
      @returns Returns a string that can be anything that your JavaScript code generates. The JavaScript
      should always return some content because an empty string is used to indicate a failure.
      If useNewWebBrowser flag is set to true while creating the palette control this API call
      will be asynchronous and an empty string is returned. Response will come in data field of HTMLEvent with action
      equal to 'response'.
      @permissions desktop
    */
    sendInfoToHTML(action: string, data: string): string
    /**
      This event is fired when the JavaScript associated with the HTML calls the
      adsk.fusionSendData function. This allows the HTML to communicate with the add-in by
      passing information to the add-in.
      @permissions desktop
    */
    readonly incomingFromHTML: HTMLEvent
    /**
      This event is fired when the user clicks the "Close" button on the palette. You can choose
      if the "Close" button is available or not when you initially create the palette. When a
      palette is closed, it still exists but is change to invisible so you can still interact with it and
      retrieve any needed information and can make it visible again. Use the deleteMe method to
      delete the palette.
      @permissions desktop
    */
    readonly closed: UserInterfaceGeneralEvent
    /**
      Gets and set the name of the palette as seen in the user interface. The name of native palettes
      cannot be set.
    */
    name: string
    /**
      Deletes this palette. Fusion native palettes cannot be deleted. Use the
      isNative property to determine if this is a native or API created palette.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Indicates if this is one of the standard Fusion palettes or a custom palette
      created through the API. If true, it is a standard Fusion palette and will
      have some restrictions on changing its properties and cannot be deleted.
    */
    readonly isNative: boolean
    /**
      Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette.
    */
    dockingOption: PaletteDockingOptions
    /**
      Gets and sets how the palette is currently docked.
    */
    dockingState: PaletteDockingStates
    /**
      Gets and sets the width of the palette. Setting this property may not always set the width. Depending on
      how the palette is docked or snapped, the width may not be editable.
    */
    width: number /*int*/
    /**
      Gets and sets the height of the palette. Setting this property may not always set the height. Depending on
      how the palette is docked or snapped, the height may not be editable.
    */
    height: number /*int*/
    /**
      Sets the position of the palette. If the palette is docked or snapped, this will result in changing it
      to be floating.
      @param left The position of the left side of the palette relative to screen space and in pixels. Because palettes can be
      positioned outside of the Fusion window, a value of zero indicates the left side of the screen and not the
      Fusion window.
      @param top The position of the top of the palette relative to screen space and in pixels. Because palettes can be
      positioned outside of the Fusion window, a value of zero indicates the top of the screen and not the
      Fusion window.
      @returns Returns true if setting the position was successful.
    */
    setPosition(left: number /*int*/, top: number /*int*/): boolean
    /**
      Sets the size of the palette. This is best used for a floating palette because either the width or
      height can be locked when a palette is docked.
      @param width Specifies the width of the palette. Depending on how the palette is docked or snapped, the width
      may not be editable.
      @param height Specifies the height of the palette. Depending on how the palette is docked or snapped, the height
      may not be editable.
      @returns Returns true if the sizing was successful. It is still considered a success even if the width or
      height could not be changed because of how the palette is docked or snapped.
    */
    setSize(width: number /*int*/, height: number /*int*/): boolean
    /**
      Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be
      positioned outside of the Fusion window, a value of zero indicates the left side of the screen and not the
      Fusion window.
    */
    left: number /*int*/
    /**
      Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be
      positioned outside of the Fusion window, a value of zero indicates the top of the screen and not the
      Fusion window.
    */
    top: number /*int*/
    /**
      Snaps this palette to another palette.
      @param palette Specifies the palette to snap to.
      @param snapOption Specifies how this palette should be snapped to the other palette.
      @returns Returns true if the palette was successfully snapped to the other palette.
    */
    snapTo(palette: Palette, snapOption: PaletteSnapOptions): boolean
    /**
      Sets the minimum size of the palette. The user cannot resize it to be smaller than
      this size. This does not change the current size of the palette unless the palette
      is already smaller than this size.
      Calling this method and setting the width and height to zero, removes the minimum
      size restriction.
      @param width Specifies the minimum width of the palette.
      @param height Specifies the minimum height of the palette.
      @returns Returns true if setting the minimum size was successful.
    */
    setMinimumSize(width: number /*int*/, height: number /*int*/): boolean
    /**
      Sets the maximum size of the palette. The user cannot resize it to be larger than
      this size. This does not change the current size of the palette unless the palette
      is already larger than this size.
      Calling this method and setting the width and height to zero, removes the maximum
      size restriction.
      @param width Specifies the maximum width of the palette.
      @param height Specifies the maximum height of the palette.
      @returns Returns true if setting the maximum size was successful.
    */
    setMaximumSize(width: number /*int*/, height: number /*int*/): boolean
    /**
      This event is fired when a navigation event occurs on the page. This allows the add-in to determine
      how this navigation should be handled by the browser.
      @permissions desktop
    */
    readonly navigatingURL: NavigationEvent
    /**
      Returns if this palette was created as a transparent palette.
    */
    readonly isTransparent: boolean
  }

  /**
    Represents the palette that is the Text Command window in Fusion.
    @remarks
    You can obtain the Text Command palette by using the itemById method of the Palettes object
    and using "TextCommands" as the ID. Below is some sample code that illustrates making sure the palette is visible
    and writing some text to it.
    ```
    textPalette = ui.palettes.itemById('TextCommands')
    if not textPalette.isVisible:
       textPalette.isVisible = True
    textPalette.writeText('This is a text message.')
    ```
    @permissions ui
  */
  abstract class TextCommandPalette extends Palette {
    /**
      Write the specified text to the TEXT COMMAND window.
      @remarks
      ```
      textPalette = ui.palettes.itemById('TextCommands')
      if not textPalette.isVisible:
         textPalette.isVisible = True
      textPalette.writeText('This is a text message.')
      ```
      @param text The text to write to the Text Command window.
      @returns Returns true if successful.
    */
    writeText(text: string): boolean
  }

  /**
    A UserInterfaceGeneralEvent is used for user-interface related events that don't
    require any additional information beyond getting the event itself.
    @permissions ui
  */
  abstract class UserInterfaceGeneralEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: UserInterfaceGeneralEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: UserInterfaceGeneralEventHandler): boolean
  }

  /**
    The UserInterfaceGeneralEventArgs is passed when a UserInterfaceGeneralEvent is fired.
    @permissions ui
  */
  abstract class UserInterfaceGeneralEventArgs extends EventArgs {
  }

  /**
    The UserInterfaceGeneralEventHandler is a client implemented class that can be
    added as a handler to a UserInterfaceGeneralEvent event and which is triggered when the event is fired.
    @permissions ui
  */
  abstract class UserInterfaceGeneralEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: UserInterfaceGeneralEventArgs): void
  }

  /**
    A HTMLEvent is fired when triggered from JavaScript code associated with HTML used
    in a palette.
    @permissions ui
  */
  abstract class HTMLEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: HTMLEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: HTMLEventHandler): boolean
  }

  /**
    The HTMLEventArgs provides access to the information sent from the JavaScript
    that's associated with HTML being displayed within a palette.
    @permissions ui
  */
  abstract class HTMLEventArgs extends EventArgs {
    /**
      The action string sent from the JavaScript associated with HTML displayed
      in the palette. The string can represent any type of data in any format but
      JSON is commonly used to pass more complex data.
    */
    readonly action: string
    /**
      The data string sent from the JavaScript associated with HTML displayed
      in the palette. The string can represent any type of data in any format but
      JSON is commonly used to pass more complex data.
    */
    readonly data: string
    /**
      Set this property to return data back to the JavaScript that's associated with the HTML.
    */
    returnData: string
    /**
      When the event is fired from a BrowserCommandInput object, this property returns
      the specific BrowserCommandInput that caused the event to fire. In all other cases
      this property returns null.
    */
    readonly browserCommandInput: BrowserCommandInput
  }

  /**
    The HTMLEventHandler is a client implemented class that can be added as a handler to a HTML
    event which is triggered by JavaScript that associated with HTML displayed within a palette
    calling the adsk.fusionSendData function to send data from the HTML back to your add-in.
    @permissions ui
  */
  abstract class HTMLEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: HTMLEventArgs): void
  }

  /**
    A NavigationEvent is fired when a link is navigated on the page in a palette.
    @permissions ui
  */
  abstract class NavigationEvent extends Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: NavigationEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: NavigationEventHandler): boolean
  }

  /**
    The NavigationEventArgs provides access to the information sent from the browser
    within a palette on a navigation event.
    @permissions ui
  */
  abstract class NavigationEventArgs extends EventArgs {
    /**
      The URL that is being navigated to.
    */
    navigationURL: string
    /**
      If True, the URL will be navigated to in an external browser by the operating system.
      If False, the default value, the URL will be navigated to in the palette's browser.
    */
    launchExternally: boolean
    /**
      If True, the default handling of this navigation event will not continue.
      If False, the default value, the default handling of this navigation event will continue.
    */
    preventDefault: boolean
    /**
      When the event is fired from a BrowserCommandInput object, this property returns
      the specific BrowserCommandInput that caused the event to fire. In all other cases
      this property returns null.
    */
    readonly browserCommandInput: BrowserCommandInput
  }

  /**
    The NavigationEventHandler is a client implemented class that can be added as a handler to a Navigation
    event which is triggered by the browser within a palette.
    @permissions ui
  */
  abstract class NavigationEventHandler extends EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: NavigationEventArgs): void
  }

  /**
    Provides access to all of the available command definitions. This is all those created via
    the API but also includes the command definitions defined by Fusion for the native commands.
    @permissions ui
  */
  abstract class CommandDefinitions extends Base {
    /**
      Creates a new command definition that can be used to create a button control and handle the response when the button is clicked.
      @param id The unique identifier for this command definition. It must be unique with respect to all other command definitions and is
      limited to the following set of characters, [A-Z][a-z][0-9] and _.
      @param name The name displayed in the UI for the associated button control.
      @param tooltip The full description of the command as seen in the extended tooltip in the user interface.
      Using the returned CommandDefinition you can also optionally set the toolClipFilename property
      to show an image the extended tooltip.
      The width of all tooltips is limited to 300 pixels. Word wrapping is enabled, so Fusion will automatically
      break the line and flow your text to the next line. However, if you include a long word that exceeds
      300 pixels, it doesn't wrap and the right portion will be clipped. This is common when displaying paths
      or URL's. If a single word is longer than 300 pixels there are a couple of options to avoid the clipping.
      The first option is to insert one or more zero width space characters within the word to define where the
      word should be broken. The UNICODE character '\u200b' defines a zero width space. This is not displayed is only used
      to designate a possible break point.
      The second option is to shorten the word by removing a section. For example, if the word is a full path to a
      file and a portion of the path is common you can remove that portion and replace it with the ellipsis character
      to indicate there is some missing text. There is a single UNICODE character you can use the ellipsis. It is '\u2026'.
      @param resourceFolder This argument defines the resource folder that contains the images used for the icon. Icons can be
      defined using either PNG or SVG files. More information about icons can be found
      in the user manual topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
      This is an optional argument and if not provided a default icon will be used.
      @returns Returns the created CommandDefinition object or null if the creation failed.
    */
    addButtonDefinition(id: string, name: string, tooltip: string, resourceFolder?: string/* = ""*/): CommandDefinition | null
    /**
      Creates a new command definition that can be used to create a single check box control and handle the response when the check box is clicked.
      @param id The unique identifier for this command definition. It must be unique with respect to all other command definitions and is
      limited to the following set of characters, [A-Z][a-z][0-9] and _.
      @param name The name displayed in the UI for the associated check box control.
      @param tooltip The full description of the command as seen in the extended tooltip in the user interface.
      Using the returned CommandDefinition you can also optionally set the toolClipFilename property
      to show an image the extended tooltip.
      The width of all tooltips is limited to 300 pixels. Word wrapping is enabled, so Fusion will automatically
      break the line and flow your text to the next line. However, if you include a long word that exceeds
      300 pixels, it doesn't wrap and the right portion will be clipped. This is common when displaying paths
      or URL's. If a single word is longer than 300 pixels there are a couple of options to avoid the clipping.
      The first option is to insert one or more zero width space characters within the word to define where the
      word should be broken. The UNICODE character '\u200b' defines a zero width space. This is not displayed is only used
      to designate a possible break point.
      The second option is to shorten the word by removing a section. For example, if the word is a full path to a
      file and a portion of the path is common you can remove that portion and replace it with the ellipsis character
      to indicate there is some missing text. There is a single UNICODE character you can use the ellipsis. It is '\u2026'.
      @param isChecked Indicates if the initial state of the check box.
      @returns Returns the created CommandDefinition object or null if the creation failed.
    */
    addCheckBoxDefinition(id: string, name: string, tooltip: string, isChecked: boolean): CommandDefinition | null
    /**
      Creates a new command definition that can be used to create a list of check boxes, radio buttons, or text with an icon within a pop-up.
      When the list is of check boxes any combinations of items in the list can be checked. The drop-down also remains displayed allowing the user to
      check and uncheck multiple items however a CommandCreated event is fired for every change.
      When the list is of radio buttons or a list of text items, only one item in the list can be selected at a time.
      When an item is selected the drop-down is immediately dismissed.
      The items in the list and their initial state are defined using functionality on the associated ListControlDefinition, which is
      accessible through the returned CommandDefinition.
      @param id The unique identifier for this command definition. It must be unique with respect to all other command definitions and is
      limited to the following set of characters, [A-Z][a-z][0-9] and _.
      @param name The name displayed in the UI for the associated selected check box list control.
      @param listControlDisplayType Specifies the type of controls to be displayed within the list.
      @param resourceFolder This argument defines the resource folder that contains the images used as the icon for items in the list.
      Icons can be defined using either PNG or SVG files. More information about icons can be found
      in the user manual topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
      @returns Returns the created CommandDefinition object or null if the creation failed.
    */
    addListDefinition(id: string, name: string, listControlDisplayType: ListControlDisplayTypes, resourceFolder?: string/* = ""*/): CommandDefinition | null
    /**
      Returns the CommandDefinition at the specified index.
      @param index The index of the command definition within the collection to return. The first item in the
      collection has in index of 0.
      @returns Returns the CommandDefinition at the specified index or null if an invalid index is specified.
    */
    item(index: number /*unsigned int*/): CommandDefinition | null
    /**
      Returns the CommandDefinition that has the specified ID.
      @param id The ID of the command definition to return.
      @returns Returns the CommandDefinition with the specified ID or null if there isn't a command definition with that ID.
    */
    itemById(id: string): CommandDefinition | null
    /**
      Gets the number of command definitions.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The CommandDefinition is the base class of the various types of commands. Command types are based
    on the type of control used to execute them in the user-interface. For example, most commands will
    use a ButtonDefinition since they're executed using a button in the user-interface. A command definition
    contains the information that defines the user-interface. For example, the name and icon. The command
    definition and also gets the notification when the user interacts with the associated control.
    @permissions ui
  */
  abstract class CommandDefinition extends Base {
    /**
      Executes this command definition. This is the same as the user clicking
      a button that is associated with this command definition.
      @remarks
      The execute method is not supported within any of the Command related events because it
      results in starting a new command which has the side-effect of terminating the current
      command, which is your running command.
      @param input This argument is ignored and exists for possible future use.
      @returns Returns true or false indicating if the execution was successful.
    */
    execute(input?: NamedValues/* = null*/): boolean
    /**
      This event is fired when the associated control is manipulated by the user. A new Command object
      is created and passed back through this event which you can then use to interact with the user
      to get any input the command requires.
    */
    readonly commandCreated: CommandCreatedEvent
    /**
      Deletes this command definition. This is only valid for API created command definitions
      and will fail if the isNative property is true.
      @returns Returns true or false indicating if the deletion was successful.
    */
    deleteMe(): boolean
    /**
      Gets if this is a native command definition. If True then there
      are limitations to edits that can be done on the command definition.
      For example a native command definition cannot be deleted.
    */
    readonly isNative: boolean
    /**
      Gets the unique id for this command definition. This is guaranteed to be unique with
      respect to all other command definitions.
    */
    readonly id: string
    /**
      Gets or sets the full filename of the image file (PNG) used for the tool clip.
      The tooltip is always shown but as the user hovers over the control it will progressively display the tool clip along with the tooltip text.
    */
    toolClipFilename: string
    /**
      Gets or sets the tooltip string. This is always shown for commands. If the tooltip description and/or tool clip are also specified then
      the tooltip will progressively display more information as the user hovers the mouse over the control.
      The width of all tooltips is limited to 300 pixels. Word wrapping is enabled, so Fusion will automatically
      break the line and flow your text to the next line. However, if you include a long word that exceeds
      300 pixels, it doesn't wrap and the right portion will be clipped. This is common when displaying paths
      or URL's. If a single word is longer than 300 pixels there are a couple of options to avoid the clipping.
      The first option is to insert one or more zero width space characters within the word to define where the
      word should be broken. The UNICODE character '\u200b' defines a zero width space. This is not displayed is only used
      to designate a possible break point.
      The second option is to shorten the word by removing a section. For example, if the word is a full path to a
      file and a portion of the path is common you can remove that portion and replace it with the ellipsis character
      to indicate there is some missing text. There is a single UNICODE character you can use the ellipsis. It is '\u2026'.
    */
    tooltip: string
    /**
      This argument defines the resource folder that contains the images used for the command icon.
      Icons can be defined using either PNG or SVG files. More information about icons can be found
      in the user manual topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
    */
    resourceFolder: string
    /**
      Gets the ControlDefinition associated with this command. The control definition
      defines the type of control that can exist in the user interface to execute this command.
      You can use properties on the control definition to define the look and behavior of
      the control.
    */
    readonly controlDefinition: ControlDefinition
    /**
      Gets or sets the visible name of the command when seen in the user interface.
    */
    name: string
  }

  /**
    The ControlDefinition is the base class for the various types of control definitions.
    You can use properties on the control definition to define the look and behavior of
    the control.
    @permissions ui
  */
  abstract class ControlDefinition extends core.Base {
    /**
      Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls.
    */
    isEnabled: boolean
    /**
      Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface.
    */
    isVisible: boolean
    /**
      Gets or sets the name for this control. This is the visible name displayed in the user interface.
    */
    name: string
  }

  /**
    Represents the information used to define a button. This isn't the visible button control but
    is the information needed to create a button control and fully defines a button except for
    it's position within the user interface.
    @permissions ui
  */
  abstract class ButtonControlDefinition extends ControlDefinition {
  }

  /**
    Represents the information used to define a check box. This isn't the visible check box control but
    is the information needed to create a check box control and fully defines a check box except for
    it's position within the user interface.
    @permissions ui
  */
  abstract class CheckBoxControlDefinition extends ControlDefinition {
    /**
      Gets or sets whether the check box is checked. Changing this will result in changing any
      associated controls and will execute the associated command.
    */
    isChecked: boolean
  }

  /**
    Represents the information used to define a list of check boxes, radio buttons, or text with icons. This class
    isn't the visible list control but is the information needed to create a list control and fully defines a list except for
    it's position within the user interface.
    @permissions ui
  */
  abstract class ListControlDefinition extends ControlDefinition {
    /**
      Gets the associated ListControlItems collection through which you can add and modify items in the list.
    */
    readonly listItems: ListItems
    /**
      Gets how this list control will be displayed as a standard list, a list of check boxes, or a list of radio buttons.
    */
    readonly listControlDisplayType: ListControlDisplayTypes
    /**
      Gets the item in the list that was last selected. This can return null
      in the case where this control is displayed as a list of check boxes and there hasn't
      been any interaction by the end-user. In the case of a list of check boxes, this returns
      the item that was last clicked by the user, whether it was to check or uncheck the item.
      In the case of a list of radio buttons, this always returns the item that is currently selected.
    */
    readonly lastSelected: ListItem
  }

  /**
    The different types of items that can be displayed in a list control.
    @permissions ui
  */
  const enum ListControlDisplayTypes {
    /**
      The list control contains check boxes.
    */
    CheckBoxListType,
    /**
      The list controls contains radio buttons.
    */
    RadioButtonlistType,
    /**
      The list control is a list of text items with optional icons.
    */
    StandardListType,
  }

  /**
    Provides access to the list of items in a check box list. This object supports the ability to add
    items to the list and iterate through the existing items.
    @permissions ui
  */
  abstract class ListItems extends Base {
    /**
      Adds a new item to the list.
      @param name The name of this item as it is displayed in the list.
      @param isSelected Sets whether this item is selected or not. If this list is associated with a control
      or input that can only have one item selected any other selected items will be unselected
      and this one will be the only selected item.
      @param icon The path to the folder containing the image files to use for the icon. This is an optional
      argument but is required in the case of ButtonRowCommandInput objects. It is optional in
      the case of a DropDownCommandInput whose style is LabeledIconDropDownStyle and for
      ListControlType whose type is not RadioButtonListType. In other cases it is not used and
      is ignored.
      Icons can be defined using either PNG or SVG files. More information about icons can be found in the
      user manual topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
      @param beforeIndex The position of the item within the list. This value indicates the index of the current
      item to insert this new item just before. For example, a value of 0 will insert it before
      the first item in the list. An index of -1 will position the button at the bottom of the list.
      @returns Returns the new ListControlItem or null in the case of a failure.
    */
    add(name: string, isSelected: boolean, icon?: string/* = ""*/, beforeIndex?: number /*int*//* = -1*/): ListItem | null
    /**
      Adds a separator to the list. This is not supported for button rows.
      @param beforeIndex The position of the item within the list. This value indicates the index of the current
      item to insert this new item just before. For example, a value of 0 will insert it before
      the first item in the list. An index of -1 will position the button at the bottom of the list.
      @returns Returns the new ListControlItem or null in the case of a failure.
    */
    addSeparator(beforeIndex: number /*int*/): ListItem | null
    /**
      Returns the specified check box list item using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ListItem | null
    /**
      Gets the number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Clears all of the items from the list.
      @returns Returns true if successful.
    */
    clear(): boolean
  }

  /**
    Represents a single item in a check box list or a drop-down command input.
    @permissions ui
  */
  abstract class ListItem extends Base {
    /**
      Gets or sets the name of this item as displayed in the list. If
      this control is a separator (isSeparator is true) or it's a button row,
      setting this property is ignored and getting it will return an empty string.
    */
    name: string
    /**
      Gets or sets the location for the icon file used for this item in the list.
      This is the path to a directory that contains the image files associated
      with this item. This is only valid when this is a standard list or button row and is
      ignored for check box lists, radio control lists, and radio button groups.
    */
    icon: string
    /**
      Gets or sets whether this item is selected. If the item is
      being displayed as a check box, this controls whether it is
      checked or not. If it's a drop-down list or button row it controls whether
      this is the single selected item. Setting a drop-down list, button row item, or radio button
      from a group to be selected will unselect the currently selected item.
      For a standard list, this will get or set the single item currently
      selected. For a separator, setting this property is ignored and
      it will always return false.
    */
    isSelected: boolean
    /**
      Deletes this item from the list. In cases where there is the concept of active item in the
      list, like with a DropDownCommandInput, this method will fail if the item you're attempting
      to delete is currently active. You need to make another item active first, and then you can
      delete the item.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Gets the index position within the list of this item.
    */
    readonly index: number /*int*/
    /**
      Gets the parent CheckBoxListControlDefinition or object.
    */
    readonly parentList: core.Base
    /**
      Gets if this control is a separator.
    */
    readonly isSeparator: boolean
  }

  /**
    Class that needs to be implemented in order to respond to the CommandCreatedEvent event.
    @permissions ui
  */
  abstract class CommandCreatedEvent extends Event {
    /**
      Adds an event handler object to this event endpoint.
      @param handler The client implemented CommandCreatedEventHandler to be called when this event is triggered.
      @returns Returns true if the handler was successfully added to the set of event handlers.
    */
    add(handler: CommandCreatedEventHandler): boolean
    /**
      Removes a handler from this event endpoint.
      @param handler A CommandCreatedEventHandler that was previously added to this event with the add method.
      @returns Returns true if the handler was found and removed from the set of event handlers.
    */
    remove(handler: CommandCreatedEventHandler): boolean
  }

  /**
    Class that contains the call back function that is called when the CommandCreated event is fired.
    @permissions ui
  */
  abstract class CommandCreatedEventHandler extends EventHandler {
    /**
      This notify member is called when an event is triggered from any event that this handler has been added to.
      @param eventArgs The arguments object with details about this event and the firing CommandEvent.
    */
    notify(eventArgs: CommandCreatedEventArgs): void
  }

  /**
    Provides data for the CommandCreated event.
    @permissions ui
  */
  abstract class CommandCreatedEventArgs extends EventArgs {
    /**
      Gets the newly created Command object that allows you to perform an action in response to the control being clicked.
    */
    readonly command: Command
  }

  /**
    The Command class contains all of the functionality needed by a command to gather
    various command input from a user, provide previews, and create the final result
    which is also encapsulated within a transaction so it can be undone.
    @permissions ui
  */
  abstract class Command extends Base {
    /**
      Gets the parent CommandDefinition object.
    */
    readonly parentCommandDefinition: CommandDefinition
    /**
      Gets an event that is fired when the command is first activated or re-activated after being suspended.
      @returns Returns a CommandEvent object that is used to connect and release from the event.
    */
    readonly activate: CommandEvent
    /**
      Gets an event that is fired when the command is deactivated. The command still exists and could still be activated again.
      @returns Returns a CommandEvent object that is used to connect and release from the event.
    */
    readonly deactivate: CommandEvent
    /**
      Gets an event that is fired when the command is destroyed. The command is destroyed and can be cleaned up.
      @returns Returns a CommandEvent object that is used to connect and release from the event.
    */
    readonly destroy: CommandEvent
    /**
      Gets an event that is fired when the command has completed gathering the required input and now
      needs to perform whatever action the command does.
      @returns Returns a CommandEvent object that is used to connect and release from the event.
    */
    readonly execute: CommandEvent
    /**
      Gets an event that is fired when the command has completed gathering the required input and now
      needs to perform a preview.
      @returns Returns a CommandEvent object that is used to connect and release from the event.
    */
    readonly executePreview: CommandEvent
    /**
      Gets the associated CommandInputs object which provides the ability
      to create new command inputs and provides access to any existing inputs
      that have already been created for this command.
    */
    readonly commandInputs: CommandInputs
    /**
      Gets an event that is fired whenever an input value is changed.
      @returns Returns an InputChangedEvent object that is used to connect and release from the event.
    */
    readonly inputChanged: InputChangedEvent
    /**
      Gets an event that is fired to allow you to check if the current state of the inputs are valid for execution.
      The timing of this event is indeterminate and not always tied to the editing of an input. There are cases where
      this isn't fired when an input is edited. This happens when an input is able to validate its content on its own.
      For example, if you enter an invalid value for a ValueCommandInput, it can evaluate this on its own, and as a
      result, the validate inputs event is not fired. Fusion will sometimes fire this event at other random times that
      are not tied to the edit of an input.
      If you want to be notified when an input changes, you should use the input changed event instead.
      @returns Returns a ValidateInputsEvent object that is used to connect and release from the event.
    */
    readonly validateInputs: ValidateInputsEvent
    /**
      Gets an event that is fired when a key on the keyboard is pressed down.
    */
    readonly keyDown: KeyboardEvent
    /**
      Gets an event that is fired when a key on the keyboard goes up.
    */
    readonly keyUp: KeyboardEvent
    /**
      Gets an event that is fired when the mouse is clicked, (a button is pressed and released).
    */
    readonly mouseClick: MouseEvent
    /**
      Gets an event that is fired when the mouse is double-clicked, (clicked twice within the time specified by a system setting.)
    */
    readonly mouseDoubleClick: MouseEvent
    /**
      Gets an event that is fired when a mouse button is pressed.
    */
    readonly mouseDown: MouseEvent
    /**
      Gets an event that is fired when the mouse is moved.
    */
    readonly mouseMove: MouseEvent
    /**
      Gets an event that is fired when a mouse button is released.
    */
    readonly mouseUp: MouseEvent
    /**
      Gets an event that is fired when the mouse wheel is rotated.
    */
    readonly mouseWheel: MouseEvent
    /**
      Gets an event that is fired when a mouse drag starts,
      (the mouse is pressed and moved).
    */
    readonly mouseDragBegin: MouseEvent
    /**
      Gets an event that is fired when the mouse is in drag mode,
      (being moved while a button is pressed).
    */
    readonly mouseDrag: MouseEvent
    /**
      Gets an event that is fired when the mouse button is released after a drag.
    */
    readonly mouseDragEnd: MouseEvent
    /**
      Specifies if the OK button is visible or not.
      If set to false then the OK button is removed and the
      "CANCEL" button text changes to "CLOSE". You can override
      the default button text using the cancelButtonText property.
    */
    isOKButtonVisible: boolean
    /**
      Gets and sets the text displayed on the OK button. When the OK and Cancel
      buttons are displayed, this text defaults to "OK". If the Cancel button
      is not displayed the text defaults to "CLOSE".
    */
    okButtonText: string
    /**
      Gets and sets the text displayed on the Cancel button. The value of this
      property is ignored if the isCancelButtonVisible property is false.
    */
    cancelButtonText: string
    /**
      Sets the initial size of the dialog when it is first displayed. If this is not
      set, Fusion will use a default size for the dialog.
      @param width The width of the dialog in pixels.
      @param height The height of the dialog in pixels.
      @returns Returns true if the default size was successfully set.
    */
    setDialogInitialSize(width: number /*int*/, height: number /*int*/): boolean
    /**
      Sets the minimum size for the dialog when resized to by the user. If this is not
      set, a default minimum size is used.
      @param width The minimum width of the dialog in pixels.
      @param height The minimum height of the dialog in pixels.
      @returns Returns true if the minimum size was successfully set.
    */
    setDialogMinimumSize(width: number /*int*/, height: number /*int*/): boolean
    /**
      Gets and Sets if this command is repeatable using the 'Repeat Last Command' option from the Fusion marking menu.
    */
    isRepeatable: boolean
    /**
      Provides a notification when the mouse passes over an entity allowing you to determine if the
      entity should be available for selection or not.
      @remarks
      This event has been retired. Equivalent functionality is provide by the preSelect event.
      @deprecated
    */
    readonly selectionEvent: SelectionEvent
    /**
      Specifies what the behavior will be when a command is preempted by the user executing another
      command. If true (the default), and all of the current inputs are valid, the command will be
      executed just the same as if the user clicked the OK button. If false, the command is terminated.
    */
    isExecutedWhenPreEmpted: boolean
    /**
      Gets and sets the associated HTML help file for this command.
      @remarks
      If this is defined then the help button will be displayed in the lower-left
      corner of the command dialog and when clicked the help file will be displayed using the application
      defined by the operating system for that file type.For example, if the helpFile property references
      a .htm or .html file, the default browser will be invoked to display the file. If a .pdf file is
      used then whatever the default application is for viewing a PDF file will be invoked.
      The file referenced must be a local file and cannot be a URL. However, you can use a local
      HTML file that redirects to a URL.
      ```
      &lthtml&gt
         &lthead&gt
            &ltmeta http-equiv="refresh" content="0 url=http://example.com/" /&gt
         &lt/head&gt
         &ltbody&gt&lt/body&gt
      &lt/html&gt
      ```
      The filename can be either a full path or a relative path with respect to the script or add-in
      .py, .js, .dll, or .dylib file. If this is an empty string, (which is the default), then the
      help button will not be displayed.
    */
    helpFile: string
    /**
      Gets and sets whether this command will automatically execute if no command inputs have been
      defined. If any command inputs have been created, the value of this property is ignored and
      the command dialog will be displayed and the command will execute when the user clicks 'OK'.
      if no command inputs have been defined and this is set to False, then the command will not
      execute but will remain running.
      The default value for this property is true so that the command will execute if no command inputs
      have been defined.
    */
    isAutoExecute: boolean
    /**
      Causes the execution of this command which results in the execute event being fired. This is the
      same effect as the user clicking the "OK" button in the command dialog and is most useful when there
      is no command dialog (no command inputs where created) and the isAutoExecute property has been set
      to False. This allows you to execute the command through code.
      @param terminate In the case where there isn't a command dialog you can also use the terminate argument to specify if
      the command should terminate after execution or continue running. This is similar to the sketch line
      command where each line placement results in the creation of an undo-able line but the command continues
      to run to allow additional lines to be placed.
      @returns Returns true if the execution of the command was successful.
    */
    doExecute(terminate: boolean): boolean
    /**
      Causes the executePreview event of this command to be fired. This is most useful when there
      is no command dialog (no command inputs where created) and the isAutoExecute property has been set
      to False. This allows you to force the preview to be generated instead of relying on changing
      command inputs.
      @returns Returns true if the execute Preview event was successfully fired..
    */
    doExecutePreview(): boolean
    /**
      When working in a parametric design in Fusion and you move any occurrences, those move operations are
      pending and aren't captured until you use the "Capture Position" command from the POSITION panel or
      use the "Revert" command from the same panel to move them all back to their original positions. If
      the design is in a pending situation and you run a command like "Create Sketch", a dialog appears
      asking if you want to capture the current position or not before continuing. This is because
      the creation of a sketch can be dependent on the current positions of occurrences in the design. Other commands, like
      "Fillet", depend directly on model geometry and do not rely on occurrence positions so running the Fillet command
      does not display the dialog and does not affect the pending state of the occurrences.
      This property allows you to specify if your command is dependent on the current position of occurrences
      or not. One good way to know if your command is dependent or not is to run the commands in the UI that are
      equivalent to the API functions you're using and see if the dialog that prompts to save or abort appears.
      If it does, then you know your command is dependent on occurrence positions.
      If this property is true, then the dialog will appear if there are any pending moved occurrences.
      The user can choose whether to capture the current changes or abort them, and then your command will continue.
      If you set this property to false, (which is the default), then even if there are pending changes, the occurrences
      are left in their current positions and your command will run.
    */
    isPositionDependent: boolean
    /**
      Specifies the cursor to display at the mouse.
      @param cursorImage The path to the PNG image to display as the cursor. This can either be a relative path from the py, dll, or dylib file
      of the full path. Specifying an empty string will set the cursor back to the default cursor.
      @param xHotSpot Specifies the position of the x pixel within the image that is the "hot" spot or the point that is used as the mouse point. A value of
      zero indicates the far left of the image. If an empty string is used as the cursorImage, this value is ignored.
      @param yHotSpot Specifies the position of the y pixel within the image that is the "hot" spot or the point that is used as the mouse point. A value of
      zero indicates the top of the image. If an empty string is used as the cursorImage, this value is ignored.
      @returns Returns true if setting the cursor was successful.
    */
    setCursor(cursorImage: string, xHotSpot: number /*int*/, yHotSpot: number /*int*/): boolean
    /**
      Gets the custom cursor information currently being used.
      @param cursorImage The full path to the png image that is being displayed as the cursor.
      @param xHotSpot Gets the position of the x pixel within the image that is the "hot" spot or the point that is used as the mouse point. A value of
      zero indicates the left of the image.
      @param yHotSpot Gets the position of the y pixel within the image that is the "hot" spot or the point that is used as the mouse point. A value of
      zero indicates the top of the image.
      @returns Returns true if getting the cursor information was successful.
    */
    getCursor(): [cursorImage: string, xHotSpot: number /*int*/, yHotSpot: number /*int*/]
    /**
      This event is used to be able to participate in the selection process in a dynamic way.
      When a user is selecting geometry, they move the mouse over the model and if the
      entity the mouse is currently over is valid for selection it will highlight indicating that
      it can be selected. This process of determining what is available for selection and highlighting
      it is referred to as the "preselect" behavior.
      You use functions on the SelectionCommandInput object to define what types of entities are
      selectable and in many cases this coarse level of specification is all that's needed, but in other
      cases you may need more control over the selection. For example, you might want to allow the user to
      selection construction planes and planar faces, which can easily be controlled by defining those as
      valid entities for selection in the SelectionCommandInput object. But if you only want to allow the
      user to select planes that are parallel then you need some dynamic control over the selection, which
      can be done using the preSelect event.
      In the example of selecting parallel planes, you would still set the valid selection types for the
      SelectionCommandInput to allow selection of construction planes and planar faces. This will limit
      the selection to only planes but any plane can still be selected. You'll also need to connect to the
      preSelect event for the command. As the user moves the mouse over any construction plane
      or planar face, the preSelect event will fire for the plane the mouse is current over. If no planes
      have yet been selected, then you allow the user to select this plane. If one or more planes have
      already selected, then in the preSelect event you'll check to see if the plane the mouse is over is
      parallel to the first plane already selected. If it is then you allow it to be selected. If it isn't
      parallel then you set the isSelectable property of the provided SelectEventArgs object to False so
      that it won't pre-highlight and won't be selectable.
      The entity and mouse position on the entity can be obtained through the Selection object returned
      through the selection property of the SelectionEventArgs object provided through the event.
      @permissions desktop
    */
    readonly preSelect: SelectionEvent
    /**
      This event fires continually while the mouse is moved over an entity that is valid for selected.
      The entity and mouse position on the entity can be obtained through the Selection object returned
      through the selection property of the SelectionEventArgs object provided through the event.
      @permissions desktop
    */
    readonly preSelectMouseMove: SelectionEvent
    /**
      This event fires when the moused is moved away from an entity that was in a pre-select state. If
      your add-in has done something in reaction to the preSelect event, like draw some custom graphics, this
      event provides the notification to clean up whatever you've done that's associated with the current
      pre-select.
      The entity and mouse position on the entity can be obtained through the Selection object returned
      through the selection property of the SelectionEventArgs object provided through the event.
      @permissions desktop
    */
    readonly preSelectEnd: SelectionEvent
    /**
      This even fires when the user selects an entity. This is different from the preselect where an
      entity is shown as being available for selection as the mouse passes over the entity. This is the actual
      selection where the user has clicked the mouse on the entity.
      The entity and mouse position on the entity can be obtained through the Selection object returned
      through the selection property of the SelectionEventArgs object provided through the event.
      @permissions desktop
    */
    readonly select: SelectionEvent
    /**
      This even fires when the user unselects an entity by clicking the mouse again on selected entity
      or canceling previous selection.
      The entity and mouse position on the entity can be obtained through the Selection object returned
      through the selection property of the SelectionEventArgs object provided through the event.
      @permissions desktop
    */
    readonly unselect: SelectionEvent
    /**
      Begin a transacted step within the command's transaction.
      If the all of the command inputs are valid, this will trigger the execute event for the current step.
      @param makeExistingStepNonUndoable If true the current step will not be undo-able.
      @returns Returns true if beginning the step was successful.
      @experimental
    */
    beginStep(makeExistingStepNonUndoable?: boolean/* = false*/): boolean
    /**
      Sets the editing feature for this command. The timeline will be rolled to the editing feature
      on activate and will the current position will be restored on deactivate.
      @experimental
    */
    editingFeature: Base
    /**
      This event is fired when the JavaScript associated with the HTML displayed in a
      BrowserCommandInput calls the adsk.fusionSendData function and when the JavaScript
      responds to the sendInfoToHTML call. The HTMLEventArgs provided by the event indicates
      which BrowserCommandInput triggered the event.
      @permissions desktop
    */
    readonly incomingFromHTML: HTMLEvent
    /**
      This event is fired when a navigation event occurs on the page displayed within a
      BrowserCommandInput. This allows the add-in to determine how this navigation should
      be handled by the browser. The NavigationEventArgs provided by the event indicates
      which BrowserCommandInput triggered the event.
      @permissions desktop
    */
    readonly navigatingURL: NavigationEvent
    /**
      As the mouse moves over entities in the graphics window, entities valid for selection are highlighted.
      Before an entity is highlighted, Fusion determines if it is a valid selectable entity using the selection
      filter defined on the SelectionCommandInput and the preSelect event of the command. The preSelectStart
      event fires when the mouse first moves over an entity valid for selection. You can obtain the entity
      and mouse position from the Selection object returned by the selection property of the SelectionEventArgs
      object provided through the event.
      Some related events are the preSelectMouseMove event, which fires as the mouse moves across the entity,
      and the preSelectEnd event, which fires when the mouse moves off the entity.
      @permissions desktop
    */
    readonly preSelectStart: SelectionEvent
    /**
      Sets the size of the dialog and overrides any size. This can be used when the command is
      created or anytime while the command is running. If the height is zero, the dialog will be sized
      to fit the command inputs currently displayed.
      @param width The width of the dialog in pixels.
      @param height The height of the dialog in pixels. If zero, the dialog will be sized to fit the command inputs currently displayed.
      @returns Returns true if size was successfully set.
    */
    setDialogSize(width: number /*int*/, height: number /*int*/): boolean
    /**
      Determines if this selection input shares a common selection set with the other selection inputs
      of this command or its own unique selection set. The default is False, which means each selection
      input will have its own selection set. This means that the items in this selection set are only
      shown as selected when this selection input is active. As a result, other selection inputs associated
      with this command can select those same entities.
      If this is True, then all selection inputs share a selection set, which means that when entities
      are selected by any of the selection inputs of this command,
      they will remain selected regardless of which command input is active. This has the side effect that
      once an entity is selected, it cannot be selected again by another selection input.
      @experimental
    */
    hasDistinctSelectionSets: boolean
  }

  /**
    An event endpoint that supports the connection to client implemented CommandEventHandlers.
    @permissions ui
  */
  abstract class CommandEvent extends Event {
    /**
      Adds an event handler object to this event endpoint.
      @param handler The client implemented CommandEventHandler to be called when this event is triggered.
      @returns Returns true if the handler was successfully added to the set of event handlers.
    */
    add(handler: CommandEventHandler): boolean
    /**
      Removes a handler from this event endpoint.
      @param handler A CommandEventHandler that was previously added to this event with the add method.
      @returns Returns true if the handler was found and removed from the set of event handlers.
    */
    remove(handler: CommandEventHandler): boolean
  }

  /**
    An command event handler base class that a client derives from to handle events triggered by a CommandEvent.
    A client implemented instance of this class can be added to a CommandEvent to receive these event notifications.
    @permissions ui
  */
  abstract class CommandEventHandler extends EventHandler {
    /**
      This notify member is called when an event is triggered from any event that this handler has been added to.
      @param eventArgs The arguments object with details about this event and the firing CommandEvent.
    */
    notify(eventArgs: CommandEventArgs): void
  }

  /**
    Provides a set of arguments from a firing CommandEvent to a CommandEventHandler's notify callback method.
    @permissions ui
  */
  abstract class CommandEventArgs extends EventArgs {
    /**
      Gets the Command object.
    */
    readonly command: Command
    /**
      Used during the execute event to get or set that the execute operations failed
      and the commands transaction should be aborted.
      This property should be ignored for all events besides the Execute event.
    */
    executeFailed: boolean
    /**
      Used during the execute event to get or set a description of an execute failure.
      This property should be ignored for all events besides the Execute event.
    */
    executeFailedMessage: string
    /**
      Used during the commandStarting event to get or set that the result of preview is valid
      and the command can reuse the result when OK is hit.
      This property should be ignored for all events besides the executePreview event.
    */
    isValidResult: boolean
    /**
      Gets the termination reason of the command. It's only valid on the destroy event.
    */
    readonly terminationReason: CommandTerminationReason
  }

  /**
    Defines the termination reason for a command.
    Commands can be terminated for a number of different reasons, and
    based on the reason commands have to do different things during
    termination so this enum defines various reasons for termination
    @permissions ui
  */
  const enum CommandTerminationReason {
    /**
      The command is terminated out of the reasons list below.
    */
    UnknownTerminationReason,
    /**
      The command is terminated by clicking OK button, and executed successfully.
    */
    CompletedTerminationReason,
    /**
      The command is terminated by clicking Cancel button.
    */
    CancelledTerminationReason,
    /**
      The command is terminated by clicking OK button, and executed failed.
    */
    AbortedTerminationReason,
    /**
      The command is terminated by activating another command.
    */
    PreEmptedTerminationReason,
    /**
      The command is terminated by closing the document.
    */
    SessionEndingTerminationReason,
  }

  /**
    An event endpoint that supports the connection to client implemented ValidateInputsEventHandlers.
    @permissions ui
  */
  abstract class ValidateInputsEvent extends Event {
    /**
      Adds an event handler to this event endpoint.
      @param handler The client implemented ValidateInputsEventHandler to be called when this event is triggered.
      @returns Returns true if the handler was successfully added to the set of event handlers.
    */
    add(handler: ValidateInputsEventHandler): boolean
    /**
      Removes a handler from this event endpoint.
      @param handler A ValidateInputsEventHandler that was previously added to this event with the add method.
      @returns Returns true if the handler was found and removed from the set of event handlers.
    */
    remove(handler: ValidateInputsEventHandler): boolean
  }

  /**
    An event handler base class that a client derives from to handle events triggered by a ValidateInputsEvent.
    A client implemented instance of this class can be added to a ValidateInputsEvent to receive these event notifications.
    @permissions ui
  */
  abstract class ValidateInputsEventHandler extends EventHandler {
    /**
      This notify member is called when an event is triggered from any event that this handler has been added to.
      @param eventArgs The arguments object with details about this event and the firing ValidateInputsEvent.
    */
    notify(eventArgs: ValidateInputsEventArgs): void
  }

  /**
    Provides a set of arguments from a firing ValidateInputsEvent to a ValidateInputsEventHandler's notify callback method.
    @permissions ui
  */
  abstract class ValidateInputsEventArgs extends EventArgs {
    /**
      Used with AreInputsValid event to specify if the all of the inputs for the
      command are valid or not. If you set this to false, indicating they are not
      valid, the OK button for the dialog is disabled forcing the user to correct
      the inputs before continuing. If you set this to true the OK button will be
      enabled, as long as the inputs satisfy their own requirements. For example,
      if a SelectionCommandInput is defined to have at minimum number of entities
      selected, that requirement must be met, or if a ValueCommandInput has an invalid
      value specified, the OK button will still be disabled.
    */
    areInputsValid: boolean
    /**
      Returns the collection of command inputs that are associated with the command this event is being fired for.
    */
    readonly inputs: CommandInputs
  }

  /**
    An event endpoint that supports the connection to client implemented KeyboardEventHandlers.
    @permissions ui
  */
  abstract class KeyboardEvent extends Event {
    /**
      Adds an event handler to this event endpoint.
      @param handler The client implemented KeyboardEventHandler to be called when this event is triggered.
      @returns Returns true if the handler was successfully added to the set of event handlers.
    */
    add(handler: KeyboardEventHandler): boolean
    /**
      Removes a handler from this event endpoint.
      @param handler A KeyboardEventHandler that was previously added to this event with the add method.
      @returns Returns true if the handler was found and removed from the set of event handlers.
    */
    remove(handler: KeyboardEventHandler): boolean
  }

  /**
    An event handler base class that a client derives from to handle events triggered by a KeyboardEvent.
    A client implemented instance of this class can be added to a KeyboardEvent to receive these event notifications.
    @permissions ui
  */
  abstract class KeyboardEventHandler extends EventHandler {
    /**
      This notify member is called when an event is triggered from any event that this handler has been added to.
      @param eventArgs The arguments object with details about this event and the firing KeyboardEvent.
    */
    notify(eventArgs: KeyboardEventArgs): void
  }

  /**
    Provides a set of arguments from a firing KeyboardEvent to a KeyboardEventHandler's notify callback method.
    @permissions ui
  */
  abstract class KeyboardEventArgs extends EventArgs {
    /**
      Gets the set of keyboard modifiers that were active. The value is the Boolean
      combination of KeyboardModifiers values.
    */
    readonly modifierMask: number /*int*/
    /**
      Gets the keyboard key.
    */
    readonly keyCode: KeyCodes
  }

  /**
    Key values on the keyboard.
    @permissions ui
  */
  const enum KeyCodes {
    /**
      No key
    */
    NoKeyCode = 0x0,
    /**
      Space
    */
    SpaceKeyCode = 0x20,
    /**
      Asterisk
    */
    AsteriskKeyCode = 0x2a,
    /**
      Plus
    */
    PlusKeyCode = 0x2b,
    /**
      Comma
    */
    CommaKeyCode = 0x2C,
    /**
      Minus
    */
    MinusKeyCode = 0x2d,
    /**
      Period
    */
    PeriodKeyCode = 0x2E,
    /**
      Slash
    */
    SlashKeyCode = 0x2f,
    /**
      D0
    */
    D0KeyCode = 0x30,
    /**
      D1
    */
    D1KeyCode = 0x31,
    /**
      D2
    */
    D2KeyCode = 0x32,
    /**
      D3
    */
    D3KeyCode = 0x33,
    /**
      D4
    */
    D4KeyCode = 0x34,
    /**
      D5
    */
    D5KeyCode = 0x35,
    /**
      D6
    */
    D6KeyCode = 0x36,
    /**
      D7
    */
    D7KeyCode = 0x37,
    /**
      D8
    */
    D8KeyCode = 0x38,
    /**
      D9
    */
    D9KeyCode = 0x39,
    /**
      Colon
    */
    ColonKeyCode = 0x3a,
    /**
      Semicolon
    */
    SemicolonKeyCode = 0x3b,
    /**
      Less
    */
    LessKeyCode = 0x3c,
    /**
      Equal
    */
    EqualKeyCode = 0x3d,
    /**
      Greater
    */
    GreaterKeyCode = 0x3e,
    /**
      Question
    */
    QuestionKeyCode = 0x3f,
    /**
      A
    */
    AKeyCode = 0x41,
    /**
      B
    */
    BKeyCode = 0x42,
    /**
      C
    */
    CKeyCode = 0x43,
    /**
      D
    */
    DKeyCode = 0x44,
    /**
      E
    */
    EKeyCode = 0x45,
    /**
      F
    */
    FKeyCode = 0x46,
    /**
      G
    */
    GKeyCode = 0x47,
    /**
      H
    */
    HKeyCode = 0x48,
    /**
      I
    */
    IKeyCode = 0x49,
    /**
      J
    */
    JKeyCode = 0x4A,
    /**
      K
    */
    KKeyCode = 0x4B,
    /**
      L
    */
    LKeyCode = 0x4C,
    /**
      M
    */
    MKeyCode = 0x4D,
    /**
      N
    */
    NKeyCode = 0x4E,
    /**
      O
    */
    OKeyCode = 0x4F,
    /**
      P
    */
    PKeyCode = 0x50,
    /**
      Q
    */
    QKeyCode = 0x51,
    /**
      R
    */
    RKeyCode = 0x52,
    /**
      S
    */
    SKeyCode = 0x53,
    /**
      T
    */
    TKeyCode = 0x54,
    /**
      U
    */
    UKeyCode = 0x55,
    /**
      V
    */
    VKeyCode = 0x56,
    /**
      W
    */
    WKeyCode = 0x57,
    /**
      X
    */
    XKeyCode = 0x58,
    /**
      Y
    */
    YKeyCode = 0x59,
    /**
      Z
    */
    ZKeyCode = 0x5A,
    /**
      Bracket left
    */
    BracketLeftKeyCode = 0x5b,
    /**
      Backslash
    */
    BackslashKeyCode = 0x5c,
    /**
      Bracket right
    */
    BracketRightKeyCode = 0x5d,
    /**
      ASCII circum
    */
    AsciiCircumKeyCode = 0x5e,
    /**
      Underscore
    */
    UnderscoreKeyCode = 0x5f,
    /**
      Quote left
    */
    QuoteLeftKeyCode = 0x60,
    /**
      Brace left
    */
    BraceLeftKeyCode = 0x7b,
    /**
      Bar
    */
    BarKeyCode = 0x7c,
    /**
      Brace right
    */
    BraceRightKeyCode = 0x7d,
    /**
      ASCII tilde
    */
    AsciiTildeKeyCode = 0x7e,
    /**
      Grave accent
    */
    GraveAccentKeyCode = 0x60,
    /**
      Escape
    */
    EscapeKeyCode = 0x01000000,
    /**
      Tab
    */
    TabKeyCode = 0x01000001,
    /**
      Backtab
    */
    BacktabKeyCode = 0x01000002,
    /**
      Backspace
    */
    BackspaceKeyCode = 0x01000003,
    /**
      Return
    */
    ReturnKeyCode = 0x01000004,
    /**
      Enter
    */
    EnterKeyCode = 0x01000005,
    /**
      Insert
    */
    InsertKeyCode = 0x01000006,
    /**
      Delete
    */
    DeleteKeyCode = 0x01000007,
    /**
      Pause
    */
    PauseKeyCode = 0x01000008,
    /**
      Print
    */
    PrintKeyCode = 0x01000009,
    /**
      SysReq
    */
    SysReqKeyCode = 0x0100000a,
    /**
      Clear
    */
    ClearKeyCode = 0x0100000b,
    /**
      Home
    */
    HomeKeyCode = 0x01000010,
    /**
      End
    */
    EndKeyCode = 0x01000011,
    /**
      Left
    */
    LeftKeyCode = 0x01000012,
    /**
      Up
    */
    UpKeyCode = 0x01000013,
    /**
      Right
    */
    RightKeyCode = 0x01000014,
    /**
      Down
    */
    DownKeyCode = 0x01000015,
    /**
      Page up
    */
    PageUpKeyCode = 0x01000016,
    /**
      Page down
    */
    PageDownKeyCode = 0x01000017,
    /**
      Shift
    */
    ShiftKeyCode = 0x01000020,
    /**
      Control
    */
    ControlKeyCode = 0x01000021,
    /**
      On Mac OS X, this corresponds to the Command keys.
      Meta
    */
    MetaKeyCode = 0x01000022,
    /**
      On Mac OS X, this corresponds to the Control keys.
      Alt
    */
    AltKeyCode = 0x01000023,
    /**
      F1
    */
    F1KeyCode = 0x01000030,
    /**
      F2
    */
    F2KeyCode = 0x01000031,
    /**
      F3
    */
    F3KeyCode = 0x01000032,
    /**
      F4
    */
    F4KeyCode = 0x01000033,
    /**
      F5
    */
    F5KeyCode = 0x01000034,
    /**
      F6
    */
    F6KeyCode = 0x01000035,
    /**
      F7
    */
    F7KeyCode = 0x01000036,
    /**
      F8
    */
    F8KeyCode = 0x01000037,
    /**
      F9
    */
    F9KeyCode = 0x01000038,
    /**
      F10
    */
    F10KeyCode = 0x01000039,
    /**
      F11
    */
    F11KeyCode = 0x0100003a,
    /**
      F12
    */
    F12KeyCode = 0x0100003b,
    /**
      Menu
    */
    MenuKeyCode = 0x01000055,
  }

  /**
    Keyboard modifier values.
    @permissions ui
  */
  const enum KeyboardModifiers {
    /**
      None
    */
    NoKeyboardModifier = 0x00000000,
    /**
      Shift
    */
    ShiftKeyboardModifier = 0x02000000,
    /**
      Control
    */
    CtrlKeyboardModifier = 0x04000000,
    /**
      Alt
    */
    AltKeyboardModifier = 0x08000000,
    /**
      Meta
    */
    MetaKeyboardModifier = 0x10000000,
  }

  /**
    An event endpoint that supports the connection to client implemented MouseEventHandlers.
    @permissions ui
  */
  abstract class MouseEvent extends Event {
    /**
      Adds an event handler to this event endpoint.
      @param handler The client implemented MouseEventHandler to be called when this event is triggered.
      @returns Returns true if the handler was successfully added to the set of event handlers.
    */
    add(handler: MouseEventHandler): boolean
    /**
      Removes a handler from this event endpoint.
      @param handler A MouseEventhandler that was previously added to this event with the add method.
      @returns Returns true if the handler was found and removed from the set of event handlers.
    */
    remove(handler: MouseEventHandler): boolean
  }

  /**
    An event handler base class that a client derives from to handle events triggered by a MouseEvent.
    A client implemented instance of this class can be added to a MouseEvent to receive these event notifications.
    @permissions ui
  */
  abstract class MouseEventHandler extends EventHandler {
    /**
      This notify member is called when an event is triggered from any event that this handler has been added to.
      @param eventArgs The arguments object with details about this event and the firing MouseEvent.
    */
    notify(eventArgs: MouseEventArgs): void
  }

  /**
    Provides a set of arguments from a firing MouseEvent to a MouseEventHandler's notify callback method.
    @permissions ui
  */
  abstract class MouseEventArgs extends EventArgs {
    /**
      Gets which mouse button(s) are pressed. The returned value
      is bitwise and can indicate that more than one button is pressed.
    */
    readonly button: MouseButtons
    /**
      Gets the number of times the button was pressed and released.
    */
    readonly clicks: number /*unsigned int*/
    /**
      Gets a signed count of the number of detents the mouse wheel has rotated.
    */
    readonly wheelDelta: number /*int*/
    /**
      Gets which modifier keys are currently pressed. The returned value
      is bitwise and can indicate that more than one button is pressed.
    */
    readonly keyboardModifiers: KeyboardModifiers
    /**
      Gets the coordinate of the mouse in screen space.
    */
    readonly position: core.Point2D
    /**
      Gets the coordinate of the mouse in viewport space, if the mouse is
      within a viewport. If the mouse is not over a viewport this property will return null.
    */
    readonly viewportPosition: core.Point2D
    /**
      Returns the viewport where the mouse event occurred, if it was within a viewport.
      If the mouse is not over a viewport this property will return null.
    */
    readonly viewport: Viewport
  }

  /**
    Mouse button values.
    @permissions ui
  */
  const enum MouseButtons {
    /**
      None
    */
    NoMouseButton = 0x0,
    /**
      Left
    */
    LeftMouseButton = 0x1,
    /**
      Right
    */
    RightMouseButton = 0x2,
    /**
      Middle
    */
    MiddleMouseButton = 0x4,
  }

  /**
    An event endpoint that supports the connection to client implemented SelectionEventHandlers.
    @permissions ui
  */
  abstract class SelectionEvent extends Event {
    /**
      Adds an event handler to this event endpoint.
      @param handler The client implemented SelectionEventHandler to be called when this event is triggered.
      @returns Returns true if the handler was successfully added to the set of event handlers.
    */
    add(handler: SelectionEventHandler): boolean
    /**
      Removes a handler from this event endpoint.
      @param handler A SelectionEventHandler that was previously added to this event with the add method.
      @returns Returns true if the handler was found and removed from the set of event handlers.
    */
    remove(handler: SelectionEventHandler): boolean
    /**
      Returns the SelectionCommandInput that is currently active in the command dialog and
      that the user is selecting entities for. This can be used to determine which set of
      rules you want to apply to determine if the current entity is selectable or not.
    */
    readonly activeInput: SelectionCommandInput
  }

  /**
    An event handler base class that a client derives from to handle events triggered by a SelectionEvent.
    A client implemented instance of this class can be added to a SelectionEvent to receive these event notifications.
    @permissions ui
  */
  abstract class SelectionEventHandler extends EventHandler {
    /**
      This notify member is called when an event is triggered from any event that this handler has been added to.
      @param eventArgs The arguments object with details about this event and the firing SelectionEvent.
    */
    notify(eventArgs: SelectionEventArgs): void
  }

  /**
    Provides a set of arguments from a firing SelectionEvent to a SelectionEventHandler's notify callback method.
    @permissions ui
  */
  abstract class SelectionEventArgs extends EventArgs {
    /**
      Gets the entity that is valid for selection.
    */
    readonly selection: Selection
    /**
      Gets or sets whether this entity should be made available to be selected.
      The value is initialized to true, so doing nothing will result
      in the entity being selectable.
    */
    isSelectable: boolean
    /**
      Gets or sets any additional entities that should be pre-highlighted and selected
      if the entity the mouse is over is selected. If you add an entity that is already
      selected, it will be unselected. The result of adding additional entities is the
      same as if they were selected one at a time by the user and the user can unselect each
      entity one at a time by picking it while it's selected.
      An example of how this might be used is that the user can select a group of
      tangentially connected edges by picking a single edge. You can use the
      BrepEdge.tangentiallyConnectedEdges to easily find the tangent edges and add them
      to the set of additional entities to be selected. These edges are pre-highlighted
      and then selected.
      If you are using this property you need to make sure that the selection
      limits for the SelectionCommandInput have been set appropriately. For example, a
      newly created SeletionCommandInput is set to only allow the selection of a single
      entity. By adding additional entities you'll need more than one entity because the
      entire set of entities will be added to the selection. Use the setSelectionLimits
      method of the SelectionCommandInput to change the number of allowed selections.
      The additional entities should all be valid based on the current selection filter.
    */
    additionalEntities: ObjectCollection
    /**
      Returns the SelectionCommandInput that is currently active in the command dialog and
      that the user is selecting entities for. This can be used to determine which set of
      rules you want to apply to determine if the current entity is selectable or not.
    */
    readonly activeInput: SelectionCommandInput
  }

  /**
    Provides access to the set of inputs for a command. Command inputs are used to gather inputs from the user when a command is executed.
    The set of inputs used by a command are created and added to the command with the methods in this class.
    @permissions ui
  */
  abstract class CommandInputs extends Base {
    /**
      Gets the parent Command object.
    */
    readonly command: Command
    /**
      Returns the specified command input using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CommandInput | null
    /**
      Returns the command input that has the specified ID.
      @param id The unique ID of the command input you want to get.
      @returns Returns the specified command input or null if the input ID doesn't match an existing command input.
    */
    itemById(id: string): CommandInput | null
    /**
      Gets the number of inputs.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a new value input to the command.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param unitType The unit type of the value. This will be used to validate the input and the returned Value object
      will be of this type.
      @param initialValue The initial value of this input as shown in the dialog. This can be a string or a real. If it's a string
      it must be able to be evaluated using the specified unit type. If it's a real it is assumed to be in database
      units for the specified unit type and is displayed as a string
      @returns Returns the created ValueCommandInput object or null if the creation failed.
    */
    addValueInput(id: string, name: string, unitType: string, initialValue: ValueInput): ValueCommandInput | null
    /**
      Adds a new boolean input to the command. The input can be shown as a check box or a button. If it's a button
      you need to specify the resource folder to define the icon to use. Buttons don't have an up or down state but
      can just be clicked.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param isCheckBox Specifies if this input should be displayed as a check box or a button. If true a check box is
      displayed, if false a button is displayed that can be clicked to toggle it's state.
      @param resourceFolder Specifies the folder that contains the icon for the input.
      This is optional if isCheckBox is true. If it's defined for a check box, the check box will
      display as a button using the icon and will have an up or down state. Icons can be defined using either
      PNG or SVG files. More information about icons can be found
      in the user manual topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
      @param initialValue Specifies the initial value of the check box or button where for a check box the value of True results
      in it being checked and for a button a value of true results in the button being pressed.
      @returns Returns the created BoolValueCommandInput object or null if the creation failed.
    */
    addBoolValueInput(id: string, name: string, isCheckBox: boolean, resourceFolder?: string/* = ""*/, initialValue?: boolean/* = false*/): BoolValueCommandInput | null
    /**
      Adds a new string input to the command.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param initialValue Specifies the initial value as shown in the dialog.
      @returns Returns the created StringValueCommandInput object or null if the creation failed.
    */
    addStringValueInput(id: string, name: string, initialValue?: string/* = ""*/): StringValueCommandInput | null
    /**
      Adds a new selection input to the command. This allows you to get entity selections from the user. The default
      behavior is that only one entity can be selected and it can be of any type. To change the selection behavior to
      select specific types and control the number of items selected use the methods and properties on the returned
      SelectionCommandInput object. You can also use the selectionEvent event that's associated with the command
      to have additional control over the selection process.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param commandPrompt The text in the tooltip shown next to the cursor.
      @returns Returns the created SelectionCommandInput object or null if the creation failed.
    */
    addSelectionInput(id: string, name: string, commandPrompt: string): SelectionCommandInput | null
    /**
      Adds a new empty drop-down input to the command. drop-downs of various types are supported.
      To add items to the drop down use the returned DropDownCommandInput object.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed label of this command as seen in the dialog.
      @param dropDownStyle Specifies the style of the drop-down.
      @returns Returns the created DropDownCommandInput object or null if the creation failed.
    */
    addDropDownCommandInput(id: string, name: string, dropDownStyle: DropDownStyles): DropDownCommandInput | null
    /**
      Adds a new row of buttons as a command input. Depending on the isMultiSelectEnabled argument it can act like an option list
      where only a single button on the row can be selected at a time or multiple buttons can be selected.
      The buttons are defined by using the returned ButtonRowCommandInput object.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed label of this command as seen in the dialog.
      @param isMultiSelectEnabled Sets if this button row can have multiple items selected at once or not.
      If True, multiple buttons can be selected at once. If False only one button
      can be selected and selecting another button unselects the one currently selected.
      @returns Returns the created ButtonRowCommandInput object or null if the creation failed.
    */
    addButtonRowCommandInput(id: string, name: string, isMultiSelectEnabled: boolean): ButtonRowCommandInput | null
    /**
      Adds a new slider input to the command. The value type is double.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param unitType The unit type of the value. This will be used to validate the input and the returned value will be in the base units for this
      unit type. For example if you specify the unitType to be "in" the returned value will be in centimeters because inches are
      a length unit and the base unit for length is centimeters.
      @param min Provides the minimum value in database units
      @param max Provides the maximum value in database units
      @param hasTwoSliders Optional input. Indicates if the slider input has two sliders.
      @returns Returns the created FloatSliderCommandInput object or null if the creation failed.
    */
    addFloatSliderCommandInput(id: string, name: string, unitType: string, min: number, max: number, hasTwoSliders?: boolean/* = false*/): FloatSliderCommandInput | null
    /**
      Adds a new slider input to the command. The value type is float.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param unitType The unit type of the value. This will be used to validate the input and the returned Value object
      will be of this type.
      @param valueList Provides the value list (in database units) of the slider command input. This defines all of the values that the slider
      can return. As the user moves the slider it will jump between these values. The low and high values
      of the list are used as the minimum and maximum values of the slider.
      @param hasTwoSliders Optional input. Indicates if the slider input has two sliders.
      @returns Returns the created FloatSliderCommandInput object or null if the creation failed.
    */
    addFloatSliderListCommandInput(id: string, name: string, unitType: string, valueList: number[], hasTwoSliders?: boolean/* = false*/): FloatSliderCommandInput | null
    /**
      Adds a new slider input to the command. The value type is integer.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param min Provides the minimum value.
      @param max Provides the maximum value.
      @param hasTwoSliders Optional input. Indicates if the slider input has two sliders.
      @returns Returns the created IntegerSliderCommandInput object or null if the creation failed.
    */
    addIntegerSliderCommandInput(id: string, name: string, min: number /*int*/, max: number /*int*/, hasTwoSliders?: boolean/* = false*/): IntegerSliderCommandInput | null
    /**
      Adds a new slider input to the command. The value type is integer.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param valueList Provides the value list of the slider command input. This defines all of the values that the slider
      can return. As the user moves the slider it will jump between these values. The low and high values
      of the list are used as the minimum and maximum values of the slider.
      @param hasTwoSliders Optional input. Indicates if the slider has two sliders.
      @returns Returns the created IntegerSliderCommandInput object or null if the creation failed.
    */
    addIntegerSliderListCommandInput(id: string, name: string, valueList: number[] /*int[]*/, hasTwoSliders?: boolean/* = false*/): IntegerSliderCommandInput | null
    /**
      Adds a text box input to the command.
      @remarks
      This method has been retired and replaced by the addSimpleTextBoxCommandInput and addFormattedTextBoxCommandInput methods.
      This method will continue to work as it did, but there were problems with the design that necessitated breaking it
      into two different types of text boxes. The simple text box cannot be formatted, but is editable by the user. The contents
      of a formatted text box can be defined using HTML but cannot be edited by the user.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog. If an empty string is provided then
      no name will be displayed and the text box will span the width of the command dialog.
      @param formattedText Specifies the formatted text to display in the input. For example, you can use basic html
      formatting such as <code>&ltb&gtBold&lt/b&gt</code>, <code>&lti&gtItalic&lt/i&gt</code>,
      and <code>&ltbr /&gt</code> for a line break. It also supports hyperlinks, which when clicked
      by the user, Fusion will open the specified URL in the default browser. Hyperlinks are defined
      using the <code>&lta&gt</code> tag such as
      "<code>You are using Autodesk's &lta href=http://fusion.autodesk.com&gtFusion&lt/a&gt.</code>".
      If you are using HTML formatting in your text, it's best to set the text box to be read-only. However,
      if you want to use the text box as a way to get input from the user, it's best to use simple text so
      not HTML formatting is assumed. To do this, use an empty string for this argument and then set the text
      using the text property after the input is created. When the text property is used any HTML formatting
      is ignored and the text is treated as basics text. This can be useful if you're using the text box to
      have the user enter HTML code so it's treated as a simple string.
      @param numRows Specifies the height of the text box as defined by the number of rows of text that can be displayed.
      If the text is larger than will fit in the box a scroll bar will automatically be displayed.
      @param isReadOnly Specifies if the text box is read-only or not.
      @returns Returns the created TextBoxCommandInput object or null if the creation failed.
    */
    addTextBoxCommandInput(id: string, name: string, formattedText: string, numRows: number /*int*/, isReadOnly: boolean): TextBoxCommandInput | null
    /**
      Adds a new spinner input to the command. The value type is float.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param unitType The unit type of the value. This will be used to validate the input and the returned Value object
      will be of this type.
      @param min Provides the minimum value in database units.
      @param max Provides the maximum value in database units.
      @param spinStep Sets the spin step value in the unit type set by the unitType argument.
      The value should be more than zero. This is the amount the slider will advance
      when the user clicks the spin button beside the value.
      @param initialValue The initial value of this input as shown in the dialog. This value is assumed to be in database
      units for the specified unit type
      @returns Returns the created FloatSpinnerCommandInput object or null if the creation failed.
    */
    addFloatSpinnerCommandInput(id: string, name: string, unitType: string, min: number, max: number, spinStep: number, initialValue: number): FloatSpinnerCommandInput | null
    /**
      Adds a new spinner input to the command. The value type is integer.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param min Provides the minimum value.
      @param max Provides the maximum value.
      @param spinStep Provides the spin step. The value should be more than zero. This is the amount the slider will advance
      when the user clicks the spin button beside the value.
      @param initialValue The initial value of this input as shown in the dialog.
      @returns Returns the created IntegerSpinnerCommandInput object or null if the creation failed.
    */
    addIntegerSpinnerCommandInput(id: string, name: string, min: number /*int*/, max: number /*int*/, spinStep: number /*unsigned int*/, initialValue: number /*int*/): IntegerSpinnerCommandInput | null
    /**
      Adds a new Radio Button Group input to the command.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed label of this radio button group as seen in the dialog.
      @returns Returns the created RadioButtonGroupCommandInput object or null if the creation failed.
    */
    addRadioButtonGroupCommandInput(id: string, name?: string/* = ""*/): RadioButtonGroupCommandInput | null
    /**
      Adds a new Group input to the command. Group Command inputs organize a set of command inputs into a collapsible
      list within a command dialog.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed label of this group as seen in the dialog.
      @returns Returns the created GroupCommandInput object or null if the creation failed.
    */
    addGroupCommandInput(id: string, name: string): GroupCommandInput | null
    /**
      Adds a new Tab input to the command. Tab command inputs contain a set of command inputs and/or group command inputs
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed label of this tab as seen in the dialog.
      @param resourceFolder An optional parameter that specifies the folder that contains the image for the tab.
      If no name is specified (no text on tab), a resourceFolder containing the image to appear
      on the tab needs to be provided. More information about icons can be found in the user manual
      topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
      @returns Returns the created TabCommandInput object or null if the creation failed.
    */
    addTabCommandInput(id: string, name: string, resourceFolder?: string/* = ""*/): TabCommandInput | null
    /**
      Adds a new Image input to the command.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed label of this Image as seen in the dialog.
      If a name is not specified (an empty string), the image will be left justified within the dialog.
      If a name is specified it will appear as a left justified label aligned with the other command input labels,
      and the left side of the image will be aligned with the other command input controls.
      @param imageFile The full path and file name of the image file.
      Supported image format is .png
      Images are displayed in the command dialog using their actual size.
      @returns Returns the created ImageCommandInput object or null if the creation failed.
    */
    addImageCommandInput(id: string, name: string, imageFile: string): ImageCommandInput | null
    /**
      Adds a new distance value input to the command. This displays a field in the command dialog where a
      distance value can be entered. It displays the distance in the dialog using current document default unit.
      There is also a graphical manipulator associated with the input.
      You use the setManipulator method of the returned DistanceValueCommandInput
      object to define the position and orientation of the manipulator.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed label of this input as seen in the dialog.
      If a name is not specified (an empty string), the input will be centered horizontally within it's row in the dialog.
      If a name is specified it will appear as a left justified label aligned with the other command input labels,
      and the left side of the image will be aligned with the other command input controls.
      @param initialValue The initial value of the input. If the value input is a number then it is interpreted as centimeters. If it is
      a string it uses the units specified in the string or if no units are specified it uses the active units of the design.
      @returns Returns the created DistanceValueCommandInput object or null if the creation failed.
    */
    addDistanceValueCommandInput(id: string, name: string, initialValue: ValueInput): DistanceValueCommandInput | null
    /**
      Adds a new direction command input to the command. The input can be shown as a check box or a button. If it's a button
      you need to specify the resource folder to define the icon to use for the Button.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param resourceFolder Specifies the folder that contains the icon to use for the input.
      This is an optional argument. The input is shown as a check box if the resource folder is not set.
      More information about icons can be found in the user manual
      topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
      @returns Returns the created DirectionCommandInput object or null if the creation failed.
    */
    addDirectionCommandInput(id: string, name: string, resourceFolder?: string/* = ""*/): DirectionCommandInput | null
    /**
      Adds a new table command input to the command.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed name of this command as seen in the dialog.
      @param numberOfColumns This argument is no longer used. The number of columns displayed is inferred by the
      number of columns that contain command inputs. As you add command inputs to the table
      the display of the table will adjust to show all of the columns that contain a command input.
      @param columnRatio Sets the width ratio of the columns. This is defined using a string
      such as "1:1:1" where this defines that the first three columns are all the same width.
      A value of "2:1" defines that the first column is twice the width of the second.
      If the table has more columns than are defined by this property, they will automatically
      default to a value of 1. If this property defines the width of more columns than are
      displayed, the extra definitions are ignored.
      You can also specify 0 as a column width and this will have the effect of hiding
      that column. Setting a column width to 0 does not delete the column or the command inputs
      but only hides them so they can be turned back on at a later time by resetting the
      column ratio.
      @returns Returns the created TableCommandInput object or null if the creation failed.
    */
    addTableCommandInput(id: string, name: string, numberOfColumns: number /*int*/, columnRatio: string): TableCommandInput | null
    /**
      Adds a new angle value input to the command. This displays a field in the command dialog where an
      angle value can be entered. It displays the angle in the dialog using degrees. There is also a graphical
      manipulator associated with the input to allow the user to graphically set the value. You use the
      setManipulator method of the returned AngleValueCommandInput object to define the position and
      orientation of the manipulator.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed label of this input as seen in the dialog.
      If a name is not specified (an empty string), the input will be centered horizontally within it's row in the dialog.
      If a name is specified it will appear as a left justified label aligned with the other command input labels,
      and the left side of the image will be aligned with the other command input controls.
      @param initialValue The initial value of the input. If the value input is a number then it is interpreted as radians. If it is
      a string it uses the units specified in the string or if no units are specified it uses degrees.
      @returns Returns the created AngleValueCommandInput object or null if the creation failed.
    */
    addAngleValueCommandInput(id: string, name: string, initialValue: ValueInput): AngleValueCommandInput | null
    /**
      Adds a new command input to the command that behaves as a browser.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param name The displayed label of this input as seen in the dialog.
      If a name is not specified (an empty string), the input will be centered horizontally within it's row in the dialog.
      If a name is specified, the name will appear as a left justified label aligned with the other command input labels,
      and the left side of the input will be aligned with the other command inputs.
      @param htmlFileURL Specifies the URL to the HTML file that will be displayed in the tab. This can be a local file or on the web.
      @param minimumHeight Defines the minimum height of the browser within the command dialog. As the user resizes the dialog, the area taken
      up by the browser will shrink and grow to fit within the defined space. It will never shrink to be less than the
      minimum height or expand to be larger than the maximum height. If the dialog can't fit the browser at the minimum size
      a scroll bar will appear for the dialog to allow the user to scroll to access all the inputs in the dialog.
      @param maximumHeight An optional parameter that specifies the maximum height of the browser within the command dialog. As the user resizes
      the dialog, the area taken up by the browser will shrink and grow to fit within the defined space. It will never
      shrink to be less than the minimum height or expand to be larger than the maximum height. If the content displayed
      within the browser does not fit within the current area, a scroll bar will appear to allow the user to scroll to see
      the entire browser content. The default value of zero sets no maximum height, so the browser will expand to the maximum
      extent available.
      @returns Returns the created BrowserCommandInput object or null if the creation failed.
    */
    addBrowserCommandInput(id: string, name: string, htmlFileURL: string, minimumHeight: number /*int*/, maximumHeight?: number /*int*//* = 0*/): BrowserCommandInput | null
    /**
      Adds a new triad command input to the command. The input is initially invisible to allow you to define the desired
      behavior and then set the isVisible property to true when you're ready to display the triad.
      The creation of a triad command input results in displaying many input fields in the command dialog. For example,
      there can be individual fields for the X, Y, and Z offset distances, the X, Y, and Z scales, the X, Y, and Z angles, etc.
      You control which fields are visible by setting properties on the returned TriadCommandInput. Even though each of these
      appears as an individual input in the command dialog, and they are all associated with the single TriadCommandInput object.
      It also results in graphics widgets being displayed to allow the user to define the values graphically.
      When a new triad is created, it displays all inputs except those that control scaling. You can use the
      properties on the returned triad to define the inputs you want to display further.
      To simplify your command dialog it can be useful put the TriadCommandInput within a GroupCommandInput so it's
      apparent to the user these items are related and they can be collapsed to reduce clutter in the dialog. This
      also allows you to label the set of displayed inputs by using the name of the GroupCommandInput.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @param transform Defines the initial position and orientation of the manipulator.
      @returns Returns the created TriadCommandInput object or null if the creation failed.
    */
    addTriadCommandInput(id: string, transform: Matrix3D): TriadCommandInput | null
    /**
      Adds a new Separator input to the command. A separator input is for visual purposes only and creates
      a line in the dialog providing a visual separation between the command inputs above and below where
      the separator is inserted.
      @param id The unique ID of this command input. It must be unique with respect to the other inputs associated with this command.
      @returns Returns the created SeparatorCommandInput object or null if the creation failed.
    */
    addSeparatorCommandInput(id: string): SeparatorCommandInput | null
  }

  /**
    Defines the different styles that a drop-down input can be.
    @permissions ui
  */
  const enum DropDownStyles {
    /**
      Defines a drop-down where it contains a list items where each item has text and an icon.
      If the icon of the list item is set to null, a radio button will be displayed instead of
      the icon. A single item can be selected at a time.
    */
    LabeledIconDropDownStyle,
    /**
      Defines a drop-down that contains a scrollable list of text only items and one item can
      be selected from the list.
    */
    TextListDropDownStyle,
    /**
      Defines a drop-down that contains a list of check boxes where multiple items can be checked.
    */
    CheckBoxDropDownStyle,
  }

  /**
    The base class for all command inputs. A CommandInput is used to gather an input value from the user when a command is executed.
    @permissions ui
  */
  abstract class CommandInput extends Base {
    /**
      Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput.
    */
    readonly commandInputs: CommandInputs
    /**
      Gets the unique identifier for this input in the command's CommandInputs.
    */
    readonly id: string
    /**
      Gets the user visible name of this input.
    */
    readonly name: string
    /**
      Gets or sets if this input is currently enabled or disabled for user interaction.
      Currently, the isEnabled property does not disable SelectionCommandInput objects but
      instead has the same effect as the SelectionCommandInput.hasFocus property.
    */
    isEnabled: boolean
    /**
      Gets or sets if this input will be visible to the user.
      Setting a SelectionCommandInput to be invisible will clear any selections it currently has.
    */
    isVisible: boolean
    /**
      Gets the parent Command.
    */
    readonly parentCommand: Command
    /**
      Gets or sets if this input fills the entire width of the dialog. If
      true, the name is ignored and the input control will fill the entire width of the command dialog.
      The default value for this property in a new command input if false, or not to fill the width.
      This property does not apply to GroupCommandInputs or TabCommandInputs.
    */
    isFullWidth: boolean
    /**
      Gets or sets the full filename of the image file (PNG) used for the tool clip.
      The tooltip is always shown but as the user hovers over the control it will progressively display
      the tool clip and description text.
    */
    toolClipFilename: string
    /**
      Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description
      and/or tool clip are also specified then the tooltip will progressively display more information as the
      user hovers the mouse over the control.
    */
    tooltip: string
    /**
      Gets or sets additional text to display progressively along with the tooltip. The text for the description
      can contain some basic HTML formatting tags to format the tags. For example the br tag can be used to
      create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will
      progressively display the tool clip and description text.
    */
    tooltipDescription: string
    /**
      Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput.
      Returns null if there is no parent.
    */
    readonly parentCommandInput: CommandInput
    /**
      Deletes this Command input.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
  }

  /**
    Provides a command input to get a unit based value from the user.
    @permissions ui
  */
  abstract class ValueCommandInput extends CommandInput {
    /**
      Gets or sets the value associated with this input. The value is always in
      the database units of the unit type specified. For example, if the unit type is "inch"
      this value is in centimeters since centimeters are the database length unit. When setting the
      value it is converted into a string using the unit type and displayed in the input box.
      When getting the value, the current expression string is evaluated and the database value
      for the unit type is returned.
      @remarks
      The isValidExpression property should be checked before using this value within the command
      because if the expression can't be evaluated there isn't a valid value. Fusion won't
      allow the execution of a command that contains ValueCommandInput object with invalid expressions
      so you can dependably use the value in the execute event of the command.
    */
    value: number
    /**
      Gets or sets the expression displayed in the input field. This can contain equations and
      references to parameters. It is evaluated using the specified unit type.
    */
    expression: string
    /**
      Gets and sets the unit type that is used when evaluating the user's input.
    */
    unitType: string
    /**
      Returns true if the current expression is valid and can be evaluated. If this
      is false, the value returned should be ignored because there currently is
      not a valid value.
    */
    readonly isValidExpression: boolean
    /**
      Gets and sets whether the minimum value has a limit. The minimum limit is set using
      the minimumValue property, and the isMinimumInclusive property controls whether the minimum
      includes the minimum value or must be greater than the minimum.
      When a new ValueCommandInput is created this defaults to false so there is no limit.
    */
    isMinimumLimited: boolean
    /**
      Gets and sets the minimum value for the input. Setting this value will automatically
      set the isMinimumLimited property to true, enabling the use of the minimum value. Use
      the isMinimumInclusive property to control if the minimum can be equal to this value or must
      be greater than the minimum.
    */
    minimumValue: number
    /**
      Gets and sets if the minimum value can be equal to the value defined by the minimumValue
      property or if it must be greater than.
      When a new ValueCommandInput is created, this defaults to true.
    */
    isMinimumInclusive: boolean
    /**
      Gets and sets whether the maximum value has a limit. The maximum limit is set using
      the maximumValue property, and the isMaximumInclusive property controls whether the maximum
      includes the maximum value or must be less than the maximum.
      When a new ValueCommandInput is created this defaults to false so there is no limit.
    */
    isMaximumLimited: boolean
    /**
      Gets and sets the maximum value for the input. Setting this value will automatically
      set the isMaximumLimited property to true, enabling the use of the maximum value. Use
      the isMaximumInclusive property to control if the maximum can be equal to this value or must
      be less than the maximum.
    */
    maximumValue: number
    /**
      Gets and sets if the maximum value can be equal to the value defined by the maximumValue
      property or if it must be less than the maximum.
      When a new ValueCommandInput is created, this defaults to true.
    */
    isMaximumInclusive: boolean
  }

  /**
    Provides a command input to interact with a text box.
    @permissions ui
  */
  abstract class TextBoxCommandInput extends CommandInput {
    /**
      Gets and sets the formatted text displayed in the dialog.
      @remarks
      Formatted text includes any basic HTML formatting that has been defined. For example, you can use
      basic HTML formatting such as ,
      and  for a line break. It also supports hyper-links, which when clicked
      by the user, Fusion will open the specified URL in the default browser. Hyper-links are defined
      using the  tag such as
      "".
      When setting the formattedText it's assumed the string has HTML formatting and it's best if the TextBoxCommandInput
      is set the input to be read-only. If the user edits formatted text, the result that's returned by both the
      formattedText and the text property may not always be as expected. If you want the user to enter or edit text
      in the text input, then you use the text property to define the text.
    */
    formattedText: string
    /**
      Gets and sets the text in the text box. When text is set using the text property, any HTML formatting is
      ignored and the full string will be displayed in the text box. For example, if you specify the string
      "Here is a &ltb&gtBold&lt/b&gt word", and use the formattedText property, you will see "Here is a <b>Bold</b> word" in
      the text box. However, if you use the text property, you will see "Here is a &ltb&gtBold&lt/b&gt word" and when you
      get the text property you will get back "Here is a &ltb&gtBold&lt/b&gt word". This can be useful if you're using
      the text box to have the user enter HTML code so it's treated as a simple string.
    */
    text: string
    /**
      Gets and sets the height of the text box as defined by the number of rows of
      text that can be displayed. If the text is larger than will fit in the box
      a scroll bar will automatically be displayed.
    */
    numRows: number /*int*/
    /**
      Gets and sets if the text box is read-only or not. If it is read-only the user
      cannot edit the text.
    */
    isReadOnly: boolean
  }

  /**
    Provides a command input to get a boolean value from the user. This is represented
    in the user interface as either a button or a check box.
    @permissions ui
  */
  abstract class BoolValueCommandInput extends CommandInput {
    /**
      Gets or sets the state of this input. If it's being displayed as a check box a value of true indicates the input is checked.
      If it's being displayed as a button, a value of true indicates the button is currently depressed.
    */
    value: boolean
    /**
      Gets and sets the folder that contains the icon to display on the button. Text
      can also be displayed, which is specified using the text property. More information about icons can be found in the user manual
      topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
    */
    resourceFolder: string
    /**
      Indicates if this is being shown as a button or check box.
    */
    readonly isCheckBox: boolean
    /**
      Gets and sets text to be displayed on the button. If the resourceFolder
      is not specified then the button will be displayed with only text. If
      text and the resource folder are specified then both the icon and text
      will be displayed.
    */
    text: string
  }

  /**
    Provides a command input to get a string value from the user.
    @permissions ui
  */
  abstract class StringValueCommandInput extends CommandInput {
    /**
      Gets or sets the value of this input.
    */
    value: string
    /**
      Gets or sets if this string input behaves as a password field.
      This defaults to false for a newly created StringValueCommandInput.
      If true, dots are displayed instead of the actual characters but
      the value property will get and set the actual string.
    */
    isPassword: boolean
    /**
      Gets and sets if the string value is read-only or not. If it is read-only the user
      cannot edit the text. This property is initialized to False for a newly created
      StringValueCommandInput object.
    */
    isReadOnly: boolean
    /**
      Specifies if the current value shown is valid or not. Any string is valid for a
      StringValueCommandInput, but you many have some criteria that the string needs
      to meet for it to be valid in your application. You use the command's validateInputs
      event to verify that inputs are valid and control whether the "OK" button is enabled
      or not, and you can also set this property on specific StringValueCommandInputs objects
      to indicate to the user that a specific value is not correct. When this property is
      true, Fusion will change the color of the text to red to indicate to the user there is
      a problem.
    */
    isValueError: boolean
  }

  /**
    Provides a command input to get a selection from the user.
    @permissions ui
  */
  abstract class SelectionCommandInput extends CommandInput {
    /**
      Gets or sets the tooltip shown next to the cursor.
    */
    commandPrompt: string
    /**
      Adds an additional filter to the existing filter list.
      @param filter The name of a selection filter to add. The valid list of selection filters can be found here: <a href="SelectionFilters_UM.htm">Selection Filters</a>.
      @returns Returns true if the filter was added successfully.
    */
    addSelectionFilter(filter: string): boolean
    /**
      Clears the list of selection filters.
      @returns Returns true if successful.
    */
    clearSelectionFilter(): boolean
    /**
      Gets or sets the list of selection filters.
      @remarks
      The valid list of selection filters can be found here: .
    */
    selectionFilters: string[]
    /**
      Gets the current number of selections the user has made for this input.
    */
    readonly selectionCount: number /*unsigned int*/
    /**
      Returns the selection at the specified index.
      @param index The index of the selection to return.
      @returns Returns the Selection at the specified index, or null on error.
    */
    selection(index: number /*unsigned int*/): Selection | null
    /**
      Adds the selection to the list of selections associated with this input. This method is not valid within
      the commandCreated event but must be used later in the command lifetime. If you want to pre-populate the
      selection when the command is starting, you can use this method in the activate method of the Command.
      It's also valid to use in other events once the command is running, such as the validateInputs event.
      @param selection The entity to add a selection of to this input. The addition may fail if the entity
      does not match the selection filter, or adding it would exceed the limits.
      @returns Returns true if a selection to the entity was added to this input.
    */
    addSelection(selection: Base): boolean
    /**
      Defines the limits for the number of selections associated with this input.
      A maximum value of 0 indicates that there is no maximum.
      @param minimum The minimum number of selections required. A value of zero means that there is no minimum limit.
      @param maximum The maximum number of selections required. A value of zero means that there is no maximum limit.
      If maximum is equal to minimum, then exactly that number of selections is required.
      @returns Returns true if the limits were successfully set.
    */
    setSelectionLimits(minimum: number /*unsigned int*/, maximum?: number /*unsigned int*//* = 0*/): boolean
    /**
      Clears the current selection so no entities are in the selection.
      @returns Returns true if successful.
    */
    clearSelection(): boolean
    /**
      Gets and sets if this selection input has focus with respect to other selection inputs on the
      command dialog. Only one selection input on a dialog can have focus at a time, so setting hasFocus to true
      will remove the focus from the selection input that previously had focus. When a selection input
      has focus any user selections will be added to that selection input, and the selection rules associated
      with that selection input will apply.
      Setting hasFocus to True for a selection input whose isVisible property is false will fail.
    */
    hasFocus: boolean
    /**
      Select bodies.
    */
    static readonly Bodies: string
    /**
      Select solid bodies (closed BRepBody).
    */
    static readonly SolidBodies: string
    /**
      Select surface bodies (open BRepBody)
    */
    static readonly SurfaceBodies: string
    /**
      Select mesh bodies.
    */
    static readonly MeshBodies: string
    /**
      Select faces of any shape.
    */
    static readonly Faces: string
    /**
      Select faces from a solid body.
    */
    static readonly SolidFaces: string
    /**
      Select faces from a surface body.
    */
    static readonly SurfaceFaces: string
    /**
      Select planar faces.
    */
    static readonly PlanarFaces: string
    /**
      Select cylindrical faces.
    */
    static readonly CylindricalFaces: string
    /**
      Select conical faces.
    */
    static readonly ConicalFaces: string
    /**
      Select spherical faces.
    */
    static readonly SphericalFaces: string
    /**
      Select toroidal faces.
    */
    static readonly ToroidalFaces: string
    /**
      Select spline (NURBS) faces.
    */
    static readonly SplineFaces: string
    /**
      Select edges of any shape.
    */
    static readonly Edges: string
    /**
      Select linear edges.
    */
    static readonly LinearEdges: string
    /**
      Select circular edges.
    */
    static readonly CircularEdges: string
    /**
      Select elliptical edges.
    */
    static readonly EllipticalEdges: string
    /**
      Select tangent edges.
    */
    static readonly TangentEdges: string
    /**
      Select edges that are not tangent.
    */
    static readonly NonTangentEdges: string
    /**
      Select vertices.
    */
    static readonly Vertices: string
    /**
      Select root components.
    */
    static readonly RootComponents: string
    /**
      Select occurrences.
    */
    static readonly Occurrences: string
    /**
      Select sketches.
    */
    static readonly Sketches: string
    /**
      Select sketch curves of any shape.
    */
    static readonly SketchCurves: string
    /**
      Select sketch lines.
    */
    static readonly SketchLines: string
    /**
      Select sketch circles.
    */
    static readonly SketchCircles: string
    /**
      Select sketch points.
    */
    static readonly SketchPoints: string
    /**
      Select construction points.
    */
    static readonly ConstructionPoints: string
    /**
      Select construction lines (axes).
    */
    static readonly ConstructionLines: string
    /**
      Select construction planes.
    */
    static readonly ConstructionPlanes: string
    /**
      Select any type of feature.
    */
    static readonly Features: string
    /**
      Select canvases.
    */
    static readonly Canvases: string
    /**
      Select decals.
    */
    static readonly Decals: string
    /**
      Select joint origins.
    */
    static readonly JointOrigins: string
    /**
      Select joints.
    */
    static readonly Joints: string
    /**
      Selects sketch geometric and dimensions constraints.
    */
    static readonly SketchConstraints: string
    /**
      Select profiles.
    */
    static readonly Profiles: string
    /**
      Select sketch text.
    */
    static readonly Texts: string
    /**
      Select custom graphics entities.
    */
    static readonly CustomGraphics: string
    /**
      Select face groups of meshes.
    */
    static readonly FaceGroups: string
    /**
      Determines if any selections the user has made before starting the command can be used by the
      command's selection inputs. The default is true, which means the active selections will be added
      to the first selection input whose selection filter allows for that entity type. For example,
      if you have two selection inputs that have filters to select any number of faces and there are
      four faces selected when the command is started, those four faces will be selected by the
      selection input. If there's another selection input for the same command that has the filter set to
      select sketch curves, and there are faces and sketch curves selected when you start the command, the
      faces will be selected by the selection input filtering for faces, and the sketch curves will be selected
      by the selection input filtering for sketch curves.
      You can programmatically control which selected entities will be added to the selection inputs by using the
      preSelect event of the command. The preSelect event will fire for each entity that was already selected before
      it's added to the selection input, and you can use it to control if it will be added to the selection input.
      @experimental
    */
    isUseCurrentSelections: boolean
    /**
      Select volumetric model.
    */
    static readonly VolumetricModel: string
  }

  /**
    Provides a command input to get the choice in a drop-down list from the user.
    @permissions ui
  */
  abstract class DropDownCommandInput extends CommandInput {
    /**
      Returns the style of drop down this was created as.
    */
    readonly dropDownStyle: DropDownStyles
    /**
      Returns the ListItems object associated with this drop-down. You use this
      object to populate and interact with the items in the drop-down.
    */
    readonly listItems: ListItems
    /**
      Gets the item in the list that is currently selected. This can return null in the
      case where no item in the list has been selected. This should be ignored
      for CheckBoxDropDownStyle style drop-downs because multiple items can be selected
      and each LiteItem should be checked individually.
    */
    readonly selectedItem: ListItem
    /**
      Gets or sets the maximum allowed size on screen of the drop down list, measured in items.
    */
    maxVisibleItems: number /*int*/
  }

  /**
    Provides a command input to get a selection of a single button from a row of buttons.
    @permissions ui
  */
  abstract class ButtonRowCommandInput extends CommandInput {
    /**
      Returns if this button row can have multiple items selected at once or not.
      If True, multiple buttons can be selected at once. If False only one button
      can be selected and selecting another button unselects the one currently selected.
    */
    readonly isMultiSelectEnabled: boolean
    /**
      Returns the ListItems object associated with this button row. You use this
      object to populate and interact with the buttons in the row. When adding items
      to a ButtonRowCommandInput, icons are required.
    */
    readonly listItems: ListItems
    /**
      Gets the button in the row that is currently selected. This can return null in the
      case where no button in the row has been selected.
    */
    readonly selectedItem: ListItem
  }

  /**
    Provides a command input to get the value of a slider from the user.
    @permissions ui
  */
  abstract class SliderCommandInput extends CommandInput {
    /**
      Uses an expression to set the value in the first input field. This can contain equations and
      is evaluated using the specified unit type.
    */
    expressionOne: string
    /**
      Uses an expression to set the value in the second input field. This can contain equations and
      is evaluated using the specified unit type.
      This property is only available when the hasTwoSliders property returns true.
    */
    expressionTwo: string
    /**
      Gets and sets the unit type that is used when evaluating the user's input.
    */
    unitType: string
    /**
      Gets if the command input has two sliders.
    */
    readonly hasTwoSliders: boolean
    /**
      Sets the text of the slider. Both the left and the right text should be set.
      @param left Indicates the text on the left side of the slider.
      @param right Indicates the text on the right side of the slider.
      @returns Returns true if successful.
    */
    setText(left: string, right: string): boolean
    /**
      Gets the texts of the slider if text has been defined.
      @param isLeft Indicates to get the left or right text.
      @returns Returns the left or right text of the slider.
    */
    getText(isLeft: boolean): string
  }

  /**
    Provides a command input to get the value of a slider from the user, the value type is float.
    @permissions ui
  */
  abstract class FloatSliderCommandInput extends SliderCommandInput {
    /**
      Gets or sets the first value associated with this input. The value is always in
      the database units of the unit type specified. For example, if the unit type is "inch"
      this value is in centimeters since centimeters are the database length unit. When setting the
      value it is converted into a string using the unit type and displayed in the input box.
    */
    valueOne: number
    /**
      Gets or sets the second value associated with this input. The value is always in
      the database units of the unit type specified. For example, if the unit type is "inch"
      this value is in centimeters since centimeters are the database length unit. When setting the
      value it is converted into a string using the unit type and displayed in the input box.
      This property is only available when the hasTwoSliders property returns true.
    */
    valueTwo: number
    /**
      Gets and sets minimum value of the slider in database units.
      Gets a failure when set if the value of this command input was added by value list.
    */
    minimumValue: number
    /**
      Gets and sets maximum value of the slider in database units.
      Gets a failure when set if the value of this command input was added by value list.
    */
    maximumValue: number
    /**
      Gets the value list of the slider. This property is valid when this input represents a list type of slider command input.
      Otherwise an empty list will be returned.
    */
    readonly valueList: number[]
    /**
      Gets and sets the spin step value in the unit type set by the unitType argument.
      The value should be more than zero. This is the amount the slider will advance
      when the user clicks the spin button beside the value.
    */
    spinStep: number
  }

  /**
    Provides a command input to get the value of a slider from the user, the value type is integer.
    @permissions ui
  */
  abstract class IntegerSliderCommandInput extends SliderCommandInput {
    /**
      Gets or sets the value associated with the first slider.
    */
    valueOne: number /*int*/
    /**
      If the hasTwoSliders property is true, this returns the value associated with
      the second slider.
    */
    valueTwo: number /*int*/
    /**
      Gets and sets minimum value of the slider. This will fail if there is a value list because the
      minimum and maximum values are defined by the value list.
    */
    minimumValue: number /*int*/
    /**
      Gets and sets maximum value of the slider. This will fail if there is a value list because the
      minimum and maximum values are defined by the value list.
    */
    maximumValue: number /*int*/
    /**
      Gets the value list of the slider. The list is empty if this command input was not added by value list.
    */
    readonly valueList: number[] /*int[]*/
    /**
      Gets and sets the spin step. This defines the amount the slider moves when the user clicks the spin
      button beside the value. The spin step should be more than zero.
    */
    spinStep: number /*unsigned int*/
  }

  /**
    Provides a command input to get the value of a spinner from the user, the value type is float.
    @permissions ui
  */
  abstract class FloatSpinnerCommandInput extends CommandInput {
    /**
      Gets and sets the value associated with this input. The value is always in
      the database units of the unit type specified. For example, if the unit type is "inch"
      this value is in centimeters since centimeters are the database length unit. When setting the
      value it is converted into a string using the unit type and displayed in the input box.
      The isValidExpression property should be checked before using this
      value within the command because if the expression can't be evaluated
      there isn't a valid value. Fusion won't allow the execution of a command
      that contains ValueCommandInput object with invalid expressions so you can
      dependably use the value in the execute event of the command.
    */
    value: number
    /**
      Gets the unit type that is used when evaluating the user's input.
    */
    readonly unitType: string
    /**
      Gets the minimum allowed value of the spinner in database units.
    */
    readonly minimumValue: number
    /**
      Gets the maximum allowed value of the spinner in database units.
    */
    readonly maximumValue: number
    /**
      Gets the spin step value in the unit type set by the unitType argument.
      The value should be more than zero. This is the amount the spinner will advance
      when the user clicks the spin button beside the value.
    */
    readonly spinStep: number
    /**
      Gets or sets the expression displayed in the input field. This can contain equations and
      references to parameters. It is evaluated using the specified unit type.
    */
    expression: string
    /**
      Returns true if the current expression is valid and can be evaluated. If this
      is false, the value returned should be ignored because there currently is
      not a valid value.
    */
    readonly isValidExpression: boolean
  }

  /**
    Provides a command input to get the value of a spinner from the user, the value type is integer.
    @permissions ui
  */
  abstract class IntegerSpinnerCommandInput extends CommandInput {
    /**
      Gets and sets the value associated with this input.
    */
    value: number /*int*/
    /**
      Gets the minimum allowed value of the spinner.
    */
    readonly minimumValue: number /*int*/
    /**
      Gets the maximum allowed value of the spinner.
    */
    readonly maximumValue: number /*int*/
    /**
      Gets the spin step. The value should be more than zero. This is the amount the spinner will advance
      when the user clicks the spin button beside the value.
    */
    readonly spinStep: number /*unsigned int*/
  }

  /**
    Provides a command input to get the choice from a radio button group from the user.
    @permissions ui
  */
  abstract class RadioButtonGroupCommandInput extends CommandInput {
    /**
      Returns the ListItems object associated with this radio button group. You use this
      object to populate and interact with the items in the radio button group.
    */
    readonly listItems: ListItems
    /**
      Gets and sets the item in the radio button list that is currently selected.
    */
    readonly selectedItem: ListItem
  }

  /**
    Represents a command input that gets a distance from the user. This displays
    an entry in the command dialog where the user can enter a value and also displays
    a manipulator in the graphics window to allow them to graphically set the value.
    The input box is displayed in the dialog when the isVisible property of the command
    input is true. The manipulator is displayed in the graphics when both the isVisible
    and isEnabled properties are true.
    @permissions ui
  */
  abstract class DistanceValueCommandInput extends CommandInput {
    /**
      Gets and sets the current value of the command input. The value is
      in centimeters but will be displayed to the user in the current default
      document units. Setting this value can fail if the input value is
      not within the minimum and maximum value range.
      The isValidExpression property should be checked before using this
      value within the command because if the expression can't be evaluated
      there isn't a valid value. Fusion won't allow the execution of a command
      that contains ValueCommandInput object with invalid expressions so you can
      dependably use the value in the execute event of the command.
    */
    value: number
    /**
      Gets or sets the expression displayed in the input field. This can contain equations and
      references to parameters but must result in a valid length expression. If units are not
      specified as part of the expression, the default units for the design are used.
    */
    expression: string
    /**
      Gets and sets minimum value, if any, that the value can be. When getting this
      property you should first check the hasMinimumValue property to see if this property
      applies. Also, the isMinimumValueInclusive indicates if the minimum includes this
      value or will be up to this value.
      Setting this value will change the isMinimumValueInclusive to True and the hasMinimumValue property to True if hasMinimumValue is currently
      False, otherwise it will just update the value.
    */
    minimumValue: number
    /**
      Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid
      to set it to False to remove the minimum value. Setting the minimumValue property will result in this property
      being set to True.
    */
    hasMinimumValue: boolean
    /**
      Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,
      if the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the
      minimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,
      this property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property
      returns True.
    */
    isMinimumValueInclusive: boolean
    /**
      Gets and sets maximum value, if any, that the value can be. When getting this
      property you should first check the hasMaximumValue property to see if this property
      applies. Also, the isMaximumValueInclusive indicates if the maximum includes this
      value or will be up to this value.
    */
    maximumValue: number
    /**
      Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid
      to set it to False to remove the maximum value. Setting the maximumValue property will result in this property
      being set to True.
    */
    hasMaximumValue: boolean
    /**
      Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,
      if the maximum value is 100 and this property is True, the maximum value can be 100. If this is False, the
      minimum value must be less than 100. When the maximum value is first defined using the maximumValue property,
      this property is set to True. The value returned by this property is only meaningful when the hasMaximumValue property
      returns True.
    */
    isMaximumValueInclusive: boolean
    /**
      Defines the position and orientation of the manipulator. The manipulator is only visible
      when both the isVisible and isEnabled properties are true. If those properties are
      true and the setManipulator has not been called, the manipulator will be displayed in
      a default location (0,0,0) and direction (1,0,0). Because of that the input is typically
      set to be invisible and/or disabled and then enabled once enough input has been specified
      that you can display the manipulator in the desired location.
      @param origin Defines the position of the manipulator in root component space.
      @param direction Defines the direction of the manipulator in root component space.
      @returns Returns true if successful.
    */
    setManipulator(origin: core.Point3D, direction: core.Vector3D): boolean
    /**
      Gets the origin point of the manipulator in the model space of the root component.
      To set the origin use the setManipulator method.
    */
    readonly manipulatorOrigin: core.Point3D
    /**
      Gets the positive direction of the manipulator in the model space or the root component.
      To set the direction use the setManipulator method.
    */
    readonly manipulatorDirection: core.Vector3D
    /**
      Returns true if the current expression is valid and can be evaluated. If this
      is false, the value returned should be ignored because there currently is
      not a valid value.
    */
    readonly isValidExpression: boolean
  }

  /**
    Represents a command input that gets an angle from the user. This displays
    an entry in the command dialog where the user can enter a value and also displays
    a manipulator in the graphics window to allow them to graphically set the value.
    The input box is displayed in the dialog when the isVisible property of the command
    input is true. The manipulator is displayed in the graphics when both the isVisible
    and isEnabled properties are true.
    @permissions ui
  */
  abstract class AngleValueCommandInput extends CommandInput {
    /**
      Gets and sets the current value of the command input. The value is in radians
      but will be displayed to the user in degrees. Setting this value can fail if the input value is
      not within the minimum and maximum value range.
      The isValidExpression property should be checked before using the value within the command
      because if the expression can't be evaluated there isn't a valid value. Fusion won't allow
      the execution of a command that contains ValueCommandInput object with invalid expressions
      so you can dependably use the value in the execute event of the command.
    */
    value: number
    /**
      Gets or sets the expression displayed in the input field. This can contain equations and
      references to parameters but must result in a valid angle expression. If units are not
      specified as part of the expression, the default user units of degrees are used.
    */
    expression: string
    /**
      Gets and sets minimum value, if any, that the value can be. The value is in radians. When getting this
      property you should first check the hasMinimumValue property to see if this property
      applies. Also, the isMinimumValueInclusive indicates if the minimum includes this
      value or will be up to this value.
      Setting this value will change the isMinimumValueInclusive to True and the hasMinimumValue
      property to True if hasMinimumValue is currently False, otherwise it will just update the value.
    */
    minimumValue: number
    /**
      Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid
      to set it to False to remove the minimum value. Setting the minimumValue property will result in this property
      being set to True.
    */
    hasMinimumValue: boolean
    /**
      Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,
      if the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the
      minimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,
      this property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property
      returns True.
    */
    isMinimumValueInclusive: boolean
    /**
      Gets and sets maximum value, if any, that the value can be. The value is in radians. When getting this
      property you should first check the hasMaximumValue property to see if this property applies. Also, the
      isMaximumValueInclusive indicates if the minimum includes this value or will be up to this value.
      Setting this value will change the isMaximumValueInclusive to True and the hasMaximumValue
      property to True if hasMaximumValue is currently False, otherwise it will just update the value.
    */
    maximumValue: number
    /**
      Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid
      to set it to False to remove the maximum value. Setting the maximumValue property will result in this property
      being set to True.
    */
    hasMaximumValue: boolean
    /**
      Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,
      if the maximum value is the value of pi (180 degrees) and this property is True, the maximum value can be pi.
      If this is False, the minimum value must be less than pi. When the maximum value is first defined using the
      maximumValue property, this property is set to True. The value returned by this property is only meaningful
      when the hasMaximumValue property returns True.
    */
    isMaximumValueInclusive: boolean
    /**
      Defines the position and orientation of the manipulator. The manipulator is only visible
      when both the isVisible and isEnabled properties are true. If those properties are
      true and the setManipulator has not been called, the manipulator will be displayed in
      a default location (0,0,0) using default directions x direction (1,0,0) and y direction (0,1,0).
      Because of that the input is typically set to be invisible and/or disabled and then enabled once
      enough input has been specified that you can display the manipulator in the desired location.
      @param origin Defines the center position of the manipulator in root component space.
      @param xDirection Defines the X direction of the manipulator in root component space. The X direction is the 0 angle direction. This
      direction, along with the Y direction vector define the plane that the manipulator is displayed on.
      @param yDirection Defines the Y direction of the manipulator in root component space. The X and Y direction vectors define the plane
      the manipulator is displayed one. When the manipulator is rotated from the xDirection vector towards the yDirection
      vector that is the positive direction.
      @returns Returns true if successful.
    */
    setManipulator(origin: core.Point3D, xDirection: core.Vector3D, yDirection: core.Vector3D): boolean
    /**
      Gets the origin point of the manipulator in the model space of the root component.
      To set the origin use the setManipulator method.
    */
    readonly manipulatorOrigin: core.Point3D
    /**
      Gets the X direction of the manipulator in the model space of the root component. The X direction is
      the 0 angle direction. This direction, along with the Y direction vector define the plane that the
      manipulator is displayed on.
      To set the direction use the setManipulator method.
    */
    readonly manipulatorXDirection: core.Vector3D
    /**
      Gets the Y direction of the manipulator in the model space of the root component. The X and Y direction
      vectors define the plane that the manipulator is displayed on.
      To set the direction use the setManipulator method.
    */
    readonly manipulatorYDirection: core.Vector3D
    /**
      Returns true if the current expression is valid and can be evaluated. If this
      is false, the value returned should be ignored because there currently is
      not a valid value.
    */
    readonly isValidExpression: boolean
  }

  /**
    Represents a command input that gets a direction from the user. This displays
    a button or a check-box in the command dialog where the user can flip the direction if desired and also displays
    a manipulator in the graphics window to allow flipping the direction by clicking and dragging on the manipulator.
    @permissions ui
  */
  abstract class DirectionCommandInput extends CommandInput {
    /**
      Defines a direction manipulator arrow in the graphics viewport whose direction can be flipped by the
      toggling the check box, clicking the button or by the user clicking and dragging on the manipulator arrow.
      @param origin The origin point of the direction manipulator (arrow) in the model space of the root component.
      @param direction The direction of the manipulator (arrow) in the model space of the root component.
      @returns Returns true if successful
    */
    setManipulator(origin: core.Point3D, direction: core.Vector3D): boolean
    /**
      Gets the origin point of the direction manipulator (arrow) in the model space of the root component.
      To set the origin use the setManipulator method.
    */
    readonly manipulatorOrigin: core.Point3D
    /**
      Gets the direction of the manipulator (arrow) in the model space of the root component.
      To set the direction use the setManipulator method.
    */
    readonly manipulatorDirection: core.Vector3D
    /**
      Gets and sets if the direction manipulator displayed is flipped (reversed 180 degrees as compared to the
      direction defined by the manipulatorDirection property). This is false for a newly created DirectionCommandInput.
    */
    isDirectionFlipped: boolean
    /**
      Gets and sets the folder that contains the icon to display on the button.
      The input is shown as a check box if the resource folder is set to an empty string. Icons can be defined
      using either PNG or SVG files. More information about icons can be found in the user manual
      topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
    */
    resourceFolder: string
  }

  /**
    Group Command inputs organize a set of command inputs into a collapsible
    list within a command dialog
    @permissions ui
  */
  abstract class GroupCommandInput extends CommandInput {
    /**
      Gets the CommandInputs collection for this GroupCommandInput.
      Use the add methods on this collection to add child CommandInputs to this Group in the desired order.
    */
    readonly children: CommandInputs
    /**
      Gets or sets if this group is expanded.
      If this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false
      then the isExpanded property must be set to true.
    */
    isExpanded: boolean
    /**
      Gets or sets if this group has a check-box for enabling/disabling the group.
      If this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false
      then the isExpanded property must be set to true.
    */
    isEnabledCheckBoxDisplayed: boolean
    /**
      Gets or sets if the enabled check-box is checked or not. This is only
      valid when the isEnabledCheckBoxDisplayed property is true.
    */
    isEnabledCheckBoxChecked: boolean
  }

  /**
    Tab command inputs contain a set of command inputs and/or group command inputs/
    @permissions ui
  */
  abstract class TabCommandInput extends CommandInput {
    /**
      Gets the CommandInputs collection for this TabCommandInput.
      Use the add methods on this collection to add child CommandInputs to this Tab in the desired order.
    */
    readonly children: CommandInputs
    /**
      Gets the folder that contains the icon for the tab. If no name is specified (no text on tab),
      a resourceFolder containing the icon needs to be provided. Icons can be defined
      using either PNG or SVG files. More information about icons can be found in the user manual
      topic <a href="UserInterface_UM.htm#IconsForCommands">User Interface Customization</a>.
    */
    readonly resourceFolder: string
    /**
      Gets if this is the currently activated (selected) tab.
    */
    readonly isActive: boolean
    /**
      Sets this to be the currently activated (selected) tab.
      @returns Returns true if the TabCommandInput was successfully activated.
    */
    activate(): boolean
  }

  /**
    Browser command inputs behave as a browser where you can define HTML to be displayed within the
    area occupied by the command input.
    @permissions ui
  */
  abstract class BrowserCommandInput extends CommandInput {
    /**
      Gets and sets the URL to the HTML file currently being displayed. This can be local or on the web.
    */
    htmlFileURL: string
    /**
      Gets and sets the minimum height of the browser within the command dialog in pixels. As the user resizes the dialog, the area taken
      up by the browser will shrink and grow to fit within the defined space. It will never shrink to be less than the
      minimum height or expand to be larger than the maximum height. If the dialog can't fit the browser at the minimum size
      a scroll bar will appear for the dialog to allow the user to scroll to access all the inputs in the dialog.
    */
    minimumHeight: number /*int*/
    /**
      Gets and sets the maximum height of the browser within the command dialog, in pixels. As the user resizes
      the dialog, the area taken up by the browser will shrink and grow to fit within the defined space. It will never
      shrink to be less than the minimum height or expand to be larger than the maximum height. If the content displayed
      within the browser does not fit within the current area, a scroll bar will appear to allow the user to scroll to see
      the entire browser content. The default value of zero sets no maximum height, so the browser will expand to the maximum
      extent available.
    */
    maximumHeight: number /*int*/
    /**
      Sends a string to the JavaScript associated with the loaded HTML.
      @remarks
      A variation of the event handler below should be implemented in the JavaScript associated
      with the HTML to receive the data. The event will be triggered by Fusion whenever the
      sendInfoToHTML method is called.
      ```
      window.fusionJavaScriptHandler = {
          handle: function(actionString, dataString){
              confirm('Action from Fusion: ' + actionString)
              confirm('Data from Fusion: ' + dataString)
              // Build up JSON return string.
              var result = {}
              result.status = 'OK'
              var response = JSON.stringify(result)
              return response
          }
      }
      ```
      Your JavaScript code should always return something in response because an empty string
      response is assumed to be a failure.
      @param action The "action" string to pass to the JavaScript associated with the HTML. This string can be
      anything but will typically be JSON formatted information.
      @param data The "data" string to pass to the JavaScript associated with the HTML. This string can be
      anything but will typically be JSON formatted information.
      @returns This API call is asynchronous and true is returned if the send was successful. Any response from
      the JavaScript response will be returned through the incomingFromHTML event using the data field of
      the provided HTMLEvent object where the action property is "response".
      @permissions desktop
    */
    sendInfoToHTML(action: string, data: string): boolean
  }

  /**
    Provides an image command input for including an image in a command dialog.
    @permissions ui
  */
  abstract class ImageCommandInput extends CommandInput {
    /**
      Gets and sets the full path and file name of the image file.
      Supported image format is .png
      Images are displayed in the command dialog using their actual size.
    */
    imageFile: string
    /**
      Gets and sets the scale of the image. This defaults to 1.0, which is full-scale.
    */
    scaleFactor: number
  }

  /**
    Represents a table within a command dialog. The table consists of
    rows and columns where each cell can contain another command input. The
    selection and button row command inputs cannot be used within a table.
    In addition to the rows and columns, each table can optionally have a
    toolbar of separate command inputs that is shown at the bottom of the table.
    A table command input can conceptually be compared to an Excel table where you
    have an infinite number of rows and columns available but use a small portion.
    As you add inputs to the table, the table will adjust so all used columns are
    visible. The visible number of rows is controlled by you and if you create
    more rows than can be displayed a scroll bar becomes available.
    For an example of this command input, see the loft command which uses it to show
    the selected profiles and rails.
    @permissions ui
  */
  abstract class TableCommandInput extends CommandInput {
    /**
      Returns the current number of visible columns displayed. Setting this property
      has no effect because the number of columns is automatically inferred by
      the command inputs that have been added to the table. The table automatically
      adjusts the number of rows displayed so all inputs can be seen.
    */
    numberOfColumns: number /*int*/
    /**
      Gets and sets the width ratio of the columns. This is defined using a string
      such as "1:1:1" where this defines that the first three columns are all the same width.
      A value of "2:1" defines that the first column is twice the width of the second.
      If the table has more columns than are defined by this property, they will automatically
      default to a value of 1. If this property defines the width of more columns than are
      displayed, the extra definitions are ignored.
      You can also specify 0 as a column width and this will have the effect of hiding
      that column. Setting a column width to 0 does not delete the column or the command inputs
      but only hides them so they can be turned back on at a later time by resetting the
      column ratio.
    */
    columnRatio: string
    /**
      Gets and sets whether a grid is displayed for the table. For a newly created
      table, this property defaults to false.
    */
    hasGrid: boolean
    /**
      Gets and sets the spacing between rows. This is defined in pixels. For a newly
      created table, this property defaults to 1.
    */
    rowSpacing: number /*int*/
    /**
      Gets and sets the spacing between columns. This is defined in pixels. For a newly
      created table, this property defaults to 1.
    */
    columnSpacing: number /*int*/
    /**
      Gets and sets the minimum number of rows displayed. This is the minimum amount of
      space taken up on the command dialog, even if the table doesn't yet contain any
      rows. For a newly created table, this property defaults to 2.
    */
    minimumVisibleRows: number /*int*/
    /**
      Gets and sets the maximum number of rows that can be displayed. As rows are added
      the visible size of the table will grow to show all rows until this maximum number
      of rows is reached and then a scroll bar will be displayed to allow the user to
      access all rows. For a new created table, this property defaults to 4.
    */
    maximumVisibleRows: number /*int*/
    /**
      Deletes the specified row. The following rows will be shifted up. The row and the
      command inputs it contains are deleted. To temporarily hide a row you can set the
      visibility of all of the command inputs it contains to be invisible. If all inputs
      are invisible the row will automatically be hidden.
      @param row The row to delete where valid values are 0 to the number of rows minus 1. A value of
      0 will delete the first row. A value greater than the number of rows will delete the
      last row.
      @returns Returns true if the delete was successful.
    */
    deleteRow(row: number /*int*/): boolean
    /**
      Gets and sets the presentation style the table is currently using for its display.
    */
    tablePresentationStyle: TablePresentationStyles
    /**
      Adds a command input to a particular cell in the table. Rows are automatically added to the table to
      able to contain the command input. The command input can span multiple columns within a row and spanning
      across multiple rows is not currently supported.
      The command input is created in the standard way but when it's added to the table using this method it
      will be displayed in the table instead of the main area of the dialog.
      @param input The command input to associate to a cell. The command input is created in the standard way but when it's added to
      the table using this method it will be displayed in the table instead of the main area of the dialog.
      @param row The row index of the cell where 0 is the first row.
      @param column The column index of the cell where 0 is the first column.
      @param rowSpan The number of additional rows that this input uses. The default value of 0 indicates that no additional
      rows are used. Row spanning is not currently supported so this value must always be 0.
      @param columnSpan The number of additional columns that this input uses. The default value of 0 indicates that no additional
      columns are used.
      @returns Returns true if the association of the command input to the cell was successful.
    */
    addCommandInput(input: CommandInput, row: number /*int*/, column: number /*int*/, rowSpan?: number /*int*//* = 0*/, columnSpan?: number /*int*//* = 0*/): boolean
    /**
      Removes the command input that is at the specified row and column. This doesn't delete the command input from
      the collection of inputs associated with the command but just removes it from being displayed in the table.
      @param row The row where the command input to be removed is located.
      @param column The row where the command input to be removed is located.
      @returns Returns true if the removal was successful.
    */
    removeInput(row: number /*int*/, column: number /*int*/): boolean
    /**
      Gets the position of the specified command input within the table.
      @param input The existing command input you want to find the associated cell for.
      @param row The returned row index of the cell.
      @param column The returned column index of the cell.
      @param rowSpan The returned number of additional rows used by the input. A value of 0
      indicates that no additional rows are used.
      @param columnSpan The returned number of additional columns used by the input. A value of 0
      indicates that no additional columns are used.
      @returns Returns true if the position was successfully returned.
    */
    getPosition(input: CommandInput): [row: number /*int*/, column: number /*int*/, rowSpan: number /*int*/, columnSpan: number /*int*/]
    /**
      Returns the number of rows in the table. The actual number of rows in the table is defined
      by the number of rows that contain command inputs.
    */
    readonly rowCount: number /*int*/
    /**
      Removes all rows in the table and the toolbar.
      @returns Returns true if successful.
    */
    clear(): boolean
    /**
      Gets and sets which row is selected in the user-interface. A value of 0 indicates
      that the first row is selected. A value of -1 indicates that no row is selected.
    */
    selectedRow: number /*int*/
    /**
      Adds a new command input to the toolbar at the bottom of the table.
      @param input Adds a command input to the toolbar at the bottom of the table. The inputs are displayed
      in the same order that they're added.
      The command input is created in the standard way but when it's added to the table using this method it
      will be displayed in the table instead of the main area of the dialog.
      @returns Returns true if the command input was successfully added.
    */
    addToolbarCommandInput(input: CommandInput): boolean
    /**
      Returns the command input that is in the specified row and column. In the case
      where a command input spans multiple columns, the same input can be returned
      from multiple positions.
      @param row The row index to return the command input from where the first row is 0.
      @param column The row index to return the command input from where the first row is 0.
      @returns Returns the command input that is in the specified row and column. If there
      isn't a command input in the specified location, null is returned.
    */
    getInputAtPosition(row: number /*int*/, column: number /*int*/): CommandInput | null
  }

  /**
    The different styles that a TableCommandInput can use for its display.
    @permissions ui
  */
  const enum TablePresentationStyles {
    /**
    */
    nameValueTablePresentationStyle,
    /**
    */
    itemBorderTablePresentationStyle,
    /**
    */
    transparentBackgroundTablePresentationStyle,
  }

  /**
    Represents a command input that displays a triad and allows the user to control translation
    rotation, and scaling. Using properties on the input you can choose which controls are available
    to the user. This displays inputs in the command dialog where the user can enter values and also
    displays a manipulator in the graphics window to allow them to graphically set the values. The
    input boxes are displayed in the dialog when the isVisible property of the command input is true.
    The manipulator is displayed in the graphics window when both the isVisible and isEnabled properties
    are true.
    It will often be useful to first create a GroupCommandInput and then create the TriadCommandInput within the group so
    it's apparent to the user these items are related and they can be collapsed to reduce clutter in the dialog. This also
    allows you to label the set of displayed inputs by using the name of the GroupCommandInput.
    @permissions ui
  */
  abstract class TriadCommandInput extends CommandInput {
    /**
      A convenience method to turn on and off the visibility of the X, Y, and Z
      translation controls.
      @param isVisible Defines if the visibility of the controls should be turned on or off. True
      indicates they will be visible.
      @returns Returns true if it was successful.
    */
    setTranslateVisibility(isVisible: boolean): boolean
    /**
      A convenience method to turn on and off the visibility of the X-Y, Y-Z, and Z-X planar
      translation controls.
      @param isVisible Defines if the visibility of the controls should be turned on or off. True
      indicates they will be visible.
      @returns Returns true if it was successful.
    */
    setPlanarMoveVisibility(isVisible: boolean): boolean
    /**
      A convenience method to turn on and off the visibility of the X, Y, and Z
      axis rotation controls.
      @param isVisible Defines if the visibility of the controls should be turned on or off. True
      indicates they will be visible.
      @returns Returns true if it was successful.
    */
    setRotateVisibility(isVisible: boolean): boolean
    /**
      A convenience method to turn on and off the visibility of the controls that
      define scaling in the X, Y, and Z direction and the X-Y, Y-Z, and Z-X planes.
      @param isVisible Defines if the visibility of the controls should be turned on or off. True
      indicates they will be visible.
      @returns Returns true if it was successful.
    */
    setScaleVisibility(isVisible: boolean): boolean
    /**
      A convenience method to turn on and off the visibility of the horizontal
      and vertical flip controls.
      @param isVisible Defines if the visibility of the controls should be turned on or off. True
      indicates they will be visible.
      @returns Returns true if it was successful.
    */
    setFlipVisibility(isVisible: boolean): boolean
    /**
      A convenience method to turn on and off the visibility of commonly used
      controls in a triad. These include the X, Y, and Z axis translations, the
      X, Y, and Z axis rotations, scaling in the X, Y, and Z directions, scaling
      on the X-Y, Y-Z and Z-X planes, translation on the X-Y, Y-Z, and Z-X planes,
      and the origin move.
      @param isVisible Defines if the visibility of the controls should be turned on or off. True
      indicates they will be visible.
      @returns Returns true if it was successful.
    */
    setFullVisibility(isVisible: boolean): boolean
    /**
      Hides all controls.
      @returns Returns true if hiding the controls was successful.
    */
    hideAll(): boolean
    /**
      Gets and sets if the control that supports translation in the X, Y, and Z directions
      is visible in both the graphical manipulator and in the dialog. In the manipulator,
      this is the large dot at the origin or the triad.
    */
    isOriginTranslationVisible: boolean
    /**
      Gets and sets if the control that supports X Translation is visible in both the
      graphical manipulator and in the dialog.
    */
    isXTranslationVisible: boolean
    /**
      Gets and sets if the control that defines the Y Translation is visible in both the
      graphical manipulator and in the dialog.
    */
    isYTranslationVisible: boolean
    /**
      Gets and sets if the control that defines the Z Translation is visible in both the
      graphical manipulator and in the dialog.
    */
    isZTranslationVisible: boolean
    /**
      Gets and sets if the control that defines the translation in the X-Y plane is
      visible in both the graphical manipulator and in the dialog.
    */
    isXYPlaneTranslationVisible: boolean
    /**
      Gets and sets if the control that defines the translation in the X-Z plane is
      visible in both the graphical manipulator and in the dialog.
    */
    isXZPlaneTranslationVisible: boolean
    /**
      Gets and sets if the control that defines the translation in the Y-Z plane is
      visible in both the graphical manipulator and in the dialog.
    */
    isYZPlaneTranslationVisible: boolean
    /**
      Sets all rotation related controls to be invisible. This is useful if you are only
      using translations or scaling.
      @returns Returns true if hiding the controls was successful.
    */
    hideAllRotations(): boolean
    /**
      Gets and sets if the control that defines the rotation around the
      X axis is visible in both the graphical manipulator and in the dialog.
    */
    isXRotationVisible: boolean
    /**
      Gets and sets if the control that defines the rotation around the
      Y axis is visible in both the graphical manipulator and in the dialog.
    */
    isYRotationVisible: boolean
    /**
      Gets and sets if the control that defines the rotation around the
      Z axis is visible in both the graphical manipulator and in the dialog.
    */
    isZRotationVisible: boolean
    /**
      Sets all scaling related controls to be invisible. This is useful if you are only
      using translations or rotations.
      @returns Returns true if hiding the controls was successful.
    */
    hideAllScaling(): boolean
    /**
      Gets and sets if the control that defines the scaling along the
      X axis is visible in both the graphical manipulator and in the dialog.
      This control lies on the X-Y plane of the triad.
    */
    isXScalingInXYVisible: boolean
    /**
      Gets and sets if the control that defines the scaling along the
      X axis is visible in both the graphical manipulator and in the dialog.
      This control lies on the X-Z plane of the triad.
    */
    isXScalingInXZVisible: boolean
    /**
      Gets and sets if the control that defines the scaling along the
      Y axis is visible in both the graphical manipulator and in the dialog.
      This control lies on the X-Y plane of the triad.
    */
    isYScalingInXYVisible: boolean
    /**
      Gets and sets if the control that defines the scaling along the
      Y axis is visible in both the graphical manipulator and in the dialog.
      This control lies on the Y-Z plane of the triad.
    */
    isYScalingInYZVisible: boolean
    /**
      Gets and sets if the control that defines the scaling along the
      Z axis is visible in both the graphical manipulator and in the dialog.
      This control lies on the X-Z plane of the triad.
    */
    isZScalingInXZVisible: boolean
    /**
      Gets and sets if the control that defines the scaling along the
      Z axis is visible in both the graphical manipulator and in the dialog.
      This control lies on the Y-Z plane of the triad.
    */
    isZScalingInYZVisible: boolean
    /**
      Gets and sets if the control that defines the scaling in the X-Y plane is
      visible in both the graphical manipulator and in the dialog.
    */
    isXYPlaneScalingVisible: boolean
    /**
      Gets and sets if the control that defines the scaling in the X-Z plane is
      visible in both the graphical manipulator and in the dialog.
    */
    isXZPlaneScalingVisible: boolean
    /**
      Gets and sets if the control that defines the scaling in the Y-Z plane is
      visible in both the graphical manipulator and in the dialog.
    */
    isYZPlaneScalingVisible: boolean
    /**
      Gets and sets if the control that defines the scaling in all directions
      visible in both the graphical manipulator and in the dialog.
    */
    isUnifiedScalingVisible: boolean
    /**
      Gets and sets if the control that lets the user flip horizontally (around the Y-Z plane of the triad)
      is visible in both the graphical manipulator and the dialog.
    */
    isHorizontalFlipVisible: boolean
    /**
      Gets and sets if the control that lets the user flip vertical (around the X-Z plane of the triad)
      is visible in both the graphical manipulator and the dialog.
    */
    isVerticalFlipVisible: boolean
    /**
      Gets and sets the current value of the translation along the X axis of the triad.
      The value is in centimeters but will be displayed to the user in default units for the design.
      The isValidExpressions property should be checked before using the returned value.
    */
    xTranslation: number
    /**
      Gets or sets the expression displayed in the input field for the X translation. This can contain
      equations and references to parameters but must result in a valid distance expression. If units
      are not specified as part of the expression, the default user units of length are used.
    */
    xTranslationExpression: string
    /**
      Gets and sets the current value of the translation along the Y axis of the triad.
      The value is in centimeters but will be displayed to the user in default units for the design.
      The isValidExpressions property should be checked before using the value within the command.
    */
    yTranslation: number
    /**
      Gets or sets the expression displayed in the input field for the Y translation. This can contain
      equations and references to parameters but must result in a valid distance expression. If units
      are not specified as part of the expression, the default user units of length are used.
    */
    yTranslationExpression: string
    /**
      Gets and sets the current value of the translation along the Z axis of the triad.
      The value is in centimeters but will be displayed to the user in default units for the design.
      The isValidExpressions property should be checked before using the value within the command.
    */
    zTranslation: number
    /**
      Gets or sets the expression displayed in the input field for the Z translation. This can contain
      equations and references to parameters but must result in a valid distance expression. If units
      are not specified as part of the expression, the default user units of length are used.
    */
    zTranslationExpression: string
    /**
      Gets and sets the current value of the rotation around the X axis of the triad. The value is in radians
      but will be displayed to the user in degrees.
      The isValidExpressions property should be checked before using the value within the command.
    */
    xRotation: number
    /**
      Gets or sets the expression displayed in the input field for the X rotation. This can contain
      equations and references to parameters but must result in a valid distance expression. If units
      are not specified as part of the expression degrees are used.
    */
    xRotationExpression: string
    /**
      Gets and sets the current value of the rotation around the Y axis of the triad. The value is in radians
      but will be displayed to the user in degrees.
      The isValidExpressions property should be checked before using the value within the command.
    */
    yRotation: number
    /**
      Gets or sets the expression displayed in the input field for the Y rotation. This can contain
      equations and references to parameters but must result in a valid distance expression. If units
      are not specified as part of the expression degrees are used.
    */
    yRotationExpression: string
    /**
      Gets and sets the current value of the rotation around the Z axis of the triad. The value is in radians
      but will be displayed to the user in degrees.
      The isValidExpressions property should be checked before using the value within the command.
    */
    zRotation: number
    /**
      Gets or sets the expression displayed in the input field for the Z rotation. This can contain
      equations and references to parameters but must result in a valid distance expression. If units
      are not specified as part of the expression degrees are used.
    */
    zRotationExpression: string
    /**
      Gets and sets the current value of the scale factor along the X axis of the triad.
      The isValidExpressions property should be checked before using the value within the command.
    */
    xScaleFactor: number
    /**
      Gets or sets the expression displayed in the input field for the X scale. This can contain
      equations and references to parameters but must result in a valid unitless expression.
    */
    xScaleFactorExpression: string
    /**
      Gets and sets the current value of the scale factor along the Y axis of the triad.
      The isValidExpressions property should be checked before using the value within the command.
    */
    yScaleFactor: number
    /**
      Gets or sets the expression displayed in the input field for the Y scale. This can contain
      equations and references to parameters but must result in a valid unitless expression.
    */
    yScaleFactorExpression: string
    /**
      Gets and sets the current value of the scale factor along the Z axis of the triad.
      The isValidExpressions property should be checked before using the value within the command.
    */
    zScaleFactor: number
    /**
      Gets or sets the expression displayed in the input field for the Z scale. This can contain
      equations and references to parameters but must result in a valid unitless expression.
    */
    zScaleFactorExpression: string
    /**
      Gets and sets the current value of the scale factor on the X-Y plane of the triad.
      The isValidExpressions property should be checked before using the value within the command.
    */
    xYPlaneScaleFactor: number
    /**
      Gets or sets the expression displayed in the input field for the X-Y plane scale. This can contain
      equations and references to parameters but must result in a valid unitless expression.
    */
    xYPlaneScaleFactorExpression: string
    /**
      Gets and sets the current value of the scale factor on the Y-Z plane of the triad.
      The isValidExpressions property should be checked before using the value within the command.
    */
    yZPlaneScaleFactor: number
    /**
      Gets or sets the expression displayed in the input field for the Y-Z plane scale. This can contain
      equations and references to parameters but must result in a valid unitless expression.
    */
    yZPlaneScaleFactorExpression: string
    /**
      Gets and sets the current value of the scale factor on the Z-X plane of the triad.
      The isValidExpressions property should be checked before using the value within the command.
    */
    zXPlaneScaleFactor: number
    /**
      Gets or sets the expression displayed in the input field for the Z-X plane scale. This can contain
      equations and references to parameters but must result in a valid unitless expression.
    */
    zXPlaneScaleFactorExpression: string
    /**
      Gets and sets the current value of the unified scale factor of the triad.
      The isValidExpressions property should be checked before using the value within the command.
    */
    unifiedeScaleFactor: number
    /**
      Gets or sets the expression displayed in the input field for the unified scale. This can contain
      equations and references to parameters but must result in a valid unitless expression.
    */
    unifiedScaleFactorExpression: string
    /**
      Gets and sets if the triad is flipped horizontally (around the around the Y-Z plane of the triad).
    */
    isFlippedHorizontal: boolean
    /**
      Gets and sets if the triad is flipped vertically (around the around the X-Z plane of the triad).
    */
    isFlippedVertical: boolean
    /**
      Gets or sets the current position, orientation, and scale of the triad using a transformation matrix.
    */
    transform: core.Matrix3D
    /**
      Gets the current position and orientation of the triad using a transformation matrix. This transform
      does not include any scaling.
    */
    readonly positionTransform: core.Matrix3D
    /**
      Returns the transform of the triad before the latest change. Using the matrices returned
      by this property and the transform property you can determine what changed. The lastChangeMade
      property is also useful to help you know the type of change to look for when comparing the
      matrices.
    */
    readonly lastTransform: core.Matrix3D
    /**
      Returns true if all of the input fields have valid expressions. If this property is false,
      the triad is incorrectly defined and the current values should not be used.
    */
    readonly isValidExpressions: boolean
    /**
      Returns which value was most recently changed. To determine the actual change made you need
      to compare the transforms returned by the transform and lastTransform properties. Having information
      about the specific type of change made makes it easier to compare the matrices because you know
      what to look for.
    */
    readonly lastChangeMade: TriadChanges
  }

  /**
    Defines the different types of edits that can be applied by the user to a triad command input.
    @permissions ui
  */
  const enum TriadChanges {
    /**
      Defines an unknown change.
    */
    TriadChangeUnknown,
    /**
      Defines a translation in the X direction of the triad.
    */
    TriadChangeXTranslation,
    /**
      Defines a translation in the Y direction of the triad.
    */
    TriadChangeYTranslation,
    /**
      Defines a translation in the Z direction of the triad.
    */
    TriadChangeZTranslation,
    /**
      Defines a translation on the X-Y plane of the triad.
    */
    TriadChangeXYTranslation,
    /**
      Defines a translation on the Y-Z plane of the triad.
    */
    TriadChangeYZTranslation,
    /**
      Defines a translation on the X-Z plane of the triad.
    */
    TriadChangeXZTranslation,
    /**
      Defines a translation in the X, Y, and Z directions of the triad.
    */
    TriadChangeXYZTranslation,
    /**
      Defines a rotation around the X axis of the triad.
    */
    TriadChangeXRotation,
    /**
      Defines a rotation around the Y axis of the triad.
    */
    TriadChangeYRotation,
    /**
      Defines a rotation around the Z axis of the triad.
    */
    TriadChangeZRotation,
    /**
      Defines a change in scale along the X axis of the triad.
    */
    TriadChangeXScale,
    /**
      Defines a change in scale along the Y axis of the triad.
    */
    TriadChangeYScale,
    /**
      Defines a change in scale along the Z axis of the triad.
    */
    TriadChangeZScale,
    /**
      Defines a uniform change in scale along the X and Y axes of the triad.
    */
    TriadChangeXYScale,
    /**
      Defines a uniform change in scale along the Y and Z axes of the triad.
    */
    TriadChangeYZScale,
    /**
      Defines a uniform change in scale along the X and Z axes of the triad.
    */
    TriadChangeXZScale,
    /**
      Defines a uniform change in scale along the X, Y, and Z axes of the triad.
    */
    TriadChangeXYZScale,
    /**
      Defines a horizontal (around the around the Y-Z plane) flip of the triad.
    */
    TriadChangeHorizontalFlip,
    /**
      Defines a vertical (around the around the X-Z plane) flip of the triad.
    */
    TriadChangeVerticalFlip,
  }

  /**
    An object that represents a visual separator within a command dialog.
    @permissions ui
  */
  abstract class SeparatorCommandInput extends CommandInput {
  }

  /**
    An event endpoint that supports the connection to client implemented InputChangedEventHandlers.
    @permissions ui
  */
  abstract class InputChangedEvent extends Event {
    /**
      Adds an event handler to this event endpoint.
      @param handler The client implemented InputChangedEventHandler to be called when this event is triggered.
      @returns Returns true if the handler was successfully added to the set of event handlers.
    */
    add(handler: InputChangedEventHandler): boolean
    /**
      Removes a handler from this event endpoint.
      @param handler A InputChangedEventHandler that was previously added to this event with the add method.
      @returns Returns true if the handler was found and removed from the set of event handlers.
    */
    remove(handler: InputChangedEventHandler): boolean
  }

  /**
    An event handler base class that a client derives from to handle events triggered by a InputChangedEvent.
    A client implemented instance of this class can be added to a InputChangedEvent to receive these event notifications.
    @permissions ui
  */
  abstract class InputChangedEventHandler extends EventHandler {
    /**
      This notify member is called when an event is triggered from any event that this handler has been added to.
      @param eventArgs The arguments object with details about this event and the firing InputChangedEvent.
    */
    notify(eventArgs: InputChangedEventArgs): void
  }

  /**
    Provides a set of arguments from a firing InputChangedEvent to a InputEventChangedEventHandler's notify callback method.
    @permissions ui
  */
  abstract class InputChangedEventArgs extends EventArgs {
    /**
      Returns the command input that has just changed.
    */
    readonly input: CommandInput
    /**
      Returns the collection of command inputs that are associated with the command this event is being fired for.
    */
    readonly inputs: CommandInputs
  }

  /**
    Provides access to the various filter settings for selections.
    @permissions ui
  */
  abstract class SelectionFilters extends Base {
    /**
      Select all B-Rep bodies.
    */
    static readonly Bodies: string
    /**
      Select solid B-Rep bodies.
    */
    static readonly SolidBodies: string
    /**
      Select B-Rep bodies that are not closed.
    */
    static readonly SurfaceBodies: string
    /**
      Select mesh bodies.
    */
    static readonly MeshBodies: string
    /**
      Select B-Rep faces of any shape.
    */
    static readonly Faces: string
    /**
      Select faces from a solid B-Rep body.
    */
    static readonly SolidFaces: string
    /**
      Select faces from a B-Rep body that has openings.
    */
    static readonly SurfaceFaces: string
    /**
      Select planar B-Rep faces.
    */
    static readonly PlanarFaces: string
    /**
      Select cylindrical B-Rep faces.
    */
    static readonly CylindricalFaces: string
    /**
      Select conical B-Rep faces.
    */
    static readonly ConicalFaces: string
    /**
      Select spherical B-Rep faces.
    */
    static readonly SphericalFaces: string
    /**
      Select toroidal B-Rep faces.
    */
    static readonly ToroidalFaces: string
    /**
      Select spline (NURBS) B-Rep faces.
    */
    static readonly SplineFaces: string
    /**
      Select B-Rep edges of any shape.
    */
    static readonly Edges: string
    /**
      Select linear B-Rep edges.
    */
    static readonly LinearEdges: string
    /**
      Select circular B-Rep edges.
    */
    static readonly CircularEdges: string
    /**
      Select elliptical B-Rep edges.
    */
    static readonly EllipticalEdges: string
    /**
      Select B-Rep edges whose faces it joins are tangent along the edge.
    */
    static readonly TangentEdges: string
    /**
      Select B-Rep edges whose faces it joins are not tangent along the edge.
    */
    static readonly NonTangentEdges: string
    /**
      Select B-Rep vertices.
    */
    static readonly Vertices: string
    /**
      Select root components.
    */
    static readonly RootComponents: string
    /**
      Select occurrences.
    */
    static readonly Occurrences: string
    /**
      Select sketches.
    */
    static readonly Sketches: string
    /**
      Select sketch curves of any shape.
    */
    static readonly SketchCurves: string
    /**
      Select sketch lines.
    */
    static readonly SketchLines: string
    /**
      Select sketch circles.
    */
    static readonly SketchCircles: string
    /**
      Select sketch points.
    */
    static readonly SketchPoints: string
    /**
      Select sketch text.
    */
    static readonly Texts: string
    /**
      Select construction points.
    */
    static readonly ConstructionPoints: string
    /**
      Select construction lines (axes).
    */
    static readonly ConstructionLines: string
    /**
      Select construction planes.
    */
    static readonly ConstructionPlanes: string
    /**
      Select features of all types.
    */
    static readonly Features: string
    /**
      Select canvases.
    */
    static readonly Canvases: string
    /**
      Select decals.
    */
    static readonly Decals: string
    /**
      Select joint origins.
    */
    static readonly JointOrigins: string
    /**
      Select joints.
    */
    static readonly Joints: string
    /**
      Selects sketch geometric and dimensions constraints.
    */
    static readonly SketchConstraints: string
    /**
      Select sketch profiles.
    */
    static readonly Profiles: string
    /**
      Select custom graphics entities.
    */
    static readonly CustomGraphics: string
    /**
      Select face groups of meshes.
    */
    static readonly FaceGroups: string
    /**
      Select volumetric model.
    */
    static readonly VolumetricModel: string
  }

  /**
    Provides access to and control over the set of selected entities in the user interface.
    @permissions ui
  */
  abstract class Selections extends Base {
    /**
      Returns the specified selection using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Selection | null
    /**
      Gets the number of entities currently selected.
    */
    readonly count: number /*unsigned int*/
    /**
      Gets or sets all entities currently selected.
    */
    all: ObjectCollection
    /**
      Adds the entity to the set of currently selected entities.
      The user will see the entity become selected in the user interface.
      @param entity The entity to select and add to this selection set.
      @returns Returns true if successful.
    */
    add(entity: Base): boolean
    /**
      Clears the selection set so no entities are currently selected.
      @returns Returns true if successful.
    */
    clear(): boolean
    /**
      Removes the specified selection from the set of selected entities.
      @param selection The selection to remove.
      @returns Returns true if the item was removed or not currently selected.
    */
    removeBySelection(selection: Selection): boolean
    /**
      Removes the selections that are associated with the specified entity from the set of selected entities.
      @param entity The entity to remove selections of.
      @returns Returns true if the item was removed or not currently selected.
    */
    removeByEntity(entity: Base): boolean
    /**
      Removes an item from the set of selected entities.
      @param index The index of the selection to remove.
      @returns Returns true if the item was removed successfully.
    */
    removeByIndex(index: number /*int*/): boolean
    /**
      Returns an array containing all of the current selections. This is
      useful in cases where you need to iterate over the set of selected entities but need
      to create or edit data as you process each one. Selections are fragile and creation and
      edit operations will clear the selections so you won't have access to the complete list
      after processing the first one.
      @returns Returns an array of all of the current selections. Selection objects are returned so
      you'll need to call their entity properties to get the actual selected entity.
    */
    asArray(): core.Selection[]
  }

  /**
    Provides access to a selection of an entity in the user interface.
    @permissions ui
  */
  abstract class Selection extends Base {
    /**
      Gets the selected entity.
    */
    readonly entity: Base
    /**
      Gets the selection point on the object.
    */
    readonly point: Point3D
  }

  /**
    An event endpoint that supports the connection to ApplicationCommandEventHandlers.
    @permissions ui
  */
  abstract class ApplicationCommandEvent extends Event {
    /**
      Adds an event handler object to this event endpoint.
      @param handler The ApplicationCommandEventHandler to be called when this event is triggered.
      @returns Returns true if the handler was successfully added to the set of event handlers.
    */
    add(handler: ApplicationCommandEventHandler): boolean
    /**
      Removes a handler from this event endpoint.
      @param handler An ApplicationCommandEventHandler that was previously added to this event with the add method.
      @returns Returns true if the handler was found and removed from the set of event handlers.
    */
    remove(handler: ApplicationCommandEventHandler): boolean
  }

  /**
    An application command event handler base class that a client derives from to handle events triggered by an
    ApplicationCommandEvent.
    A client implemented instance of this class can be added to an ApplicationCommandEvent to receive these event
    notifications.
    @permissions ui
  */
  abstract class ApplicationCommandEventHandler extends EventHandler {
    /**
      This notify member is called when an event is triggered from any event that this handler has been added to.
      @param eventArgs The arguments object with details about this event and the firing ApplicationCommandEvent.
    */
    notify(eventArgs: ApplicationCommandEventArgs): void
  }

  /**
    Provides a set of arguments from a firing ApplicationCommandEvent to an ApplicationCommandEventHandler's
    notify callback method.
    @permissions ui
  */
  abstract class ApplicationCommandEventArgs extends EventArgs {
    /**
      Returns the CommandDefinition object for the command the event is being fired for.
    */
    readonly commandDefinition: CommandDefinition
    /**
      Returns the unique id of the command the event if being fired for.
    */
    readonly commandId: string
    /**
      Used during the commandStarting event to get or set if the command should
      be allowed to continue executing or be canceled. This defaults to false,
      which will allow the command to execute. Setting this to true will cancel
      the command and not begin the execution.
      This property should be ignored for all events besides the commandStarting event.
    */
    isCanceled: boolean
    /**
      Returns the reason the command is being terminated.
      This property should be ignored for all events besides the commandTerminated event.
    */
    readonly terminationReason: CommandTerminationReason
  }
}

export declare namespace adsk.fusion {

  /**
    Provides access to the Arrange features in a component and provides the functionality
    to create new Arrange features
  */
  abstract class ArrangeFeatures extends core.Base {
    /**
      Returns the specified Arrange feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ArrangeFeature | null
    /**
      Returns the specified Arrange feature using the name of the feature.
      @param name The name of the Arrange feature as seen in the timeline.
      @returns Returns the specified Arrange feature, if it exists. Otherwise it returns null.
    */
    itemByName(name: string): ArrangeFeature
    /**
      Returns the number of Arrange features in the component.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new ArrangeFeatureInput object. An ArrangeFeatureInput object is the logical equivalent to the
      command dialog when creating an Arrange feature. It provides access to the various options and collects
      all the required input when creating an Arrange feature. Once fully defined, you pass this into the add method
      to create the Arrange feature.
      @param solverType Specify if the input will be used to define a "2D True Shape", "2D Rectangular", or "3D" type of arrange feature.
      @returns Returns an ArrangeFeatureInput object or null in the case of failure.
    */
    createInput(solverType: ArrangeSolverTypes): ArrangeFeatureInput | null
    /**
      Creates a new Arrange feature. Use the create2DInput or create3DInput method to first create an input object and fully
      define the required input. Then, pass that input object to the add method to create the Arrange feature.
      @param input The ArrangeFeature2DInput or ArrangeFeature3DInput object that defines the required information needed to create a new Arrange feature.
      An ArrangeFeatureInput object is the logical equivalent to the command dialog when creating an Arrange feature.
      It provides access to the various options and collects all of the required input when creating an Arrange feature and
      call the add method is the API equivalent to clicking the OK button on the command dialog to create the Arrange feature.
      @returns Returns the newly created ArrangeFeature object.
    */
    add(input: ArrangeFeatureInput): ArrangeFeature
  }

  /**
    Represents an Arrange feature within a component.
  */
  abstract class ArrangeFeature extends Feature {
    /**
      Returns a definition object that provides access to the information defining this arrange
      feature and provides access to the resulting arrangement of occurrences.
      To use this property, you need to position the timeline marker immediately before the Arrange feature.
      This can be accomplished using the following code: arrangeFeature.timelineObject.rollTo(True)
    */
    readonly definition: ArrangeDefinition
    /**
      Returns the collection of ArrangeComponent objects that are being arranged.
      To use this property, you need to position the timeline marker immediately before the Arrange feature.
      This can be accomplished using the following code: arrangeFeature.timelineObject.rollTo(True)
    */
    readonly arrangeComponents: ArrangeComponents
    /**
      Returns the envelope definition associated with this arrangement.
      To use this property, you need to position the timeline marker immediately before the Arrange feature.
      This can be accomplished using the following code: arrangeFeature.timelineObject.rollTo(True)
    */
    readonly envelopeDefinition: ArrangeEnvelopeDefinition
    /**
      Returns the resulting envelopes and their contents.
    */
    readonly resultEnvelopes: ArrangeResultEnvelopes
    /**
      Returns an array of ArrangeComponent objects that did not fit in the arrangement. This is
      most useful in the case where partial arrange has been enabled, which means some
      components may have been arranged and others were left out.
      To use this property, you need to position the timeline marker immediately before the Arrange feature.
      This can be accomplished using the following code: arrangeFeature.timelineObject.rollTo(True)
    */
    readonly unusedComponents: ArrangeComponent[]
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ArrangeFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ArrangeFeature | null
    /**
      Returns statistics about the arrangement in JSON format as a string. Each item in the JSON is identified with its English name,
      and the current localized name is also provided. The values follow the API rules, where all length values are in centimeters,
      and areas are in square centimeters. The returned JSON may include additional values in the future, so code consuming this
      output should be tolerant of new fields.
      @returns A JSON string containing the arrangement statistics, or an empty string if the operation fails.
    */
    readonly arrangeStatistics: string
  }

  /**
    The ArrangeDefinition object is the base class for the ArrangeDefinition2D and ArrangeDefinition3D
    objects. It provides access to the information that defines an existing Arrange feature.
  */
  abstract class ArrangeDefinition extends core.Base {
    /**
      Gets the type of arrange feature defined by this definition.
    */
    readonly solverType: ArrangeSolverTypes
    /**
      Gets if the original components were moved to create the arrangement or copied were created.
      This value can only be set when creating a new arrangement.
    */
    readonly isCreateCopies: boolean
  }

  /**
    This object defines all of the settings associated with a 2D arrangement. This is used
    for both rectangular and true shape arrangements, but some properties are ignored
    in some cases.
  */
  abstract class Arrange2DDefinition extends ArrangeDefinition {
    /**
      Gets and sets the global rotation type.
    */
    globalRotation: ArrangeRotationTypes
    /**
      Returns the parameter that controls the global quantity. You can modify the value by
      using the properties on the returned ModelParameter object.
    */
    readonly globalQuantity: ModelParameter
    /**
      Gets and sets the global direction for selected faces. When true, the components specified
      by selecting a face will be oriented such that the selection face will be oriented upward
      in the arrangement.
    */
    isGlobalDirectionFaceUp: boolean
    /**
      Gets and sets if parts can be nested within void areas of other parts.
      This is only used when
      the solver type is 2D True Shape and is ignored for 2D Rectangular solutions.
    */
    isPartInPartAllowed: boolean
    /**
      Defines the angle of the grain direction of the envelope. An angle of 0 is in the X direction
      of the envelope. You can modify the value by using the properties on the returned ModelParameter object.
      This is only valid when the solver type is True Shape and it returns null in all other cases.
    */
    readonly grainDirection: ModelParameter
  }

  /**
    This object defines all of the settings associated with a 3D arrangement.
  */
  abstract class Arrange3DDefinition extends ArrangeDefinition {
  }

  /**
    Defines the different types of arrangement solvers that are supported.
  */
  const enum ArrangeSolverTypes {
    /**
      True Shape 2D arrangement solver. This is an arrangement type where the components
      are arranged on a plane so they fit tightly together honoring the
      arrangement definition.
    */
    Arrange2DTrueShapeSolverType,
    /**
      Rectangular 2D arrangement solver. This is an arrangement type where the rectangular bounding box
      of the component is used to calculate the arrangement, not the actual shape of the part.
    */
    Arrange2DRectangularSolverType,
    /**
      3D arrangement solver. This is an arrangement type where the parts are arranged within a
      3D rectangular volume where the bounding box of the parts is used to determine the size of the part.
    */
    Arrange3DSolverType,
  }

  /**
    Defines the different types of rotations supported.
  */
  const enum ArrangeRotationTypes {
    /**
      Specifies that a component is using the global rotation type.
    */
    GlobalArrangeRotationType,
    /**
      Specifies that all rotation types are allowed.
    */
    AllRotationsArrangeRotationType,
    /**
      Specifies that no rotation is allowed.
    */
    NoneArrangeRotationType,
    /**
      Specifies that only 180 deg rotation is allowed.
    */
    Only180ArrangeRotationType,
    /**
      Specifies that only 90 and 270 deg rotation is allowed.
    */
    Only90And270ArrangeRotationType,
  }

  /**
    The collection of ArrangeComponent objects associated with an arrangement. This provides
    access to existing ArrangeComponent objects and supports adding new components to the
    the arrangement. An ArrangeComponent object defines an occurrence along with additional
    arrangement information. This object is used for both the creation of a new Arrange
    feature and querying and modifying an existing Arrange feature.
  */
  abstract class ArrangeComponents extends core.Base {
    /**
      Returns an ArrangeComponent object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ArrangeComponent | null
    /**
      Returns the number of ArrangeComponent objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a new ArrangeComponent object to the collection.
      @param occurrenceOrFace For a 2D arrange this can be an Occurrence or BRepFace object that defines which component to use.
      If a BRepFace object is used, the face is used to orient the part in the arrangement and will face
      up or down depending on the isGlobalDirectionFaceUp property on the ArrangeFeature2DInput object.
      For a 2D arrange, if an Occurrence is provided, the Occurrence will be oriented in the arrangement such that the
      largest face points downward.
      For a 3D arrange this can be an Occurrence or BRepFace object but if a BRepFace is provided it does
      not define the orientation but is only used to get the parent Occurrence. For a 3D arrange the arranged
      occurrences have the same orientation as the original occurrence but are positioned within the 3D envelope.
      @returns Returns the created ArrangeComponent where you can use properties on it to define the various
      other settings supported to control how the component is arranged.
    */
    add(occurrenceOrFace: core.Base): ArrangeComponent
  }

  /**
    Defines a component within an arrangement. This specifies an occurrence along with additional
    arrangement information. This object is the API equivalent of a single line within the component
    list shown in the Arrange dialog. This object is used for both the creation of a new Arrange
    feature and querying and modifying an existing Arrange feature.
  */
  abstract class ArrangeComponent extends core.Base {
    /**
      The BRepFace or Occurrence that was used to identify this ArrangeComponent.
    */
    readonly occurrenceOrFace: core.Base
    /**
      Returns the Occurrence associated with this ArrangeComponent. If an Occurrence was used to define
      this ArrangeComponent, this will return the same thing as the occurrenceOrFace. If a BRepFace was
      used to define this ArrangeComponent, this will return the Occurrence the face is in. This is a
      convenience property to make accessing the occurrence simpler.
    */
    readonly occurrence: Occurrence
    /**
      Specifies the quantity of this component to use in the arrange. This defaults
      to -1, which indicates that the global quantity is to be used.
      For a 3D arrange, this property is ignored and the quantity is always one.
    */
    quantity: number /*int*/
    /**
      Specifies if the direction is flipped from it's default direction.
      For a component defined by a face the default direction is defined by the selected face
      and the isGlobalDirectionFaceUp property of the Arrange2DDefinition associated with the
      parent ArrangeFeature object.
      For a component defined by an occurrence, the default direction orients the occurrence
      such that the largest face points downward.
      For a 3D arrange, this property is ignored and the orientation of the part is
      the same as it exists in the original assembly.
    */
    isDirectionFlipped: boolean
    /**
      Gets and sets the rotation type for this ArrangeComponent. This defaults to
      use the global rotation type defined for the arrangement.
      For a 3D arrange, this property is ignored.
    */
    rotationType: ArrangeRotationTypes
    /**
      Gets and sets the rotation angle of this ArrangeComponent. The value is defined
      in Radians, is relative to the zero direction vector returned by the
      zeroDirectionVector property, and is in a counterclockwise direction.
      This is only valid for 2D True Shape arrangements and is ignored for
      2D rectangular and 3D arrangements.
    */
    rotation: number
    /**
      Sets the rotation angle using the specified edge such that the edge
      is pointing in the zero rotation angle. This is a convenience method to
      set the rotation angle. The rotation property can be used to accomplish
      the same result.
      This is only valid for 2D True Shape arrangements and will fail for
      2D rectangular and 3D arrangements.
      @param edge The BRepEdge object being used to define rotation of the component.
      @returns Returns true if successful.
    */
    setRotationUsingEdge(edge: BRepEdge): boolean
    /**
      Returns a vector that is the zero degree direction of this
      ArrangeComponent.
    */
    readonly zeroDirection: core.Vector3D
    /**
      Returns a vector that is the up direction of this ArrangeComponent.
    */
    readonly upDirection: core.Vector3D
    /**
      Specifies the nesting priority for this component.
      For a 3D arrange, this property is ignored and setting it will fail.
    */
    priority: ArrangePriorities
    /**
      Specifies if this component will be used to fill any left over
      empty space in the available envelopes.
      This is only valid for 2D True Shape arrangements and is ignored for
      2D rectangular and 3D arrangements.
    */
    isFiller: boolean
    /**
      Deletes this ArrangeComponent from the arrangement.
      @returns Returns true if the deletion was successful.
    */
    deleteMe(): boolean
    /**
      Returns the ArrangeFeature this ArrangeComponent is associated with. This
      property returns null in the case where a feature hasn't been created yet
      and there is only an ArrangeFeatureInput.
    */
    readonly parentArrangeFeature: ArrangeFeature
  }

  /**
    Defines the different types of arrange priorities that are supported.
  */
  const enum ArrangePriorities {
    /**
      Very low arrange priority.
    */
    VeryLowArrangePriority,
    /**
      Low arrange priority.
    */
    LowArrangePriority,
    /**
      Medium arrange priority.
    */
    MediumArrangePriority,
    /**
      High arrange priority.
    */
    HighArrangePriority,
    /**
      Very high arrange priority.
    */
    VeryHighArrangePriority,
  }

  /**
    The ArrangeEnvelope object is the base class for the different types of arrangement
    envelopes and provides access to the information that defines the envelope(s). This
    defines the settings of the envelope and the EnvelopeResult provides access to the
    resulting envelope and its contents.
  */
  abstract class ArrangeEnvelopeDefinition extends core.Base {
    /**
      Returns the parameter that controls the width of the envelope frame. This defines the
      offset distance of the objects from the edge of the frame. You can modify the value by
      using the properties on the returned ModelParameter object.
    */
    readonly frameWidth: ModelParameter
    /**
      Returns the parameter that controls the space between objects in the arrangement.
      You can modify the value by using the properties on the returned ModelParameter object.
    */
    readonly objectSpacing: ModelParameter
    /**
      Returns the parameter that controls the offset of the objects from the base plane of
      the arrangement (the "up" direction). You can modify the value by using the properties on the returned
      ModelParameter object.
    */
    readonly placementClearance: ModelParameter
    /**
      Gets and sets if a partial arrange is allowed for this envelope.
    */
    isPartialArrangeAllowed: boolean
    /**
      Returns the parent ArrangeFeature this envelope is associated with.
    */
    readonly parentArrange: ArrangeFeature
  }

  /**
    The ArrangeProfileEnvelopeDefinition object represents envelopes defined by a profile or
    face in an Arrange feature. This defines the settings of the envelope and the
    EnvelopeResult provides access to the resulting envelope and its contents.
  */
  abstract class ArrangeProfileOrFaceEnvelopeDefinition extends ArrangeEnvelopeDefinition {
    /**
      Gets and sets an array containing any combination of Profile and planar
      BRepFace objects. These objects define the shapes of the envelopes. Currently,
      if a Profile is used, it must be the only Profile in its parent sketch.
    */
    profilesAndFaces: core.Base[]
  }

  /**
    The ArrangePlaneEnvelope object represents an arrange envelope defined
    by a construction plane. This defines the settings of the envelope and the
    EnvelopeResult provides access to the resulting envelope and its contents.
  */
  abstract class ArrangePlaneEnvelopeDefinition extends ArrangeEnvelopeDefinition {
    /**
      Gets and sets the ConstructionPlane the envelope is defined on.
    */
    plane: ConstructionPlane
    /**
      Returns the parameter that controls the length of the envelope frame. This defines the
      You can modify the value by using the properties on the returned ModelParameter object.
    */
    readonly length: ModelParameter
    /**
      Returns the parameter that controls the width of the envelope frame. This defines the
      You can modify the value by using the properties on the returned ModelParameter object.
    */
    readonly width: ModelParameter
    /**
      Returns the parameter that controls the X offset of the frame from the origin of the
      construction plane. You can modify the value by using the properties on the returned
      ModelParameter object.
    */
    readonly originXOffset: ModelParameter
    /**
      Returns the parameter that controls the Y offset of the frame from the origin of the
      construction plane. You can modify the value by using the properties on the returned
      ModelParameter object.
    */
    readonly originYOffset: ModelParameter
    /**
      Returns the parameter that controls the offset distance between envelopes when there is
      more than one. You can modify the value by using the properties on the returned
      ModelParameter object.
    */
    readonly envelopeSpacing: ModelParameter
    /**
      Returns the parameter that defines the number of envelopes that can be created.
      A value of -1 indicates that there is no limit.
    */
    readonly quantity: ModelParameter
  }

  /**
    The Arrange3DEnvelope object represents an 3D arrange envelope.
  */
  abstract class Arrange3DEnvelopeDefinition extends ArrangeEnvelopeDefinition {
    /**
      Gets and sets the ConstructionPlane the envelope is defined on.
    */
    plane: ConstructionPlane
    /**
      Returns the parameter that controls the length of the envelope volume. This defines the
      You can modify the value by using the properties on the returned ModelParameter object.
    */
    readonly length: ModelParameter
    /**
      Returns the parameter that controls the width of the envelope volume. This defines the
      You can modify the value by using the properties on the returned ModelParameter object.
    */
    readonly width: ModelParameter
    /**
      Returns the parameter that controls the height of the envelope volume. This defines the
      You can modify the value by using the properties on the returned ModelParameter object.
    */
    readonly height: ModelParameter
    /**
      Returns the parameter that controls the X offset of the envelope volume from the origin of
      the construction plane. You can modify the value by using the properties on the returned
      ModelParameter object.
    */
    readonly originXOffset: ModelParameter
    /**
      Returns the parameter that controls the Y offset of the envelope volume from the origin of
      the construction plane. You can modify the value by using the properties on the returned
      ModelParameter object.
    */
    readonly originYOffset: ModelParameter
    /**
      Returns the parameter that controls the clearance of the objects from the top of the
      envelope volume. You can modify the value by using the properties on the returned
      ModelParameter object.
    */
    readonly ceilingClearance: ModelParameter
  }

  /**
    Provides access to the results of an arrangement. For 3D arrangements, this will always
    contain a single result. For plane or profile envelopes this can contain multiple envelope results.
  */
  abstract class ArrangeResultEnvelopes extends core.Base {
    /**
      Returns the specified Arrange envelope result using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ArrangeResultEnvelope | null
    /**
      Returns the number of Arrange envelope results for this Arrange feature.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The ArrangeResult object represents the results of an arrangement
    for a single envelope.
  */
  abstract class ArrangeResultEnvelope extends core.Base {
    /**
      Gets and sets the name of the envelope as seen in the browser.
    */
    name: string
    /**
      Returns a collection object of the occurrences in this envelope.
    */
    readonly occurrences: ArrangeOccurrenceResults
    /**
      Returns the ArrangeFeature object this result is for.
    */
    readonly parentFeature: ArrangeFeature
    /**
      Returns the envelope definition that provides the settings for this envelope.
      To use this property, you need to position the timeline marker immediately before the Arrange feature.
      This can be accomplished using the following code: arrangeFeature.timelineObject.rollTo(True)
    */
    readonly envelopeDefinition: ArrangeEnvelopeDefinition
  }

  /**
    Represents the arrange result of a single envelope that is defined on a plane.
  */
  abstract class ArrangePlaneResultEnvelope extends ArrangeResultEnvelope {
    /**
      The bounding box of the this result. The coordinates are defined
      using the coordinate system of the construction plane used to
      define the envelope.
    */
    readonly boundingBox: core.BoundingBox2D
  }

  /**
    Represents the arrange envelope result of a 3D arrange feature.
  */
  abstract class Arrange3DResultEnvelope extends ArrangeResultEnvelope {
    /**
      The bounding box of this result. The coordinates are defined with respect
      to the root component base coordinate system.
    */
    readonly boundingBox: core.BoundingBox3D
  }

  /**
    Represents the arrange envelope result of a profile or face defined arrange feature.
  */
  abstract class ArrangeProfileOrFaceResultEnvelope extends ArrangeResultEnvelope {
    /**
      Returns the Profile or BRepFace object that defines the shape of this result envelope.
    */
    readonly profileOrFace: core.Base
  }

  /**
    A collection that contains the occurrences in an Arrange envelope.
  */
  abstract class ArrangeOccurrenceResults extends core.Base {
    /**
      Returns the specified Arrange occurrence using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ArrangeOccurrenceResult | null
    /**
      Returns the number of Arrange occurrences in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The ArrangeOccurrence object represents a single occurrence within an Arrange
    envelope.
  */
  abstract class ArrangeOccurrenceResult extends core.Base {
    /**
      The Occurrence object in the Arrange envelope.
    */
    readonly occurrence: Occurrence
    /**
      The ArrangeComponent from the Arrange definition that resulted in the
      create of this occurrence.
    */
    readonly arrangeComponent: ArrangeComponent
    /**
      The Arrange envelope this occurrence is within.
    */
    readonly parentEnvelope: ArrangeResultEnvelope
  }

  /**
    The ArrangeFeatureInput object is the base class for the different types of input
    objects used to create an arrange feature.
  */
  abstract class ArrangeFeatureInput extends core.Base {
    /**
      Returns the arrange feature solver type defined by this input.
    */
    readonly solverType: ArrangeSolverTypes
    /**
      Returns a definition input object that provides access to the information to define an arrange feature.
      This will return different types of definition inputs depending on the solver type specified when
      creating the input.
    */
    readonly definition: ArrangeDefinitionInput
    /**
      Returns the ArrangeComponents object associated with this input. Use this to add and define
      the components that will be arranged.
    */
    readonly arrangeComponents: ArrangeComponents
    /**
      Defines an envelope input defined by a plane for the arrange feature. Only a single envelope input can exist at a time. Calling
      this method will cause any existing envelope object input that has been created for this input to be invalid.
      @param plane The Construction plane the envelope will be on.
      @param length The length of the envelope. This is the size of the envelope as measured along the X axis of the specified
      construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
      @param width The width of the envelope. This is the size of the envelope as measured along the Y axis of the specified
      construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
      @returns Returns the created Arrange2DPlaneEnvelopeInput object or null if the creation fails.
    */
    setPlaneEnvelope(plane: ConstructionPlane, length: core.ValueInput, width: core.ValueInput): Arrange2DPlaneEnvelopeInput | null
    /**
      Defines an envelope defined by one or more profiles or planar faces. Only a single envelope input can exist at time.
      Calling this method will cause any existing envelope input object to be invalid.
      @param profilesOrFaces An array of Profile and planar BRepFace objects that define the shape of the available envelopes.
      @returns Returns the created Arrange2DProfileOrFaceEnvelopeInput object or null if the creation fails.
    */
    setProfileOrFaceEnvelope(profilesOrFaces: core.Base[]): Arrange2DProfileOrFaceEnvelopeInput | null
    /**
      Defines a 3D envelope input. Only a single envelope input can exist at time. Calling this method will
      cause any existing envelope input object to be invalid.
      @param plane The Construction plane the envelope will be on.
      @param length The length of the envelope. This is the size of the envelope as measured along the X axis of the specified
      construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
      @param width The width of the envelope. This is the size of the envelope as measured along the Y axis of the specified
      construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
      @param height The height of the envelope. This is the size of the envelope as measured along the Z axis of the specified
      construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
      @returns Returns the created Arrange3DEnvelopeInput object or null if the creation fails.
    */
    set3DEnvelope(plane: ConstructionPlane, length: core.ValueInput, width: core.ValueInput, height: core.ValueInput): Arrange3DEnvelopeInput | null
  }

  /**
    The ArrangeDefinition object is the base class for the ArrangeDefinition2D and ArrangeDefinition3D
    objects. It provides access to the information that defines an existing Arrange feature.
  */
  abstract class ArrangeDefinitionInput extends core.Base {
    /**
      Gets the type of arrange feature defined by this definition.
    */
    readonly solverType: ArrangeSolverTypes
    /**
      Gets and set if the original components will be moved or copied to create the arrangement.
      This defaults to true.
    */
    isCreateCopies: boolean
  }

  /**
    This object defines all of the settings associated with a 2D arrangement. This is used
    for both rectangular and true shape arrangements, but some properties are ignored
    in some cases.
  */
  abstract class ArrangeDefinition2DInput extends ArrangeDefinitionInput {
    /**
      Gets and sets the global rotation type. This defaults to AllRotationsArrangeRotationType.
    */
    globalRotation: ArrangeRotationTypes
    /**
      Gets and sets the global quantity, which is the default quantity value for components. This defaults to 1.
      This value will become a parameter when the arrangement is created. When created with a real value it must be a whole number.
      You can also use a string where it is interpreted the same as when entered in the command dialog. The expression must result
      in a unitless whole number. It's also possible to use an equation like "Total / 4" where "Total" is an existing parameter and be
      evenly divided by four.
    */
    globalQuantity: core.ValueInput
    /**
      Gets and sets the global direction for input faces. When true, the components specified
      by selecting a face will be oriented such that the selection face will be oriented upward
      in the arrangement. This defaults to true.
    */
    isGlobalDirectionFaceUp: boolean
    /**
      Gets and sets if parts can be nested within void areas of other parts. This defaults to true.
      This is only used when the solver type is 2D True Shape and is ignored for 2D Rectangular solutions.
    */
    isPartInPartAllowed: boolean
    /**
      Defines the angle of the grain direction of the envelope. This is only used when the solver type is True Shape.
      An angle of 0 is in the X direction of the envelope, and the default value is zero.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in radians. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses degrees as the units. For example, if you specify "45" it will result in a 45 degree  grain
      direction. Using a string you can also define an equation for the expression, "PartAngle / 2" where "PartAngle"
    */
    grainDirection: core.ValueInput
  }

  /**
    This object defines all of the settings associated with a 3D arrangement.
  */
  abstract class ArrangeDefinition3DInput extends ArrangeDefinitionInput {
  }

  /**
    The base class used to define the arrange envelope when creating an Arrange feature.
  */
  abstract class ArrangeEnvelopeInput extends core.Base {
    /**
      Gets and sets if a partial arrange is allowed. If true, it will still create a result when there is not
      enough space on the envelope to fit all of the components. Components are arranged until all the
      available space is used up. The components that were not included in the partial arrangement are
      highlighted in the components list. If the envelope size increases, the arrangement recalculates
      to include the components that did not previously fit in the arrangement.
    */
    isPartialArrangeAllowed: boolean
    /**
      Specifies the distance of the components and the bottom of the envelope. This raises the components
      above the X-Y plane of the specified construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created
      using a real number it is in centimeters. If you use a string, it is evaluated the same as a value
      would be in the command dialog and uses the current document units. For example, if the document
      units are inch and you specific "0.25" it will result in 1/4 inch clearance. You can also specify
      the units as part of the expression, such as "0.25 in + 2 mm". And you can define equations like
      "ToolDia + 2 mm" where "ToolDia" is an existing parameter.
    */
    placementClearance: core.ValueInput
    /**
      Specifies the minimum distance between the components in the arrangement and the envelope frame.
      This value will become a parameter when the arrangement is created. If the ValueInput is created
      using a real number it is in centimeters. If you use a string, it is evaluated the same as a value
      would be in the command dialog and uses the current document units. For example, if the document
      units are inch and you specific "0.25" it will result in 1/4 inch clearance. You can also specify
      the units as part of the expression, such as "0.25 in + 2 mm". And you can define equations like
      "ToolDia + 2 mm" where "ToolDia" is an existing parameter.
    */
    frameWidth: core.ValueInput
    /**
      Specifies the minimum clearance between components in the arrangement. for a 3D layout this
      also specified the distance between the components in the Z direction.
      This value will become a parameter when the arrangement is created. If the ValueInput is created
      using a real number it is in centimeters. If you use a string, it is evaluated the same as a value
      would be in the command dialog and uses the current document units. For example, if the document
      units are inch and you specific "0.25" it will result in 1/4 inch clearance. You can also specify
      the units as part of the expression, such as "0.25 in + 2 mm". And you can define equations like
      "ToolDia + 2 mm" where "ToolDia" is an existing parameter.
    */
    objectSpacing: core.ValueInput
  }

  /**
    The Arrange2DEnvelopeInput is a base class used to define the various settings common to
    the envelopes defined by a plane or by profiles and planar faces.
  */
  abstract class Arrange2DEnvelopeInput extends ArrangeEnvelopeInput {
    /**
      Specifies if the arrangement of objects is so they are above or X-Y plane of the envelope.
      Defaults to false so the objects are above the construction plane, profile or face.
    */
    isFlipped: boolean
  }

  /**
    This object is used to specify the input needed to define an envelope using profiles and planar
    faces to define the envelope shapes.
  */
  abstract class Arrange2DProfileOrFaceEnvelopeInput extends Arrange2DEnvelopeInput {
    /**
      Gets and sets an array that contains a combination of Profile and planar BRepFace objects that will be used to define
      the shape of the envelopes.
    */
    profilesOrFaces: core.Base[]
  }

  /**
    This object is used to specify the input needed to define a 2D rectangular envelope.
  */
  abstract class Arrange2DPlaneEnvelopeInput extends Arrange2DEnvelopeInput {
    /**
      Gets and sets the construction plane that will be used for this envelope.
    */
    plane: ConstructionPlane
    /**
      Gets and sets length of the envelope. This is the size of the envelope as measured along the X axis of the specified
      construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
    */
    length: core.ValueInput
    /**
      Gets and sets the width of the envelope. This is the size of the envelope as measured along the Y axis of the specified
      construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
    */
    width: core.ValueInput
    /**
      Gets and sets the X offset of the envelope from the origin of the construction plane. This value defaults to zero.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
    */
    originXOffset: core.ValueInput
    /**
      Gets and sets the Y offset of the envelope from the origin of the construction plane. This value defaults to zero.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
    */
    originYOffset: core.ValueInput
    /**
      Specifies the number of envelopes that can be used. The default value is -1 which means there is no limit.
      This value will become a parameter when the arrangement is created. When created with a real value it must be a whole number.
      You can also use a string where it is interpreted the same as when entered in the command dialog. The expression must result
      in a unitless whole number. It's also possible to use an equation like "Total / 4" where "Total" is an existing parameter and be
      evenly divided by four.
    */
    quantity: core.ValueInput
    /**
      For a 2D plane envelope, this defines the spacing between envelopes when there is more than one.
      This value will become a parameter when the arrangement is created. If the ValueInput is created
      using a real number it is in centimeters. If you use a string, it is evaluated the same as a value
      would be in the command dialog and uses the current document units. For example, if the document
      units are inch and you specific "0.25" it will result in 1/4 inch clearance. You can also specify
      the units as part of the expression, such as "0.25 in + 2 mm". And you can define equations like
      "ToolDia + 2 mm" where "ToolDia" is an existing parameter.
    */
    envelopeSpacing: core.ValueInput
  }

  /**
    This object is used to specify the input needed to define a 3D envelope.
  */
  abstract class Arrange3DEnvelopeInput extends ArrangeEnvelopeInput {
    /**
      Gets and sets the construction plane that will be used for this envelope.
    */
    plane: ConstructionPlane
    /**
      Gets and sets length of the envelope. This is the size of the envelope as measured along the X axis of the specified
      construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
    */
    length: core.ValueInput
    /**
      Gets and sets width of the envelope. This is the size of the envelope as measured along the Y axis of the specified
      construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
    */
    width: core.ValueInput
    /**
      Gets and sets height of the envelope. This is the size of the envelope as measured along the Z axis of the specified
      construction plane.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
    */
    height: core.ValueInput
    /**
      Gets and sets the X offset of the envelope from the origin of the construction plane. This value defaults to zero.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
    */
    originXOffset: core.ValueInput
    /**
      Gets and sets the Y offset of the envelope from the origin of the construction plane. This value defaults to zero.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
    */
    originYOffset: core.ValueInput
    /**
      Gets and sets the ceiling clearance of the 3D envelope. This value defaults to zero.
      This value will become a parameter when the arrangement is created. If the ValueInput is created using a
      real number it is in centimeters. If you use a string, it is evaluated the same as a value would be in the command
      dialog and uses the current document units. For example, if the document units are inch and you specific "0.25" it
      will result in 1/4 inch clearance. Using a string, you can also specify the units as part of the expression,
      such as "0.25 in + 2 mm". And you can define equations like "PartSize + 2 mm" where "PartSize" is an existing parameter.
    */
    ceilingClearance: core.ValueInput
  }

  /**
    The BRepBodies collection provides access to all of the B-Rep
    bodies within a component.
  */
  abstract class BRepBodies extends core.Base {
    /**
      Function that returns the specified body using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepBody | null
    /**
      Returns a specific body using the name of the body within the collection.
      @param name The name of the body, as seen in the browser, to return.
      @returns The BRepBody or null if a body with the defined name is not found.
    */
    itemByName(name: string): BRepBody | null
    /**
      Returns the number of bodies in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new BRepBody object. The input can be a persisted or transient BRepBody and the
      result is a persisted BRepBody. In a direct modeling design, the BRepBody is created within
      the component the BRepBodies collection was obtained from. In a parametric modeling design,
      the new BRepBody is created within the specified Base Feature.
      Because of a current limitation, if you want to create a BRepBody in a parametric model,
      you must first call the edit method of the base feature, then use the add method to create
      the body, and finally call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
      @param body The input BRepBody. Typically this is a transient BRepBody but that's not a requirement. In
      any case, there is not any association back to the original BRepBody.
      @param targetBaseFeature The BaseFeature object that this BRep body will be associated with. This is an optional
      requirement. It is required in a parametric modeling design but is ignored in a direct
      modeling design.
      @returns Returns the newly created BRepBody or null if the creation failed.
    */
    add(body: BRepBody, targetBaseFeature?: BaseFeature/* = null*/): BRepBody | null
  }

  /**
    Types that define the nature of the relationship between a point and a containing entity.
  */
  const enum PointContainment {
    /**
      The point lies inside.
    */
    PointInsidePointContainment,
    /**
      The point lies on the boundary.
    */
    PointOnPointContainment,
    /**
      The point lies outside.
    */
    PointOutsidePointContainment,
    /**
      The containment relationship is unknown.
    */
    UnknownPointContainment,
  }

  /**
    Represents a B-Rep (Boundary Representation) body.
  */
  abstract class BRepBody extends core.Base {
    /**
      Returns the component this body is owned by.
    */
    readonly parentComponent: Component
    /**
      Returns a collection of all of the lumps in the body.
    */
    readonly lumps: BRepLumps
    /**
      Returns a collection of all of the shells in the body.
    */
    readonly shells: BRepShells
    /**
      Returns a collection of all of the faces in the body.
    */
    readonly faces: BRepFaces
    /**
      Returns a collection of all of the edges in the body.
    */
    readonly edges: BRepEdges
    /**
      Returns a collection of all of the vertices in the body.
    */
    readonly vertices: BRepVertices
    /**
      Returns whether this body is closed (solid) or not.
    */
    readonly isSolid: boolean
    /**
      Returns the bounding box of this body.
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Returns all of the edges that connect concave faces.
    */
    readonly concaveEdges: BRepEdges
    /**
      Returns all of the edges that connect convex faces.
    */
    readonly convexEdges: BRepEdges
    /**
      Returns the area in cm ^ 2.
    */
    readonly area: number
    /**
      Returns the volume in cm ^ 3. Returns 0 in the case the body is not solid.
    */
    readonly volume: number
    /**
      Determines the relationship of the input point with respect to this body.
      @param point The point to do the containment check for.
      @returns Returns a value from the PointContainment enum indicating the relationship of
      the input point to the body.
    */
    pointContainment(point: core.Point3D): PointContainment
    /**
      Indicates if this body is represented in the model or is transient.
    */
    readonly isTransient: boolean
    /**
      Gets and sets the name of the body.
      This property is only valid if the IsTransient property is false.
    */
    name: string
    /**
      Gets if this body is currently visible in the graphics window. Use the
      isLightBulbOn to change if the light bulb beside the body node in the
      browser is on or not. Parent nodes in the browser can have their light
      bulb off which affects all of their children. This property indicates
      the final result and whether this body is actually visible or not.
      This property is only valid if the IsTransient property is false.
    */
    isVisible: boolean
    /**
      Gets and sets if this body is selectable.
      This property is only valid if the IsTransient property is false.
    */
    isSelectable: boolean
    /**
      Deletes the body.
      This property is only valid if the IsTransient property is false.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Copies the body to the clipboard.
      This property is only valid if the IsTransient property is false.
      @returns Returns true if the copy was successful.
    */
    copy(): boolean
    /**
      Cuts the body to the clipboard.
      This property is only valid if the IsTransient property is false.
      @returns Returns true if the cut was successful.
    */
    cut(): boolean
    /**
      Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying
      an override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
      this property to null will remove any override.
      This property is only valid if the IsTransient property is false.
    */
    appearance: core.Appearance
    /**
      Read-write property that gets the source of the appearance for the body. If this returns OverrideAppearanceSource, an override exists
      on this body. The override can be removed by setting the Appearance property to null.
      This property is only valid if the IsTransient property is false.
    */
    readonly appearanceSourceType: core.AppearanceSourceTypes
    /**
      Gets and sets the material assigned to this body.
      This property is only valid if the IsTransient property is false.
    */
    material: core.Material
    /**
      Returns the mesh manager object for this body.
    */
    readonly meshManager: MeshManager
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      BRepBody object is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object. Also returns null in the case
      where this body is transient.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BRepBody
    /**
      Returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      This method is only valid if the IsTransient property is false.
      @param occurrence The occurrence that defines the context for the created proxy.
      @returns Returns the new BRepBoy proxy or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BRepBody | null
    /**
      Creates a new component and occurrence within the component that currently owns this body.
      This body is moved into the new component and returned. The newly created component can be
      obtained by using the parentComponent property of the BRepBody object.
      This method is only valid if the IsTransient property is false.
      @returns Returns the BRrepBody in the new component or null in the case the creation failed.
    */
    createComponent(): BRepBody | null
    /**
      Moves this body from it's current component into the root component or the component owned by the
      specified occurrence.
      @param target The target can be either the root component or an occurrence.
      In the case where an occurrence is specified, the body will be moved into the parent component of the target
      occurrence and the target occurrence defines the transform of how the body will be copied so that the body
      maintains it's same position with respect to the assembly.
      @returns Returns the moved BRepBody or null in the case the move failed.
    */
    moveToComponent(target: core.Base): BRepBody | null
    /**
      Creates a copy of this body into the specified target.
      @param target The target can be either the root component or an occurrence.
      In the case where an occurrence is specified, the body will be copied into the parent component of the target
      occurrence and the target occurrence defines the transform of how the body will be copied so that the body
      maintains it's same position with respect to the assembly.
      If target is null, then a copy of the body is created in the owning component of the original body.
      @returns Returns the moved BRepBody or null in the case the move failed.
    */
    copyToComponent(target: core.Base): BRepBody | null
    /**
      Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc
      of this body. Property values will be calculated using the 'LowCalculationAccuracy' setting when using this property
      to get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method
      on the Design class instead.
      @returns Returns a PhysicalProperties object that can be used to get the various physical property related values.
    */
    readonly physicalProperties: PhysicalProperties
    /**
      Gets and set if the light bulb beside the body node in the
      browser is on or not. Parent nodes in the browser can have their light
      bulb off which affects all of their children so this property does not
      indicate if the body is actually visible, just that it should be visible
      if all of it's parent nodes are also visible. Use the isVisible property
      to determine if it's actually visible.
      This property is only valid if the IsTransient property is false.
    */
    isLightBulbOn: boolean
    /**
      Returns the collection of attributes associated with this face.
    */
    readonly attributes: core.Attributes
    /**
      If this body is associated with a base feature, this property will return that base feature.
      If it's not associated with a base feature, this property will return null.
    */
    readonly baseFeature: BaseFeature
    /**
      Creates a new body where the faces and edges are converted to different
      types of geometry based on the input options. This is particularly useful
      when you need a body made up entirely of NURBS surfaces.
      The tempId on the faces, edges, and vertices on the new body will match
      with the corresponding tempId on the original body. In cases where faces are
      split as a result of the conversion there can be more than one face or edge in
      the new body that matches to a single face or edge in the original body. The
      findByTempId method will find the entity with the matching id.
      @param options Input options that define how the conversion should be done. These are
      bitwise options so they can be combined.
      @returns Returns the new converted body or null in the case of failure.
    */
    convert(options: BRepConvertOptions): BRepBody | null
    /**
      Returns all of the faces, edges, or vertices that match the input ID.
      @param tempId The ID of the B-Rep entity to find.
      @returns Returns an array of entities that have the specified ID. This
      returns an array because it's possible that a body created by converting a
      body can have multiple entities with the same ID in the case where a curve
      or face was split. Returns an empty array in the case where no match is found.
    */
    findByTempId(tempId: number /*int*/): core.Base[]
    /**
      Gets and sets the opacity override assigned to this body. A value of 1.0 specifies
      that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
      This value is not necessarily related to what the user sees because the opacity is inherited.
      For example, if you this body is in a component and that component's opacity is set to something
      other than 1.0, the body will also be shown as slightly transparent even though the opacity
      property for the body will return 1.0. Because the component that contains the body can be
      referenced as an occurrence in other components and they can have different opacity settings,
      it's possible that different instances of the same body can display using different opacity levels.
      To get the opacity that it is being displayed with use the BrepBody.visibleOpacity property.
      This is the API equivalent of the "Opacity Control" command available for the body in the browser.
    */
    opacity: number
    /**
      The user can set an override opacity for components and bodies these opacity overrides combine if
      children and parent components have overrides. This property returns the actual opacity that is
      being used to render the body. To set the opacity use the opacity property of the BRepBody object.
    */
    readonly visibleOpacity: number
    /**
      Returns the current revision ID of the body. This ID changes any time the body is modified in any way. By getting
      and saving the ID when you create any data that is dependent on the body, you can then compare the saved
      ID with the current ID to determine if the body has changed to know if you should update your data.
    */
    readonly revisionId: string
    /**
      Returns any wire bodies that exist within this body.
    */
    readonly wires: BRepWires
    /**
      Indicates if this body is represented in the model or is temporary.
    */
    readonly isTemporary: boolean
    /**
      Returns a token for the BRepBody object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same body.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
      This is only valid for bodies that exist in the design, (the isTemporary
      property is false).
    */
    readonly entityToken: string
    /**
      Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc
      of this body.
      @param accuracy Specifies the desired level of computational accuracy of the property calculations.
      The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
      @returns Returns a PhysicalProperties object that can be used to get the various physical property related values.
    */
    getPhysicalProperties(accuracy?: CalculationAccuracy/* = CalculationAccuracy.LowCalculationAccuracy*/): PhysicalProperties
    /**
      Returns the TextureMapControl object associated with this body when there is an
      appearance assigned to the body that has a texture associated with it. If there
      isn't a texture, this property will return null. If there is a texture, you can
      use the returned object to query and modify how the texture is applied to the body.
    */
    readonly textureMapControl: core.TextureMapControl
    /**
      Indicates if this body represents a sheet metal folded part or not and if a flat pattern can be created.
    */
    readonly isSheetMetal: boolean
    /**
      Returns an oriented bounding box of the body that is best oriented to tightly fit the body.
    */
    readonly orientedMinimumBoundingBox: core.OrientedBoundingBox3D
    /**
      Returns a bounding box that tightly fits this body.
    */
    readonly preciseBoundingBox: core.BoundingBox3D
  }

  /**
    Defines the various options when converting the geometry of a B-Rep body or face
    to NURBS. This is used by the convert method of the BRepBody and BRepFace objects.
  */
  const enum BRepConvertOptions {
    /**
      Converts all procedurally calculated faces and edges into NURBS within the
      base tolerance. For example, an edge that is the intersection of two faces
      is represented as the exact analytical intersection of the two faces. This
      is converted into a NURBS curve as part of the conversion.
    */
    ProceduralToNURBSConversion = 0,
    /**
      Converts all analytic surfaces (cylinder, elliptical cylinder, cone, elliptical cone,
      sphere, and torus) except planes to NURBS surfaces.
    */
    AnalyticsToNURBSConversion = 1,
    /**
      Converts all planar faces to NURBS surfaces.
    */
    PlanesToNURBSConversion = 2,
    /**
      Splits any periodic surfaces so they become open surfaces.
    */
    SplitPeriodicFacesConversion = 4,
  }

  /**
    BRepLump collection.
  */
  abstract class BRepLumps extends core.Base {
    /**
      Function that returns the specified lump using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepLump | null
    /**
      Returns the number of lumps in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents an entirely connected set of entities. A BRepBody consists of BRepLumps.
  */
  abstract class BRepLump extends core.Base {
    /**
      Returns the BRepShells owned by the lump
    */
    readonly shells: BRepShells
    /**
      Returns the BRepFaces owned by the lump
    */
    readonly faces: BRepFaces
    /**
      Returns the BRepEdges owned by the lump
    */
    readonly edges: BRepEdges
    /**
      Returns the BRepVertices owned by the lump
    */
    readonly vertices: BRepVertices
    /**
      Returns the immediate owner BRepBody of the lump
    */
    readonly body: BRepBody
    /**
      Returns true of the lump is closed
    */
    readonly isClosed: boolean
    /**
      Returns the bounding box of the lump
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Returns the area in cm ^ 2.
    */
    readonly area: number
    /**
      Returns the volume in cm ^ 3. Returns 0 in the case the lump is not solid.
    */
    readonly volume: number
    /**
      Determines the relationship of the input point with respect to this lump.
      @param point The point to do the containment check for.
      @returns Returns a value from the PointContainment enum indicating the relationship of
      the input point to the lump.
    */
    pointContainment(point: core.Point3D): PointContainment
    /**
      Returns the mesh manager object for this lump.
    */
    readonly meshManager: MeshManager
    /**
      Returns the assembly context that is directly referencing this
      object in an assembly. This is only valid in the case where this
      BRepLump object is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BRepLump
    /**
      Returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context for the created proxy.
      @returns Returns the new BrepLump proxy or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BRepLump | null
    /**
      Returns a token for the BRepLump object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same lump.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
      This is only valid for lump that exist in the design, (the isTemporary
      property is false).
    */
    readonly entityToken: string
  }

  /**
    BRepShell collection.
  */
  abstract class BRepShells extends core.Base {
    /**
      Function that returns the specified shell using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepShell | null
    /**
      The number of shells in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents an entirely connected set of BRepFaces. A BRepLump may contain multiple BRepShells.
  */
  abstract class BRepShell extends core.Base {
    /**
      Returns the BRepFaces directly owned by this shell
    */
    readonly faces: BRepFaces
    /**
      returns the BRepEdges owned by this shell
    */
    readonly edges: BRepEdges
    /**
      Returns the BRepVertices owned by this shell
    */
    readonly vertices: BRepVertices
    /**
      Returns the parent lump of this shell.
    */
    readonly lump: BRepLump
    /**
      Returns the parent body of the shell.
    */
    readonly body: BRepBody
    /**
      Returns the bounding box of this shell
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Determines the relationship of the input point with respect to this shell.
      @param point The point to do the containment check for.
      @returns Returns a value from the PointContainment enum indicating the relationship of
      the input point to the shell.
    */
    pointContainment(point: core.Point3D): PointContainment
    /**
      Returns true if this shell is closed
    */
    readonly isClosed: boolean
    /**
      Returns true if the faces of this shell bound a void or an empty space within an outer shell.
    */
    readonly isVoid: boolean
    /**
      Returns the area in cm ^ 2.
    */
    readonly area: number
    /**
      Returns the volume in cm ^ 3. Returns 0 in the case the shell is not solid.
    */
    readonly volume: number
    /**
      Returns the mesh manager object for this shell.
    */
    readonly meshManager: MeshManager
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      BRepShell object is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BRepShell
    /**
      Returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context for the created proxy.
      @returns Returns the new BrepShell proxy or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BRepShell | null
    /**
      Returns the wire body, if any, that exists in this shell. Returns null if the
      shell doesn't have a wire body.
    */
    readonly wire: BRepWire
    /**
      Returns a token for the BRepShell object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same shell.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
      This is only valid for shells that exist in the design, (the isTemporary
      property is false).
    */
    readonly entityToken: string
  }

  /**
    BRepFace collection.
  */
  abstract class BRepFaces extends core.Base {
    /**
      Function that returns the specified face using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepFace | null
    /**
      The number of faces in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represent a connected region on a single geometric surface.
  */
  abstract class BRepFace extends core.Base {
    /**
      Returns the BRepEdges used by this face
    */
    readonly edges: BRepEdges
    /**
      Returns the BRepVertices used by this face
    */
    readonly vertices: BRepVertices
    /**
      Returns the parent shell of the face.
    */
    readonly shell: BRepShell
    /**
      Returns the BRepLoops owned by this face
    */
    readonly loops: BRepLoops
    /**
      Returns the parent body of the face.
    */
    readonly body: BRepBody
    /**
      Returns the underlying surface geometry of this face
    */
    readonly geometry: core.Surface
    /**
      Returns a SurfaceEvaluator to allow geometric evaluations across the face's surface.
      This evaluator differs from the evaluator available from the Surface obtained from the geometry
      property by being bounded by the topological boundaries of this face.
    */
    readonly evaluator: core.SurfaceEvaluator
    /**
      Returns a sample point guaranteed to lie on the face's surface, within the face's boundaries, and not on a boundary edge.
    */
    readonly pointOnFace: core.Point3D
    /**
      Returns the set of faces that are tangentially adjacent to this face.
      In other words, it is the set of faces that are adjacent to this face's edges
      and have a smooth transition across those edges.
    */
    readonly tangentiallyConnectedFaces: BRepFaces
    /**
      Returns a MeshManager object that allows access to existing and new meshes of this face.
    */
    readonly meshManager: MeshManager
    /**
      Read-write property that gets and sets the current appearance of the face. Setting this property will result in applying
      an override appearance to the face and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
      this property to null will remove any override.
    */
    appearance: core.Appearance
    /**
      Read-write property that gets the source of the appearance for the face. If this returns OverrideAppearanceSource, an override exists
      on this face. The override can be removed by setting the Appearance property to null.
    */
    readonly appearanceSourceType: core.AppearanceSourceTypes
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      BRepFace object is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BRepFace
    /**
      Returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context for the created proxy.
      @returns Returns the new BRepFace proxy or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BRepFace | null
    /**
      Returns the area in cm ^ 2.
    */
    readonly area: number
    /**
      Returns the bounding box of this face
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Returns a point at the centroid (aka, geometric center) of the face.
    */
    readonly centroid: core.Point3D
    /**
      Returns the collection of attributes associated with this face.
    */
    readonly attributes: core.Attributes
    /**
      Returns the temporary ID of this face. This ID is only good while the document
      remains open and as long as the owning BRepBody is not modified in any way.
      The findByTempId method of the BRepBody will return the entity in the body with the given ID.
    */
    readonly tempId: number /*int*/
    /**
      Creates a new body where this face and its edges are converted to different
      types of geometry based on the input options.
      The tempId on the faces, edges, and vertices on the new body will match
      with the corresponding tempId on the original body. In cases where the face is
      split as a result of the conversion there can be more than one face or edge in
      the new body that matches to a single face or edge in the original body.
      @param options Input options that define how the conversion should be done. These are
      bitwise options so they can be combined.
      @returns Returns the new converted body or null in the case of failure.
    */
    convert(options: BRepConvertOptions): BRepBody | null
    /**
      Gets if the normal of this face is reversed with respect to the surface geometry associated
      with this face.
    */
    readonly isParamReversed: boolean
    /**
      Returns a token for the BRepFace object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same face.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
      This is only valid for faces that exist in the design, (the isTemporary
      property is false).
    */
    readonly entityToken: string
    /**
      Checks if input point is on this BRepFace. This takes into account any boundaries so if the point is within a void area of the face, this will return false.
      @param point The input point to check.
      @param tolerance Specifies how close the point must be to the face to be considered on the face.
      Defaults to the point tolerance which can be obtained using the Application.pointTolerance
      property. The value is in centimeters.
      @returns Returns true if the point lies on the face.
    */
    isPointOnFace(point: core.Point3D, tolerance?: number/* = 0*/): boolean
  }

  /**
    BRepLoop collection.
  */
  abstract class BRepLoops extends core.Base {
    /**
      Function that returns the specified loop using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepLoop | null
    /**
      The number of loops in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents a connected portion of a BRepFace boundary. It consists of a chain of BRepCoEdges.
  */
  abstract class BRepLoop extends core.Base {
    /**
      Returns the BRepEdges used by this loop
    */
    readonly edges: BRepEdges
    /**
      Returns the BRepCoEdges consisting this loop
    */
    readonly coEdges: BRepCoEdges
    /**
      Returns true of this loop is an outer loop of a face
    */
    readonly isOuter: Boolean
    /**
      Returns the bounding box of this loop
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Returns the parent face of the loop.
    */
    readonly face: BRepFace
    /**
      Returns the parent body of the loop.
    */
    readonly body: BRepBody
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      BRepLoop object is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BRepLoop
    /**
      Returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context for the created proxy.
      @returns Returns the new BrepLoop proxy or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BRepLoop | null
    /**
      Returns a token for the BRepLoop object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same loop.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
      This is only valid for loops that exist in the design, (the isTemporary
      property is false).
    */
    readonly entityToken: string
  }

  /**
    BRepEdge collection.
  */
  abstract class BRepEdges extends core.Base {
    /**
      Function that returns the specified edge using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepEdge | null
    /**
      The number of edges in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents a one-dimensional topological element that can be used to bound a BRepFace A BRepEdge uses a single, connected and bounded subset of a curve for it geometry.
  */
  abstract class BRepEdge extends core.Base {
    /**
      Returns the BRepVertex that bounds its low parameter end.
    */
    readonly startVertex: BRepVertex
    /**
      Returns the BRepVertex that bounds its high parameter end.
    */
    readonly endVertex: BRepVertex
    /**
      Returns the BRepFaces that are associated with this edge through its BRepCoEdges.
    */
    readonly faces: BRepFaces
    /**
      Returns the parent shell of the edge.
    */
    readonly shell: BRepShell
    /**
      Returns the parent body of the edge.
    */
    readonly body: BRepBody
    /**
      Returns if the edge's geometry is degenerate.
      For example, the apex of a cone is a degenerate edge.
    */
    readonly isDegenerate: boolean
    /**
      Returns CurveEvaluator3D for evaluation.
    */
    readonly evaluator: core.CurveEvaluator3D
    /**
      Returns the underlying curve geometry of the edge.
    */
    readonly geometry: core.Curve3D
    /**
      Returns if the edge is tolerant.
      The tolerance used is available from the tolerance property.
    */
    readonly isTolerant: boolean
    /**
      Returns the tolerance used by a tolerant edge.
      This value is only useful when isTolerant is true.
    */
    readonly tolerance: number
    /**
      Returns a sample point guaranteed to lie on the edge's curve, within its boundaries,
      and not on a vertex (unless this is a degenerate edge).
    */
    readonly pointOnEdge: core.Point3D
    /**
      Returns the BRepCoEdges on the edge.
    */
    readonly coEdges: BRepCoEdges
    /**
      Returns if the parametric direction of this edge is reversed
      from the parametric direction of the underlying curve obtained from the geometry property.
      An edge's parametric direction is from the start vertex to the end vertex.
      But the underlying curve geometry may have the opposite parameterization.
      This property indicates if the parameterization order of the evaluator obtained from
      this edge is reversed from the order of the geometry curve's evaluator.
    */
    readonly isParamReversed: boolean
    /**
      Returns a collection of edges that includes all of the edges tangentially connected
      to this edge. The result includes this edge. The edges are in the collection
      in their connected order.
    */
    readonly tangentiallyConnectedEdges: core.ObjectCollection
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      BRepEdge object is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BRepEdge
    /**
      Returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context for the created proxy.
      @returns Returns the new BrepEdge proxy or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BRepEdge | null
    /**
      Returns the collection of attributes associated with this face.
    */
    readonly attributes: core.Attributes
    /**
      Returns the length of the edge in centimeters.
    */
    readonly length: number
    /**
      Returns the temporary ID of this edge. This ID is only good while the document
      remains open and as long as the owning BRepBody is not modified in any way.
      The findByTempId method of the BRepBody will return the entity in the body with the given ID.
    */
    readonly tempId: number /*int*/
    /**
      Returns the bounding box of this edge.
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Returns a token for the BRepEdge object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same edge.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
      This is only valid for edges that exist in the design, (the isTemporary
      property is false).
    */
    readonly entityToken: string
  }

  /**
    BRepVertex collection.
  */
  abstract class BRepVertices extends core.Base {
    /**
      Function that returns the specified vertex using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepVertex | null
    /**
      The number of vertices in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A 0-dimensional topological entity that bounds a BRepEdge.
  */
  abstract class BRepVertex extends core.Base {
    /**
      Returns the BRepFaces that uses this vertex through BRepEdge
    */
    readonly faces: BRepFaces
    /**
      Returns the BRepEdges bounded by this vertex
    */
    readonly edges: BRepEdges
    /**
      Returns if the vertex is tolerant.
      The tolerance used is available from the tolerance property.
    */
    readonly isTolerant: boolean
    /**
      Returns the tolerance used by a tolerant vertex.
      This value is only useful when isTolerant is true.
    */
    readonly tolerance: number
    /**
      Returns the underlying geometry point
    */
    readonly geometry: core.Point3D
    /**
      Returns the parent shell.
    */
    readonly shell: BRepShell
    /**
      Returns the parent body.
    */
    readonly body: BRepBody
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      BRepVertex object is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BRepVertex
    /**
      Returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context for the created proxy.
      @returns Returns the new BrepVertex proxy or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BRepVertex | null
    /**
      Returns the collection of attributes associated with this face.
    */
    readonly attributes: core.Attributes
    /**
      Returns the temporary ID of this vertex. This ID is only good while the document
      remains open and as long as the owning BRepBody is not modified in any way.
      The findByTempId method of the BRepBody will return the entity in the body with the given ID.
    */
    readonly tempId: number /*int*/
    /**
      Returns a token for the BRepVertex object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same vertex.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
      This is only valid for vertices that exist in the design, (the isTemporary
      property is false).
    */
    readonly entityToken: string
  }

  /**
    BRepCoEdge Collection.
  */
  abstract class BRepCoEdges extends core.Base {
    /**
      Function that returns the specified co-edge using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepCoEdge | null
    /**
      The number of co-edges in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents the use of a BRepEdge by a BRepFace.
  */
  abstract class BRepCoEdge extends core.Base {
    /**
      Returns the edge this co-edge is associated with.
    */
    readonly edge: BRepEdge
    /**
      Returns the loop this co-edge is part of.
    */
    readonly loop: BRepLoop
    /**
      Returns a curve evaluator that can be used to perform geometric evaluations on the co-edge.
    */
    readonly evaluator: core.CurveEvaluator2D
    /**
      Returns a geometry object that represents the shape of this co-edge in parameter space of the parent face's surface.
    */
    readonly geometry: core.Curve2D
    /**
      Indicates if the orientation of this co-edge is in the same direction or opposed to its associated edge.
    */
    readonly isOpposedToEdge: boolean
    /**
      Returns if the parametric direction of this co-edge is reversed
      from the parametric direction of the underlying curve obtained from the geometry property.
      A co-edge's parametric direction is from the start vertex to the end vertex.
      But the underlying curve geometry may have the opposite parameterization.
      This property indicates if the parameterization order of the evaluator obtained from
      this co-edge is reversed from the order of the geometry curve's evaluator.
    */
    readonly isParamReversed: boolean
    /**
      Returns the next co-edge in the loop.
    */
    readonly next: BRepCoEdge
    /**
      Returns the body this co-edge is part of.
    */
    readonly body: BRepBody
    /**
      Returns the co-edge on the adjacent face
    */
    readonly partner: BRepCoEdge
    /**
      Returns the previous co-edge in the loop.
    */
    readonly previous: BRepCoEdge
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      BRepCoEdge object is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BRepCoEdge
    /**
      Returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context for the created proxy.
      @returns Returns the new BrepCoEdge proxy or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BRepCoEdge | null
    /**
      Returns a token for the BRepCoEdge object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same co-edge.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
      This is only valid for co-edges that exist in the design, (the isTemporary
      property is false).
    */
    readonly entityToken: string
  }

  /**
    Provides access to B-Rep wire bodies.
  */
  abstract class BRepWires extends core.Base {
    /**
      Function that returns the specified wire using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepWire | null
    /**
      The number of B-Rep wire bodies in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents a single B-Rep wire body. A wire body consists of one or
    more edges and their vertices.
  */
  abstract class BRepWire extends core.Base {
    /**
      Returns the B-Rep edges associated with this wire body.
    */
    readonly edges: BRepEdges
    /**
      Returns the B-Rep vertices associated with this wire body.
    */
    readonly vertices: BRepVertices
    /**
      Returns the co-edges associated with this wire body. The co-edges record
      the connections between the edges in the wire body.
    */
    readonly coEdges: BRepCoEdges
    /**
      Indicates if this entities making up this wire body are planar and all lie on the same plane.
    */
    readonly isPlanar: boolean
    /**
      Returns the parent BRepBody object that contains this wire.
    */
    readonly parent: BRepBody
    /**
      Method that computes the offset for a planar wire. A BRepBody containing the resulting
      BRepWire object(s) is returned. It's possible that the offset result of a single wire
      can result in multiple wires.
      @param planeNormal Input Vector3D object that defines the positive direction of the
      plane the plane the wire lies on. This vector must be normal to the plane and is used to
      determine the side to offset the curves to. A positive offset distance is in the direction
      of the cross product (wire_tangent x wire_plane_normal). A negative offset is in the
      opposite direction.
      @param distance The offset distance in centimeters. See the description for the Normal argument to see how
      a positive or negative value for the distance specifies the direction of the offset.
      @param cornerType Specifies how the corners are connected when offsetting the curves results in gaps in the corners.
      See the documentation of the enum for a detailed description of each option.
      @returns Returns a new temporary BRepBody that contains one or more wires that represent the offset.
    */
    offsetPlanarWire(planeNormal: core.Vector3D, distance: number, cornerType: OffsetCornerTypes): BRepBody
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      BRepFace object is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BRepWire
    /**
      Returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context for the created proxy.
      @returns Returns the new BRepWire proxy or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BRepWire | null
  }

  /**
    Specifies the different types of corners that can be created when offsetting a wire body.
    These settings are used when the curves are offset outwards, which creates a gap at the
    corner. These represent the three ways the gap is filled.
  */
  const enum OffsetCornerTypes {
    /**
      Creates an arc at the corner to fill the gap. This is similar to filleting the corner
      with a fillet that is the same radius as the offset.
    */
    CircularOffsetCornerType,
    /**
      Creates lines that are tangent to the offset curves and connect at the corner.
    */
    LinearOffsetCornerType,
    /**
      Extends the offset curves so the connect at the corner.
    */
    ExtendedOffsetCornerType,
  }

  /**
    A utility object that provides functionality to create and manipulate B-Rep data outside
    the context of a document. The provides direct access to the modeling core without the
    overhead of parametrics, persistence, transactions, or graphics. It also provides a way
    of directly defining and creating B-Rep data.
  */
  abstract class TemporaryBRepManager extends core.Base {
    /**
      Gets the TempoaryBRepManager object. This object provides access to functionality to
      create an manipulate temporary B-Rep data outside the context of a document.
      @returns Returns the TemporaryBRepManager object.
    */
    static get(): TemporaryBRepManager
    /**
      Creates a temporary copy of the input BRepBody, BRepFace, or BRepEdge object.
      @param bRepEntity The BRepBody, BRepFace, BRepLoop, or BRepEdge to create a copy of. This can be a parametric
      B-Rep entity or a temporary B-Rep entity.
      @returns Returns a BRepBody that contains the result. If a BRepBody is input the copy is
      of the entire body. If a BRepFace is input, then the result is a BRepBody that
      contains a single face. If a BRepLoop is input then the result is a BRepBody that
      contains a wire where each edge in the loop will have a corresponding edge in the wire.
      If a BRepEdge is input then the result is a BRepBody that contains a wire that contains
      the single edge.
    */
    copy(bRepEntity: core.Base): BRepBody
    /**
      Calculates the intersection between the input body and plane and creates a
      wire body that represents the intersection curves.
      @param body The BRepBody to intersection.
      @param plane The geometry Plane to intersect with the body.
      @returns Returns a BRepBody that contains a wire body that represents the intersection.
    */
    planeIntersection(body: BRepBody, plane: core.Plane): BRepBody
    /**
      Creates a new body by creating a ruled surface between the two input wire bodies.
      @param sectionOne BRepWire that defines the shape of the first section.
      @param sectionTwo BRepWire that defines the shape of the second section.
      @returns Returns the created ruled surface as a BRepBody object.
    */
    createRuledSurface(sectionOne: BRepWire, sectionTwo: BRepWire): BRepBody
    /**
      Calculates the silhouette curve geometry for a given face as viewed from a given direction.
      @param face Input BRepFace object to calculate the silhouette curve for.
      @param viewDirection Input Vector3D object that defines the view direction to calculate the silhouette curve relative to.
      The silhouette curve(s) will lie along the path where the face normal is perpendicular to the view direction.
      @param returnCoincidentSilhouettes Input Boolean that specifies if silhouette curves that are coincident to the edges of the face should be
      returned or not. If true, these curves will be returned.
      @returns Returns a SurfaceBody object that will contain one or more BRepWire objects that represent the silhouette curve(s).
      This method can return null in the case where there is not a silhouette curve for the specified face.
    */
    createSilhouetteCurves(face: BRepFace, viewDirection: core.Vector3D, returnCoincidentSilhouettes: boolean): BRepBody | null
    /**
      Deletes one or more faces from a temporary BRepBody. The body that will be modified is determined
      by getting the parent body of the input faces.
      @param faces An array of BRepFace objects to delete. If more than one face is provided,
      all of the faces must exist within the same body.
      @param deleteSpecifiedFaces This allows you to either delete the faces that were input or to keep those faces and delete all the
      other faces in the body.
      @returns Returns true if the operation was successful.
    */
    deleteFaces(faces: BRepFace[], deleteSpecifiedFaces: boolean): boolean
    /**
      Performs the specified Boolean operation between the two input bodies. The input bodies need
      not be solid but can be faces that are combined or trimmed.
      @param targetBody The target body that will be modified as a result of the Boolean operation.
      @param toolBody The tool body that will be used to operate on the target body.
      @param booleanType The type of Boolean operation to perform.
      @returns Returns true if the operation was successful. If successful, the target body is modified as a result of the
      Boolean operation. Because of this the targetBody must always be a temporary BRepBody. The tool body is not
      modified. This is analogous to a machining operation where you have the target that is being machined and
      the tool that removes material.
    */
    booleanOperation(targetBody: BRepBody, toolBody: BRepBody, booleanType: BooleanTypes): boolean
    /**
      Transforms the input body using the specified transformation matrix.
      @param body The BRepBody object to transform.
      @param transform The transformation matrix that defines the transform to apply to the body.
      @returns Returns true if the specified transform was successfully applied to the body.
    */
    transform(body: BRepBody, transform: core.Matrix3D): boolean
    /**
      Creates new BRepBody objects based on the contents of the specified file.
      @param filename The full path and name of the file to read in. This can be a SMT, SMB, SAT, or SAB file.
      @returns A BRepBodies collection object is returned which can contain multiple BRepBody objects.
      null is returned in the case where it was unable to read the file.
    */
    createFromFile(filename: string): BRepBodies
    /**
      Exports the input bodies to the specified file.
      @param bodies An array of BRepBody objects that you want to export.
      @param filename The filename to write the BRepBody objects to. The type of file to create
      is inferred from the extension of the file. The valid extensions are ".sat" and ".smt".
      @returns Returns true if the export was successful.
    */
    exportToFile(bodies: BRepBody[], filename: string): boolean
    /**
      Creates a new temporary solid box BRepBody object.
      @param box The OrientedBoundingBox3D object that defines the position, orientation, and
      size of the box to crate.
      @returns Returns the newly created temporary BRepBody object or null in the case of failure.
    */
    createBox(box: core.OrientedBoundingBox3D): BRepBody | null
    /**
      Creates a temporary solid cylinder or cone BRepBody object.
      @param pointOne A point at one end of the cylinder or cone.
      @param pointOneRadius The radius of the cylinder or cone at the point one end, in centimeters.
      @param pointTwo A point at the opposite end of the cylinder or cone.
      @param pointTwoRadius The radius of the cylinder or cone at the point two end, in centimeters.
      For a cylinder the pointTwoRadius should be equal to the pointOneRadius.
      @returns Returns the newly created temporary BRepBody object or null in the case of failure.
    */
    createCylinderOrCone(pointOne: core.Point3D, pointOneRadius: number, pointTwo: core.Point3D, pointTwoRadius: number): BRepBody | null
    /**
      Creates a temporary elliptical solid cylinder or cone BrepBody object.
      @param pointOne A point at one end of the cylinder or cone.
      @param pointOneMajorRadius The major radius of the cylinder or cone at the point one end, in centimeters.
      @param pointOneMinorRadius The minor radius of the cylinder or cone at the point one end, in centimeters.
      @param pointTwo A point at the opposite end of the cone.
      @param pointTwoMajorRadius The major radius of the cylinder or cone at the point two end, in centimeters. The
      minor radius is automatically determined using the point one ratio of the minor and major
      radii.
      @param majorAxisDirection A Vector3D object that defines the direction of the major axis.
      @returns Returns the newly created temporary BRepBody object or null in the case of failure.
    */
    createEllipticalCylinderOrCone(pointOne: core.Point3D, pointOneMajorRadius: number, pointOneMinorRadius: number, pointTwo: core.Point3D, pointTwoMajorRadius: number, majorAxisDirection: core.Vector3D): BRepBody | null
    /**
      Creates a temporary spherical BRepBody object.
      @param center The center point of the sphere.
      @param radius The radius of the sphere in centimeters.
      @returns Returns the newly created temporary BRepBody object or null in the case of failure.
    */
    createSphere(center: core.Point3D, radius: number): BRepBody | null
    /**
      Creates a temporary toroidal BRepBody object.
      @param center The center point of the torus.
      @param axis The axis of the torus.
      @param majorRadius The radius, in centimeters, of the major radius of the torus. If the torus was created
      by sweeping a circle around another circle this would be the radius of the path circle.
      @param minorRadius The radius, in centimeters, of the minor radius of the torus. If the torus was created
      by sweeping a circle around another circle this would be the radius of the profile circle.
      @returns Returns the newly created temporary BRepBody object or null in the case of failure.
    */
    createTorus(center: core.Point3D, axis: core.Vector3D, majorRadius: number, minorRadius: number): BRepBody | null
    /**
      Creates a body from multiple wires that all lie within the same plane. Multiple wires are
      used when creating a plane with interior holes. One wire defines the outer shape and the
      other wires define the interior loops of the created face.
      @param wireBodies An array of bodies that contain planar wires. Each wire must be closed, they should not overlap,
      and they should all lie on the same plane.
      @returns Returns a BRepBody containing the created BRepFace object or null in the case of failure.
    */
    createFaceFromPlanarWires(wireBodies: BRepBody[]): BRepBody | null
    /**
      Method that finds regions of faces on two bodies which overlap and creates new bodies where the faces
      are split at the edges of the overlaps. This does not modify the original bodies but creates new
      temporary bodies that contain the imprints.
      @remarks
      The picture below shows an example of imprinting. The picture on the left shows the initial two bodies
      that are positioned so there are coincident faces. The picture on the right shows the two bodies individually
      so you can see the result of the imprint and how the coincident faces were split.
      The ability to imprint solids can be important to applications that need to mesh models. By creating edges
      at the points where solids connect, it guarantees that there will be mesh nodes along those boundaries.
      @param bodyOne Input BRepBody that will participate in the imprint operation. This body can be either a parametric
      or temporary body.
      @param bodyTwo Input BRepBody that will participate in the imprint operation. This body can be either a parametric
      or temporary body.
      @param imprintCoincidentEdges Input Boolean that indicates if overlapping edges should be included in the result. The picture below
      shows an example of when this argument will make a difference. The two bodies have overlapping faces
      and there is also an overlapping edge. If this argument is true, then the edge shown in red below
      will be included in the output as an overlapping edge. If False it will not be included and only
      the edges of the overlapping faces will be in the overlapping faces collections.
      <br/><br/><center><img src="../images/ImprintOverlappingEdges.png"></center>
      @param resultBodyOne Output temporary BRepBody that contains the imprinted body that corresponds to the body provided through the bodyOne argument.
      @param resultBodyTwo Output temporary BRepBody that contains the imprinted body that corresponds to the body provided through the bodyTwo argument.
      @param bodyOneOverlappingFaces Output array of BRepFace objects that represent the overlapping faces that are part of resultBodyOne. Faces at the same index within the
      collection returned here and that returned by the bodyTwoOverlappingFaces are overlapping.
      @param bodyTwoOverlappingFaces Output array of BRepFace objects that represent the overlapping faces that are part of resultBodyTwo. Faces at the same index within the
      collection returned here and that returned by the bodyOneOverlappingFaces are overlapping.
      @param bodyOneOverlappingEdges Output array of BRepEdge objects that represent the overlapping edges that are part of resultBodyOne. Edges at the same index within the
      collection returned here and that returned by the bodyTwoOverlappingEdges are overlapping.
      @param bodyTwoOverlappingEdges Output array of BRepEdge objects that represent the overlapping edges that are part of resultBodyTwo. Edges at the same index within the
      collection returned here and that returned by the bodyOneOverlappingEdges are overlapping.
      @param tolerance Optional Input double that specifies the tolerance, in centimeters, to use when comparing the bodies. If not specified, or a value of zero
      is specified, the internal modeling tolerance will be used.
      @returns Returns true if the imprint calculation was successful.
    */
    imprintOverlapBodies(bodyOne: BRepBody, bodyTwo: BRepBody, imprintCoincidentEdges: boolean, tolerance?: number/* = 0.0*/): [resultBodyOne: BRepBody, resultBodyTwo: BRepBody, bodyOneOverlappingFaces: BRepFace[], bodyTwoOverlappingFaces: BRepFace[], bodyOneOverlappingEdges: BRepEdge[], bodyTwoOverlappingEdges: BRepEdge[]]
    /**
      Give an array of curve geometry objects, this method creates a new wire body.
      @param curves An array containing the input Curve3D objects. These can be Arc3D, Circle3D, Ellipse3D, EllipticalArc3D or Line3D objects.
      @param edgeMap An array of edges in the returned body. The order that the edges are in this collection is the
      same order as the original corresponding Curve3D object is in the input curves array. This allows you to
      map between the original input curve and created edge.
      @param allowSelfIntersections Specifies if you want to allow self-intersection in the input curves or not.
      @returns Returns the B-Rep body containing the created wire or null in the case of failure.
    */
    createWireFromCurves(curves: core.Curve3D[], allowSelfIntersections?: boolean/* = false*/): [edgeMap: BRepEdge[]] | null
    /**
      Creates a B-Rep body that contains a wire with a single edge that represents a helical curve.
      @param axisPoint A Point3D object that defines a point along the axis of the helix.
      @param axisVector A Vector3D object that defines the direction of the axis of the helix.
      @param startPoint A Point3D that defines the start point of the helix. This is a point on the helix and defines the starting
      point of the helix. The distance of this point to the axis defines the starting radius of the helix.
      @param pitch The pitch of the helix, or the distance between each of the turns, in centimeters.
      @param turns The number of turns of the helix.
      @param taperAngle The taper angle of the helix in radians.
      @returns Returns a temporary BRepBody object that contains a wire body that is the shape of the
      specified helix. Return null if the creation failed.
    */
    createHelixWire(axisPoint: core.Point3D, axisVector: core.Vector3D, startPoint: core.Point3D, pitch: number, turns: number, taperAngle: number): BRepBody | null
    /**
      Computes the approximate outline of a body. The outline is the loops formed from projecting the non-occluded
      silhouette curves of the body onto a plane. The outline is returned as a temporary BRepBody consisting of
      planar BRepFace objects whose boundaries form the outline.
      The computed outline can be an approximation i.e. not precise. This is to make it useful in cases where robustness
      is more important than precision. For most cases, a precise analytical result is computed, but in some cases,
      the silhouette of a curved surface may be approximated by a series of straight lines. Even though it's an
      approximation you can control the tolerance of the approximation. A tighter tolerance will result in a longer compute time.
      @param body Input BRepBody object to calculate the projected outline for.
      @param projectionPlane Input Plane object that defines the position and orientation of the plane to project the body onto. The resulting body will lie on this plane.
      @param tolerance Input value that specifies the tolerance in centimeters to use when approximating smooth surfaces with line segments. A negative tolerance
      uses the default value which is 0.001 times the length of the diagonal of the bounding box of the input body. A positive tolerance must be
      greater than the point tolerance (0.000001).
      @param containsApproximation Output value that indicates if the result contains any silhouette curves that are an approximation of the true silhouette.
      @returns Returns a BRepBody object consisting of planar BRepFace objects whose boundaries define the body's outline.
    */
    createProjectedBodyOutline(body: BRepBody, projectionPlane: core.Plane, tolerance: number): [containsApproximation: boolean]
  }

  /**
    Defines the different type of boolean operations that are supported.
  */
  const enum BooleanTypes {
    /**
      Subtracts the tool body from the target body.
    */
    DifferenceBooleanType,
    /**
      Intersection the tool body with the target body.
    */
    IntersectionBooleanType,
    /**
      Unions the tool body with the target body.
    */
    UnionBooleanType,
  }

  /**
    This object is used to define a temporary B-Rep body. This includes solid, surface, and wire
    bodies. The class supports the ability to define the geometry and topology of the B-Rep and
    once the definition is complete, it supports the creation of a temporary BRepBody object.
  */
  abstract class BRepBodyDefinition extends core.Base {
    /**
      Static function that creates a new BRepBodyDefinition object. It's initially empty but you can use
      the functionality it provides to define the geometry and topology of the B-Rep
      object you want to create.
      @returns Returns the newly created BRepBodyDefinition object.
    */
    static create(): BRepBodyDefinition
    /**
      Attempts to create a temporary BRepBody object using the definition
      provided by this BRepBodyDefinition object. Properties on this BRepBodyDefinition
      are used to define some of the criteria that control how the body is created.
      @returns Returns the newly created BRepBody object if successful, otherwise null is returned.
      Information about the body creation can be obtained by using the outcomeInfo property.
      The outcome info is especially useful when initially writing and debugging your code to understand
      why the creation of the body is failing.
    */
    createBody(): BRepBody | null
    /**
      Specifies if full healing is done when creating the body. This defaults to true and it's highly recommended
      that you do full healing because it can find and correct problems with the input. If you're sure that the
      B-Rep definition that you've constructed is correct then you can set this to false to skip the full
      healing process.
    */
    doFullHealing: boolean
    /**
      Returns an array of strings that contain information about the outcome of the previous
      call of the createBody method. This is especially useful when the createBody method fails,
      (returns null), because it provides information about why the failure occurred. It can
      also sometimes provide some information even when createBody succeeds.
      Each string that's returned represents a single set of information and is packaged as JSON
      such as '{"description":"vertex data is null or inconsistent with edge geometry","associativeID":"unknown","code":37}'
      The description is an English description of the error or warning. The associativeID maps back to the
      entity provided that is the cause of the problem. The ID is the associative ID you can optionally
      assign to the entity definition. The code is an internal code for the error or warning.
      An empty array is returned if createBody succeeded and there's no additional information.
    */
    readonly outcomeInfo: string[]
    /**
      Provides access to the BRepLumpDefinitions object associated with this BRepBodyDefinition.
      It's through the returned collection that you can create new BRepLumpDefinition objects.
    */
    readonly lumpDefinitions: BRepLumpDefinitions
    /**
      Using a curve in model space it creates a new BRepEdgeDefinition object that's associated with the body.
      @param startVertex Vertex definition that defines the start of the edge. For a closed curve, like a circle, you still
      need to provide a vertex on the curve but you should use the same BRepVertexDefinition for both the start and end vertices.
      @param endVertex Vertex definition that defines the end of the edge. For a closed curve, like a circle, this should be the
      same vertex as used for the start vertex.
      @param modelSpaceCurve A Curve3D object that defines the shape of the edge using 3D geometry in model space.
      Valid input is an Arc3D, NurbsCurve3D, Circle3D, Ellipse3D, EllipticalArc3D, or Line3D.
      @returns Returns the created BRepEdgeDefinition object or null in the case of failure.
    */
    createEdgeDefinitionByCurve(startVertex: BRepVertexDefinition, endVertex: BRepVertexDefinition, modelSpaceCurve: core.Curve3D): BRepEdgeDefinition | null
    /**
      Creates a new BRepVertexDefinition object that's associated with the body.
      @param position Specifies the position of the vertex in model space.
      @returns Returns the created BRepVertexDefinition object or null in the case of failure.
    */
    createVertexDefinition(position: core.Point3D): BRepVertexDefinition | null
  }

  /**
    Represents the definition of a B-Rep edge that can be used as input to create a BRepBody.
  */
  abstract class BRepEdgeDefinition extends core.Base {
    /**
      Gets and sets the associate ID of this edge definition. This ID will be copied to the corresponding
      edge when the BRepBodyDefinition is used to create a BrepBody. It is used internally by Fusion as
      the identifier for the edge and is used for tracking this geometry for parametric recomputes.
    */
    associativeID: number /*int*/
    /**
      Gets and sets the start vertex of the edge definition.
    */
    startVertex: BRepVertexDefinition
    /**
      Gets and sets the end vertex of the edge definition.
    */
    endVertex: BRepVertexDefinition
    /**
      Gets and sets the curve that defines the shape of the edge.
    */
    modelSpaceCurve: core.Curve3D
    /**
      Gets and sets if the two faces that share this edge can be merged along this
      edge. This property defaults to true so that merging is always done but this
      can be set to false in cases where you want to preserve the edge.
      An example where merging is typically done is when you have multiple planar
      faces that all lie on the same plane and are connected. When merging is allowed
      these faces can be replaced by a single face and the edges connecting the
      faces (the merged edges) are no longer part of the body.
    */
    isMergeable: boolean
  }

  /**
    Represents the definition of a B-Rep vertex that can be used as input to create a BRepBody that includes this vertex.
  */
  abstract class BRepVertexDefinition extends core.Base {
    /**
      Gets and sets the position of the vertex in model space.
    */
    position: core.Point3D
  }

  /**
    Provides access to the BRepLumpDefinition objects associated with the BRepBodyDefinition
    and it's through this object that you create new BRepLumpDefinition objects.
  */
  abstract class BRepLumpDefinitions extends core.Base {
    /**
      Function that returns the specified BRepLumpDefinition object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepLumpDefinition | null
    /**
      The number of B-Rep lump definition objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new empty BRepLumpDefinition associated with the parent BRepBodyDefinition object.
      @returns Returns the newly created BRepLumpDefinition object.
    */
    add(): BRepLumpDefinition
  }

  /**
    Represents the definition of a B-Rep lump which is used in defining the topology of a B-Rep body.
  */
  abstract class BRepLumpDefinition extends core.Base {
    /**
      Provides access to the BRepShellDefinitions object associated with this BRepLumpDefinition.
      It's through the returned collection that you can create new BRepShellDefinition objects.
    */
    readonly shellDefinitions: BRepShellDefinitions
  }

  /**
    Provides access to the BRepShellDefinition objects associated with the object the collection was obtained from.
    It's through this object that you create new BRepShellDefinition objects.
  */
  abstract class BRepShellDefinitions extends core.Base {
    /**
      Function that returns the specified BRepShellDefinition object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepShellDefinition | null
    /**
      The number of B-Rep shell definition objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new empty BRepShellDefinition object associated with the parent BRepLumpDefinition.
      @returns Returns the newly created BRepShellDefinition object.
    */
    add(): BRepShellDefinition
  }

  /**
    Represents the definition of a B-Rep shell that can be used as input to create a BRepBody that includes this shell.
  */
  abstract class BRepShellDefinition extends core.Base {
    /**
      Provides access to the BRepFaceDefinitions object associated with this BRepShellDefinition.
      It's through the returned collection that you can create new BRepFaceDefinition objects.
    */
    readonly faceDefinitions: BRepFaceDefinitions
    /**
      Returns the single BRepWireDefinition associated with this shell definition.
    */
    readonly wireDefinition: BRepWireDefinition
  }

  /**
    Provides access to the BRepFaceDefinition objects associated with the object the collection was obtained from.
    It's through this object that you create new BRepFaceDefinition objects.
  */
  abstract class BRepFaceDefinitions extends core.Base {
    /**
      Function that returns the specified BRepFaceDefinition object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepFaceDefinition | null
    /**
      The number of B-Rep face definition objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new BrepFaceDefinition within the parent BRepShellDefinition object.
      @param surfaceGeometry Input surface object that defines the geometry of the face. Valid objects for input are
      NurbsSurface, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Plane, Sphere, and Torus.
      @param isParamReversed Input Boolean that indicates if the normal of this face is reversed with respect to the
      surface geometry associated with this face definition.
      @returns Returns the newly created BRepFaceDefinition object or null in the case of failure.
    */
    add(surfaceGeometry: core.Surface, isParamReversed: boolean): BRepFaceDefinition | null
  }

  /**
    Represents the definition of a B-Rep face that can be used as input to create a BRepBody that includes this face.
  */
  abstract class BRepFaceDefinition extends core.Base {
    /**
      Gets and sets the associate ID of this face definition. This ID will be copied to the corresponding
      face when the BRepBodyDefinition is used to create a BrepBody. It is used by Fusion as
      the identifier for the face and is used for tracking this geometry for parametric recomputes.
    */
    associativeID: number /*int*/
    /**
      Provides access to the BRepLoopDefinitions object associated with this BRepFaceDefinition.
      It's through the returned collection that you can create new BRepLoopDefinition objects.
    */
    readonly loopDefinitions: BRepLoopDefinitions
    /**
      Gets and sets the surface geometry associated with this face definition.
    */
    surfaceGeometry: core.Surface
    /**
      Gets and sets if the normal of this face is reversed with respect to the surface geometry associated
      with this face definition.
    */
    isParamReversed: boolean
  }

  /**
    Provides access to the BRepLoopDefinition objects associated with the parent BRepFaceDefinition object.
    It's through this object that you create new BRepLoopDefinition objects.
  */
  abstract class BRepLoopDefinitions extends core.Base {
    /**
      Function that returns the specified BRepLoopDefinition object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepLoopDefinition | null
    /**
      The number of B-Rep loop definition objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new empty loop associated with the parent face definition.
      @returns Returns the newly created BRepLoopDefinition object.
    */
    add(): BRepLoopDefinition
  }

  /**
    Represents the definition of a B-Rep loop that can be used as input to create a BRepBody that includes this loop.
  */
  abstract class BRepLoopDefinition extends core.Base {
    /**
      Provides access to the BRepCoEdgeDefinitions object associated with the parent BRepFaceDefinition object.
      It's through the returned collection that you can create new BRepCoEdgeDefinition objects.
    */
    readonly bRepCoEdgeDefinitions: BRepCoEdgeDefinitions
  }

  /**
    Provides access to the BRepCoEdgeDefinition objects associated with the parent BRepLoopDefinition object.
    It's through this object that you create new BRepCoEdgeDefinition objects.
  */
  abstract class BRepCoEdgeDefinitions extends core.Base {
    /**
      Function that returns the specified BRepCoEdgeDefinition object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepCoEdgeDefinition | null
    /**
      The number of B-Rep co-edge definition objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new BrepCoEdgeDefinition object associated with the parent BrepLoopDefinition object.
      @param edgeDefinition The BRepEdgeDefinition object this co-edge is related to.
      @param isOpposedToEdge Boolean that indicates if the orientation of this BRepCoEdgeDefinition is reversed with respect
      to the associated BRepEdgeDefinition object.
      @returns Returns the newly created BrepCoEdgeDefinition object or null in the case of failure.
    */
    add(edgeDefinition: BRepEdgeDefinition, isOpposedToEdge: boolean): BRepCoEdgeDefinition | null
  }

  /**
    Represents the definition of a B-Rep co-edge that can be used as input to create a BRepBody that includes this co-edge.
  */
  abstract class BRepCoEdgeDefinition extends core.Base {
    /**
      Gets and sets the BRepEdgeDefinition object associated with this BrepCoEdgeDefinition object.
    */
    edgeDefinition: BRepEdgeDefinition
    /**
      Gets and sets if the orientation of this BRepCoEdgeDefinition object is reversed with
      respect to the associated BRepEdgeDefinition object.
    */
    isOpposedToEdge: boolean
  }

  /**
    Represents the definition of a B-Rep wire that can be used as input to create a BRepBody that includes this wire.
  */
  abstract class BRepWireDefinition extends core.Base {
    /**
      Provides access to the BRepWireEdgeDefinitions object associated with the parent BRepWireDefinition object.
      It's through the returned collection that you can create new BRepWireEdgeDefinitions objects.
    */
    readonly wireEdgeDefinitions: BRepWireEdgeDefinitions
  }

  /**
    A collection of BRepWireEdgeDefinition objects. Using this collection you can create new
    BRepWireDefinition objects to full define a wire body.
  */
  abstract class BRepWireEdgeDefinitions extends core.Base {
    /**
      Function that returns the specified BRepWireEdgeDefinition object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepWireEdgeDefinition | null
    /**
      The number of B-Rep wire edge definition objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new BRepWireEdgeDefinition object associated with the parent BRepWireDefinition object.
      @param startVertex Vertex definition that defines the start of the edge. For a closed curve, like a circle, you still
      need to provide a vertex on the curve but should use the same BRepVertexDefinition for both the start and end vertices.
      @param endVertex Vertex definition that defines the end of the edge. For a closed curve, like a circle, this should be the
      same vertex as used for the start vertex.
      @param modelSpaceCurve A Curve3D object that defines the shape of the edge using 3D geometry in model space.
      Valid input is an Arc3D, NurbsCurve3D, Circle3D, Ellipse3D, EllipticalArc3D, or Line3D.
      @returns Returns the newly created BRepWireEdgeDefinition object or null in the case of failure.
    */
    add(startVertex: BRepVertexDefinition, endVertex: BRepVertexDefinition, modelSpaceCurve: core.Curve3D): BRepWireEdgeDefinition | null
  }

  /**
    Represents the definition of an edge in B-Rep wire that can be used as input to create a BRepBody that includes this wire edge.
  */
  abstract class BRepWireEdgeDefinition extends core.Base {
    /**
      Gets and sets the associate ID of this B-Rep wire definition. This ID will be copied to the corresponding
      edge when the BRepBodyDefinition is used to create a BrepBody. It is used by Fusion as
      the identifier for the edge and is used for tracking this geometry for parametric recomputes.
    */
    associativeID: number /*int*/
    /**
      Gets and sets the start vertex of the wire edge definition.
    */
    startVertex: BRepVertexDefinition
    /**
      Gets and sets the end vertex of the wire edge definition.
    */
    endVertex: BRepVertexDefinition
    /**
      Gets and sets the Curve3D object that defines the shape of the edge using 3D geometry in model space.
      Valid objects are an Arc3D, NurbsCurve3D, Circle3D, Ellipse3D, EllipticalArc3D, or Line3D.
    */
    modelSpaceCurve: core.Curve3D
  }

  /**
    The Components collection object provides access to existing components in a design.
  */
  abstract class Components extends core.Base {
    /**
      Function that returns the specified component using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Component | null
    /**
      The number of components in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified component by name.
      @param name The name of the component within the collection to return.
      @returns Returns the specified component or null if the name is not found.
    */
    itemByName(name: string): Component | null
    /**
      Returns the Component that has the specified ID.
      @param id The ID of the Component to get. This is the same id used by PIM (Product Information Model).
      @returns Returns the specified Component or null in the case where there isn't a Component with the specified ID in this Design.
    */
    itemById(id: string): Component | null
  }

  /**
    The BaseComponent object that defines all of the common design data
    and is the base class for the product specific components.
  */
  abstract class BaseComponent extends core.Base {
    /**
      Property that gets and sets the name of this component. This is the name
      shown in the browser for each occurrence referencing this component.
    */
    name: string
    /**
      Property that returns the Occurrences collection associated with this component.
      This provides access to the occurrences at the top-level of this component and provides
      the functionality to add new occurrences.
    */
    readonly occurrences: Occurrences
    /**
      Returns all occurrences at the top-level of this component that reference the specified component.
      The returned list is read-only.
      @param component The component that is being referenced by the occurrences that will be returned.
      @returns The occurrences referenced by the specified component.
    */
    occurrencesByComponent(component: Component): OccurrenceList
    /**
      Returns all of the occurrences in the assembly regardless of their level within the assembly structure.
      The returned list is read-only.
    */
    readonly allOccurrences: OccurrenceList
    /**
      Returns all occurrences, at any level of the assembly, that reference the specified component.
      The returned list is read-only.
      @param component The component that is being referenced by the occurrences that will be returned.
      @returns The occurrences referenced by the specified component.
    */
    allOccurrencesByComponent(component: Component): OccurrenceList
    /**
      Returns the construction planes collection associated with this component.
      This provides access to the existing construction planes and supports
      the creation of new construction planes.
    */
    readonly constructionPlanes: ConstructionPlanes
    /**
      Returns the construction axes collection associated with this component.
      This provides access to the existing construction axes and supports
      the creation of new construction axes.
    */
    readonly constructionAxes: ConstructionAxes
    /**
      Returns the construction points collection associated with this component.
      This provides access to the existing construction points and supports
      the creation of new construction points.
    */
    readonly constructionPoints: ConstructionPoints
    /**
      Returns the B-Rep bodies collection associated with this component.
    */
    readonly bRepBodies: BRepBodies
    /**
      Returns the parent product this component is owned by.
    */
    readonly parentDesign: Design
    /**
      Finds all the B-Rep entities that are intersected by the specified ray. This can return BRepFace, BrepEdge,
      and BRepVertex objects.
      @param originPoint Input point that defines the origin of the ray. The search for entities begins at this point.
      @param rayDirection Input vector that defines the direction of the ray. The ray is infinite so the length of the vector is ignored.
      @param entityType The type of B-Rep entity wanted. You can also take advantage of B-Rep topology to infer other intersections. For example,
      If you get a BRepEdge it implies that the faces the edge connects were also intersected. If a BRepVertex is returned it
      implies the edges that the vertex connects were intersected and the faces that the edges connect were intersected.
      @param proximityTolerance Optional argument that specifies the tolerance for the search. All entities within this distance from the ray and of the specified type will be returned. If not specified a default small tolerance is used.
      @param visibleEntitiesOnly Optional argument that indicates whether or not invisible entities should be included in the search. Defaults to True indicating that invisible entities will be ignored.
      @param hitPoints An ObjectCollection of Point3D objects that represent the coordinates where the ray hit the found entity. There will be the same number of hit points as returned entities
      and they will be in the collections in the same order. In other words, hit point 1 corresponds with found entity 1, hit point 2 corresponds with found entity 2, and so on.
      Because of the proximity tolerance the hitPoint may not actually lie on the entity but will be within the proximity tolerance to it.
      It's an optional out argument, returns the hit points if an existing ObjectCollection is input. You can create a new ObjectCollection by using
      the static create method on the ObjectCollection class.
      @returns Returns an ObjectCollection containing the entities found. The returned collection can be empty indicating nothing was found. The points are returned
      in an order where they are arranged based on their distance from the origin point where the closest point is first. If an entity is hit more than
      once, the entity is returned once for the first intersection.
    */
    findBRepUsingRay(originPoint: core.Point3D, rayDirection: core.Vector3D, entityType: BRepEntityTypes, proximityTolerance?: number/* = -1*/, visibleEntitiesOnly?: boolean/* = true*/, hitPoints?: core.ObjectCollection/* = null*/): core.ObjectCollection
    /**
      Finds all the entities of the specified type at the specified location.
      @param point Input coordinate that specifies the component space point at which to find the entities.
      @param entityType The type of B-Rep entity wanted. You can also take advantage of B-Rep topology to infer other that other entities were found. For example,
      If you get a BRepEdge it implies that the faces the edge connects were also found. If a BRepVertex is returned it
      implies the edges that the vertex connects were found and the faces that the edges connect were found.
      @param proximityTolerance Specifies the tolerance for the search. All entities within this distance from the search point that match the filter will be returned. If not specified a default tolerance is used.
      @param visibleEntitiesOnly indicates whether or not invisible objects should be included in the search. Defaults to True indicating that invisible objects will be ignored.
      @returns Returns an ObjectCollection containing the entities found. The returned collection can be empty indicating nothing was found.
    */
    findBRepUsingPoint(point: core.Point3D, entityType: BRepEntityTypes, proximityTolerance?: number/* = -1*/, visibleEntitiesOnly?: boolean/* = true*/): core.ObjectCollection
    /**
      Returns the canvases collection associated with this component. This provides access to the
      existing canvases and supports the creation of new canvases.
    */
    readonly canvases: Canvases
    /**
      Returns the PropertyGroups object associated with this component.
    */
    readonly propertyGroups: core.PropertyGroups
    /**
      Returns the DataComponent associated with this component. The DataComponent
      provides ID information that can be used to access this component using the
      MFG DM API. These ID's don't exist until a component has been saved. The ID's
      are generated by MFG DM API on the cloud, so there will be a slight delay
      after saving before the ID's are available. This property returns null in
      the case the MFG DM API information doesn't exist yet.
      When opening a design, the MFG DM API information is obtained from the cloud
      and as a result may not be available immediately after opening a document. Again,
      this property will return null in this case too. Essentially, null is returned
      in all cases where good ID information is not yet available.
      @experimental
    */
    readonly dataComponent: core.DataComponent
    /**
      Returns the decals collection associated with this component. This provides access to the
      existing decals and supports the creation of new decals.
    */
    readonly decals: Decals
  }

  /**
    Used by the findBRepUsingRay and findBRepUsingPoint methods to specify the desired return type.
  */
  const enum BRepEntityTypes {
    /**
      Specifies that BRepBody objects should be returned.
    */
    BRepBodyEntityType,
    /**
      Specifies that BRepFace objects should be returned.
    */
    BRepFaceEntityType,
    /**
      Specifies that BRepEdge objects should be returned.
    */
    BRepEdgeEntityType,
    /**
      Specifies that BRepVertex objects should be returned.
    */
    BRepVertexEntityType,
  }

  /**
    Represents a component in the data model.
    A component represents a set of geometry, features, and parameters that make up an item in the design.
    A component can be referenced multiple times into a design with a Occurrence object.
  */
  abstract class Component extends BaseComponent {
    /**
      Returns the sketches collection associated with this component.
      This provides access to the existing sketches and supports
      the creation of new sketches.
    */
    readonly sketches: Sketches
    /**
      Returns the collection that provides access to all of the features
      associated with this component.
    */
    readonly features: Features
    /**
      Returns the mesh bodies collection associated with this component.
    */
    readonly meshBodies: MeshBodies
    /**
      Returns the collection of model parameters in the Component.
    */
    readonly modelParameters: ModelParameters
    /**
      Gets and sets if the light bulb of the origin folder as seen in the browser is on or off.
      This controls the visibility of the origin construction geometry.
    */
    isOriginFolderLightBulbOn: boolean
    /**
      Gets and sets if the light bulb of the construction folder as seen in the browser is on or off.
      This controls the visibility of the (non-origin) construction geometry
      (i.e. planes, points, axes).
    */
    isConstructionFolderLightBulbOn: boolean
    /**
      Gets and sets if the light bulb of the sketch folder as seen in the browser is on or off.
      This controls the visibility of the sketches in this component.
    */
    isSketchFolderLightBulbOn: boolean
    /**
      Returns the XY origin construction plane.
    */
    readonly xYConstructionPlane: ConstructionPlane
    /**
      Returns the XZ origin construction plane.
    */
    readonly xZConstructionPlane: ConstructionPlane
    /**
      Returns the YZ origin construction plane.
    */
    readonly yZConstructionPlane: ConstructionPlane
    /**
      Returns the X origin construction axis.
    */
    readonly xConstructionAxis: ConstructionAxis
    /**
      Returns the Y origin construction axis.
    */
    readonly yConstructionAxis: ConstructionAxis
    /**
      Returns the Z origin construction axis.
    */
    readonly zConstructionAxis: ConstructionAxis
    /**
      Returns the origin construction point.
    */
    readonly originConstructionPoint: ConstructionPoint
    /**
      Gets and sets the part number associated with this component. Setting this
      to an empty string will reset it to be the same as the component name.
    */
    partNumber: string
    /**
      Gets and sets the description associated with this component.
    */
    description: string
    /**
      Creates an open profile based on the input curve(s).
      @param curves A SketchCurve or an ObjectCollection containing multiple sketch entities. If a single sketch curve
      is input the chainCurves argument is checked to determine if connected curves (they do not need to be tangent)
      should be automatically found. If multiple curves are provided the chainCurves argument is always
      treated as false so you must provide all of the curves in the object collection that you want included in the profile.
      The provided curves must all connect together in a single path.
      The input curves do not need to be in the same sketch, but they do need to geometrically connect for
      a valid profile to be created.
      @param chainCurves If true, this finds any curves within the same sketch that connect to the single input curve and automatically includes them in the profile. If
      false, only the curves provided will be used to define the profile. This argument is ignored and treated as false if multiple curves are input.
      @returns Returns the new Profile object or null in the case of a failure.
    */
    createOpenProfile(curves: core.Base, chainCurves?: boolean/* = true*/): Profile | null
    /**
      Creates a profile based on the outside open edges of a BRepFace.
      @param edges A single BRepEdge object or an ObjectCollection containing multiple BRepEdge objects, or a BRepLoop object. If a single edge
      is input, the chainEdges argument is checked to determine if connected edges (they do not need to be tangent)
      should be automatically found. If multiple edges are provided the chainEdges argument is always
      treated as false so you must provide all of the edges in the object collection that you want included in the profile.
      and the edges must all connect together in a single path. if a BRepLoop object is provided, all of the edges in the loop
      are included in the profile and the chainEdges argument is ignored.
      @param chainEdges If true, this finds any edges that connect to the single input edge and automatically includes them in the profile. If
      false, only the edges provided will be used to define the profile. This argument is ignored and treated as false if multiple edges
      or a BRepLoop is input.
      @returns Returns the new Profile object or null in the case of a failure.
    */
    createBRepEdgeProfile(edges: core.Base, chainEdges?: boolean/* = true*/): Profile | null
    /**
      Returns the collection of joints associated with this component.
    */
    readonly joints: Joints
    /**
      Returns the collection of as-built joints associated with this component.
    */
    readonly asBuiltJoints: AsBuiltJoints
    /**
      Returns the collection of rigid groups associated with this component.
    */
    readonly rigidGroups: RigidGroups
    /**
      Gets and sets the physical material assigned to this component.
    */
    material: core.Material
    /**
      Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc
      of this component. Property values will be calculated using the 'LowCalculationAccuracy' setting when using this property
      to get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method instead.
      @returns Returns a PhysicalProperties object that can be used to get the various physical property related values.
    */
    readonly physicalProperties: PhysicalProperties
    /**
      Performs a Save Copy As on this component. This saves the specified component as a new document
      in the specified location.
      @param name The name to use for the new document. If this is an empty string, Fusion will use the
      name of the component being saved.
      @param dataFolder The data folder to save the new document to.
      @param description The description string of the document. This can be an empty string.
      @param tag The tag string of the document. This can be an empty string.
      @returns Returns a DataFileFuture object that can be used to track the progress of the upload and get the
      resulting DataFile once it's available on A360.
    */
    saveCopyAs(name: string, dataFolder: core.DataFolder, description: string, tag: string): core.DataFileFuture
    /**
      Returns the bounding box of this component. This is always in world space of the component.
      The boundingBox2 method provides greater control over which types of entities you want
      included in the bounding box calculation.
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Gets and sets if the light bulb of the joints folder as seen in the browser is on or off.
      This controls the visibility of the joints in this occurrence. The light bulb for the
      folder is component specific and will turn off the joints for all occurrences referencing
      the component.
    */
    isJointsFolderLightBulbOn: boolean
    /**
      Returns the collection of attributes associated with this face.
    */
    readonly attributes: core.Attributes
    /**
      Gets and sets if the light bulb of the bodies folder as seen in the browser is on or off.
      This controls the visibility of the solid/surface bodies and the mesh bodies in this component.
    */
    isBodiesFolderLightBulbOn: boolean
    /**
      Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc
      of this component.
      @param accuracy Specifies the desired level of computational accuracy of the property calculations.
      The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
      @returns Returns a PhysicalProperties object that can be used to get the various physical property related values.
    */
    getPhysicalProperties(accuracy?: CalculationAccuracy/* = CalculationAccuracy.LowCalculationAccuracy*/): PhysicalProperties
    /**
      Transforms a set of occurrences in one step. This provides better performance than transforming them one at a time.
      This method is only valid when called on the root component because Fusion flattens the entire assembly structure
      when manipulating the assembly so all transforms are relative to the root component.
      @param occurrences An array of Occurrence objects that you want to transform. These must all be in the context of the root component which
      means proxies must be used for occurrences that are in sub-components.
      @param transforms An array of Matrix3D objects that defines the transform to apply to each occurrence. This array must be the same size
      as the array provided for the occurrences argument and the transform will be applied to the occurrence at the same index
      in the occurrences array.
      @param ignoreJoints Specifies if the joints are to be ignored and the occurrences are to be positioned based on then specified transform or if
      the joints should be used and the occurrence is transformed the best it can while still honoring the joints.
      @returns Returns true if the transform was successful.
    */
    transformOccurrences(occurrences: Occurrence[], transforms: core.Matrix3D[], ignoreJoints: boolean): boolean
    /**
      Returns all joints in this component and any sub components. The joints returned are all in the context
      of this component so any joints in sub components will be proxies. This is primarily useful when used
      from the root component because Fusion flattens the assembly structure, including joints, when manipulating
      an assembly.
    */
    readonly allJoints: Joint[]
    /**
      Returns all joint origins in this component and any sub components. The joint origins returned are all in the context
      of this component so any joint origins in sub components will be proxies. This is primarily useful when used
      from the root component because Fusion flattens the assembly structure, including joint origins, when manipulating
      an assembly.
    */
    readonly allAsBuiltJoints: AsBuiltJoint[]
    /**
      Returns all as-built joints in this component and any sub components. The as-built joints returned are all in the context
      of this component so any as-built joints in sub components will be proxies. This is primarily useful when used
      from the root component because Fusion flattens the assembly structure, including as-built joints, when manipulating
      an assembly.
    */
    readonly allJointOrigins: JointOrigin[]
    /**
      Returns all rigid groups in this component and any sub components. The rigid groups returned are all in the context
      of this component so any rigid groups in sub components will be proxies. This is primarily useful when used
      from the root component because Fusion flattens the assembly structure, including rigid groups, when manipulating
      an assembly.
    */
    readonly allRigidGroups: RigidGroup[]
    /**
      Gets and sets the opacity override assigned to this component. A value of 1.0 specifies
      that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
      This is only applicable for a non-root local component.
      This value is not necessarily related to what the user sees because the opacity is inherited.
      For example, if you have TopComponent and it has a component in it called SubComponent and you
      set the opacity of TopComponent to be 0.5, SubComponent will also be shown as slightly transparent
      even though the opacity property for it will return 1.0. Because a component can be referenced as
      an occurrence in other components and they can have different opacity settings, it's possible that
      different instances of the same component can display using different opacity levels. To get the
      opacity that it is being displayed with use the Occurrence.visibleOpacity property.
    */
    opacity: number
    /**
      Returns the collection of joint origins associated with this component.
    */
    readonly jointOrigins: JointOrigins
    /**
      Returns the customGraphicsGroups object in this component.
    */
    readonly customGraphicsGroups: CustomGraphicsGroups
    /**
      Returns the current revision ID of the component. This ID changes any time the component is modified in any way. By getting
      and saving the ID when you create any data that is dependent on the component, you can then compare the saved
      ID with the current ID to determine if the component has changed to know if you should update your data.
    */
    readonly revisionId: string
    /**
      Returns a token for the Component object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same component.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Returns the persistent ID of the component. This ID is created with the component and does not change.
      Because this ID does not change, different revisions of the same design or copies of the design asset/file
      will retain this ID. If components from different designs have the same ID, it indicates they are either
      different revisions or a copy of the design was made. Therefore, this ID will always be unique within a
      single design, but may not be unique in an assembly where externally referenced designs include different
      revisions or copies of a design.
      The ID is also the same ID used by PIM (Product Information Model).
    */
    readonly id: string
    /**
      Returns all tangent relationships in this component and any sub components. The tangent relationships returned are all
      in the context of this component so any tangent relationships in sub components will be proxies. This is primarily useful when used
      from the root component because Fusion flattens the assembly structure, including tangent relationships, when manipulating
      an assembly.
    */
    readonly allTangentRelationships: TangentRelationship[]
    /**
      Returns the collection of tangent relationships associated with this component.
    */
    readonly tangentRelationships: TangentRelationships
    /**
      Gets the existing flat pattern or returns null in the case where a flat pattern doesn't exist in this component.
    */
    readonly flatPattern: FlatPattern
    /**
      Creates a flat pattern of the sheet metal folded body. The isSheetMetal property of the BRepBody object can be
      used to determine if a particular body can be flattened. Creating a flat pattern will fail if a flat pattern already exists in the
      component. You can determine if a flat pattern already exists by checking if the flatPattern property returns a FlatPattern object
      or null.
      @param stationaryFace A planar face in the sheet metal body that is on the top or bottom of the part and not an edge face. This face will
      be positioned on the X-Y plane of the flat pattern and the rest of the model will be flattened relative to this face.
      The face must exist on a body that is owned by this component.
      @returns Returns the newly created flat pattern.
    */
    createFlatPattern(stationaryFace: BRepFace): FlatPattern
    /**
      Gets and sets the active sheet metal rule. This can return null in the case where
      the component has never contained any sheet metal related data.
    */
    activeSheetMetalRule: SheetMetalRule
    /**
      Gets and sets if the light bulb of the canvas folder as seen in the browser is on or off.
      This controls the visibility of all the canvases in the component.
    */
    isCanvasFolderLightBulbOn: boolean
    /**
      Gets whether the component was created from a fasteners library item."
    */
    readonly isLibraryItem: boolean
    /**
      Returns the bounding box of the specified entity types within the component.
      @param entityTypes Bitwise value that specifies the types of entities to include in the
      calculation of the bounding box.
      @returns Returns a BoundingBox3D object if the calculation was successful and null in the case where there is no valid geometry and the bounding box is empty.
    */
    boundingBox2(entityTypes: BoundingBoxEntityTypes): core.BoundingBox3D | null
    /**
      Returns a bounding box that tightly fits around all B-Rep bodies in the component.
      All other geometry types are ignored.
    */
    readonly preciseBoundingBox: core.BoundingBox3D
    /**
      Returns an oriented bounding box that is best oriented to tightly fit all B-Rep bodies in the component.
      All other geometry types are ignored.
    */
    readonly orientedMinimumBoundingBox: core.OrientedBoundingBox3D
    /**
      Gets and sets the color associated with a component. This color is only used when the
      "Display Component Colors" command is enabled. Enabling the display of component colors
      is done through the command or API using the Application.isComponentColorsDisplayed property.
      When this is on, all bodies in a component will display using the color assigned to the component.
      Fusion randomly assigns a color to a component when it is created. This property allows you to
      get and change the assigned default color. Setting this property to null results in a new
      color being randomly assigned by Fusion. This is the equivalent of the "Cycle Component Color"
      command available in the context menu of a component.
    */
    componentColor: core.Color
    /**
      Gets and sets whether the light bulb of the decal folder, as seen in the browser, is on or off.
      This controls the visibility of all the decals in the component.
    */
    isDecalFolderLightBulbOn: boolean
    /**
      Creates a thumbnail for this component. This can be a root component to get a thumbnail that
      represents the associated file, or it can be any sub component to get a thumbnail of a subset of the
      complete assembly or individual parts.
      @param width Optional argument to define the width of the thumbnail in pixels. A default width of 256 pixels is used if no width is specified.
      @param height Optional argument to define the height of the thumbnail in pixels. A default height of 256 pixels is used if no height is specified.
      @param imageType Optional argument to define the type of image data to create. The default of PNG is used if no type is specified. Valid types
      include "PNG", "JPG", "TIF", and "BMP".
      @returns Returns a DataObject that you can use to save the thumbnail to a file or to access the binary data
      of the bitmap directly.
    */
    createThumbnail(width?: number /*int*//* = 256*/, height?: number /*int*//* = 256*/, imageType?: string/* = "PNG"*/): core.DataObject
    /**
      Returns the MFGDM model ID for this component.
      @experimental
    */
    readonly mfgdmModelId: string
    /**
      Returns the collection of assembly constraints associated with this component.
    */
    readonly assemblyConstraints: AssemblyConstraints
    /**
      Returns all assembly constraints in this component and any sub components. The assembly constraints
      returned are all in the context of this component so any joints in sub components will be proxies.
      This is primarily useful when used from the root component because Fusion flattens the assembly
      structure, including joints, when manipulating an assembly.
    */
    readonly allAssemblyConstraints: AssemblyConstraint[]
  }

  /**
    Specifies the various types of entities that can be included in bounding box calculations.
    This is a bitwise friendly enum so types can be combined to specify more than one type.
  */
  const enum BoundingBoxEntityTypes {
    /**
      Will include all types of geometry in the calculation.
    */
    AllEntitiesBoundingBoxEntityType = 0,
    /**
      Includes Solid B-Rep bodies in the bounding box calculation.
    */
    SolidBRepBodyBoundingBoxEntityType = 1,
    /**
      Includes B-Rep bodies that are not watertight (surfaces) in the
      bounding box calculation.
    */
    SurfaceBodyBoundingBoxEntityType = 2,
    /**
      Includes mesh bodies in the bounding box calculation.
    */
    MeshBodyBoundingBoxEntityType = 4,
    /**
      Includes sketch geometry in the bounding box calculation.
    */
    SketchBoundingBoxEntityType = 8,
    /**
      Includes the visible portion of construction geometry in the bounding box calculation.
    */
    ConstructionBoundingBoxEntityType = 16,
  }

  /**
    Provides a list of components.
  */
  abstract class ComponentList extends core.Base {
    /**
      Function that returns the specified component using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Component | null
    /**
      Returns the number of components in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Provides access to occurrences within a component and provides
    methods to create new occurrences.
  */
  abstract class Occurrences extends core.Base {
    /**
      Function that returns the specified occurrence using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Occurrence | null
    /**
      Returns the number of occurrences in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified occurrence using the name of the occurrence.
      @param name The name of the occurrence to return.
      @returns Returns the occurrence or null if an invalid name was specified
    */
    itemByName(name: string): Occurrence | null
    /**
      Method that creates a new occurrence using an existing component. This is the equivalent
      of copying and pasting an occurrence in the user interface.
      @param component The existing component to create a new occurrence of.
      @param transform A transform that defines the location for the new occurrence
      @returns Returns the newly created occurrence or null if the creation failed.
    */
    addExistingComponent(component: Component, transform: core.Matrix3D): Occurrence | null
    /**
      Method that creates a new component and an occurrence that references it.
      @param transform A transform that defines the location for the new occurrence.
      @returns Returns the newly created occurrence or null if the creation failed.
    */
    addNewComponent(transform: core.Matrix3D): Occurrence | null
    /**
      Returns the contents of this collection as an OccurrencesList object. This
      is useful when writing a function that traverses an assembly.
    */
    readonly asList: OccurrenceList
    /**
      Method that inserts an existing file.
      @param dataFile The dataFile to insert.
      @param transform A transform that defines the location for the new occurrence.
      @param isReferencedComponent Indicates if the insert is to be an external reference or embedded within this document.
      This method will fail if the dataFile being inserted is not from the same project as the document
      it is being inserted into while isReferencedComponent is True.
      @returns Returns the newly created occurrence or null if the insert failed.
      Insert will fail if the dataFile being inserted is not from the same project as the document
      it is being inserted into while isReferencedComponent is True.
    */
    addByInsert(dataFile: core.DataFile, transform: core.Matrix3D, isReferencedComponent: boolean): Occurrence | null
    /**
      Get the current list of all occurrences.
      The occurrences are returned in the same order as they appear in the browser.
      @returns Returns the current list of all occurrences.
    */
    asArray(): Occurrence[]
    /**
      Method that creates a new occurrence by creating a new component that is a copy of an existing
      component. This is the equivalent of copying and using the "Paste New" command in the user interface. This
      is different from the addExistingComponent in that it's not a new instance to the existing component but a
      new component is created that has it's own definition (sketches, features, etc.) and a new occurrence instance
      is created to reference this new component.
      @param component The existing component to create a copy of.
      @param transform A transform that defines the location for the new occurrence
      @returns Returns the newly created occurrence or null if the creation failed. The newly created component can be
      obtained by using the component property of the returned Occurrence.
    */
    addNewComponentCopy(component: Component, transform: core.Matrix3D): Occurrence | null
    /**
      Method that inserts a configuration from a configured design.
      The insert will fail if the configured design being used is not from the same project as the file
      it is being inserted into.
      @param configurationRow The row that specifies which configuration to use.
      @param transform A transform that defines the location for the new occurrence.
      @returns Returns the newly created occurrence or null if the add failed.
    */
    addFromConfiguration(configurationRow: ConfigurationRow, transform: core.Matrix3D): Occurrence | null
  }

  /**
    Represents an occurrence of a component at any level within a subassembly.
  */
  abstract class Occurrence extends core.Base {
    /**
      This is the sourceComponent for the occurrence and is affected
      by the assembly context.
      This is the top-level component where the path begins.
    */
    readonly sourceComponent: Component
    /**
      Returns a read only list of child occurrences where only the occurrences
      in this occurrence's AssemblyContext are returned .
    */
    readonly childOccurrences: OccurrenceList
    /**
      The component this occurrence references.
    */
    readonly component: Component
    /**
      The name of the occurrence. This is the name as seen in the browser. It is a reflection
      of the component name with an added counter suffix (i.e. 'OccurrenceName:1').
    */
    readonly name: string
    /**
      The name of the occurrence, including the full path of occurrences as seen in the browser.
      The top-level component will depend on the context but will typically be the root component
      of the design. A name for an occurrence that is at the third level of an assembly could be
      "Sub1:1+Sub2:1+PartA:1".
    */
    readonly fullPathName: string
    /**
      Read-write property that gets and sets the appearance override for this occurrence.
      This property can return null indicating there is no override appearance and that the
      contents of the occurrence are displayed using there defined appearance.
      Setting the property to null will remove any override appearance for this occurrence.
    */
    appearance: core.Appearance
    /**
      Gets and sets if the light bulb of this occurrence as displayed in the browser is on or off.
      An occurrence will only be visible if the light bulb is switched on. However,
      the light bulb can be on and the occurrence still invisible if a higher level occurrence
      in the assembly context is not visible because its light bulb is off.
    */
    isLightBulbOn: boolean
    /**
      Gets whether the occurrence is visible.
      This property is affected by the assembly context.
    */
    readonly isVisible: boolean
    /**
      Gets and sets the 3d matrix data that defines this occurrences orientation and
      position in its assembly context.
      @remarks
      This property has been retired and replaced by the transform2 property. This method
      remains and has the same behavior as before. It returns incorrect results in some cases but some
      existing programs may be relying on these bad results so this property remains unchanged. It will
      be best to use the transform2 property.
      @deprecated
    */
    transform: core.Matrix3D
    /**
      Deletes the occurrence from the design. If this is the last occurrence
      referencing a specific Component, the component is also deleted.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Returns the timeline object associated with the creation of this occurrence.
    */
    readonly timelineObject: TimelineObject
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      references the component the object is defined within.
      Returns null in the case where the object is not in the context of an assembly
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
      The return type is strongly typed for each object.
    */
    readonly nativeObject: Occurrence
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      Fails if this object is not the NativeObject.
      @param occurrence The occurrence that represents the context you want to create this proxy in.
      @returns Returns the proxy for the occurrence in the context of the specified occurrence.
      Returns null if it failed.
    */
    createForAssemblyContext(occurrence: Occurrence): Occurrence | null
    /**
      Gets and sets whether this occurrence is pinned or not.
    */
    isGrounded: boolean
    /**
      Gets and sets whether this occurrence is selectable or not.
    */
    isSelectable: boolean
    /**
      Gets and sets whether this occurrence is isolated in the UI. When an occurrence
      is isolated it is the only one visible in the user-interface. Only one occurrence
      can be isolated at a time so setting this property to true will un-isolate an occurrence
      that is currently isolated. Setting this property to false for an occurrence that is
      current isolated will un-isolate it so that no occurrence will be isolated.
    */
    isIsolated: boolean
    /**
      Gets whether this occurrence is the active edit target in the user interface.
      This is the same as checking the state of the radio button next to the occurrence in the browser.
      To activate the occurrence use the Activate method.
    */
    readonly isActive: boolean
    /**
      Makes the occurrence the active edit target in the user interface. This is the same
      as enabling the radio button next to the occurrence in the browser.
      @returns Returns true if the activation was successful.
    */
    activate(): boolean
    /**
      Moves this occurrence from it's current component into the component owned by the specified occurrence.
      This occurrence and the target occurrence must be in the same context.
      @param targetOccurrence The target occurrence defines both the component and the transform to apply when moving the occurrence. The
      occurrence will be copied into the parent component of the target occurrence and the target occurrence also defines
      the transform of how the occurrence will be copied so that the occurrence maintains it's same position in model space.
      @returns Returns the moved Occurrence or null in the case the move failed.
    */
    moveToComponent(targetOccurrence: Occurrence): Occurrence | null
    /**
      Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc
      of this occurrence. Property values will be calculated using the 'LowCalculationAccuracy' setting when using this property
      to get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method instead.
      @returns Returns a PhysicalProperties object that can be used to get the various physical property related values.
    */
    readonly physicalProperties: PhysicalProperties
    /**
      Gets if this occurrence is referencing an external component.
    */
    readonly isReferencedComponent: boolean
    /**
      Returns the bounding box of this occurrence.
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Returns the joints that affect the position of this occurrence. For example, if a joint has
      been created between this occurrence and another occurrence, this property will return that
      joint. If the occurrence is a proxy, the joints returned will also be proxies in the same
      context as the occurrence.
    */
    readonly joints: JointList
    /**
      Returns the rigid groups that this occurrence is a member of. If the occurrence is a proxy,
      the joints returned will also be proxies in the same context as the occurrence.
    */
    readonly rigidGroups: RigidGroupList
    /**
      Returns the as-built joints that affect the position of this occurrence. If the occurrence is a proxy,
      the as-built joints returned will also be proxies in the same context as the occurrence.
    */
    readonly asBuiltJoints: AsBuiltJointList
    /**
      Returns the collection of attributes associated with this face.
    */
    readonly attributes: core.Attributes
    /**
      Returns the body proxies for the B-Rep bodies in the component referenced by this occurrence.
      For example if you get the occurrences from the root component and then use this property to
      get the bodies from those occurrences, the bodies returned will return information in the context of the root
      component, not the component they actually exist in.
    */
    readonly bRepBodies: BRepBodies
    /**
      Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc
      of this occurrence.
      @param accuracy Specifies the desired level of computational accuracy of the property calculations.
      The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
      @returns Returns a PhysicalProperties object that can be used to get the various physical property related values.
    */
    getPhysicalProperties(accuracy?: CalculationAccuracy/* = CalculationAccuracy.LowCalculationAccuracy*/): PhysicalProperties
    /**
      The user can set an override opacity for components and these opacity overrides combine if
      children and parent components have overrides. This property returns the actual opacity that is
      being used to render the occurrence. To set the opacity use the opacity property of the Component object.
    */
    readonly visibleOpacity: number
    /**
      When the component this occurrence references is an external reference (the isReferencedComponent property returns true),
      this will break the link and create a local Component that this occurrence will reference. The new local Component can
      be accessed through the Occurrence using the component property.
      This method will fail if the occurrence is not referencing an external component.
      @returns Returns true if the break link was successful.
    */
    breakLink(): boolean
    /**
      Returns a token for the Occurrence object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same occurrence.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Gets and sets the 3d matrix data that defines this occurrences orientation and
      position in its assembly context. This property replaces the transform property, which
      has been retired because there are cases where it returns the incorrect results.
    */
    transform2: core.Matrix3D
    /**
      When the component this occurrence references is an external reference (the isReferencedComponent property returns true),
      this will return the object that represents that reference. Through the DocumentReference object you can modify
      the version and get other information associated with the reference.
      This property will fail if the occurrence is not referencing an external component.
    */
    readonly documentReference: core.DocumentReference
    /**
      Replaces this occurrence or all occurrences that reference the same external component with a new component.
      This method will fail if the occurrence is not referencing an external component.
      @param newFile Specifies the DataFile you want to use as the replacement. The DataFile specified
      must exist in the same hub as the parent assembly.
      @param replaceAll Indicates if you want to replace only this single occurrence or all occurrences that reference
      the same external design.
      @returns Returns true if the replacement was successful.
    */
    replace(newFile: core.DataFile, replaceAll: boolean): boolean
    /**
      Returns the bounding box of the specified entity types within the occurrence.
      @param entityTypes Bitwise value that specifies the types of entities to include in the
      calculation of the bounding box.
      @returns Returns a BoundingBox3D object if the calculation was successful and null in the case where there is no valid geometry and the bounding box is empty.
    */
    boundingBox2(entityTypes: BoundingBoxEntityTypes): core.BoundingBox3D | null
    /**
      Returns a bounding box that tightly fits around all B-Rep bodies in the occurrence.
      All other geometry types are ignored.
    */
    readonly preciseBoundingBox: core.BoundingBox3D
    /**
      Returns an oriented bounding box that is best oriented to tightly fit all B-Rep bodies in the occurrence.
      All other geometry types are ignored.
    */
    readonly orientedMinimumBoundingBox: core.OrientedBoundingBox3D
    /**
      Returns if this occurrence represents a configuration or not. If true, you can access
      the full configuration from the parent component.
    */
    readonly isConfiguration: boolean
    /**
      Changes which configuration is used for this occurrence. Use the isConfiguration property
      to determine if this occurrence references a configuration.
      @param newRow The row to switch to. This row must be from the same ConfigurationTopTable as the current row. You
      can access the table from the parent design.
      @returns Returns true if the switch was successful.
    */
    switchConfiguration(newRow: ConfigurationRow): boolean
    /**
      If this occurrence is a configuration, this property returns the row that defines it. If it isn't
      a configuration, null is returned.
    */
    readonly configurationRow: ConfigurationRow
    /**
      Returns the DataFile object that represents the specific version of the design used by this occurrence.
      From the DataFile you can access other version of the file, most importantly, you can access the latest
      version and get the top configuration table from it.
    */
    readonly configuredDataFile: core.DataFile
    /**
      Gets and sets whether this occurrence is grounded to parent or not.
    */
    isGroundToParent: boolean
    /**
      Gets and sets the initial position of the occurrence.
      Setting the initial transform is not valid for all occurrences. For instance, this operation could fail if the occurrence is created by a pattern among other cases.
      To determine if setting the initial transform is possible, use the isValidForEditInitialPosition property.
      If this property returns false, attempting to set the initial transform will result in failure.
    */
    initialTransform: core.Matrix3D
    /**
      Gets whether this occurrence is valid for edit initial position.
    */
    readonly isVaildForEditInitialPosition: boolean
    /**
      Gets the DataComponent for the target component in the source component's document.
      This only applies for Occurrence's with an assembly context whose source component
      is a top level opened design.
      @experimental
    */
    readonly dataComponent: core.DataComponent
  }

  /**
    Provides a list of occurrences.
  */
  abstract class OccurrenceList extends core.Base {
    /**
      Returns the specified occurrence using an index into the collection.
      @param index The index of the occurrence within the collection to return. The first item has an index of 0.
      @returns Returns the specified occurrence or null in the case of an invalid index.
    */
    item(index: number /*unsigned int*/): Occurrence | null
    /**
      Returns the number of occurrences in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified occurrence using the name of the occurrence.
      @param name The name of the occurrence to return.
      @returns Returns the occurrence or null if an invalid name was specified
    */
    itemByName(name: string): Occurrence | null
  }

  /**
    The collection of joints in this component. This provides access to all existing joints
    and supports the ability to create new joints.
  */
  abstract class Joints extends core.Base {
    /**
      Function that returns the specified joint using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Joint | null
    /**
      Creates a JointInput object, which is the API equivalent to the Joint command dialog. You
      you use methods and properties on the returned class to set the desired options, similar to
      providing input and setting options in the Joint command dialog. Once the settings are defined
      you call the Joints.add method passing in the JointInput object to create the actual joint.
      @param geometryOrOriginOne A JointGeometry or JointOrigin object that defines the first set of geometry of the joint.
      JointGeometry objects are created by using the various static methods on the JointGeometry class
      and JointOrigin objects are created through the JointOrigins object.
      @param geometryOrOriginTwo A JointGeometry or JointOrigin object that defines the second set of geometry of the joint.
      JointGeometry objects are created by using the various static methods on the JointGeometry class
      and JointOrigin objects are created through the JointOrigins object.
      @returns Returns the JointInput object or null if the creation failed.
    */
    createInput(geometryOrOriginOne: core.Base, geometryOrOriginTwo: core.Base): JointInput | null
    /**
      Creates a new joint.
      @param input The JointInput object that defines the geometry and various inputs that fully define a joint.
      A JointInput object is created using the Joints.createInput method.
      @returns Returns the newly created Joint or null in the case of failure.
    */
    add(input: JointInput): Joint | null
    /**
      Returns number of joints in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified joint using a name.
      @param name The name of the item within the collection to return.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): Joint | null
    /**
      Creates a joint input to define an inferred joint. Use functionality on
      the returned InferredJointInput to define the input needed to infer a joint.
      @returns Returns an InferredJointInput.
      @experimental
    */
    createInferredJointInput(): InferredJointInput
    /**
      Creates a new inferred joint.
      @param input The InferredJointInput object that defines the pairs of geometry and other settings
      that Fusion will use to infer a joint from.
      An InferredJointInput object is created using the Joints.createInferredJointInput method.
      @returns Returns the newly created Joint or fails if there is bad input.
      @experimental
    */
    addInferredJoint(input: InferredJointInput): Joint
  }

  /**
    A list of joints.
  */
  abstract class JointList extends core.Base {
    /**
      Function that returns the specified joint using an index into the list.
      @param index The index of the item within the list to return. The first item in the list has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Joint | null
    /**
      Function that returns the specified joint using a name.
      @param name The name of the item within the list to return.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): Joint | null
    /**
      Returns number of joints in the list.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A list of as-built joints.
  */
  abstract class AsBuiltJointList extends core.Base {
    /**
      Function that returns the specified as-built joint using an index into the list.
      @param index The index of the item within the list to return. The first item in the list has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): AsBuiltJoint | null
    /**
      Function that returns the specified as-built joint using a name.
      @param name The name of the item within the list to return.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): AsBuiltJoint | null
    /**
      Returns number of as-built joints in the list.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Defines all of the information required to create a new joint. This object provides
    equivalent functionality to the Joint command dialog in that it gathers the required
    information to create a joint.
  */
  abstract class JointInput extends core.Base {
    /**
      Gets and sets the first JointGeometry or JointOrigin for this joint.
    */
    geometryOrOriginOne: core.Base
    /**
      Gets and sets the second JointGeometry or JointOrigin for this joint.
    */
    geometryOrOriginTwo: core.Base
    /**
      Specifies the angle between two input geometries. This is effectively the
      angle between the two primary axes of the input geometries. When a new
      JointInput object is created, this value defaults to zero. When the joint
      is created this will become the value of the parameter that controls the joint angle.
      When using a real value to define the angle, the value is in radians. When
      using a string the expression is evaluated using the document default units for angles.
    */
    angle: core.ValueInput
    /**
      Specifies the offset between two input geometries. This is effectively the
      offset distance between the two planes defined by the primary and secondary axes
      of the input geometries. When a new JointInput object is created, this value defaults to zero.
      When the joint is created this will become the value of the parameter that controls the joint offset.
      When using a real value to define the offset, the value is in centimeters. When
      using a string the expression is evaluated using the document default units for distance.
    */
    offset: core.ValueInput
    /**
      Gets and sets if the joint direction is flipped or not. This is effectively
      specifying if the third axis of the two input geometries is facing (false) or
      opposed (true).
    */
    isFlipped: boolean
    /**
      Defines the relationship between the two joint geometries as a rigid joint.
      @returns Returns true if successful.
    */
    setAsRigidJointMotion(): boolean
    /**
      Defines the relationship between the two joint geometries as a revolute joint.
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      from.
      @returns Returns true if the operation was successful.
    */
    setAsRevoluteJointMotion(rotationAxis: JointDirections, customRotationAxisEntity?: core.Base/* = null*/): boolean
    /**
      Defines the relationship between the two joint geometries as a slider joint.
      @param sliderDirection Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the
      customSliderDirectionEntity argument must also be provided.
      @param customSliderDirectionEntity If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
      the custom slider direction. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsSliderJointMotion(sliderDirection: JointDirections, customSliderDirectionEntity?: core.Base/* = null*/): boolean
    /**
      Defines the relationship between the two joint geometries as a cylindrical joint.
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      from.
      @returns Returns true if the operation was successful.
    */
    setAsCylindricalJointMotion(rotationAxis: JointDirections, customRotationAxisEntity?: core.Base/* = null*/): boolean
    /**
      Defines the relationship between the two joint geometries as a pin-slot joint.
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param slideDirection Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the
      customSlideDirectionEntity argument must also be provided.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      @param customSlideDirectionEntity If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
      the custom slide direction. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsPinSlotJointMotion(rotationAxis: JointDirections, slideDirection: JointDirections, customRotationAxisEntity?: core.Base/* = null*/, customSlideDirectionEntity?: core.Base/* = null*/): boolean
    /**
      Defines the relationship between the two joint geometries as a planar joint.
      @param normalDirection Defines the direction of the normal of the single degree of rotation.
      This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection,
      or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
      argument must also be provided.
      @param customNormalDirectionEntity If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
      the direction of the normal. This can be several types of entities that can define a direction.
      @param customPrimarySlideDirection This arguments defines the direction of the primary slide direction. A default primary slide direction
      is automatically chosen and will be used if this argument is not provided or is null. The secondary slide
      direction is automatically inferred from the normal and primary slide directions.
      @returns Returns true if the operation was successful.
    */
    setAsPlanarJointMotion(normalDirection: JointDirections, customNormalDirectionEntity?: core.Base/* = null*/, customPrimarySlideDirection?: core.Base/* = null*/): boolean
    /**
      Defines the relationship between the two joint geometries as a ball joint.
      @param pitchDirection Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
      CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument.
      @param yawDirection Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
      CustomJointDirection is specified then you must also provide a value for the customYawDirection argument.
      @param customPitchDirection If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
      angel is measured from. This can be several types of entities that can define a direction.
      @param customYawDirection If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
      angel is measured from. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsBallJointMotion(pitchDirection: JointDirections, yawDirection: JointDirections, customPitchDirection?: core.Base/* = null*/, customYawDirection?: core.Base/* = null*/): boolean
    /**
      Returns an object derived from JointMotion that defines how the motion between the two joint geometries is defined.
    */
    readonly jointMotion: JointMotion
  }

  /**
    @experimental
  */
  abstract class InferredJointInput extends core.Base {
    /**
      Returns the collection object used to define the geometric relationships from which the joint will be inferred.
      A geometric relationship defines several things: the pair of entities, if the relationship is flipped,
      if it defines a mating alignment or an angle, and the value of the offset or angle.
    */
    readonly geometricRelationships: GeometricRelationships
  }

  /**
    A joint in a design.
  */
  abstract class Joint extends core.Base {
    /**
      Returns the parent component that owns this joint.
    */
    readonly parentComponent: Component
    /**
      Gets and sets the name of the joint.
    */
    name: string
    /**
      Gets and sets the first JointGeometry or JointOrigin for this joint.
      If the JointType is InferredJointType, this property will return null when queried and will
      fail if it set.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
    */
    geometryOrOriginOne: core.Base
    /**
      Gets and sets the second JointGeometry or JointOrigin for this joint.
      If the JointType is InferredJointType, this property will return null when queried and will
      fail if it set.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
    */
    geometryOrOriginTwo: core.Base
    /**
      Returns the parameter controlling the angle between the two input geometries. This is effectively the
      angle between the two primary axes of the two joint geometries.
      This property will return null in the case where the jointType property returns InferredJointType
    */
    readonly angle: ModelParameter
    /**
      Returns the parameter controlling the offset between the two input geometries. This is effectively the
      offset distance between the two planes defined by the primary and secondary axes
      of the input geometries or the offset along the tertiary axis (z axis) of the joint.
      This property will return null in the case where the jointType property returns InferredJointType.
    */
    readonly offset: ModelParameter
    /**
      Gets and sets if the joint direction is flipped or not. This is effectively
      specifying if the third axis of the two input geometries is facing (false) or
      opposed (true).
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
      The value of this property should be ignored in the case where the jointType property returns InferredJointType.
    */
    isFlipped: boolean
    /**
      Returns a JointMotion object that defines the motion relationship between the two geometries.
      This property will return null in the case where the jointType property returns InferredJointType.
    */
    readonly jointMotion: JointMotion
    /**
      Deletes this joint.
      @returns Returns true if the delete is successful.
    */
    deleteMe(): boolean
    /**
      Returns the timeline object associated with this joint.
    */
    readonly timelineObject: TimelineObject
    /**
      Redefines the relationship between the two joint geometries as a rigid joint.
      This method will fail in the case where the jointType property returns InferredJointType.
      To use this method, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
      @returns Returns true if successful.
    */
    setAsRigidJointMotion(): boolean
    /**
      Redefines the relationship between the two joint geometries as a revolute joint.
      This method will fail in the case where the jointType property returns InferredJointType.
      To use this method, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      from.
      @returns Returns true if the operation was successful.
    */
    setAsRevoluteJointMotion(rotationAxis: JointDirections, customRotationAxisEntity?: core.Base/* = null*/): boolean
    /**
      Redefines the relationship between the two joint geometries as a slider joint.
      This method will fail in the case where the jointType property returns InferredJointType.
      To use this method, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
      @param sliderDirection Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the
      customSliderDirectionEntity argument must also be provided.
      @param customSliderDirectionEntity If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
      the custom slider direction. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsSliderJointMotion(sliderDirection: JointDirections, customSliderDirectionEntity?: core.Base/* = null*/): boolean
    /**
      Redefines the relationship between the two joint geometries as a cylindrical joint.
      This method will fail in the case where the jointType property returns InferredJointType.
      To use this method, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      from.
      @returns Returns true if the operation was successful.
    */
    setAsCylindricalJointMotion(rotationAxis: JointDirections, customRotationAxisEntity?: core.Base/* = null*/): boolean
    /**
      Redefines the relationship between the two joint geometries as a pin-slot joint.
      This method will fail in the case where the jointType property returns InferredJointType.
      To use this method, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param slideDirection Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the
      customSlideDirectionEntity argument must also be provided.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      @param customSlideDirectionEntity If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
      the custom slide direction. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsPinSlotJointMotion(rotationAxis: JointDirections, slideDirection: JointDirections, customRotationAxisEntity?: core.Base/* = null*/, customSlideDirectionEntity?: core.Base/* = null*/): boolean
    /**
      Redefines the relationship between the two joint geometries as a planar joint.
      This method will fail in the case where the jointType property returns InferredJointType.
      To use this method, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
      @param normalDirection Defines the direction of the normal of the single degree of rotation.
      This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection,
      or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
      argument must also be provided.
      @param customNormalDirectionEntity If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
      the direction of the normal. This can be several types of entities that can define a direction.
      @param customPrimarySlideDirection This arguments defines the direction of the primary slide direction. A default primary slide direction
      is automatically chosen and will be used if this argument is not provided or is null. The secondary slide
      direction is automatically inferred from the normal and primary slide directions.
      @returns Returns true if the operation was successful.
    */
    setAsPlanarJointMotion(normalDirection: JointDirections, customNormalDirectionEntity?: core.Base/* = null*/, customPrimarySlideDirection?: core.Base/* = null*/): boolean
    /**
      Redefines the relationship between the two joint geometries as a ball joint.
      This method will fail in the case where the jointType property returns InferredJointType.
      To use this method, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
      @param pitchDirection Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
      CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument.
      @param yawDirection Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
      CustomJointDirection is specified then you must also provide a value for the customYawDirection argument.
      @param customPitchDirection If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
      angel is measured from. This can be several types of entities that can define a direction.
      @param customYawDirection If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
      angel is measured from. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsBallJointMotion(pitchDirection: JointDirections, yawDirection: JointDirections, customPitchDirection?: core.Base/* = null*/, customYawDirection?: core.Base/* = null*/): boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: Joint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): Joint | null
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      Gets and sets if this joint is suppressed.
    */
    isSuppressed: boolean
    /**
      Gets and sets if the light bulb of this joint as displayed in the browser is on or off.
      A joint will only be visible if the light bulb is switched on. However,
      the light bulb can be on and the joint still invisible if a higher level occurrence
      in the assembly context is not visible because its light bulb is off or the joints folder
      is light bulb is off.
    */
    isLightBulbOn: boolean
    /**
      Gets whether the joint is visible. To change the visibility see the isLightBulbOn property.
      This property is affected by the assembly context.
    */
    readonly isVisible: boolean
    /**
      Returns the collection of attributes associated with this joint.
    */
    readonly attributes: core.Attributes
    /**
      Returns the current health state of the joint.
    */
    readonly healthState: FeatureHealthStates
    /**
      Returns the error or warning message in the case where the healthState property returns either
      WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
    */
    readonly errorOrWarningMessage: string
    /**
      Returns the first of two occurrences that this joint defines a relationship between. This is the occurrence
      that can also be found through the geometryOrOriginOne property.
    */
    readonly occurrenceOne: Occurrence
    /**
      Returns the first of two occurrences that this joint defines a relationship between. This is the occurrence
      that can also be found through the geometryOrOriginTwo property.
    */
    readonly occurrenceTwo: Occurrence
    /**
      Gets and sets if the joint is locked.
    */
    isLocked: boolean
    /**
      Returns a token for the Joint object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same joint.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Returns the parameter controlling the offset along the primary axis (x axis) of the joint. To edit this
      value, get the parameter and use one of its properties to edit the value.
      This property will return null in the case where the jointType property returns InferredJointType.
    */
    readonly offsetX: ModelParameter
    /**
      Returns the parameter controlling the offset along the primary axis (y axis) of the joint. To edit this
      value, get the parameter and use one of its properties to edit the value.
      This property will return null in the case where the jointType property returns InferredJointType.
    */
    readonly offsetY: ModelParameter
    /**
      Returns the position and orientation of the joint geometry associated with the first occurrence.
      This is returned as a 3D matrix which provides the origin and the X, Y, and Z axis vectors of the
      coordinate system.
      This property is especially useful in cases where the JointGeometry cannot be obtained. This can
      happen when the model has been modified in a way where the geometry used to create the joint is
      no longer available.
      This property will return null in the case where the jointType property returns InferredJointType.
    */
    readonly geometryOneTransform: core.Matrix3D
    /**
      Returns the position and orientation of the joint geometry associated with the second occurrence.
      This is returned as a 3D matrix which provides the origin and the X, Y, and Z axis vectors of the
      coordinate system.
      This property is especially useful in cases where the JointGeometry cannot be obtained. This can
      happen when the model has been modified in a way where the geometry used to create the joint is
      no longer available.
      This property will return null in the case where the jointType property returns InferredJointType.
    */
    readonly geometryTwoTransform: core.Matrix3D
    /**
      Returns the set of geometric relationships that were used to infer this joint. This property is
      only valid when the jointType property returns InferredJointType. Otherwise, it returns null.
      @experimental
    */
    readonly geometricRelationships: GeometricRelationships
  }

  /**
    This object represents a set of geometry relationships. They are used when creating a new inferred
    joint or assembly constraint and querying an existing one.
  */
  abstract class GeometricRelationships extends core.Base {
    /**
      Function that returns the specified GeometricRelationship using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): GeometricRelationship | null
    /**
      Creates a GeometricRelationship object, which defines two entities that will be used to either infer
      a joint or to create an assembly constraint.
      @param entityOne Specifies the entity from the first occurrence being constrained. The entity can be a BRepFace, BRepEdge,
      BRepVertex ,SketchLine, SketchPoint, ConstructionPlane, ConstructionAxis, or ConstructionPoint object in the
      component referenced by the occurrence. It must be a proxy relative to the root component of the assembly.
      For an inferred joint, if multiple geometric relationships are created, the entities for entityOne must all
      be from the same occurrence.This is because a single joint will be inferred between the two occurrences.
      For an assembly constraint, if multiple geometric relationships are created, the entities for entityOne must
      all be from the same occurrence. This is because all the geometric relationships constrain the occurrence
      this entity is from.
      @param entityTwo Specifies the entity from the second occurrence being constrained. The entity can be a BRepFace, BRepEdge,
      BRepVertex, SketchLine, SketchPoint, ConstructionPlane, ConstructionAxis, or ConstructionPoint object in the
      component referenced by the occurrence. It must be a proxy relative to the root component of the assembly.
      For an inferred joint, if multiple geometric relationships are created, the entities for entityTwo must all
      be from the same occurrence. This is because a single joint will be inferred between the two occurrences.
      For an assembly constraint, if multiple geometric relationships are created, the entities for entityTwo must
      all be from the same occurrence. This is because all the geometric relationships constrain the occurrence
      this entity is from.
      @param isMate Specifies if this geometric relationship defines a mate or an angle between the two input entities.
      If true, it defines a mate if false, it is an angle.
      @param value Specifies the value associated with the geometric relationship. If isMate is true, the value is a length,
      and a real value in centimeters. If it is a string, it is an expression that must evaluate to a length.
      If the isMate argument is False, the value is an angle, and a real value in radians. If it is a string,
      it is an expression that must evaluate to an angle.
      @param biasPointOne This optional argument defines a position on the first entity that will be used when positioning the two
      occurrences. In the user interface, if you select two faces and create an inferred joint, the two faces
      will be used to mate the occurrences together. Still, there are infinite possibilities of how the
      occurrences can be positioned relative to one another. The location of the selection points is used
      to determine a single result, and the occurrences will be positioned so that the selection points are
      coincident. There aren't selection points in the API, but you can optionally define points that will
      be used, like the selection points. Fusion will calculate arbitrary points on the entities if the
      bias points aren't provided. The bias points are not remembered and are only used for the initial placement.
      @param biasPointTwo See the description for biasPointOne.
      @returns Returns the GeometricRelationship object or null if the creation failed.
    */
    add(entityOne: core.Base, entityTwo: core.Base, isMate: boolean, value: core.ValueInput, biasPointOne?: core.Point3D/* = null*/, biasPointTwo?: core.Point3D/* = null*/): GeometricRelationship | null
    /**
      Returns number of geometric relationships in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    This object represents a pair of entity inputs that are used when inferring a joint from geometry
    or for an assembly constraint.
  */
  abstract class GeometricRelationship extends core.Base {
    /**
      Gets and sets if this relationship is suppressed. This property is only valid when this geometric
      relationship is associated with an existing AssemblyConstraint. Otherwise, getting the value of
      this property will always return false, and setting it will be ignored.
    */
    isSuppressed: boolean
    /**
      Returns the name of the constraint as seen in the browser. This property will only return a name
      when the geometric relationship is associated with an existing AssemblyConstraint or inferred
      Joint (the isTemporary property is false). Otherwise, it will return an empty string.
    */
    readonly name: string
    /**
      Gets and sets the first entity in the relationship. The entity can be a BRepFace, BRepedge,
      BRepVertex, SketchPoint, SketchCurve, ConstructionPlane, ConstructionAxis, or ConstructionPoint object.
      If the GeometricRelationship is associated with an existing joint or assembly constraint
      (the isTemporary property is false), you need to position the timeline marker immediately
      before the joint or assembly constraint. This can be accomplished using the following code:
      thisJointOrConstraint.timelineObject.rollTo(True).
    */
    entityOne: core.Base
    /**
      Gets and sets the second entity in the relationship. The entity can be a BRepFace, BRepedge,
      BRepVertex, SketchPoint, SketchCurve, ConstructionPlane, ConstructionAxis, or ConstructionPoint object.
      If the GeometricRelationship is associated with an existing joint or assembly constraint
      (the isTemporary property is false), you need to position the timeline marker immediately
      before the joint or assembly constraint. This can be accomplished using the following code:
      thisJointOrConstraint.timelineObject.rollTo(True).
    */
    entityTwo: core.Base
    /**
      Gets and sets if the directions of the entities are aligned or opposed. The natural direction
      is for them to be opposed, and flipping them will align them.
      If the GeometricRelationship is associated with an existing joint or assembly constraint
      (the isTemporary property is false), you need to position the timeline marker immediately
      before the joint or assembly constraint. This can be accomplished using the following code:
      thisJointOrConstraint.timelineObject.rollTo(True).
    */
    isFlipped: boolean
    /**
      Gets and sets if this geometric relationships defines a mate or angle relationship between
      the two input entities. If true, it is a mate relationship.
    */
    readonly isMate: boolean
    /**
      This method redefines an existing geometric relationship by defining if it is a mate or
      angle and specifying a new value.
      If the GeometricRelationship is associated with an existing joint or assembly constraint
      (the isTemporary property is false), you need to position the timeline marker immediately
      before the joint or assembly constraint. This can be accomplished using the following code:
      thisJointOrConstraint.timelineObject.rollTo(True).
      @param isMate This argument indicates if the geometric relationship defines a mate or an angle. A value
      of true indicates a mate relationship.
      @param offsetOrAngleValue This argument specifies the value associated with the geometric relationship. If isMate
      is true, the value is a length, and if it is a real value, then it is centimeters. If it
      is a string, it is an expression that must evaluate to a length. If isMate is False,
      the value is an angle, and if it is a real value, then it is radians. If it is a string,
      it is an expression that must evaluate to an angle.
      @returns Returns true if the redefinition was successful.
    */
    redefineOffsetOrAngle(isMate: boolean, offsetOrAngleValue: core.ValueInput): boolean
    /**
      This property is used when creating a new joint or assembly constraint and defines the
      offset or angle associated with this geometric relationship. The value defaults to 0,
      but can be set with a ValueInput defining a length or angle. It can be either a real
      value, which will be in centimeters or radians, or a string, which is an expression
      whose units are length or angle.
      If the GeometricRelationship is associated with an existing joint or assembly constraint
      (the isTemporary property is false), this property will return null and fail if set. To
      get and set the value in this case you should use the offsetOrAngle property to access
      the controlling parameter.
    */
    offsetOrAngleValue: core.ValueInput
    /**
      This property is used when the geometric relationship is associated with an existing joint
      or assembly constraint (the isTemporary property is false). It returns the parameter that
      controls the offset or angle of this geometric relationship. You can change the value
      by editing properties on the returned ModelParameter object.
      If this geometric relationship is associated with a JointInput object (the isTemporary
      property is true), this property returns null, and you should use the offsetOrAngleValue
      property to get and set the value.
    */
    readonly offsetOrAngle: ModelParameter
    /**
      This method deletes this geometric relationship.
      If the isTemporary property is True, it removes it from the input object.
      If the GeometricRelationship is associated with an existing joint or assembly constraint
      (the isTemporary property is false), you need to position the timeline marker immediately
      before the joint or assembly constraint. This can be accomplished using the following code:
      thisJointOrConstraint.timelineObject.rollTo(True).
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Returns the parent AssemblyConstraint, Joint, InferredJointInput, or  AssemblyConstraintInput
      object with which this geometric relationship is associated.
    */
    readonly parent: core.Base
    /**
      Specifies if this GeometricRelationship is a child of an input object is being used to create a
      new Joint or AssemblyConstraint or is being used by an existing Joint or AssemblyConstraint.
    */
    readonly isTemporary: boolean
    /**
      This property is used to define a third vector when an angle constraint is being defined.
      This property is ignored for mate constraints.
      In some cases, when specifying entityOne and entityTwo for an angle constraint there
      is more than one solution. When the constraint is solved, entityOne and entityTwo each define
      a vector. When the reference entity is provided, the vectors need to follow the "right hand rule"
      with respect to the reference entity. This means the angle between the reference entity and the
      cross product of entityOne and entityTwo should be between 0 and 90 deg.
      The reference entity can be a planar BRepFace or a linear or circular BRepedge.
      This property can return and be set to null to indicate there is no reference entity.
    */
    angleReferenceEntity: core.Base
  }

  /**
    A transient object used to define and query the geometric input of a joint and the resulting coordinate
    system it defines. New JointGeometry objects are created using its various static create methods and
    are then used as input to the Joints.createInput method.
  */
  abstract class JointGeometry extends core.Base {
    /**
      Creates a new transient JointGeometry object based on a planar BRepFace object. A JointGeometry
      object can be used to create a joint or joint origin.
      @param face The planar BRepFace object
      @param edge A BRepEdge edge object that is one of the edges of the specified face. This argument can be
      null in the case where the keyPointType is CenterKeypoint indicating the center of the face
      is to be used. When an edge is used, the keyPointType specifies the position along the edge
      for the keypoint.
      @param keyPointType Specifies the position along the edge where the joint keypoint will be located. For open edges
      this can be StartKeyPoint, MiddleKeyPoint, or EndKeyPoint. For closed edges (i.e. circles), it
      must be CenterKeyPoint. When no edge is specified, it must be CenterKeyPoint indicating the center
      of area of the face is to be used.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createByPlanarFace(face: BRepFace, edge: BRepEdge, keyPointType: JointKeyPointTypes): JointGeometry | null
    /**
      Creates a new transient JointGeometry object based on a non-planar analytical BRepFace object. This is limited
      to cylinders, cones, spheres, and tori. A JointGeometry object can be used to create a joint or joint origin.
      @param face The cylindrical, conical, spherical, or toroidal BRepFace object.
      @param keyPointType Specifies the position relative to the input face where the joint keypoint will be located. For cylinders
      and cones this can be StartKeyPoint, MiddleKeyPoint, or EndKeyPoint. For spheres and tori this must be
      CenterKeyPoint.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createByNonPlanarFace(face: BRepFace, keyPointType: JointKeyPointTypes): JointGeometry | null
    /**
      Creates a new transient JointGeometry object based on a planar BRepFace object. A JointGeometry
      object can be used to create a joint or joint origin.
      @param profile The Profile object.
      @param sketchCurve A sketch curve that is part of the input profile. This argument can be
      null in the case where the keyPointType is CenterKeypoint indicating the center of the profile
      is to be used. When a curve is used, the keyPointType specifies the position along the curve
      for the keypoint.
      @param keyPointType Specifies the position along the curve where the joint keypoint will be located. For open curves (lines, arcs, elliptical arcs, and open splines)
      this can be StartKeyPoint, MiddleKeyPoint, or EndKeyPoint. For closed analytic (circles and ellipses), it
      must be CenterKeyPoint. When no curve is specified, it must be CenterKeyPoint indicating the center
      of area of the profile is to be used.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createByProfile(profile: Profile, sketchCurve: SketchCurve, keyPointType: JointKeyPointTypes): JointGeometry | null
    /**
      Creates a new transient JointGeometry object using a BRepEdge or SketchCurve as input. A JointGeometry
      object can be used to create a joint or joint origin.
      @param curve Input BRepEdge or SketchCurve.
      @param keyPointType The position on the curve where to position the joint coordinate system. For any open curves
      the valid types are StartKeyPoint, MiddleKeyPoint, CenterKeyPoint and EndKeyPoint. For circular and elliptical
      shaped curves the option is CenterKeyPoint. For closed spline curves either StartKeyPoint or
      EndKeyPoint can be used and the result is the same.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createByCurve(curve: core.Base, keyPointType: JointKeyPointTypes): JointGeometry | null
    /**
      Creates a new transient JointGeometry object using a ConstructionPoint, SketchPoint or BRepVertex as input.
      A JointGeometry object can be used to create a joint or joint origin.
      @param point The ConstructionPoint, SketchPoint or BRepVertex object.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createByPoint(point: core.Base): JointGeometry | null
    /**
      Returns the type of geometry this JointGeometry object represents.
    */
    readonly geometryType: JointGeometryTypes
    /**
      Returns the keypoint type this JointGeometry is using.
    */
    readonly keyPointType: JointKeyPointTypes
    /**
      The first entity that's defining this joint geometry. This can be various types of geometry depending
      on how this joint geometry is defined. The geometryType property indicates how this joint geometry is
      defined a provides a clue about the type of geometry to expect back from this property.
    */
    readonly entityOne: core.Base
    /**
      This is the second entity that defines this joint geometry. This isn't used for all joint geometry types
      and will return null in the cases where it's not used. A second geometry is used in the case where the geometryType
      property returns JointProfileGeometry, JointPlanarBRepFaceGeometry, JointBetweenTwoFacesGeometry or JointByTwoEdgeIntersectionGeometry.
    */
    readonly entityTwo: core.Base
    /**
      Returns the origin point that's been calculated for this joint geometry.
    */
    readonly origin: core.Point3D
    /**
      Returns the direction of the primary axis that's been calculated for this joint geometry.
      Conceptually, this is the Z-axis of the computed coordinate system.
    */
    readonly primaryAxisVector: core.Vector3D
    /**
      Returns the direction of the secondary axis that's been calculated for this joint geometry.
      Conceptually, this is the X-axis of the computed coordinate system.
    */
    readonly secondaryAxisVector: core.Vector3D
    /**
      Returns the direction of the third axis that's been calculated for this joint geometry.
      Conceptually, this is the Y-axis of the computed coordinate system.
    */
    readonly thirdAxisVector: core.Vector3D
    /**
      Creates a new transient JointGeometry object based on a plane bisecting the two input planes.
      @param planeOne The first planar entity that the joint origin will be created between. This can be a planar BRepFace
      or a ConstructionPlane object.
      @param planeTwo The second planar entity that the joint origin will be created between. This can be a planar BRepFace
      or a ConstructionPlane object.
      @param entityOne Specifies the entity that is used to define the keypoint. This can be many types of geometry including
      edges, planar and non-planar faces, profiles, and sketch geometry.
      @param entityTwo If the entityOne argument is a planar BRepFace or a Profile, then this argument specifies either
      an edge on the face or a sketch curve on the profile. For a planar face this argument is optional in the
      case where the keyPointType argument is CenterKeyPoint indicating the center of area of the face is to be used.
      @param keyPointType Specifies the position on the keyPointGeometry where the keypoint will be defined. This keypoint is then
      projected onto the plane to define the position of the joint geometry.
      The values that are valid for this argument depend on the type of geometry specified for the geometry and edgeOrCurve
      arguments.
      If the geometry argument is a planar face and the edgeOrCurve argument is an open BRepEdge object
      then this can be StartKeyPoint, MiddleKeyPoint, or EndKeyPoint. If the geometry argument is a planar face and the edgeOrCurve argument
      is a closed BRepEdge object (i.e. circles), it must be CenterKeyPoint. If the geometry argument is a planar face and
      the edgeOrCurve argument is null, then this must be CenterKeyPoint indicating the center of area of the face.
      If the geometry argument is a non-planar face (cylinder, cone, sphere, or torus) this can be StartKeyPoint, MiddleKeyPoint, or EndKeyPoint
      for cylinders and cones but must be CenterKeyPoint for spheres and tori. The edgeOrCurve argument is ignored in this case.
      If the geometry argument is a profile and the edgeOrCurve argument is null this can be CenterKeyPoint indicating the center of area
      of the profile. If the geometry argument is a profile and the edgeOrCurve argument is an open sketch curve on the profile
      then this can be StartKeyPoint, MiddleKeyPoint, or EndKeyPoint. If the geometry argument is a profile and the edgeOrCurve argument
      is a closed sketch curve (i.e. circles), it must be CenterKeyPoint.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createByBetweenTwoPlanes(planeOne: core.Base, planeTwo: core.Base, entityOne: core.Base, entityTwo: core.Base, keyPointType: JointKeyPointTypes): JointGeometry | null
    /**
      Returns the first plane for joint geometry that is defined between two planes. Returns null in all other cases.
    */
    readonly planeOne: core.Base
    /**
      Returns the second plane for joint geometry that is defined between two planes. Returns null in all other cases.
    */
    readonly planeTwo: core.Base
    /**
      Creates a new transient JointGeometry object that is positioned at the intersection of the two input linear BRepEdge objects.
      @param edgeOne The first linear BRepEdge object.
      @param edgeTwo The second linear BRepEdge object. This edge must exist either on the same body as edgeOne or on a body in the same component as edgeOne.
      edgeOne and edgeTwo must also both lie on the same plane and must intersect, they cannot be parallel.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createByTwoEdgeIntersection(edgeOne: fusion.BRepEdge, edgeTwo: fusion.BRepEdge): JointGeometry | null
    /**
      Creates a new transient JointGeometry object based on a cylinder or cone BRepFace object.
      @param face The cylindrical or conical BRepFace object.
      @param angle Specifies the angle relative to the parameterization of the input face. The zero, or start angle, is where the v parameter of the
      cylinder is zero. This can be determined by using the getPointAtParameter method of the SurfaceEvaluator object obtained from the
      evaluator property of the BRepFace object. The possible values can be StartJointQuadrantAngleType, QuarterJointQuadrantAngleType,
      MiddleJointQuadrantAngleType or ThirdQuarterJointQuadrantAngleType.
      @param height Specifies the vertical position relative to the bottom of the cylinder at the given angle. The possible values can be StartKeyPoint,
      MiddleKeyPoint or EndKeyPoint.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createByCylinderOrConeFace(face: BRepFace, angle: JointQuadrantAngleTypes, height: JointKeyPointTypes): JointGeometry | null
    /**
      Creates a new transient JointGeometry object based on a sphere BRepFace object.
      @param face The sphere BRepFace object.
      @param azimuthAngle Specifies the azimuth angle relative to the v parameterization of the input face. The zero, or start angle, is where the v parameter
      of the sphere is zero. This can be determined by using the getPointAtParameter method of the SurfaceEvaluator object obtained from
      the evaluator property of the BRepFace object. The possible values can be StartJointQuadrantAngleType, QuarterJointQuadrantAngleType,
      MiddleJointQuadrantAngleType or ThirdQuarterJointQuadrantAngleType.
      @param polarAngle Specifies the polar angle relative to the u parameterization of the input face. The zero, or start angle, is where the u parameter
      of the sphere is zero. This can be determined by using the getPointAtParameter method of the SurfaceEvaluator object obtained from
      the evaluator property of the BRepFace object. The possible values can be StartKeyPoint for the north pole, MiddleKeyPoint for
      points on the equator, or EndKeyPoint for the south pole.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createBySphereFace(face: BRepFace, azimuthAngle: JointQuadrantAngleTypes, polarAngle: JointKeyPointTypes): JointGeometry | null
    /**
      Creates a new transient JointGeometry object based on a torus BRepFace object.
      @param face The torus BRepFace object.
      @param azimuthAngle Specifies the azimuth angle relative to the v parameterization of the input face. The zero, or start angle, is where the v parameter
      of the sphere is zero. This can be determined by using the getPointAtParameter method of the SurfaceEvaluator object obtained from
      the evaluator property of the BRepFace object. The possible values can be StartJointQuadrantAngleType, QuarterJointQuadrantAngleType,
      MiddleJointQuadrantAngleType or ThirdQuarterJointQuadrantAngleType.
      @param sectionAngle Specifies the angle relative to the start point of the section circle at give azimuth angle. The possible values can be
      StartJointQuadrantAngleType, QuarterJointQuadrantAngleType, MiddleJointQuadrantAngleType or ThirdQuarterJointQuadrantAngleType.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createByTorusFace(face: BRepFace, azimuthAngle: JointQuadrantAngleTypes, sectionAngle: JointQuadrantAngleTypes): JointGeometry | null
    /**
      Creates a new transient JointGeometry object based on a spline BRepFace object.
      @param face The spline BRepFace object.
      @param paramU Specifies the u parameter of the input spline face where the joint keypoint will be located. The possible values
      can be StartKeyPoint, MiddleKeyPoint or EndKeyPoint.
      @param paramV Specifies the v parameter of the input spline face where the joint keypoint will be located. The possible values
      can be StartKeyPoint, MiddleKeyPoint or EndKeyPoint.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createBySplineFace(face: BRepFace, paramU: JointKeyPointTypes, paramV: JointKeyPointTypes): JointGeometry | null
    /**
      Creates a new transient JointGeometry object based on a BRepFace object as well as a BRepEdge object which is on the BRepFace.
      @param face The cylindrical, conical, spherical, toroidal or spline BRepFace object.
      @param edge A BRepEdge object that is one of the edges on the selected face.
      @param edgePointType Specifies the position along the edge where the joint keypoint will be located. The possible values depend on whether the
      edge is closed or not. For closed edge, the possible values can be StartJointTangentFaceEdgePointType,
      QuarterJointTangentFaceEdgePointType, MiddleJointTangentFaceEdgePointType or ThirdQuarterJointTangentFaceEdgePointType.
      For open edge, the possible values can be StartJointTangentFaceEdgePointType, MiddleJointTangentFaceEdgePointType,
      or EndJointTangentFaceEdgePointType.
      @returns Returns the transient JointGeometry object that can be used to create a joint or joint origin or null in the case of a failure.
    */
    static createByTangentFaceEdge(face: BRepFace, edge: BRepEdge, edgePointType: JointTangentFaceEdgePointTypes): JointGeometry | null
    /**
      Returns the tangent face type this JointGeometry is using.
    */
    readonly tangentFaceType: JointTangentFaceTypes
    /**
      Returns the first tangent face parameter.
    */
    readonly tangentFaceParamOne: number
    /**
      Returns the second tangent face parameter.
    */
    readonly tangentFaceParamTwo: number
  }

  /**
    List of the different types of ways that geometry for a joint can be defined.
  */
  const enum JointGeometryTypes {
    /**
      Joint geometry defined by a construction point.
    */
    JointConstructionPointGeometry,
    /**
      Joint geometry defined by a sketch point.
    */
    JointSketchPointGeometry,
    /**
      Joint geometry defined by a B-Rep Vertex.
    */
    JointBRepVertexGeometry,
    /**
      Joint geometry defined by a B-Rep edge.
    */
    JointBRepEdgeGeometry,
    /**
      Joint geometry defined by a sketch curve.
    */
    JointSketchCurveGeometry,
    /**
      Joint geometry defined by a profile.
    */
    JointProfileGeometry,
    /**
      Joint geometry defined by a planar B-Rep face.
    */
    JointPlanarBRepFaceGeometry,
    /**
      Joint geometry defined by a non-planar B-Rep face.
    */
    JointNonPlanarBRepFaceGeometry,
    /**
      Joint geometry defined between two planes.
    */
    JointBetweenTwoPlanesGeometry,
    /**
      Joint geometry defined by two edge intersection.
    */
    JointByTwoEdgeIntersectionGeometry,
    /**
      Joint geometry defined by tangent faces: cylinder or cone, sphere, torus and spline
    */
    JointTangentBRepFaceGeometry,
    /**
      Joint geometry defined by tangent face and edge.
    */
    JointTangentBRepFaceEdgeGeometry,
  }

  /**
    List of the various keypoints of geometry that can be used when defining joint geometry.
  */
  const enum JointKeyPointTypes {
    /**
      Specifies the position of the keypoint at the start of the entity.
    */
    StartKeyPoint,
    /**
      Specifies the position of the keypoint at the middle of the entity.
    */
    MiddleKeyPoint,
    /**
      Specifies the position of the keypoint at the end of the entity.
    */
    EndKeyPoint,
    /**
      Specifies the position of the keypoint at the center of the entity.
      This applies to entities like circles, ellipses, planar faces, and profiles.
    */
    CenterKeyPoint,
  }

  /**
    List of the various angle types of geometry that can be used when defining joint geometry
    on cylinder or cone, sphere and torus
  */
  const enum JointQuadrantAngleTypes {
    /**
      Specifies the angle at the start point of a circle
    */
    StartJointQuadrantAngleType,
    /**
      Specifies the angle at the quarter point of a circle
    */
    QuarterJointQuadrantAngleType,
    /**
      Specifies the angle at the half point of a circle
    */
    MiddleJointQuadrantAngleType,
    /**
      Specifies the angle at the third quarter point of a circle
    */
    ThirdQuarterJointQuadrantAngleType,
  }

  /**
    List of the tangent face types, including cylinder or cone, sphere, torus and spline.
  */
  const enum JointTangentFaceTypes {
    /**
      Specifies the tangent face type for cyliner or cone
    */
    NoneJointTangentFaceType,
    /**
      Specifies the tangent face type for cyliner or cone
    */
    CylinderOrConeJointTangentFaceType,
    /**
      Specifies the tangent face type for sphere
    */
    SphereJointTangentFaceType,
    /**
      Specifies the tangent face type for torus
    */
    TorusJointTangentFaceType,
    /**
      Specifies the tangent face type for spline
    */
    SplineJointTangentFaceType,
  }

  /**
    List of the tangent face types, including cylinder or cone, sphere, torus and spline.
  */
  const enum JointTangentFaceEdgePointTypes {
    /**
      Specifies the start point of the edge.
    */
    StartJointTangentFaceEdgePointType,
    /**
      Specifies the point at the quarter of whole length of the edge.
    */
    QuarterJointTangentFaceEdgePointType,
    /**
      Specifies the middle point of the edge.
    */
    MiddleJointTangentFaceEdgePointType,
    /**
      Specifies the point at third quarter of whole length of the edge.
    */
    ThirdQuarterJointTangentFaceEdgePointType,
    /**
      Specifies the end point of the edge.
    */
    EndJointTangentFaceEdgePointType,
  }

  /**
    List of the various types of joints.
  */
  const enum JointTypes {
    /**
      Specifies a rigid type of joint.
    */
    RigidJointType,
    /**
      Specifies a revolute type of joint.
    */
    RevoluteJointType,
    /**
      Specifies a slider type of joint.
    */
    SliderJointType,
    /**
      Specifies a cylindrical type of joint.
    */
    CylindricalJointType,
    /**
      Specifies a pin-slot type of joint.
    */
    PinSlotJointType,
    /**
      Specifies a planar type of joint.
    */
    PlanarJointType,
    /**
      Specifies a ball type of joint.
    */
    BallJointType,
    /**
      Specifies a joint that is inferred from the input geometry.
    */
    InferredJointType,
  }

  /**
    Specifies the different types of directions that can be used to define directions of a joint.
  */
  const enum JointDirections {
    /**
      Defines a direction in the X-axis of the joints coordinate system.
    */
    XAxisJointDirection,
    /**
      Defines a direction in the Y-axis of the joints coordinate system.
    */
    YAxisJointDirection,
    /**
      Defines a direction in the Z-axis of the joints coordinate system.
    */
    ZAxisJointDirection,
    /**
      Defines that the joint direction is custom and is defined by an entity.
    */
    CustomJointDirection,
  }

  /**
    The base class for the classes that represent all of the
    various joint types.
  */
  abstract class JointMotion extends core.Base {
    /**
      Returns an enum value indicating the type of joint this joint represents.
    */
    readonly jointType: JointTypes
  }

  /**
    Represents the set of information specific to a rigid joint. A
    rigid joint doesn't support any additional information beyond
    getting the joint type which it derives from JointMotion.
  */
  abstract class RigidJointMotion extends JointMotion {
  }

  /**
    Represents the set of information specific to a revolute joint.
  */
  abstract class RevoluteJointMotion extends JointMotion {
    /**
      Gets and sets the direction of the axis of rotation. This can be set to
      XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
      return those three directions and CustomJointDirection. If this returns
      CustomJointDirection then the customRotationAxisEntity will return an entity
      that defines the axis. If there is a custom rotation axis defined and this
      property is set to one of the three standard axes, the custom rotation will
      be removed and customRotationAxisEntity will return null.
    */
    rotationAxis: JointDirections
    /**
      Returns the direction of the rotation axis. This property will return null in the case
      where the RevolutionJointMotion object was obtained from a JointInput object.
    */
    readonly rotationAxisVector: adsk.core.Vector3D
    /**
      This property can be set using various types of entities that can infer an
      axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
      This property is only valid in the case where the rotationAxis property returns
      CustomJointDirection. Setting this property will automatically set
      the rotationAxis property to CustomJointDirection.
    */
    customRotationAxisEntity: core.Base
    /**
      Gets and sets the rotation value. This is in radians. Setting this value is
      the equivalent of using the Drive Joints command.
    */
    rotationValue: number
    /**
      Returns a JointLimits object that defines the rotation limits for this joint.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly rotationLimits: JointLimits
  }

  /**
    Represents the set of information specific to a slider joint.
  */
  abstract class SliderJointMotion extends JointMotion {
    /**
      Gets and sets the direction of the slide. This can be set to
      XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
      return those three directions and CustomJointDirection. If this returns
      CustomJointDirection then the customSlideDirectionEntity will return an entity
      that defines the direction. If there is a custom direction defined and this
      property is set to one of the three standard axes, the custom direction will
      be removed and customSlideDirectionEntity will return null.
    */
    slideDirection: JointDirections
    /**
      Returns the direction of the slide. This property will return null in the case
      where the SliderJointMotion object was obtained from a JointInput object.
    */
    readonly slideDirectionVector: adsk.core.Vector3D
    /**
      This property can be set using various types of entities that can infer a
      direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
      This property is only valid in the case where the slideDirection property returns
      CustomJointDirection. Setting this property will automatically set
      the slideDirection property to CustomJointDirection.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
    */
    customSlideDirectionEntity: core.Base
    /**
      Gets and sets the slide value. This is in centimeters. Setting this value is
      the equivalent of using the Drive Joints command.
    */
    slideValue: number
    /**
      Returns a JointLimits object that defines the slide limits for this joint.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly slideLimits: JointLimits
  }

  /**
    Represents the set of information specific to a cylindrical joint.
  */
  abstract class CylindricalJointMotion extends JointMotion {
    /**
      Gets and sets the direction of the axis of rotation. This can be set to
      XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
      return those three directions and CustomJointDirection. If this returns
      CustomJointDirection then the customRotationAxisEntity will return an entity
      that defines the axis. If there is a custom rotation axis defined and this
      property is set to one of the three standard axes, the custom rotation will
      be removed and customRotationAxisEntity will return null.
    */
    rotationAxis: JointDirections
    /**
      Returns the direction of the rotation axis. This property will return null in the case
      where the CylindricalJointMotion object was obtained from a JointInput object.
    */
    readonly rotationAxisVector: adsk.core.Vector3D
    /**
      This property can be set using various types of entities that can infer an
      axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
      This property is only valid in the case where the rotationAxis property returns
      CustomJointDirection. Setting this property will automatically set
      the rotationAxis property to CustomJointDirection.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
    */
    customRotationAxisEntity: core.Base
    /**
      Gets and sets the rotation value. This is in radians. Setting this value is
      the equivalent of using the Drive Joints command.
    */
    rotationValue: number
    /**
      Returns a JointLimits object that defines the rotation limits for this joint.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly rotationLimits: JointLimits
    /**
      Gets and sets the slide value. This is in centimeters. Setting this value is
      the equivalent of using the Drive Joints command.
    */
    slideValue: number
    /**
      Returns a JointLimits object that defines the slide limits for this joint.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly slideLimits: JointLimits
  }

  /**
    Represents the set of information specific to a pin slot joint.
  */
  abstract class PinSlotJointMotion extends JointMotion {
    /**
      Gets and sets the direction of the axis of rotation. This can be set to
      XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
      return those three directions and CustomJointDirection. If this returns
      CustomJointDirection then the customRotationAxisEntity will return an entity
      that defines the axis. If there is a custom rotation axis defined and this
      property is set to one of the three standard axes, the custom rotation will
      be removed and customRotationAxisEntity will return null.
    */
    rotationAxis: JointDirections
    /**
      Returns the direction of the rotation axis. This property will return null in the case
      where the PinSlotJointMotion object was obtained from a JointInput object.
    */
    readonly rotationAxisVector: adsk.core.Vector3D
    /**
      This property can be set using various types of entities that can infer an
      axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
      This property is only valid in the case where the rotationAxis property returns
      CustomJointDirection. Setting this property will automatically set
      the rotationAxis property to CustomJointDirection.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
    */
    customRotationAxisEntity: core.Base
    /**
      Gets and sets the rotation value. This is in radians. Setting this value is
      the equivalent of using the Drive Joints command.
    */
    rotationValue: number
    /**
      Returns a JointLimits object that defines the rotation limits for this joint.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly rotationLimits: JointLimits
    /**
      Gets and sets the direction of the slide motion in the slot. This can be set to
      XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
      return those three directions and CustomJointDirection. If this returns
      CustomJointDirection then the customSlideDirectionEntity will return an entity
      that defines the direction. If there is a custom direction defined and this
      property is set to one of the three standard axes, the custom direction will
      be removed and customSlideDirectionEntity will return null.
    */
    slideDirection: JointDirections
    /**
      Returns the direction of the primary slide direction. This property will return null in the case
      where the PinSlotJointMotion object was obtained from a JointInput object.
    */
    readonly slideDirectionVector: adsk.core.Vector3D
    /**
      This property can be set using various types of entities that can infer a
      direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
      This property is only valid in the case where the slideDirection property returns
      CustomJointDirection. Setting this property will automatically set
      the slideDirection property to CustomJointDirection.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
    */
    customSlideDirectionEntity: core.Base
    /**
      Gets and sets the slide value. This is in centimeters. Setting this value is
      the equivalent of using the Drive Joints command.
    */
    slideValue: number
    /**
      Returns a JointLimits object that defines the slide limits for this joint.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly slideLimits: JointLimits
  }

  /**
    Represents the set of information specific to a planar joint.
  */
  abstract class PlanarJointMotion extends JointMotion {
    /**
      Gets and sets the direction of the normal of the single degree of rotation.
      This can be set to XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection.
      It can return those three directions and CustomJointDirection. If this returns
      CustomJointDirection then the customNormalDirectionEntity will return an entity
      that defines the direction. If there is a custom direction defined and this
      property is set to one of the three standard axes, the custom direction will
      be removed and customNormalDirectionEntity will return null.
    */
    normalDirection: JointDirections
    /**
      Returns the direction of the normal direction. This property will return null in the case
      where the PlanarJointMotion object was obtained from a JointInput object.
    */
    readonly normalDirectionVector: adsk.core.Vector3D
    /**
      This property defines a custom normal direction and can be set using various types
      of entities that can infer a direction. For example, a linear edge, sketch line,
      planar face, and cylindrical face.This property is only valid in the case where the
      normalDirection property returns CustomJointDirection. Setting this property will
      automatically set the normalDirection property to CustomJointDirection.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
    */
    customNormalDirectionEntity: core.Base
    /**
      Gets the direction used as the primary direction for the two translational degrees of
      freedom. The value of this property is automatically set when setting the normalDirection.
      When reading this value it can return XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection,
      or CustomJointDirection. If it's CustomJointDirection then the direction the direction can be
      determined using the primarySlideDirectionVector and the entity controlling the direction can
      be get and set using the customPrimarySlideDirectionEntity.
    */
    readonly primarySlideDirection: JointDirections
    /**
      Returns the direction of the primary slide direction. This property will return null in the case
      where the PlanarJointMotion object was obtained from a JointInput object.
    */
    readonly primarySlideDirectionVector: adsk.core.Vector3D
    /**
      This property can be set using various types of entities that can infer a
      direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
      When reading this property, it is only valid in the case where the primarySlideDirection property returns
      CustomJointDirection. Setting this property will automatically set the primarySlideDirection property to
      CustomJointDirection. The entity defining the custom direction by be perpendicular to the normal direction.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
    */
    customPrimarySlideDirectionEntity: core.Base
    /**
      Returns the direction of the secondary slide direction. This property will return null in the case
      where the PlanarJointMotion object was obtained from a JointInput object.
    */
    readonly secondarySlideDirectionVector: adsk.core.Vector3D
    /**
      Gets and sets the rotation value. This is in radians. Setting this value is
      the equivalent of using the Drive Joints command.
    */
    rotationValue: number
    /**
      Returns a JointLimits object that defines the limits of rotation for this joint.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly rotationLimits: JointLimits
    /**
      Gets and sets the offset value in the primary direction. This is in centimeters.
      Setting this value is the equivalent of using the Drive Joints command.
    */
    primarySlideValue: number
    /**
      Returns a JointLimits object that defines the limits in the primary direction for this joint.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly primarySlideLimits: JointLimits
    /**
      Gets and sets the offset value in the secondary direction. This is in centimeters.
      Setting this value is the equivalent of using the Drive Joints command.
    */
    secondarySlideValue: number
    /**
      Returns a JointLimits object that defines the limits in the secondary direction for this joint.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly secondarySlideLimits: JointLimits
  }

  /**
    Represents the set of information specific to a ball joint.
  */
  abstract class BallJointMotion extends JointMotion {
    /**
      Gets and sets the direction that the pitch is measured from.
      This can only be set to ZAxisJointDirection and can return ZAxisJointDirection
      or CustomJointDirection. If this returns CustomJointDirection then the
      customNormalDirectionEntity will return an entity that defines the direction.
      If there is a custom direction defined and this property is set to ZAxisJointDirection,
      the custom direction will be removed and customNormalDirectionEntity will return null.
    */
    pitchDirection: JointDirections
    /**
      This property defines a custom pitch direction and can be set using various types
      of entities that can infer a direction. For example, a linear edge, sketch line,
      planar face, and cylindrical face.This property is only valid in the case where the
      pitchDirection property returns CustomJointDirection. Setting this property will
      automatically set the pitchDirection property to CustomJointDirection.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
    */
    customPitchDirectionEntity: core.Base
    /**
      Returns the direction that the pitch angle is measured from. This property will return null in the case
      where the BallJointMotion object was obtained from a JointInput object.
    */
    readonly pitchDirectionVector: core.Vector3D
    /**
      Gets and sets the direction that the pitch is measured from.
      This can only be set to XAxisJointDirection and can return XAxisJointDirection
      or CustomJointDirection. If this returns CustomJointDirection then the
      customYawDirectionEntity will return an entity that defines the direction.
      If there is a custom direction defined and this property is set to XAxisJointDirection,
      the custom direction will be removed and customYawDirectionEntity will return null.
    */
    yawDirection: JointDirections
    /**
      This property defines a custom yaw direction and can be set using various types
      of entities that can infer a direction. For example, a linear edge, sketch line,
      planar face, and cylindrical face.This property is only valid in the case where the
      yawDirection property returns CustomJointDirection. Setting this property will
      automatically set the yawDirection property to CustomJointDirection.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: thisJoint.timelineObject.rollTo(True)
    */
    customYawDirectionEntity: core.Base
    /**
      Returns the direction that the yaw angle is measured from. This property will return null in the case
      where the BallJointMotion object was obtained from a JointInput object.
    */
    readonly yawDirectionVector: core.Vector3D
    /**
      Returns the direction that the roll angle is measured from. This property will return null in the case
      where the BallJointMotion object was obtained from a JointInput object.
    */
    readonly rollDirectionVector: core.Vector3D
    /**
      Gets and sets the pitch value. This is in radians. Setting this value is
      the equivalent of using the Drive Joints command.
    */
    pitchValue: number
    /**
      Returns a JointLimits object that defines the limits of rotation for the pitch.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly pitchLimits: JointLimits
    /**
      Gets and sets the yaw value. This is in radians. Setting this value is
      the equivalent of using the Drive Joints command.
    */
    yawValue: number
    /**
      Returns a JointLimits object that defines the limits of rotation for the yaw.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly yawLimits: JointLimits
    /**
      Gets and sets the roll value. This is in radians. Setting this value is
      the equivalent of using the Drive Joints command.
    */
    rollValue: number
    /**
      Returns a JointLimits object that defines the limits of rotation for the roll.
      Use the functionality of the returned JointLimits object to get, set, and modify
      the joint limits.
    */
    readonly rollLimits: JointLimits
  }

  /**
    Used to define limits for the range of motion of a joint.
  */
  abstract class JointLimits extends core.Base {
    /**
      The minimum value of the value. This is in either centimeters
      or radians depending on if the joint value this is associated with
      defines a distance or an angle.
    */
    minimumValue: number
    /**
      The maximum value of the value. This is in either centimeters
      or radians depending on if the joint value this is associated with
      defines a distance or an angle.
    */
    maximumValue: number
    /**
      The resting state value. This is in either centimeters
      or radians depending on if the joint value this is associated with
      defines a distance or an angle.
    */
    restValue: number
    /**
      Gets and sets whether the minimum joint limit is enabled or not.
    */
    isMinimumValueEnabled: boolean
    /**
      Gets and sets whether the maximum joint limit is enabled or not.
    */
    isMaximumValueEnabled: boolean
    /**
      Gets and sets whether the resting joint value is enabled or not.
    */
    isRestValueEnabled: boolean
  }

  /**
    The collection of assembly constraints in this component. This provides access to all existing
    assembly constraints and supports the ability to create new assembly constraints.
  */
  abstract class AssemblyConstraints extends core.Base {
    /**
      Function that returns the specified assembly constraint using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): AssemblyConstraint | null
    /**
      Function that returns the specified assembly constraint object using a name.
      @param name The name of the item within the collection to return.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): AssemblyConstraint | null
    /**
      Returns the number of assembly constraint objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates an assembly constraint input to define an assembly constraint. Use functionality
      on the returned AssemblyConstraintInput to define the input needed to create an assembly constraint.
      @returns Returns an AssemblyConstraintInput.
    */
    createInput(): AssemblyConstraintInput
    /**
      Creates a new assembly constraint.
      @param input The AssemblyConstraintInput object that defines the geometry and various inputs that define an
      assembly constraint. An AssemblyConstraintInput object is created using
      the AssemblyConstraints.createInput method.
      @returns Returns the newly created AssemblyConstraint or null in the case of failure.
    */
    add(input: AssemblyConstraintInput): AssemblyConstraint | null
  }

  /**
    Defines all of the information required to create a new assembly constraint. This object provides
    equivalent functionality to the Assembly Relationships command dialog in that it gathers the required
    information to create an assembly constraint.
  */
  abstract class AssemblyConstraintInput extends core.Base {
    /**
      Returns the collection object used to define the geometric relationships that
      the constraints will be inferred from. A geometric relationship defines a pair of entities,
      if the relationships is flipped, and the offset or angle value.
    */
    readonly geometricRelationships: GeometricRelationships
  }

  /**
    Represents an assembly constraint.
  */
  abstract class AssemblyConstraint extends core.Base {
    /**
      Gets and sets the name of the assembly constraint. This is the name seen in the browser and timeline.
    */
    name: string
    /**
      Returns the set of geometric relationships used for this assembly constraint.
    */
    readonly geometricRelationships: GeometricRelationships
    /**
      Returns the parent component that owns this assembly constraint.
    */
    readonly parentComponent: Component
    /**
      Deletes this assembly constraint.
      @returns Returns true if the delete is successful.
    */
    deleteMe(): boolean
    /**
      Returns the timeline object associated with this assembly constraint.
    */
    readonly timelineObject: TimelineObject
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: AssemblyConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): AssemblyConstraint | null
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      Gets and sets if this assembly constraint is suppressed. If suppressed,
      all of the assembly constraints within the  will be suppressed.
    */
    isSuppressed: boolean
    /**
      Returns the collection of attributes associated with this assembly constraint.
    */
    readonly attributes: core.Attributes
    /**
      Returns the current health state of the assembly constraint.
    */
    readonly healthState: FeatureHealthStates
    /**
      Returns the error or warning message in the case where the healthState property returns either
      WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
    */
    readonly errorOrWarningMessage: string
    /**
      Returns a token for the assembly constraint object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same assembly constraint.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Gets and sets if the light bulb of this assembly constraint, as displayed in the browser, is on or off.
      An assembly constraint will only be visible if the light bulb is switched on. However,
      the light bulb can be on and the assembly constraint still invisible if a higher level occurrence
      in the assembly context is not visible because its light bulb is off or the light bulb of the parent Joints
      folder is off.
    */
    isLightBulbOn: boolean
    /**
      Gets whether the assembly constraint is visible. To change the visibility see the isLightBulbOn property.
      This property is affected by the assembly context.
    */
    readonly isVisible: boolean
  }

  /**
    The collection of as-built joints in this component. This provides access to all existing
    as-built joints and supports the ability to create new as-built joints.
  */
  abstract class AsBuiltJoints extends core.Base {
    /**
      Function that returns the specified as-built joint using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): AsBuiltJoint | null
    /**
      Function that returns the specified as-built joint using a name.
      @param name The name of the item within the collection to return.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): AsBuiltJoint | null
    /**
      Returns number of joint origins in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates an AsBuiltJointInput object which is used to collect all of the information needed
      to create an as-built joint. This object is equivalent to the as-built joint dialog in the
      user-interface in that it doesn't represent an actual joint but just the information needed
      to create an as-built joint. Once this is fully defined the add method can be called, passing
      this object in to create the actual joint.
      @param occurrenceOne Specifies the first of two occurrences the joint is between.
      @param occurrenceTwo Specifies the second of two occurrences the joint is between.
      @param geometry Specifies the geometry of where the joint will be positioned. If the as-built joint is
      a rigid joint, this argument should be null because no geometry is needed.
      @returns Returns the new AsBuiltJointInput object or null in the case of failure.
    */
    createInput(occurrenceOne: Occurrence, occurrenceTwo: Occurrence, geometry: JointGeometry): AsBuiltJointInput | null
    /**
      Creates a new as-built joint.
      @param input An AsBuiltJointInput object that was created using the AsBuiltJoints.createInput method and then fully defined
      using the properties and methods on the AsBuiltJointInput object.
      @returns Returns the new AsBuiltJoint object or null in the case of failure.
    */
    add(input: AsBuiltJointInput): AsBuiltJoint | null
  }

  /**
    Represent an as-built joint.
  */
  abstract class AsBuiltJoint extends core.Base {
    /**
      Returns the parent component that owns this AsBuiltJoint.
    */
    readonly parentComponent: Component
    /**
      The name of the as-built joint as it is displayed in the timeline and the browser. The
      name can be changed.
    */
    name: string
    /**
      Specifies the first of two occurrences the joint is between.
    */
    readonly occurrenceOne: Occurrence
    /**
      Specifies the second of two occurrences the joint is between.
    */
    readonly occurrenceTwo: Occurrence
    /**
      Specifies the position of the joint. Getting this property will return null and
      setting it will be ignored in the case where the joint motion is rigid.
      To set this property, you need to position the timeline marker to immediately before this as-built joint.
      This can be accomplished using the following code: thisAsBuiltJoint.timelineObject.rollTo(True)
    */
    geometry: JointGeometry
    /**
      Deletes this as-built joint.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Returns the timeline object associated with this as-built joint.
    */
    readonly timelineObject: TimelineObject
    /**
      Returns a JointMotion object that defines the motion relationship between the two geometries.
    */
    readonly jointMotion: JointMotion
    /**
      Redefines the relationship between the two joint geometries as a rigid joint.
      To use this method, you need to position the timeline marker to immediately before this as-built joint.
      This can be accomplished using the following code: thisAsBuiltJoint.timelineObject.rollTo(True)
      @returns Returns true if successful.
    */
    setAsRigidJointMotion(): boolean
    /**
      Redefines the relationship between the two joint geometries as a revolute joint.
      To use this method, you need to position the timeline marker to immediately before this as-built joint.
      This can be accomplished using the following code: thisAsBuiltJoint.timelineObject.rollTo(True)
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param geometry Redefines the joint geometry. If not provided, the existing geometry is used. This argument is
      required if the current joint motion is rigid.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      from.
      @returns Returns true if the operation was successful.
    */
    setAsRevoluteJointMotion(rotationAxis: JointDirections, geometry?: JointGeometry/* = null*/, customRotationAxisEntity?: core.Base/* = null*/): boolean
    /**
      Redefines the relationship between the two joint geometries as a slider joint.
      To use this method, you need to position the timeline marker to immediately before this as-built joint.
      This can be accomplished using the following code: thisAsBuiltJoint.timelineObject.rollTo(True)
      @param sliderDirection Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the
      customSliderDirectionEntity argument must also be provided.
      @param geometry Redefines the joint geometry. If not provided, the existing geometry is used. This argument is
      required if the current joint motion is rigid.
      @param customSliderDirectionEntity If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
      the custom slider direction. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsSliderJointMotion(sliderDirection: JointDirections, geometry?: JointGeometry/* = null*/, customSliderDirectionEntity?: core.Base/* = null*/): boolean
    /**
      Redefines the relationship between the two joint geometries as a cylindrical joint.
      To use this method, you need to position the timeline marker to immediately before this as-built joint.
      This can be accomplished using the following code: thisAsBuiltJoint.timelineObject.rollTo(True)
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param geometry Redefines the joint geometry. If not provided, the existing geometry is used. This argument is
      required if the current joint motion is rigid.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      from.
      @returns Returns true if the operation was successful.
    */
    setAsCylindricalJointMotion(rotationAxis: JointDirections, geometry?: JointGeometry/* = null*/, customRotationAxisEntity?: core.Base/* = null*/): boolean
    /**
      Redefines the relationship between the two joint geometries as a pin-slot joint.
      To use this method, you need to position the timeline marker to immediately before this as-built joint.
      This can be accomplished using the following code: thisAsBuiltJoint.timelineObject.rollTo(True)
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param slideDirection Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the
      customSlideDirectionEntity argument must also be provided.
      @param geometry Redefines the joint geometry. If not provided, the existing geometry is used. This argument is
      required if the current joint motion is rigid.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      @param customSlideDirectionEntity If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
      the custom slide direction. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsPinSlotJointMotion(rotationAxis: JointDirections, slideDirection: JointDirections, geometry?: JointGeometry/* = null*/, customRotationAxisEntity?: core.Base/* = null*/, customSlideDirectionEntity?: core.Base/* = null*/): boolean
    /**
      Redefines the relationship between the two joint geometries as a planar joint.
      To use this method, you need to position the timeline marker to immediately before this as-built joint.
      This can be accomplished using the following code: thisAsBuiltJoint.timelineObject.rollTo(True)
      @param normalDirection Defines the direction of the normal of the single degree of rotation.
      This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection,
      or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
      argument must also be provided.
      @param geometry Redefines the joint geometry. If not provided, the existing geometry is used. This argument is
      required if the current joint motion is rigid.
      @param customNormalDirectionEntity If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
      the direction of the normal. This can be several types of entities that can define a direction.
      @param customPrimarySlideDirection This arguments defines the direction of the primary slide direction. A default primary slide direction
      is automatically chosen and will be used if this argument is not provided or is null. The secondary slide
      direction is automatically inferred from the normal and primary slide directions.
      @returns Returns true if the operation was successful.
    */
    setAsPlanarJointMotion(normalDirection: JointDirections, geometry?: JointGeometry/* = null*/, customNormalDirectionEntity?: core.Base/* = null*/, customPrimarySlideDirection?: core.Base/* = null*/): boolean
    /**
      Redefines the relationship between the two joint geometries as a ball joint.
      To use this method, you need to position the timeline marker to immediately before this as-built joint.
      This can be accomplished using the following code: thisAsBuiltJoint.timelineObject.rollTo(True)
      @param pitchDirection Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
      CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument.
      @param yawDirection Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
      CustomJointDirection is specified then you must also provide a value for the customYawDirection argument.
      @param geometry Redefines the joint geometry. If not provided, the existing geometry is used. This argument is
      required if the current joint motion is rigid.
      @param customPitchDirection If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
      angel is measured from. This can be several types of entities that can define a direction.
      @param customYawDirection If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
      angel is measured from. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsBallJointMotion(pitchDirection: JointDirections, yawDirection: JointDirections, geometry?: JointGeometry/* = null*/, customPitchDirection?: core.Base/* = null*/, customYawDirection?: core.Base/* = null*/): boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: AsBuiltJoint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): AsBuiltJoint | null
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      Gets and sets if this as-built joint is suppressed.
    */
    isSuppressed: boolean
    /**
      Gets and sets if the light bulb of this as-built joint as displayed in the browser is on or off.
      A joint will only be visible if the light bulb is switched on. However,
      the light bulb can be on and the joint still invisible if a higher level occurrence
      in the assembly context is not visible because its light bulb is off or the joints folder
      is light bulb is off.
    */
    isLightBulbOn: boolean
    /**
      Gets whether the as-built joint is visible. To change the visibility see the isLightBulbOn property.
      This property is affected by the assembly context.
    */
    readonly isVisible: boolean
    /**
      Returns the collection of attributes associated with this as-built joint.
    */
    readonly attributes: core.Attributes
    /**
      Returns a token for the AsBuiltJoint object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same as-built joint.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Returns the position and orientation of the joint geometry associated with this as-built joint.
      This is returned as a 3D matrix which provides the origin and the X, Y, and Z axis vectors of the
      coordinate system.
      This property is especially useful in cases where the JointGeometry cannot be obtained. This can
      happen when the model has been modified in a way where the geometry used to create the joint is
      no longer available.
    */
    readonly transform: core.Matrix3D
  }

  /**
    Defines all of the information needed to create an as-built joint.
  */
  abstract class AsBuiltJointInput extends core.Base {
    /**
      Specifies the first of two occurrences the joint is between.
    */
    occurrenceOne: Occurrence
    /**
      Specifies the second of two occurrences the joint is between.
    */
    occurrenceTwo: Occurrence
    /**
      Specifies the position of the joint.
    */
    geometry: JointGeometry
    /**
      Defines the relationship between the two joint geometries as a rigid joint.
      @returns Returns true if successful.
    */
    setAsRigidJointMotion(): boolean
    /**
      Defines the relationship between the two joint geometries as a revolute joint.
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      from.
      @returns Returns true if the operation was successful.
    */
    setAsRevoluteJointMotion(rotationAxis: JointDirections, customRotationAxisEntity?: core.Base/* = null*/): boolean
    /**
      Defines the relationship between the two joint geometries as a slider joint.
      @param sliderDirection Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the
      customSliderDirectionEntity argument must also be provided.
      @param customSliderDirectionEntity If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
      the custom slider direction. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsSliderJointMotion(sliderDirection: JointDirections, customSliderDirectionEntity?: core.Base/* = null*/): boolean
    /**
      Defines the relationship between the two joint geometries as a cylindrical joint.
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      from.
      @returns Returns true if the operation was successful.
    */
    setAsCylindricalJointMotion(rotationAxis: JointDirections, customRotationAxisEntity?: core.Base/* = null*/): boolean
    /**
      Defines the relationship between the two joint geometries as a pin-slot joint.
      @param rotationAxis Specifies which axis the rotation is around. If this is set to CustomJointDirection then the
      customRotationAxisEntity argument must also be provided.
      @param slideDirection Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the
      customSlideDirectionEntity argument must also be provided.
      @param customRotationAxisEntity If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
      the custom axis of rotation. This can be several types of entities that an axis can be derived
      @param customSlideDirectionEntity If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
      the custom slide direction. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsPinSlotJointMotion(rotationAxis: JointDirections, slideDirection: JointDirections, customRotationAxisEntity?: core.Base/* = null*/, customSlideDirectionEntity?: core.Base/* = null*/): boolean
    /**
      Defines the relationship between the two joint geometries as a planar joint.
      @param normalDirection Defines the direction of the normal of the single degree of rotation.
      This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection,
      or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
      argument must also be provided.
      @param customNormalDirectionEntity If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
      the direction of the normal. This can be several types of entities that can define a direction.
      @param customPrimarySlideDirection This arguments defines the direction of the primary slide direction. A default primary slide direction
      is automatically chosen and will be used if this argument is not provided or is null. The secondary slide
      direction is automatically inferred from the normal and primary slide directions.
      @returns Returns true if the operation was successful.
    */
    setAsPlanarJointMotion(normalDirection: JointDirections, customNormalDirectionEntity?: core.Base/* = null*/, customPrimarySlideDirection?: core.Base/* = null*/): boolean
    /**
      Defines the relationship between the two joint geometries as a ball joint.
      @param pitchDirection Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
      CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument.
      @param yawDirection Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
      CustomJointDirection is specified then you must also provide a value for the customYawDirection argument.
      @param customPitchDirection If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
      angel is measured from. This can be several types of entities that can define a direction.
      @param customYawDirection If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
      angel is measured from. This can be several types of entities that can define a direction.
      @returns Returns true if the operation was successful.
    */
    setAsBallJointMotion(pitchDirection: JointDirections, yawDirection: JointDirections, customPitchDirection?: core.Base/* = null*/, customYawDirection?: core.Base/* = null*/): boolean
    /**
      Returns one of the objects derived from JointMotion that defines how the motion between
      the two joint geometries is defined. Can be null if the motion hasn't yet been defined.
    */
    readonly jointMotion: JointMotion
  }

  /**
    The collection of joint origins in this component. This provides access to all existing
    joint origins and supports the ability to create new joint origins.
  */
  abstract class JointOrigins extends core.Base {
    /**
      Function that returns the specified joint origin using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): JointOrigin | null
    /**
      Function that returns the specified joint origin using a name.
      @param name The name of the item within the collection to return.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): JointOrigin | null
    /**
      Returns number of joint origins in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a JointOriginInput object which is used to collect all of the information
      needed to create a simple joint origin. The creation of the input object takes the required
      input as the geometry argument and you can optionally use methods and properties on the created
      JointOriginInput to set other optional settings. The JointOrigin is created by calling the add
      method of the JointOrigins object and passing it the JointOriginInput object.
      @param geometry A JointGeometry object that defines the geometry the joint origin will be created on.
      @returns Returns a JointOriginInput object if successfully created and null if it fails.
    */
    createInput(geometry: JointGeometry): JointOriginInput | null
    /**
      Create a new joint origin.
      @param input A JointOriginInput object that full defines all of the information needed to create a joint origin.
      You create a JointOriginInput by using the createInput method of the JointOrigins object.
      @returns Returns a JointOrigin object if successfully created and null if it fails.
    */
    add(input: JointOriginInput): JointOrigin | null
  }

  /**
    A list of joint origins.
  */
  abstract class JointOriginList extends core.Base {
    /**
      Function that returns the specified joint origin using an index into the list.
      @param index The index of the item within the list to return. The first item in the list has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): JointOrigin | null
    /**
      Function that returns the specified joint origin using a name.
      @param name The name of the item within the list to return.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): JointOrigin | null
    /**
      Returns number of joint origins in the list.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents an existing joint origin in a design.
  */
  abstract class JointOrigin extends core.Base {
    /**
      Returns the parent component that owns this joint origin.
    */
    readonly parentComponent: Component
    /**
      Gets and sets the name of this joint origin. This is the name seen by the user in the timeline.
    */
    name: string
    /**
      Gets and sets the joint geometry for this joint origin input. This
      defines the location of the joint origin.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: joint.timelineObject.rollTo(True)
    */
    geometry: JointGeometry
    /**
      Gets the parameter that controls the angle. The value can be changed
      using the functionality of the returned ModelParameter object.
    */
    readonly angle: ModelParameter
    /**
      Gets the parameter that controls the X offset direction. The value can be changed
      using the functionality of the returned ModelParameter object.
    */
    readonly offsetX: ModelParameter
    /**
      Gets the parameter that controls the Y offset direction. The value can be changed
      using the functionality of the returned ModelParameter object.
    */
    readonly offsetY: ModelParameter
    /**
      Gets the parameter that controls the Z offset direction. The value can be changed
      using the functionality of the returned ModelParameter object.
    */
    readonly offsetZ: ModelParameter
    /**
      Gets and sets if the joint origin direction is flipped or not.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: joint.timelineObject.rollTo(True)
    */
    isFlipped: boolean
    /**
      Gets and sets the entity that defines the X axis direction. This defaults
      to null meaning the X axis is inferred from the input geometry.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: joint.timelineObject.rollTo(True)
    */
    xAxisEntity: core.Base
    /**
      Gets and sets the entity that defines the Z axis direction. This defaults
      to null meaning the Z axis is inferred from the input geometry.
      To set this property, you need to position the timeline marker to immediately before this joint.
      This can be accomplished using the following code: joint.timelineObject.rollTo(True)
    */
    zAxisEntity: core.Base
    /**
      Returns the direction of the primary axis that's been calculated for this joint origin. This
      is conceptually the Z axis as shown by the triad representing the joint origin.
    */
    readonly primaryAxisVector: core.Vector3D
    /**
      Returns the direction of the secondary axis that's been calculated for this joint origin. This
      is conceptually the X axis as shown by the triad representing the joint origin.
    */
    readonly secondaryAxisVector: core.Vector3D
    /**
      Returns the direction of the third axis that's been calculated for this joint origin. This
      is conceptually the Y axis as shown by the triad representing the joint origin.
    */
    readonly thirdAxisVector: core.Vector3D
    /**
      Deletes this joint origin.
      @returns Returns true if successful.
    */
    deleteMe(): boolean
    /**
      Returns the timeline object associated with this joint origin.
    */
    readonly timelineObject: TimelineObject
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: JointOrigin
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): JointOrigin | null
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      Returns the collection of attributes associated with this joint origin.
    */
    readonly attributes: core.Attributes
    /**
      Returns a token for the JointOrigin object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same joint origin.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Gets and sets if the light bulb of this jointOrigin as displayed in the browser is on or off.
      A joint origin will only be visible if the light bulb is switched on. However,
      the light bulb can be on and the joint origin still invisible if a higher level occurrence
      in the assembly context is not visible because its light bulb is off or the joint origins folder
      light bulb is off.
    */
    isLightBulbOn: boolean
    /**
      Returns the position and orientation of the joint geometry associated with this joint origin.
      This is returned as a 3D matrix which provides the origin and the X, Y, and Z axis vectors of the
      coordinate system.
      This property is especially useful in cases where the JointGeometry cannot be obtained. This can
      happen when the model has been modified in a way where the geometry used to create the joint is
      no longer available.
    */
    readonly transform: core.Matrix3D
  }

  /**
    Defines all of the information required to create a new joint origin. This object provides
    equivalent functionality to the Joint Origin command dialog in that it gathers the required
    information to create a joint origin.
  */
  abstract class JointOriginInput extends core.Base {
    /**
      Gets and sets the joint geometry for this joint origin input. This
      defines the location of the joint origin.
    */
    geometry: JointGeometry
    /**
      Gets and sets the value that defines the angle for the joint origin. This defaults to zero
      if it's not specified. The value defines an angle and if the ValueInput is defined using
      the createByReal method the value is assumed to be radians.
    */
    angle: core.ValueInput
    /**
      Gets and sets the value that defines the X offset direction. This defaults to zero
      if it's not specified. The value defines a distance and if the ValueInput is defined using
      the createByReal method the value is assumed to be centimeters.
    */
    offsetX: core.ValueInput
    /**
      Gets and sets the value that defines the Y offset direction. This defaults to zero
      if it's not specified. The value defines a distance and if the ValueInput is defined using
      the createByReal method the value is assumed to be centimeters.
    */
    offsetY: core.ValueInput
    /**
      Gets and sets the value that defines the Z offset direction. This defaults to zero
      if it's not specified. The value defines a distance and if the ValueInput is defined using
      the createByReal method the value is assumed to be centimeters.
    */
    offsetZ: core.ValueInput
    /**
      Gets and sets if the joint origin direction is flipped or not.
    */
    isFlipped: boolean
    /**
      Gets and sets the entity that defines the X axis direction. This defaults
      to null meaning the X axis is inferred from the input geometry.
    */
    xAxisEntity: core.Base
    /**
      Gets and sets the entity that defines the Z axis direction. This defaults
      to null meaning the Z axis is inferred from the input geometry.
    */
    zAxisEntity: core.Base
    /**
      Returns the direction of the primary axis that's been calculated for this joint origin. This
      is conceptually the Z axis as shown by the triad representing the joint origin.
    */
    readonly primaryAxisVector: core.Vector3D
    /**
      Returns the direction of the secondary axis that's been calculated for this joint origin. This
      is conceptually the X axis as shown by the triad representing the joint origin.
    */
    readonly secondaryAxisVector: core.Vector3D
    /**
      Returns the direction of the third axis that's been calculated for this joint origin. This
      is conceptually the Y axis as shown by the triad representing the joint origin.
    */
    readonly thirdAxisVector: core.Vector3D
    /**
      Gets and sets the value that defines the first global orient parameter for the joint origin.
      This defaults to zero if it's not specified.
      For Cylineder or cone, it represents the angle around the center axis.
      For Sphere and Torus, it represents the angle around the center axis.
      For Spline, it represents the U parameter.
    */
    globalOrientParamOne: core.ValueInput
    /**
      Gets and sets the value that defines the second global orient parameter for the joint origin.
      This defaults to zero if it's not specified.
      For Cylinder or cone, it is not used.
      For Sphere, it represents the polar angle, which is the angle between the radius line and the equator plane.
      For Torus, it represents the angle around the center of the section circle.
      For Spline, it represents the V parameter.
    */
    globalOrientParamTwo: core.ValueInput
  }

  /**
    The collection of rigid groups in this component. This provides access to all existing
    rigid groups and supports the ability to create new rigid groups.
  */
  abstract class RigidGroups extends core.Base {
    /**
      Function that returns the specified rigid group using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): RigidGroup | null
    /**
      Function that returns the specified rigid group using a name.
      @param name The name of the item within the collection to return.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): RigidGroup | null
    /**
      Returns number of joint origins in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new rigid group.
      @param occurrences An ObjectCollection containing the occurrences to use in creating the rigid group.
      @param includeChildren Boolean indicating if the children of the input occurrences should be included in the rigid group.
      @returns Returns the new RigidGroup object or null in the case of failure.
    */
    add(occurrences: core.ObjectCollection, includeChildren: boolean): RigidGroup | null
  }

  /**
    A list of rigid groups.
  */
  abstract class RigidGroupList extends core.Base {
    /**
      Function that returns the specified rigid group using an index into the list.
      @param index The index of the item within the list to return. The first item in the list has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): RigidGroup | null
    /**
      Function that returns the specified rigid group using a name.
      @param name The name of the item within the list to return.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): RigidGroup | null
    /**
      Returns number of rigid groups in the list.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents a rigid group within an assembly.
  */
  abstract class RigidGroup extends core.Base {
    /**
      Returns the parent component that owns this rigid group.
    */
    readonly parentComponent: Component
    /**
      Gets and sets the name of the rigid group as seen in the timeline.
    */
    name: string
    /**
      Deletes this rigid group.
      @returns Returns True if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Returns the list of occurrences that are part of the rigid group.
    */
    readonly occurrences: OccurrenceList
    /**
      Sets which occurrences are to be part of this rigid group.
      To use this method, you need to position the timeline marker to immediately before this group.
      This can be accomplished using the following code: group.timelineObject.rollTo(True)
      @param occurrences An ObjectCollection containing the occurrences to use in creating the rigid group.
      @param includeChildren Boolean indicating if the children of the input occurrences should be included in the rigid group.
      @returns Returns true if successful.
    */
    setOccurrences(occurrences: core.ObjectCollection, includeChildren: boolean): boolean
    /**
      Returns the timeline object associated with this rigid group.
    */
    readonly timelineObject: TimelineObject
    /**
      Gets and sets if this rigid group is suppressed.
    */
    isSuppressed: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: RigidGroup
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): RigidGroup | null
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      Returns the collection of attributes associated with this rigid group.
    */
    readonly attributes: core.Attributes
    /**
      Returns a token for the RigidGroup object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same rigid group.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Gets and sets whether the occurrences that are part of this rigid group are visible or not.
    */
    isVisible: boolean
  }

  /**
    The collection of Tangent Relationships in this component. This provides access to all existing tangent relationships
    and supports the ability to create new tangent relationships.
  */
  abstract class TangentRelationships extends core.Base {
    /**
      Function that returns the specified tangent relationship using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): TangentRelationship | null
    /**
      Creates a TangentRelationshipInput object, which is the API equivalent to the Tangent Relationship
      command dialog. You use methods and properties on the returned class to set the desired options,
      similar to providing input in the Tangent Relationship command dialog. Once the settings are defined
      you call the TangentRelationships.add method passing in the TangentRelationshipInput object to create
      the actual TangentRelationship.
      @param faceOne A BRepFace object that will remain tangent to the set of specified tangent faces.
      @param tangentFaces A single BRepFace object that is part of the body that faceOne will remain tangent to. All
      of the faces of the body will be used when computing the tangent relationship.
      @returns Returns the TangentRelationshipInput object or null if the creation failed.
    */
    createInput(faceOne: fusion.BRepFace, tangentFaces: adsk.core.Base): TangentRelationshipInput | null
    /**
      Creates a new tangent relationship between two components.
      @param input The TangentRelationshipInput object that defines the geometry and various inputs that fully define a tangent
      relationship. A TangentRelationshipInput object is created using the TangentRelationships.createInput method.
      @returns Returns the newly created TangentRelationship or null in the case of failure.
    */
    add(input: TangentRelationshipInput): TangentRelationship | null
    /**
      Returns number of TangentRelationship objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified tangent relationship using a name.
      @param name The name of the item within the collection to return.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): TangentRelationship | null
  }

  /**
    Defines all of the information required to create a new tangent relationship. This object provides
    equivalent functionality to the Tangent Relationship command dialog in that it gathers the required
    information to create a tangent relationship.
  */
  abstract class TangentRelationshipInput extends core.Base {
    /**
      Gets and sets the first BRepFace object that will remain tangent to the set of specified tangent faces.
    */
    faceOne: fusion.BRepFace
    /**
      Gets and sets a single BRepFace object that is part of the body that faceOne will remain tangent to. All
      of the faces of the body will be used when computing the tangent relationship.
    */
    tangentFaces: adsk.core.Base
  }

  /**
    A tangent relationship in a design.
  */
  abstract class TangentRelationship extends core.Base {
    /**
      Returns the parent component that owns this tangent relationship.
    */
    readonly parentComponent: Component
    /**
      Gets and sets the name of the tangent relationship.
    */
    name: string
    /**
      Gets and sets the first BRepFace object that will remain tangent to the set of specified tangent faces.
      To set this property, you need to position the timeline marker to immediately before this
      tangent relationship. This can be accomplished using the following code:
      thisTangentRelationship.timelineObject.rollTo(True)
    */
    faceOne: core.Base
    /**
      Gets and sets a single BRepFace object that is part of the body that faceOne will remain
      tangent to. All of the faces of the body will be used when computing the tangent relationship.
      To set this property, you need to position the timeline marker to immediately before this
      tangent relationship. This can be accomplished using the following code:
      thisTangentRelationship.timelineObject.rollTo(True)
    */
    tangentFaces: adsk.core.Base
    /**
      Deletes this tangent relationship.
      @returns Returns true if the delete is successful.
    */
    deleteMe(): boolean
    /**
      Returns the timeline object associated with this tangent relationship.
    */
    readonly timelineObject: TimelineObject
    /**
      The native object is the tangent relationship in the context of the
      component it was created within.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: TangentRelationship
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): TangentRelationship | null
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      Gets and sets if this tangent relationship is suppressed.
    */
    isSuppressed: boolean
    /**
      Returns the collection of attributes associated with this tangent relationship.
    */
    readonly attributes: core.Attributes
    /**
      Returns the current health state of the tangent relationship.
    */
    readonly healthState: FeatureHealthStates
    /**
      Returns the error or warning message in the case where the healthState property returns either
      WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
    */
    readonly errorOrWarningMessage: string
    /**
      Returns the first of two occurrences that this tangent relationship defines a relationship between.
    */
    readonly occurrenceOne: Occurrence
    /**
      Returns the second of two occurrences that this tangent relationship defines a relationship between.
    */
    readonly occurrenceTwo: Occurrence
    /**
      Returns a token for the TangentRelationship object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same tangent relationship.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
  }

  /**
    Provides access to the existing contact sets in a design and supports creating new contact sets.
  */
  abstract class ContactSets extends core.Base {
    /**
      Returns the specified contact set using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ContactSet | null
    /**
      Returns the specified contact set.
      @param name The name of the contact set to return.
      @returns Returns the specified contact set or null there isn't a contact set with that name.
    */
    itemByName(name: string): ContactSet | null
    /**
      Returns the number of contacts sets in the design.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new contact set for the provided occurrences and/or bodies.
      @param occurrencesAndBodies An array of Occurrence or BRepBody objects that will be included in the contact set.
      All occurrences and bodies must be in the context of the root component.
      @returns Returns the newly created ContactSet or null in the case of failure.
    */
    add(occurrencesAndBodies: core.Base[]): ContactSet | null
  }

  /**
    Represents a contact set in a design.
  */
  abstract class ContactSet extends core.Base {
    /**
      Gets and sets the name of the contact set.
    */
    name: string
    /**
      Gets and sets the group of Occurrence and/or BRepBody objects that are part of this contact set.
    */
    occurencesAndBodies: core.Base[]
    /**
      Deletes this contact set from the design.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Gets and sets if this contact set is currently suppressed.
    */
    isSuppressed: boolean
  }

  /**
    The base class of all configuration tables.
  */
  abstract class ConfigurationTable extends core.Base {
    /**
      Returns the unique ID of this table.
    */
    readonly id: string
    /**
      Returns the rows (configurations) defined for this table and provides the functionality to create new rows.
    */
    readonly rows: ConfigurationRows
    /**
      Returns the cell at the specified row and column.
      @param column The index of the column the cell is in. An index of 0 is the first column and does not include the name column.
      @param row The index of the row the cell is in. An index of 0 is the first row and does not include the header row.
    */
    getCell(column: number /*unsigned int*/, row: number /*unsigned int*/): ConfigurationCell
  }

  /**
    API object representing the top configuration table associated with a configured design.
    When obtained from the DataFile object of a configured design, the functionality is limited because it's not
    loaded in Fusion, and there is no access to the Fusion objects represented in the table. For example, any
    properties that return a Component or Parameter will return null because those objects aren't available.
  */
  abstract class ConfigurationTopTable extends ConfigurationTable {
    /**
      Gets the name of the table as seen in the user interface.
    */
    readonly name: string
    /**
      Returns the columns defined for this table and provides the functionality to create new columns.
    */
    readonly columns: ConfigurationColumns
    /**
      Returns the row that is currently active. To set the active row, use the activate method on the
      ConfigurationRow object.
    */
    readonly activeRow: ConfigurationRow
    /**
      Returns any custom theme tables associated with this top table.
    */
    readonly customThemeTables: ConfigurationCustomThemeTables
    /**
      Returns the appearance table associated with this top table. The returned table can be empty
      and not have any columns. In this case, the table is not displayed in the user interface.
      Use the returned table to add columns.
    */
    readonly appearanceTable: ConfigurationAppearanceTable
    /**
      Returns the material table associated with this top table. The returned table can be empty
      and not have any columns. In this case, the table is not displayed in the user interface.
      Use the returned table to add columns.
    */
    readonly materialTable: ConfigurationMaterialTable
    /**
      Returns the plastic rule table associated with this top table. The returned table can be
      empty and not have any columns. In this case, the table is not displayed in the user interface.
      Use the returned table to add columns.
    */
    readonly plasticRuleTable: ConfigurationPlasticRuleTable
    /**
      Returns the sheet metal rule table associated with this top table. The returned table can be
      empty and not have any columns. In this case, the table is not displayed in the user interface.
      Use the returned table to add columns.
    */
    readonly sheetMetalRuleTable: ConfigurationSheetMetalRuleTable
    /**
      Moves the specified columns from one table to another.
      @param columns An array of the columns within the top table you want to move.
      @param targetTable The table you want to move the columns to. The target must be a custom theme table.
      @returns Returns an array of the columns created due to the move.
    */
    moveColumns(columns: ConfigurationColumn[], targetTable: ConfigurationCustomThemeTable): ConfigurationColumn[]
  }

  /**
    Provides access to the custom theme tables associated with a configuration table and provides the
    functionality to create new custom theme tables.
  */
  abstract class ConfigurationCustomThemeTables extends core.Base {
    /**
      Creates a new custom theme table using the specified columns.
      @param columns An array of ConfigurationColumn objects used to create a new custom theme table. The columns
      must exist within the top configuration table, and they cannot include any ConfigurationThemeColumn,
      ConfigurationPropertyColumn, ConfigurationAppearanceColumn, ConfigurationMaterialColumn, ConfigurationPlasticRuleColumn,
      or ConfigurationSheetMetalRuleColumn objects. The specified columns will be removed from the main table,
      and a new ConfigurationThemeColumn will be created in the top table to reference the newly created custom theme table.
      @returns Returns the newly created ConfigurationCustomThemeTable or null if the creation fails.
    */
    add(columns: ConfigurationColumn[]): ConfigurationCustomThemeTable | null
    /**
      A method that returns the specified custom theme table using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConfigurationCustomThemeTable | null
    /**
      Returns the number of custom theme tables associated with the top table.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    API object representing a custom theme configuration table associated with a top table.
  */
  abstract class ConfigurationCustomThemeTable extends ConfigurationTable {
    /**
      Gets and sets the name of the table as seen in the user interface.
    */
    name: string
    /**
      Returns the columns in this table.
    */
    readonly columns: ConfigurationColumns
    /**
      Deletes this custom theme table from the configuration.
      @param deleteColumns If true, this deletes the columns in the custom theme table. If false, it moves them back to the top table.
      @returns Returns true if the delete was successful.
    */
    deleteMe(deleteColumns: boolean): boolean
    /**
      Returns the column in the top table that references this custom theme table.
    */
    readonly parentTableColumn: ConfigurationThemeColumn
    /**
      Moves the specified columns from one table to another.
      @param columns An array of the columns within this table that you want to move.
      @param targetTable The table you want to move the columns to. The target must be either a top table or a custom theme table.
      @returns Returns an array of the columns created due to the move.
    */
    moveColumns(columns: ConfigurationColumn[], targetTable: ConfigurationTable): ConfigurationColumn[]
  }

  /**
    Returns a collection of the columns in the table. The Name column is not included in this list.
  */
  abstract class ConfigurationColumns extends core.Base {
    /**
      A method that returns the specified column object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConfigurationColumn | null
    /**
      A method that returns the specified column object using the ID of the column.
      @param id The ID of the column within the collection to return.
      @returns Returns the specified item or null if no column matches the provided ID.
    */
    itemById(id: string): ConfigurationColumn | null
    /**
      Returns the number of columns in the table. The name column is not included.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a new parameter column to the configuration table. If a parameter column already
      exists for the parameter, the existing column is returned.
      This is only valid for TopConfigurationTable and ThemeConfigurationTable objects.
      It will fail for all other table types.
      @param parameter The parameter to add to the table.
      @returns Returns the new column or null in the case of failure.
    */
    addParameterColumn(parameter: Parameter): ConfigurationParameterColumn | null
    /**
      Adds a new column to control the suppression of a feature. The term "feature" is
      used broadly and includes anything displayed in the timeline. If a suppression column already
      exists for the feature, the existing column is returned.
      This is only valid for TopConfigurationTable and ThemeConfigurationTable objects.
      It will fail for all other table types.
      @param feature The feature to add to the table. Any object that is displayed in the timeline can be
      used as input. For example, some valid objects are any modeling features, sketches,
      construction geometry, and joints.
      @returns Returns the new column or null in the case of failure.
    */
    addSuppressColumn(feature: core.Base): ConfigurationSuppressColumn | null
    /**
      Adds a new column to control the visibility of an entity. If a visibility column already
      exists for the entity, the existing column is returned.
      This is only valid for ConfigurationTopTable and ConfigurationCustomThemeTable objects
      and will fail for all other table types.
      @param entity Returns the entity whose visibility will be controlled by this column.
      @returns Returns the new column or null in the case of failure.
    */
    addVisibilityColumn(entity: core.Base): ConfigurationVisibilityColumn | null
    /**
      Add a new column to control which configuration is used for an inserted configuration.
      If an insert column already exists for the occurrence, the existing column is returned.
      This is only valid for ConfigurationTopTable and ConfigurationCustomThemeTable objects
      and will fail for all other table types.
      @param occurrence The occurrence that references a configuration.
      @returns Returns the new column or null in the case of failure.
    */
    addInsertColumn(occurrence: Occurrence): ConfigurationInsertColumn | null
    /**
      Add a new column to control the property inside the component.
      The component is the owner of the property.
      This is only valid for TopConfigurationTable.
      It will fail for all other table types.
      @param property The property to add to the table.
      @returns Returns the new column or null in the case of failure.
    */
    addPropertyColumn(property: core.Property): ConfigurationPropertyColumn | null
    /**
      Creates the columns in the configuration table to control the type of thread associated with a
      thread feature or a tapped hole. Because configuring a thread requires several pieces of information,
      this method collects it all at once and creates all the corresponding feature aspect columns.
      @param threadFeature The thread or tapped hole feature whose thread will be controlled by the configuration table.
      @param threadColumns Enum value that indicates which columns should be created to control the thread type. You can fully
      define the thread type by specifying the type, size, designation, and class. Or you can leave the
      thread type controlled by the feature and only configure the size, designation, and class. Or you
      can leave the thread type and size controlled by the feature and only configure the designation and
      class. Or you can leave the thread type, size, and designation controlled by the feature and only
      configure the class. As a result, this can create and return 4, 3, 2, or 1 columns.
      @returns Returns an array of the columns created. They are in order of type, size, designation, and class.
    */
    addThreadTypeColumns(threadFeature: Feature, threadColumns: ConfigurationThreadColumns): ConfigurationFeatureAspectColumn[]
    /**
      Creates a new column to control an aspect of a feature that supports being configured.
      @param feature The feature to be configured. The term "feature" is used broadly and includes ThreadFeature, HoleFeature that is tapped, Joint,
      and AsBuiltJoint objects. The existing column is returned if a feature aspect column already exists for the feature and aspect type.
      @param aspectType The aspect type to create a column for. The type specified must be a valid type for the specified feature otherwise, this will fail with an error.
      @returns Returns the created ConfigurationFeatureAspectColumn or null in the case of failure.
    */
    addFeatureAspectColumn(feature: core.Base, aspectType: ConfigurationFeatureAspectTypes): ConfigurationFeatureAspectColumn | null
    /**
      Creates the columns in the configuration table to control the clearance information associated with a
      clearance hole. Because configuring a clearance hole requires several pieces of related information,
      this method collects it all at once and creates all the corresponding feature aspect columns.
      The fit is also a setting that controls the hole clearance, but it's independent of the other settings and can be
      created independently using the addFeatureAspectColumn method.
      @param holeFeature The hole feature that defines a clearance hole whose clearance will be controlled by the configuration table.
      @param holeClearanceColumns Enum value that indicates which columns should be created to control the clearance hole definition. You can fully
      define the clearance hole by specifying the standard, fastener type, and size. Or you can leave the
      standard controlled by the hole and only configure the fastener type, and size. Or you
      can leave the standard and fastener type controlled by the hole and only configure the size.
      As a result, this can create and return 3, 2, or 1 columns.
      The fit is also a setting that controls the hole clearance, but it's independent of the other settings and can be
      created independently using the addFeatureAspectColumn method.
      @returns Returns an array of the columns created. They are in order of standard, fastener type, and size.
    */
    addClearanceTypeColumns(holeFeature: HoleFeature, holeClearanceColumns: ConfigurationClearanceHoleColumns): ConfigurationFeatureAspectColumn[]
  }

  /**
    Enum that defines the valid combinations of thread columns that can be configured.
  */
  const enum ConfigurationThreadColumns {
    /**
      Defines that the thread type, size, designation, and class will fully define the thread on
      the thread feature or tapped hole.
    */
    ThreadType_Size_Designation_ClassColumns,
    /**
      Defines that the thread size, designation, and class will be used to partially define
      the thread. The Thread feature or tapped hole controls the thread type.
    */
    ThreadSize_Designation_ClassColumns,
    /**
      Defines that the thread designation and class will be used to partially define the thread.
      The Thread feature or tapped hole controls the thread type and size.
    */
    ThreadDesignation_ClassColumns,
    /**
      Defines that the thread class will be used to partially define the thread.
      The Thread feature or tapped hole controls the thread type, size, and designation.
    */
    ThreadClassColumns,
    /**
      Defines that the thread type, size, and designation will fully define a tapered tapped hole.
    */
    TaperedThreadType_Size_DesignationColumns,
    /**
      Defines that the size and designation will be used to partially define a tapered tapped hole.
      The tapped hole controls the thread type.
    */
    TaperedSize_DesignationColumns,
    /**
      Defines that the designation will be used to partially define a tapered tapped hole.
      The tapped hole controls thread type and size.
    */
    TaperedDesignationColumns,
  }

  /**
    Enum that defines the valid combinations of clearance hole columns that can be configured.
  */
  const enum ConfigurationClearanceHoleColumns {
    /**
      Defines that the clearance hole standard, fastener type, and and size will be used to define the clearance hole.
      The fit is defined separately.
    */
    Standard_Type_Size_ClearanceHoleColumns,
    /**
      Defines that the clearance hole fastener type, and size will be used to partially define the clearance hole.
      The Hole feature controls the standard, and the fit is defined separately.
    */
    Type_Size_ClearanceHoleColumns,
    /**
      Defines that the clearance hole size and fit will be used to partially define the clearance hole.
      The Hole feature controls the standard and fastener type, and the fit is defined separately.
    */
    Size_ClearanceHoleColumns,
  }

  /**
    Represents a column in a configuration table. This is the base class for the more specific
    column types. The "Name" column is not considered a standard column but is a value associated
    with each table row.
  */
  abstract class ConfigurationColumn extends core.Base {
    /**
      The title of this column. In a top table, this can only be edited for suppression,
      visibility, parameter, and theme table columns. It behaves as read-only for all other types.
      In a theme table, the title of all the columns can be modified except for the column that
      represents the root component for materials and appearances.
      If the table was obtained from a DataFile, this property behaves as read-only for all the columns.
    */
    title: string
    /**
      The index position of this column within the table. The first column is at index 0 and
      does not include the "Name" column.
    */
    readonly index: number /*unsigned int*/
    /**
      The id of the column. This is constant and cannot be changed by the user.
    */
    readonly id: string
    /**
      Deletes this column from the table. Property columns cannot be deleted. If the table was
      obtained from a DataFile, this method will fail.
      @returns Returns true if the deletion was successful.
    */
    deleteMe(): boolean
    /**
      Returns the number of rows in this column.
    */
    readonly rowCount: number /*unsigned int*/
  }

  /**
    Returns a collection of the rows in the table. The header row is not included in this list.
  */
  abstract class ConfigurationRows extends core.Base {
    /**
      A method that returns the specified row using an index into the collection. These are returned
      in the same order as in the table the first row is the default row.
      @param index The index of the row to return, where the first row is index 0. The headers do not count as a row.
      @returns Returns the specified row or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConfigurationRow | null
    /**
      A method that returns the row with the specified ID.
      @param id The id of the row to return.
      @returns Returns the specified row or null if a row with the specified ID does not exist.
    */
    itemById(id: string): ConfigurationRow | null
    /**
      A method that returns the row with the specified name.
      @param name The name of the row to return.
      @returns Returns the specified row or null if the named row does not exist.
    */
    itemByName(name: string): ConfigurationRow | null
    /**
      Returns the number of rows in the table where the header row is not included.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a new row to the table.  For the top table, this creates a new configuration.
      For theme tables, this creates a new theme. The new row is added to the bottom of the table,
      and the cell values are copied from the row above it. You can also use the ConfigurationRow.copy
      method to create a new row by copying any existing row.
      @param name The name of the new row. An empty string can be provided, which will cause Fusion to use a
      default naming scheme to create a name.
      @returns Returns the newly created row.
    */
    add(name: string): ConfigurationRow
  }

  /**
    Used to check the state of the asynchronous configuration operation
  */
  abstract class ConfigurationFuture extends core.Future {
  }

  /**
    Represents a row in a configuration table. The header row is not considered a standard row but
    is information associated with each column.
    For a top table, each row represents a configuration, and for a theme table, each row represents a theme.
  */
  abstract class ConfigurationRow extends core.Base {
    /**
      Gets the unique ID that identifies this row. The ID remains constant for this row as
      long as the row exists. This is different than the name, which the user can change.
    */
    readonly id: string
    /**
      Gets and sets the name of this row. Names must be unique with respect to other rows in this
      table. If you specify a name that exists, Fusion will append a counter to ensure uniqueness.
      For example, if "Small" is already used and you name another row "Small", you will end up with "Small (1)".
    */
    name: string
    /**
      The index position of this row within the table. The first row is at index 0 and does not include the header row.
    */
    readonly index: number /*unsigned int*/
    /**
      Deletes this row from the table. The first row of the top table cannot be deleted, and this method will fail.
      @returns Returns true if the deletion was successful.
    */
    deleteMe(): boolean
    /**
      Causes this row to become the active row in the table.
      @returns Returns true if the activation was successful.
    */
    activate(): boolean
    /**
      Gets the cell in this row at the specified column index. The first column has an index of 0 and does not include the name column.
      @param columnIndex The index of the column to return the cell for. The first column has an index 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCellByColumnIndex(columnIndex: number /*unsigned int*/): ConfigurationCell | null
    /**
      Gets the cell in this row at the column with the specified ID.
      @param columnId The ID of the column the cell is in.
      @returns Returns the specified cell if successful or null if a column with the specified ID does not exist.
    */
    getCellByColumnId(columnId: string): ConfigurationCell | null
    /**
      Creates a new row by copying this row.
      @param name The name to use for the new row. An empty string indicates that Fusion should use the default naming scheme.
      Names must be unique with respect to other rows in this table. If you specify a name that exists,
      Fusion will append a counter to ensure uniqueness. For example, if "Small" is already used and you name
      another row "Small", you will end up with "Small (1)".
      @returns Returns the newly created row or null in the case of failure.
    */
    copy(name: string): ConfigurationRow | null
    /**
      Returns the configuration table this row is a member of.
    */
    readonly parentTable: ConfigurationTable
    /**
      Causes this row to be generated.
      @returns Returns a future that can be used to determine when the generation is complete.
      Null is returned in the case where starting the generation fails.
    */
    generate(): ConfigurationFuture
  }

  /**
    Represents a single cell within a configuration table. This is the base class for the type-specific cell objects.
  */
  abstract class ConfigurationCell extends core.Base {
    /**
      Returns the row this cell is in.
    */
    readonly parentRow: ConfigurationRow
  }

  /**
    Represents a theme table column in a top configuration table.
  */
  abstract class ConfigurationThemeColumn extends ConfigurationColumn {
    /**
      Returns the theme table that this column references.
    */
    readonly referencedTable: ConfigurationTable
    /**
      Gets the cell in this column at the specified row index. The first row has an index of 0 and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationThemeCell | null
    /**
      Gets the cell in this column at the row specified by its name.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationThemeCell | null
    /**
      Gets the cell in this column at the row specified by its ID.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the id is not found.
    */
    getCellByRowId(rowId: string): ConfigurationThemeCell | null
    /**
      Returns the parent table this column is in.
    */
    readonly parentTable: ConfigurationTable
  }

  /**
    Represents an individual cell within a top configuration table that specifies which row in the custom theme table should be used.
  */
  abstract class ConfigurationThemeCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationThemeColumn
    /**
      Gets and sets the row to use from the referenced table.
    */
    referencedTableRow: ConfigurationRow
  }

  /**
    Represents a column where a configured design has been inserted in this design.
  */
  abstract class ConfigurationInsertColumn extends ConfigurationColumn {
    /**
      Returns the occurrence that is associated with this configuration insertion.
      This property returns null when the table being queried was obtained from a DataFile object.
    */
    readonly occurrence: Occurrence
    /**
      Gets the cell in this column at the specified row. The first row has an index of 0 and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationInsertCell | null
    /**
      Gets the cell in this column at the row specified by its name.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationInsertCell | null
    /**
      Gets the cell in this column at the row specified by its ID.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowId(rowId: string): ConfigurationInsertCell | null
    /**
      Returns the parent table, either top or custom theme table, this column is in.
    */
    readonly parentTable: ConfigurationTable
  }

  /**
    Represents a single cell within a top or custom theme configuration table that controls which configuration is
    used for an inserted configured design. Use the parent column to get the feature being suppressed.
  */
  abstract class ConfigurationInsertCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationInsertColumn
    /**
      Gets and sets which row of the configured design is used for this cell. When setting this property,
      the row must come from the configured design used by the occurrence associated with the parent column of this cell.
    */
    row: ConfigurationRow
  }

  /**
    Represents a parameter column in a top or custom theme configuration table.
  */
  abstract class ConfigurationParameterColumn extends ConfigurationColumn {
    /**
      Returns the parameter being controlled by this column.
      This property returns null when the table being queried was obtained from a DataFile object.
    */
    readonly parameter: Parameter
    /**
      Gets the cell in this column at the specified row. The first row has an index of 0 and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationParameterCell | null
    /**
      Gets the cell in this column at the row specified by its name.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationParameterCell | null
    /**
      Gets the cell in this column at the row specified by its ID.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the id is not found.
    */
    getCellByRowId(rowId: string): ConfigurationParameterCell | null
    /**
      Returns the parent table, either top or custom theme table, this column is in.
    */
    readonly parentTable: ConfigurationTable
  }

  /**
    Represents a single cell within a configuration table that controls the value of a parameter.
    Get the parent column to get the parameter being controlled.
  */
  abstract class ConfigurationParameterCell extends ConfigurationCell {
    /**
      Returns the column this cell is in. From the column, you can get the parameter object being controlled.
    */
    readonly parentColumn: ConfigurationParameterColumn
    /**
      Gets and sets the expression that defines the value of the associated parameter when the parent row
      is active. This property behaves as read-only when the table is obtained from a DataFile object.
    */
    expression: string
    /**
      Gets and sets the value of the parameter in database units. You can use the units property of the associated
      Parameter object, which you can get from the column, to determine the type of units this parameter is
      defined in. Setting this property will overwrite any existing expression. This property behaves as read-only
      when the table is obtained from a DataFile object.
    */
    value: number
  }

  /**
    Represents a suppress column in a top or custom theme configuration table.
  */
  abstract class ConfigurationSuppressColumn extends ConfigurationColumn {
    /**
      Returns the feature whose suppression state is being controlled by this column.
      The term "feature" is used broadly and includes anything displayed in the timeline.
      This property returns null when the table being queried was obtained from a DataFile object.
    */
    readonly feature: core.Base
    /**
      Gets the cell in this column at the specified row. The first row has an index of 0 and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationSuppressCell | null
    /**
      Gets the cell in this column at the row specified by its name.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationSuppressCell | null
    /**
      Gets the cell in this column at the row specified by its ID.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowId(rowId: string): ConfigurationSuppressCell | null
    /**
      Returns the parent table, either top or custom theme table, this column is in.
    */
    readonly parentTable: ConfigurationTable
  }

  /**
    Represents a single cell within a configuration table that controls if a feature is suppressed.
    Get the parent column to get the feature being suppressed.
  */
  abstract class ConfigurationSuppressCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationSuppressColumn
    /**
      Specifies if the feature is suppressed or not. This property behaves as read-only when the table is obtained from a DataFile.
    */
    isSuppressed: boolean
  }

  /**
    Represents a visibility column in a top or custom theme configuration table.
  */
  abstract class ConfigurationVisibilityColumn extends ConfigurationColumn {
    /**
      Returns the entity whose visibility is being controlled by this column.
      This property returns null when the table being queried was obtained from a DataFile object.
    */
    readonly entity: core.Base
    /**
      Gets the cell in this column at the specified row. The first row has an index of 0 and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationVisibilityCell | null
    /**
      Gets the cell in this column at the row specified by its name.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationVisibilityCell | null
    /**
      Gets the cell in this column at the row specified by its ID.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the id is not found.
    */
    getCellByRowId(rowId: string): ConfigurationVisibilityCell | null
    /**
      Returns the parent table, either top or custom theme table, this column is in.
    */
    readonly parentTable: ConfigurationTable
  }

  /**
    Represents a single cell within a configuration table that controls whether an entity is visible. Get the parent column to get the entity.
  */
  abstract class ConfigurationVisibilityCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationVisibilityColumn
    /**
      Specifies if the entity is visible or not. This property behaves as read-only when the table is obtained from a DataFile.
    */
    isVisible: boolean
  }

  /**
    Represents a configuration table that defines the appearances assigned to bodies and components.
  */
  abstract class ConfigurationAppearanceTable extends ConfigurationTable {
    /**
      Returns the collection that provides access to this table's columns and the ability to create new columns.
    */
    readonly columns: ConfigurationAppearanceColumns
    /**
      Clears the content of the appearance table, removes the reference from the top table, and hides it in the user interface.
      @returns Returns true if successful.
    */
    clear(): boolean
    /**
      Returns the column in the top table that references this appearance table.
    */
    readonly parentTableColumn: ConfigurationThemeColumn
    /**
      Returns the name of the table as seen in the user interface.
    */
    readonly name: string
  }

  /**
    Provides access to the columns in an appearance table. This collection can be empty when no
    columns have been created. When the table is empty, it is not displayed in the user interface,
    and adding a column causes the table to be displayed.
  */
  abstract class ConfigurationAppearanceColumns extends core.Base {
    /**
      A method that returns the specified column using an index into the collection.
      These are returned in the same order as they appear in the table.
      @param index The index of the column to return, where the first column is index 0. The name column is not included.
      @returns Returns the specified column or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConfigurationAppearanceColumn | null
    /**
      A method that returns the column with the specified ID.
      @param id The id of the column to return.
      @returns Returns the specified column or null if a column with the specified ID does not exist.
    */
    itemById(id: string): ConfigurationAppearanceColumn | null
    /**
      Returns the number of columns in the table where the name column is not included.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a new column to the appearance table. If you are adding the first column to the table and
      it is anything other than the root component, an additional column for the root component will
      automatically be created as the first column.
      @param entity The root component, occurrence, or body whose appearance will be controlled by this column.
      @returns Returns the newly created ConfigurationAppearanceColumn object or null if it fails.
    */
    add(entity: core.Base): ConfigurationAppearanceColumn | null
  }

  /**
    Represents an appearance column in the appearance table. This defines the appearance to
    use for a specific component.
  */
  abstract class ConfigurationAppearanceColumn extends ConfigurationColumn {
    /**
      Returns the Component or BRepBody being controlled by this column. This property returns
      null when the table being queried was obtained from a DataFile object.
    */
    readonly entity: core.Base
    /**
      Gets the cell in this column at the specified row. The first row has an index of 0
      and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationAppearanceCell | null
    /**
      Gets the cell in this column at the row specified by its name.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationAppearanceCell | null
    /**
      Gets the cell in this column at the row specified by its ID.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the id is not found.
    */
    getCellByRowId(rowId: string): ConfigurationAppearanceCell | null
    /**
      Returns the parent appearance table this column is in.
    */
    readonly parentAppearanceTable: ConfigurationAppearanceTable
  }

  /**
    Represents a single cell within a ConfigurationAppearanceTable table that controls which
    appearance is assigned to a component or body.
  */
  abstract class ConfigurationAppearanceCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationAppearanceColumn
    /**
      Gets and sets the appearance associated with this cell.
      This property can return null indicating the appearance from the physical material assigned to the object is inherited.
      Setting the property to null will inherit the appearance from the physical material assigned to the object.
    */
    appearance: core.Appearance
  }

  /**
    Represents a configuration table that defines materials assigned to bodies and components.
  */
  abstract class ConfigurationMaterialTable extends ConfigurationTable {
    /**
      Returns the collection that provides access to the columns in this table.
    */
    readonly columns: ConfigurationMaterialColumns
    /**
      Clears the content of the material table, removes the reference from the top table,
      and hides it in the user interface.
      @returns Returns true if successful.
    */
    clear(): boolean
    /**
      Returns the column in the top table that references this material table.
    */
    readonly parentTableColumn: ConfigurationThemeColumn
    /**
      Returns the name of the table as seen in the user interface.
    */
    readonly name: string
  }

  /**
    Provides access to the columns in a material table. This collection can be empty when
    no columns have been created. When the table is empty, it is not displayed in the
    user interface, and adding a column causes the table to be displayed.
  */
  abstract class ConfigurationMaterialColumns extends core.Base {
    /**
      A method that returns the specified column using an index into the collection.
      These are returned in the same order as they appear in the table.
      @param index The index of the column to return, where the first column is index 0.
      The name column is not included.
      @returns Returns the specified column or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConfigurationMaterialColumn | null
    /**
      A method that returns the column with the specified ID.
      @param id The id of the column to return.
      @returns Returns the specified column or null if a column with the specified ID does not exist.
    */
    itemById(id: string): ConfigurationMaterialColumn | null
    /**
      Returns the number of columns in the table where the name column is not included.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a new column to the material table. If you are adding the first column to the table
      and it is anything other than the root component, an additional column for the root
      component will automatically be created as the first column.
      @param entity The component or body whose material will be controlled by this column.
      @returns Returns the newly created ConfigurationMaterialColumn object or null if it fails.
    */
    add(entity: core.Base): ConfigurationMaterialColumn | null
  }

  /**
    Represents a material column in the material table. This defines the material to use for a specific component.
  */
  abstract class ConfigurationMaterialColumn extends ConfigurationColumn {
    /**
      Returns the Component or BRepBody being modified by this column. This property
      returns null when the table being queried was obtained from a DataFile object.
    */
    readonly entity: core.Base
    /**
      Gets the cell in this column at the specified row. The first row has an
      index of 0 and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationMaterialCell | null
    /**
      Gets the cell in this column at the row specified by its name.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationMaterialCell | null
    /**
      Gets the cell in this column at the row specified by its ID.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the id is not found.
    */
    getCellByRowId(rowId: string): ConfigurationMaterialCell | null
    /**
      Returns the parent material table this column is in.
    */
    readonly parentMaterialTable: ConfigurationMaterialTable
  }

  /**
    Represents a single cell within a ConfigurationMaterialTable table that controls which
    material is assigned to a component or body.
  */
  abstract class ConfigurationMaterialCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationMaterialColumn
    /**
      Gets and sets the material associated with this cell. When setting this property,
      the material used must exist in the design.
    */
    material: core.Material
  }

  /**
    Represents a configuration table that defines different plastic rules.
  */
  abstract class ConfigurationPlasticRuleTable extends ConfigurationTable {
    /**
      Returns the collection that provides access to the columns in this table.
    */
    readonly columns: ConfigurationPlasticRuleColumns
    /**
      Clears the content of the plastic rule table, removes the reference from
      the top table, and hides it in the user interface.
      @returns Returns true if successful.
    */
    clear(): boolean
    /**
      Returns the column in the top table that references this plastic rule table.
    */
    readonly parentTableColumn: ConfigurationThemeColumn
    /**
      Returns the name of the table as seen in the user interface.
    */
    readonly name: string
  }

  /**
    Provides access to the columns in a plastic rule table. This collection can be empty
    when no columns have been created. When the table is empty, it is not displayed in the
    user interface, and adding a column causes the table to be displayed.
  */
  abstract class ConfigurationPlasticRuleColumns extends core.Base {
    /**
      A method that returns the specified column using an index into the collection.
      These are returned in the same order as they appear in the table.
      @param index The index of the column to return, where the first column is index 0.
      The name column is not included.
      @returns Returns the specified column or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConfigurationPlasticRuleColumn | null
    /**
      A method that returns the column with the specified ID.
      @param id The id of the column to return.
      @returns Returns the specified column or null if a column with the specified ID does not exist.
    */
    itemById(id: string): ConfigurationPlasticRuleColumn | null
    /**
      Returns the number of columns in the table where the name column is not included.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a new column to the plastic rule table.
      @param component The component whose active plastic rule will be controlled by this column.
      @returns Returns the newly created ConfigurationPlasticRuleColumn object or null if it fails.
    */
    add(component: Component): ConfigurationPlasticRuleColumn | null
  }

  /**
    Represents a plastic rule column in a configuration table. This defines the plastic rule to use for a specific component.
  */
  abstract class ConfigurationPlasticRuleColumn extends ConfigurationColumn {
    /**
      Returns the Component being modified by this column. This property
      returns null when the table being queried was obtained from a DataFile object.
    */
    readonly component: fusion.Component
    /**
      Gets the cell in this column at the specified row. The first row has an index of 0 and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationPlasticRuleCell | null
    /**
      Gets the cell in this column at the row specified by its name.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationPlasticRuleCell | null
    /**
      Gets the cell in this column at the row specified by its ID.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the id is not found.
    */
    getCellByRowId(rowId: string): ConfigurationPlasticRuleCell | null
    /**
      Returns the parent plastic rule table this column is in.
    */
    readonly parentPlasticRuleTable: ConfigurationPlasticRuleTable
  }

  /**
    Represents a single cell within a configuration table that controls which sheet plastic rule is assigned to a component.
  */
  abstract class ConfigurationPlasticRuleCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationPlasticRuleColumn
    /**
      Gets and sets the plastic rule defined for this cell.
    */
    plasticRule: PlasticRule
  }

  /**
    Represents a configuration table that defines different sheet metal rules.
  */
  abstract class ConfigurationSheetMetalRuleTable extends ConfigurationTable {
    /**
      Returns the collection that provides access to the columns in this table.
    */
    readonly columns: ConfigurationSheetMetalRuleColumns
    /**
      Clears the content of the sheet metal rule table, removes the reference from the top table, and hides it in the user interface.
      @returns Returns true if successful.
    */
    clear(): boolean
    /**
      Returns the column in the top table that references this sheet metal rule table.
    */
    readonly parentTableColumn: ConfigurationThemeColumn
    /**
      Returns the name of the table as seen in the user interface.
    */
    readonly name: string
  }

  /**
    Provides access to the columns in a sheet metal rule table. This collection can be empty when
    no columns have been created. When the table is empty, it is not displayed in the user interface,
    and adding a column causes the table to be displayed.
  */
  abstract class ConfigurationSheetMetalRuleColumns extends core.Base {
    /**
      A method that returns the specified column using an index into the collection.
      These are returned in the same order as they appear in the table.
      @param index The index of the column to return, where the first column is index 0. The name column is not included.
      @returns Returns the specified column or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConfigurationSheetMetalRuleColumn | null
    /**
      A method that returns the column with the specified ID.
      @param id The id of the column to return.
      @returns Returns the specified column or null if a column with the specified ID does not exist.
    */
    itemById(id: string): ConfigurationSheetMetalRuleColumn | null
    /**
      Returns the number of columns in the table where the name column is not included.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a new column to the sheet metal rule table.
      @param component The component whose active sheet metal rule will be controlled by this column.
      @returns Returns the newly created ConfigurationPlasticRuleColumn object or null if it fails.
    */
    add(component: Component): ConfigurationSheetMetalRuleColumn | null
  }

  /**
    Represents a sheet metal rule column in a configuration table. This defines the sheet metal rule to use for a specific component.
  */
  abstract class ConfigurationSheetMetalRuleColumn extends ConfigurationColumn {
    /**
      Returns the Component being modified by this column. This property
      returns null when the table being queried was obtained from a DataFile object.
    */
    readonly component: fusion.Component
    /**
      Returns the name of the component associated with this column. This is useful when
      the table is obtained from a DataFile object, and the component object is unavailable.
    */
    readonly componentName: string
    /**
      Gets the cell in this column at the specified row. The first row has an index of 0 and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationSheetMetalRuleCell | null
    /**
      Gets the cell in this column at the row specified by its name.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationSheetMetalRuleCell | null
    /**
      Gets the cell in this column at the row specified by its ID.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the id is not found.
    */
    getCellByRowId(rowId: string): ConfigurationSheetMetalRuleCell | null
    /**
      Returns the parent sheet metal rule table this column is in.
    */
    readonly parentSheetMetalRuleTable: ConfigurationSheetMetalRuleTable
  }

  /**
    Represents a single cell within a configuration table that controls which sheet metal rule is assigned to a component.
  */
  abstract class ConfigurationSheetMetalRuleCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationSheetMetalRuleColumn
    /**
      Gets and sets the sheet metal rule defined for this cell.
    */
    sheetMetalRule: SheetMetalRule
  }

  /**
    Represents a property column in a configuration table.
  */
  abstract class ConfigurationPropertyColumn extends ConfigurationColumn {
    /**
      Returns the property whose value is controlled by this column.
    */
    readonly parentProperty: core.Property
    /**
      Gets the cell in this column at the specified row. The first row has an index of 0 and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationPropertyCell | null
    /**
      Gets the cell in this column at the row specified by its name.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationPropertyCell | null
    /**
      Gets the cell in this column at the row specified by its ID.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the id is not found.
    */
    getCellByRowId(rowId: string): ConfigurationPropertyCell | null
    /**
      Returns the parent table this column is in.
    */
    readonly parentTable: ConfigurationTable
  }

  /**
    Represents an individual cell within a configuration table that defines
    the value of a property.
  */
  abstract class ConfigurationPropertyCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationPropertyColumn
    /**
      Gets and sets the value of the property associated with the parent column of this cell.
    */
    value: string
  }

  /**
    Represents a feature aspect column in a configuration table. Feature aspects are properties
    of a feature that are unique to a particular type of feature. This includes various thread
    and joint settings.
  */
  abstract class ConfigurationFeatureAspectColumn extends ConfigurationColumn {
    /**
      Returns the feature being controlled by this column.
      This property returns null when the table being queried was obtained from a DataFile object.
    */
    readonly feature: core.Base
    /**
      Gets the type of feature aspect this column is controlling.
    */
    readonly aspectType: ConfigurationFeatureAspectTypes
    /**
      Gets the cell in this column at the specified row. Depending on the type of data in the
      cells within the column a ConfigurationFeatureAspectBooleanCell or ConfigurationFeatureAspectStringCell
      will be returned. The first row has an index of 0 and does not include the header row.
      @param rowIndex The index of the row to return the cell for. The first row has an index of 0.
      @returns Returns the specified cell if successful and null if an invalid index was specified.
    */
    getCell(rowIndex: number /*unsigned int*/): ConfigurationCell | null
    /**
      Gets the cell in this column at the row specified by its name. Depending on the type of data in the
      cells within the column a ConfigurationFeatureAspectBooleanCell or ConfigurationFeatureAspectStringCell
      will be returned.
      @param rowName The name of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the name is not found.
    */
    getCellByRowName(rowName: string): ConfigurationCell | null
    /**
      This method returns the cell in this column at the row identified by its ID. Depending on the type of data in the
      cells within the column, a ConfigurationFeatureAspectBooleanCell or ConfigurationFeatureAspectStringCell will be returned.
      @param rowId The ID of the row to return the cell for.
      @returns Returns the specified cell if successful and null if the id is not found.
    */
    getCellByRowId(rowId: string): ConfigurationCell | null
    /**
      This property returns the parent table, either the top or custom theme table this column is in.
    */
    readonly parentTable: ConfigurationTable
  }

  /**
    This object represents a cell from a column that defines a configuration feature aspect with a Boolean value.
  */
  abstract class ConfigurationFeatureAspectBooleanCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationFeatureAspectColumn
    /**
      Gets and sets the value of the property associated with the parent column of this cell.
    */
    value: boolean
  }

  /**
    Represents a cell from a column that defines a configuration feature aspect that is
    a String value.
  */
  abstract class ConfigurationFeatureAspectStringCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationFeatureAspectColumn
    /**
      Gets and sets the value of the property associated with the parent column of this cell.
    */
    value: string
  }

  /**
    Defines a list of all of the different aspects of a feature that can be configured.
  */
  const enum ConfigurationFeatureAspectTypes {
    /**
      A feature aspect that defines the thread type of a thread or tapped hole.
    */
    ThreadTypeFeatureAspectType,
    /**
      A feature aspect that defines the thread size of a thread or tapped hole.
    */
    ThreadSizeFeatureAspectType,
    /**
      A feature aspect that defines the thread designation of a thread or tapped hole.
    */
    ThreadDesignationFeatureAspectType,
    /**
      A feature aspect that defines the thread class of a thread or tapped hole.
    */
    ThreadClassFeatureAspectType,
    /**
      A feature aspect that defines if the thread is cosmetic or modeled.
    */
    ThreadModeledFeatureAspectType,
    /**
      A feature aspect that defines if the thread goes the full length of the cylinder.
    */
    ThreadFullLengthFeatureAspectType,
    /**
      A feature aspect that defines if the thread is right or left handed.
    */
    ThreadIsRightHandedFeatureAspectType,
    /**
      A feature aspect that controls if a joint is flipped.
    */
    JointFlipFeatureAspectType,
    /**
      A feature aspect that defines the snap to the first occurrence of a joint.
    */
    JointSnapOneFeatureAspectType,
    /**
      A feature aspect that defines the snap to the second occurrence of a joint.
    */
    JointSnapTwoFeatureAspectType,
    /**
      A feature aspect that defines the standard for a clearance hole.
    */
    ClearanceHoleStandardFeatureAspectType,
    /**
      A feature aspect that defines the fastener type of a clearance hole.
    */
    ClearanceHoleTypeFeatureAspectType,
    /**
      A feature aspect that defines the size of a clearance hole.
    */
    ClearanceHoleSizeFeatureAspectType,
    /**
      A feature aspect that defines the fit of a clearance hole.
    */
    ClearanceHoleFitFeatureAspectType,
  }

  /**
    This object represents a column in the table that controls which joint
    snap to use for a particular joint. The columns contains a list of
    joint snaps that have been defined specifically for that column. One of
    the joint snaps is specified for each cell in the column. That joint snap
    will be used by the joint when the row that cell is in is active.
  */
  abstract class ConfigurationJointSnapColumn extends ConfigurationFeatureAspectColumn {
    /**
      Returns the joint or as-built joint being controlled by this column.
      This property returns null when the table being queried was obtained from a DataFile object.
    */
    readonly joint: core.Base
    /**
      Provides access to any joint snaps that have been defined for this column. Using
      the returned collection you can define new joint snaps. Use the cell to specify
      which of the defined snaps is used for a specific row.
    */
    readonly snaps: ConfigurationJointSnaps
  }

  /**
    Collection object that provides access to all the joint snaps that have been
    defined for a ConfigurationJointSnapColumn. You can also use this collection
    to define new joint snaps that will then be available when specifying which
    snap to use in a cell.
  */
  abstract class ConfigurationJointSnaps extends core.Base {
    /**
      A method that returns the specified snap using an index into the collection.
      @param index The index of the snap to return, where the first row is index 0.
      @returns Returns the specified snap or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConfigurationJointSnap | null
    /**
      A method that returns the snap with the specified name.
      @param name The name of the snap to return.
      @returns Returns the specified snap or null if a snap with the specified name does not exist.
    */
    itemByName(name: string): ConfigurationJointSnap | null
    /**
      Returns the number of snaps for the column.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a new snap to the column. The snaps associated with the column can be used
      in the cells in the column.
      @param name The name of the new snap. The name must be unique with respect to the other snaps
      defined for this column. An empty string can be provided, which will cause Fusion
      to use a default naming scheme to create a name.
      @param jointGeometry A JointGeometry object that defines how the snap is defined. When creating the JointGeometry
      object, it must be limited to geometry in the occurrence associated with the column.
      @returns Returns the newly created ConfigurationJointSnap.
    */
    add(name: string, jointGeometry: core.Base): ConfigurationJointSnap
  }

  /**
    This object represents an individual joint snap that has been defined for a
    ConfigurationJointSnapColumn. Multiple joint snaps can be defined for a column
    and then one of those joint snaps is specified in each cell of the column.
  */
  abstract class ConfigurationJointSnap extends core.Base {
    /**
      Gets and sets the name of the snap.
    */
    name: string
    /**
      Gets and sets the JointGeometry object for this snap.
    */
    jointGeometry: core.Base
    /**
      Deletes this joint snap.
      @returns Returns true if the deletion was successful.
    */
    deleteMe(): boolean
  }

  /**
    This object represents a joint snap that has been defined for a ConfigurationJointSnapColumn.
    Joint snaps are defined on the parent column, and the cell specifies which of the defined
    snaps will be used when the parent row of the cell is active.
  */
  abstract class ConfigurationJointSnapCell extends ConfigurationCell {
    /**
      Returns the column this cell is in.
    */
    readonly parentColumn: ConfigurationJointSnapColumn
    /**
      Gets and sets which snap will be used when the row this cell is in is active. When
      setting this property, only snaps defined for the  parent column of this cell
      can be used.
    */
    snap: ConfigurationJointSnap
  }

  /**
    Provides access to the construction planes within a component and provides
    methods to create new construction planes.
  */
  abstract class ConstructionPlanes extends core.Base {
    /**
      Function that returns the specified construction plane using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConstructionPlane | null
    /**
      Returns the specified construction plane using the name of the construction
      plane as it is displayed in the browser.
      @param name The name of the construction plane as it is displayed in the browser
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): ConstructionPlane | null
    /**
      Returns the number of construction planes in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Create a ConstructionPlaneInput object that is in turn used to create a ConstructionPlane.
      @param occurrenceForCreation A creation occurrence is needed if the input is in another component AND the
      construction plane is not in the root component. The occurrenceForCreation is analogous
      to the active occurrence in the UI.
      @returns Returns a ConstructionPlaneInput object
    */
    createInput(occurrenceForCreation?: Occurrence/* = null*/): ConstructionPlaneInput
    /**
      Creates and adds a new ConstructionPlane using the creation parameters in
      the ConstructionPlaneInput.
      If the ConstructionPlaneInput was defined using the setByPlane method then
      the add will only work in the direct modeling model and will fail in the parametric modeling mode.
      @param input A ConstructionPlaneInput object
      @returns Returns the newly created construction plane or null if the creation failed.
    */
    add(input: ConstructionPlaneInput): ConstructionPlane | null
    /**
      Returns the component that owns this collection.
    */
    readonly component: Component
  }

  /**
    A ConstructionPlaneInput is a throwaway object used to create a ConstructionPlane
    The usage pattern is:
    a. create a ConstructionPlaneInput (ConstructionPlanes.CreateInput)
    b. call one of the member functions to specify how the ConstructionPlane is created
    c. create the ConstructionPlane (call ConstructionPlanes.Add)
    d. stop referencing the ConstructionPlaneInput (so it gets deleted).
  */
  abstract class ConstructionPlaneInput extends core.Base {
    /**
      This input method is for creating a non-parametric construction plane positioned in
      space as defined by the input Plane object.
      This method of defining a construction plane is only valid when working in the direct modeling mode.
      This is not valid when working in the parametric modeling mode and will fail.
      @param plane A transient plane object
      @returns Returns true if the construction plane definition is successful.
    */
    setByPlane(plane: core.Plane): boolean
    /**
      This input method is for creating a construction plane that is offset from a planar
      face or construction plane at a specified distance. This can result in
      a parametric or non-parametric construction plane depending on whether the parent
      component is parametric or is a direct edit component.
      @param planarEntity A plane, planar face or construction plane from which to create the offset plane
      @param offset ValueInput object that specifies the offset distance for the plane
      @returns Returns true if the construction plane definition is successful.
    */
    setByOffset(planarEntity: core.Base, offset: core.ValueInput): boolean
    /**
      This input method is for creating a construction plane through an edge, axis or line
      at a specified angle. This can result in a parametric or non-parametric construction
      plane depending on whether the parent component is parametric or is a direct edit
      component.
      @param linearEntity The axis about which to rotate the plane
      @param angle The angle at which to create the plane
      @param planarEntity The planar face or construction plane the angle is measured from.
      @returns Returns true if the construction plane definition is successful.
    */
    setByAngle(linearEntity: core.Base, angle: core.ValueInput, planarEntity: core.Base): boolean
    /**
      This input method is for creating a construction plane tangent to a cylindrical or
      conical face at a specified point. This can result in a parametric or non-parametric construction
      plane depending on whether the parent component is parametric or is a direct edit
      component.
      @param tangentFace A cylindrical or conical face to create the plane tangent to
      @param angle The angle relative to the planarEntity input at which to create the tangent plane
      @param planarEntity The planar face or construction plane the tangent is measured from.
      @returns Returns true if the construction plane definition is successful.
    */
    setByTangent(tangentFace: BRepFace, angle: core.ValueInput, planarEntity: core.Base): boolean
    /**
      This input method is for creating a construction plane at the midpoint between
      two planar faces or construction planes. This can result in a parametric or
      non-parametric construction plane depending on whether the parent component is
      parametric or is a direct edit component.
      @param planarEntityOne The first planar face or construction plane to create a bisecting plane between
      @param planarEntityTwo The second planar face or construction plane to create a bisecting plane between
      @returns Returns true if the construction plane definition is successful.
      This will fail if the two planes are co-planar.
    */
    setByTwoPlanes(planarEntityOne: core.Base, planarEntityTwo: core.Base): boolean
    /**
      This input method is for creating a construction plane that passes through two
      coplanar linear entities or axes.
      Defines a plane by specifying two coplanar linear entities. This can result in a
      parametric or non-parametric construction plane depending on whether the parent
      component is parametric or is a direct edit component.
      @param linearEntityOne The first of two coplanar linear entities to define the plane
      @param linearEntityTwo The second of two coplanar linear entities to define the plane
      @returns Returns true if the construction plane definition is successful.
      This will fail if the two linear entities are not coplanar.
    */
    setByTwoEdges(linearEntityOne: core.Base, linearEntityTwo: core.Base): boolean
    /**
      This input method is for creating a construction plane through three points that
      define a triangle. This can result in a parametric or non-parametric construction
      plane depending on whether the parent component is parametric or is a direct edit
      component.
      @param pointEntityOne The first construction point, sketch point or vertex in the triangle
      @param pointEntityTwo The second construction point, sketch point or vertex in the triangle
      @param pointEntityThree The third construction point, sketch point or vertex in the triangle
      @returns Returns true if the construction plane definition is successful.
      This will fail if the points do not form a triangle (no two
      points can be coincident and all three cannot be collinear).
    */
    setByThreePoints(pointEntityOne: core.Base, pointEntityTwo: core.Base, pointEntityThree: core.Base): boolean
    /**
      This input method is for creating a construction plane tangent to a face
      and aligned to a point. This can result in a parametric or non-parametric
      construction plane depending on whether the parent component is parametric or is a
      direct edit component.
      @param tangentFace A face to create the plane tangent to
      @param pointEntity A construction point, sketch point or vertex the tangent plane aligns to.
      This point need not lie on the tangent face.
      @returns Returns true if the construction plane definition is successful.
    */
    setByTangentAtPoint(tangentFace: BRepFace, pointEntity: core.Base): boolean
    /**
      This input method is for creating a construction plane normal to, and at
      specified distance along, a path defined by an edge or sketch profile.
      This can result in a parametric or non-parametric
      construction plane depending on whether the parent component is parametric or is a
      direct edit component.
      @param pathEntity The path can be an edge, sketch curve, or a path of multiple entities.
      @param distance The distance is a value from 0 to 1 indicating the position along the path where 0
      is at the start and 1 is at the end.
      @returns Returns true if the construction plane definition is successful.
    */
    setByDistanceOnPath(pathEntity: core.Base, distance: core.ValueInput): boolean
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the ConstructionPlane is created based on geometry (e.g. a planarEntity)
      in another component AND (the ConstructionPlane) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      When creating a construction plane that is owned by a base or form feature, set this property to the
      base or form feature you want to associate the new construction plane with. By default, this is null,
      meaning it will not be associated with a base or form feature.
      Because of a current limitation, if you want to create a construction plane associated with a base
      or form feature, you must set this property AND call the startEdit method of the base or form feature,
      create the feature, and then call the finishEdit method of the base or form feature. The base or form
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseOrFormFeature: core.Base
    /**
      Defines a construction plane that is offset from a planar face or construction plane
      and whose offset distance is defined by a vertex, sketch point, or construction point where
      the plane passes through the point.
      @param planarEntity A planar BRepFace, ConstructionPlane, or Plane object that the new construction plane will be
      offset from. A Plane object is only valid in a direct-edit design or a base feature. In that case
      a non-parametric result is created.
      @param point A BRepVertex, SketchPoint, ConstructionPoint, or Point3D that defines the offset distance.
      A Point3D is only valid in a direct-edit design. In that case a non-parametric result is created.
      @returns Returns true if construction plane definition is successful.
    */
    setByOffsetThroughPoint(planarEntity: core.Base, point: core.Base): boolean
  }

  /**
    ConstructionPlane Object
  */
  abstract class ConstructionPlane extends core.Base {
    /**
      Returns a plane that represents the position and orientation of the construction plane.
      This geometry is defined in the AssemblyContext of this ConstructionPlane.
    */
    readonly geometry: core.Plane
    /**
      Returns the name of the construction plane as it is shown in the browser.
    */
    name: string
    /**
      Returns the ConstructionPlaneDefinition object which provides access to the information
      defining this ConstructionPlane.
    */
    readonly definition: ConstructionPlaneDefinition
    /**
      Deletes the construction plane.
      @returns Returns a bool indicating if the delete was successful or not.
    */
    deleteMe(): boolean
    /**
      Indicates if this construction plane can be deleted. Base
      construction planes can not be deleted.
    */
    readonly isDeletable: boolean
    /**
      Indicates if this construction plane is parametric or not.
    */
    readonly isParametric: boolean
    /**
      Indicates if the light bulb (as displayed in the browser) is on.
      A construction plane will only be visible if it's light bulb, and that of it's
      containing folder and parent component/s are also on.
    */
    isLightBulbOn: boolean
    /**
      Indicates if the construction plane is visible.
      This property is affected by the AssemblyContext of the construction plane.
    */
    readonly isVisible: boolean
    /**
      Gets and sets the display size of the construction plane. The bounding
      box defines the min and max corners of the plane as defined in the
      2D space of the construction plane.
    */
    displayBounds: core.BoundingBox2D
    /**
      Returns the parent component or base feature. If both the design and the construction
      plane are parametric, the parent will be a component. If the design is parametric and
      the construction plane is not, the parent will be a base feature. If
      the design is not parametric the parent will be a component.
    */
    readonly parent: core.Base
    /**
      Returns the component this construction plane belongs to.
    */
    readonly component: Component
    /**
      Returns the timeline object associated with this construction plane.
    */
    readonly timelineObject: TimelineObject
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ConstructionPlane
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ConstructionPlane | null
    /**
      If this construction plane is associated with a base feature, this property will return that base feature.
      If it's not associated with a base feature, this property will return null.
    */
    readonly baseFeature: BaseFeature
    /**
      Returns the collection of attributes associated with this construction plane.
    */
    readonly attributes: core.Attributes
    /**
      Returns the current health state of this construction plane.
    */
    readonly healthState: FeatureHealthStates
    /**
      Returns the error or warning message in the case where the healthState property returns either
      WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
    */
    readonly errorOrWarningMessage: string
    /**
      Returns the current position and orientation of the construction plane as a matrix.
      For a parametric construction plane, this property is read-only. For a construction
      plane in a direct modeling model or in a base feature, this is read-write and can be
      used to reposition the constructions plane.
    */
    transform: core.Matrix3D
    /**
      Returns a token for the ConstructionPlane object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same construction plane.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
  }

  /**
    A Base class to return the information, possibly parametric, used to define the ConstructionPlane.
  */
  abstract class ConstructionPlaneDefinition extends core.Base {
    /**
      Returns the ConstructionPlane object
    */
    readonly parentConstructionPlane: ConstructionPlane
  }

  /**
    The definition for a non-parametric construction plane. All constructions planes will
    return this type of definition regardless of method used to initially create them.
  */
  abstract class ConstructionPlaneByPlaneDefinition extends ConstructionPlaneDefinition {
    /**
      Gets and sets the position of the construction plane. Setting this property
      is only valid for a construction plane in a direct edit design or in a base feature.
      Construction planes in a parametric model are parametrically controlled and cannot
      be directly edited.
    */
    plane: core.Plane
  }

  /**
    ConstructionPlaneOffsetDefinition defines a construction plane that is offset by a specified
    distance from a planar face or construction plane by a specified distance. A positive or negative
    value can control the direction of the offset.
  */
  abstract class ConstructionPlaneOffsetDefinition extends ConstructionPlaneDefinition {
    /**
      Returns a Parameter object that controls the value of the offset. You can use properties
      of the returned Parameter object to modify the offset.
    */
    readonly offset: Parameter
    /**
      Gets the planar face or construction plane this construction plane
      is parametrically dependent on.
    */
    readonly planarEntity: core.Base
    /**
      Redefines the input geometry of the construction plane.
      @param offset ValueInput object that specifies the offset distance
      @param planarEntity A plane, planar face or construction plane from which to measure the offset from
      @returns Returns true is the operation is successful
    */
    redefine(offset: core.ValueInput, planarEntity: core.Base): boolean
  }

  /**
    ConstructionPlaneAtAngleDefinition defines a ConstructionPlane by an angle around
    a linear entity.
  */
  abstract class ConstructionPlaneAtAngleDefinition extends ConstructionPlaneDefinition {
    /**
      Returns a Parameter object that controls the value of the angle. You can use properties
      of the returned Parameter object to modify the angle.
    */
    readonly angle: Parameter
    /**
      Gets the linear edge, construction line, or sketch line that defines
      the axis of rotation for the construction plane.
    */
    readonly linearEntity: core.Base
    /**
      Gets the planar face or construction plane the angle for this
      construction plane is measured from and is parametrically dependent on.
      This property is only valid for construction planes that were created using
      the API. When an angle construction plane is created using the user interface
      the plane is not defined by the user and a plane is automatically inferred by
      Fusion. In this case, this property will return null.
    */
    readonly planarEntity: core.Base
    /**
      Redefines the input geometry of the construction plane.
      @param angle A ValueInput object that defines the angle at which to create the construction plane
      @param linearEntity The linear edge, construction line, or sketch line that defines the axis of rotation to
      measure the angle about
      @param planarEntity A plane, planar face or construction plane the angle of the construction plane is
      measured from
      @returns Returns true if the redefinition of the plane is successful.
    */
    redefine(angle: core.ValueInput, linearEntity: core.Base, planarEntity: core.Base): boolean
  }

  /**
    ConstructionPlaneTangentDefinition defines a ConstructionPlane tangent to a cylindrical or conical
    face at a point.
  */
  abstract class ConstructionPlaneTangentDefinition extends ConstructionPlaneDefinition {
    /**
      Returns a Value object that for a transient definition provides the current
      assigned value. For a definition associated with a construction plane, it
      provides access to the associated parameter controlling the angle.
    */
    readonly angle: Parameter
    /**
      Gets the cylindrical or conical face that the construction plane
      is tangent to.
    */
    readonly tangentFace: core.Base
    /**
      Gets the planar face or construction plane the angle for this
      construction plane is measured from and is parametrically dependent on.
    */
    readonly planarEntity: core.Base
    /**
      Redefines the input geometry of the construction plane.
      @param angle A Value object that defines the angle of the construction plane
      @param tangentFace The cylindrical or conical face that the construction plane is tangent to.
      @param planarEntity The planar face or construction plane the angle for this
      construction plane is measured from
      @returns Returns true if the redefinition of the plane is successful.
    */
    redefine(angle: core.ValueInput, tangentFace: core.Base, planarEntity: core.Base): boolean
  }

  /**
    ConstructionPlaneMidplaneDefinition defines a ConstructionPlane by...
  */
  abstract class ConstructionPlaneMidplaneDefinition extends ConstructionPlaneDefinition {
    /**
      Gets the first planar face or construction plane that defines this ConstructionPlane.
    */
    readonly planarEntityOne: core.Base
    /**
      Gets the second planar face or construction plane that defines this ConstructionPlane.
    */
    readonly planarEntityTwo: core.Base
    /**
      Redefines the input geometry of the construction plane.
      @param planarEntityOne The first planar face or construction plane that defines this ConstructionPlane.
      @param planarEntityTwo The second planar face or construction plane that defines this ConstructionPlane.
      @returns Returns true if the redefinition of the plane is successful.
    */
    redefine(planarEntityOne: core.Base, planarEntityTwo: core.Base): boolean
  }

  /**
    ConstructionPlaneTwoEdgesDefinition defines a ConstructionPlane by two co-planar
    linear entities like edges, sketch lines or construction axis.
  */
  abstract class ConstructionPlaneTwoEdgesDefinition extends ConstructionPlaneDefinition {
    /**
      Gets the first linear edge, construction line, or sketch line that defines
      the construction plane.
    */
    readonly linearEntityOne: core.Base
    /**
      Gets the second linear edge, construction line, or sketch line that defines
      the construction plane.
    */
    readonly linearEntityTwo: core.Base
    /**
      Redefines the input geometry of the construction plane.
      @param linearEntityOne The first linear edge, construction line, or sketch line that defines
      the construction plane.
      @param linearEntityTwo The second linear edge, construction line, or sketch line that defines
      the construction plane.
      @returns Returns true if successful.
    */
    redefine(linearEntityOne: core.Base, linearEntityTwo: core.Base): boolean
  }

  /**
    ConstructionPlaneThreePointDefinition defines a ConstructionPlane by 3 point entities
    (e.g. (sketch points, vertices or construction points) that form a triangle (i.e.
    no two points the same and they aren't collinear).
  */
  abstract class ConstructionPlaneThreePointsDefinition extends ConstructionPlaneDefinition {
    /**
      Gets the first construction point, sketch point or vertex.
    */
    readonly pointEntityOne: core.Base
    /**
      Gets the second construction point, sketch point or vertex.
    */
    readonly pointEntityTwo: core.Base
    /**
      Gets the third construction point, sketch point or vertex.
    */
    readonly pointEntityThree: core.Base
    /**
      Redefines the input geometry of the construction plane.
      @param pointEntityOne Gets the first construction point, sketch point or vertex.
      @param pointEntityTwo Gets the second construction point, sketch point or vertex.
      @param pointEntityThree Gets the third construction point, sketch point or vertex.
      @returns Returns true if the redefinition of the plane is successful.
    */
    redefine(pointEntityOne: core.Base, pointEntityTwo: core.Base, pointEntityThree: core.Base): boolean
  }

  /**
    ConstructionPlaneTangentAtPointDefinition defines a ConstructionPlane tangent to a
    face and aligned to a point.
  */
  abstract class ConstructionPlaneTangentAtPointDefinition extends ConstructionPlaneDefinition {
    /**
      Gets the tangent face.
    */
    readonly tangentFace: BRepFace
    /**
      Gets the point (sketch point, vertex, construction point) used to align the plane.
    */
    readonly pointEntity: core.Base
    /**
      Redefines the input geometry of the construction plane.
      @param tangentFace The face to create the plane tangent to
      @param pointEntity The point (sketch point, vertex, construction point) used to align the plane.
      @returns Returns true if the redefinition of the plane is successful.
    */
    redefine(tangentFace: core.Base, pointEntity: core.Base): boolean
  }

  /**
    ConstructionDistanceOnPathDefinition defines a ConstructionPlane normal to an edge or
    sketch profile at a specified position along the path defined by the edge or sketch profile.
  */
  abstract class ConstructionPlaneDistanceOnPathDefinition extends ConstructionPlaneDefinition {
    /**
      Gets the sketch curve, edge, or a profile object.
    */
    readonly pathEntity: core.Base
    /**
      Redefines the input defining the construction plane.
      @param pathEntity The sketch curve, edge, or a profile object
      @param distance The ValueInput object that defines the distance along the path
      @returns Returns true if the redefinition of the plane is successful.
    */
    redefine(pathEntity: core.Base, distance: core.ValueInput): boolean
    /**
      Gets the distance along the path.
    */
    readonly distance: Parameter
  }

  /**
    Defines a construction plane that is offset from a planar face or construction plane
    and whose offset distance is defined by a vertex, sketch point, or construction point where
    the plane passes through the point.
  */
  abstract class ConstructionPlaneOffsetThroughPointDefinition extends ConstructionPlaneDefinition {
    /**
      Returns the point that controls the offset.
    */
    readonly point: core.Base
    /**
      Returns the planar face or construction plane this construction plane
      is parametrically dependent on.
    */
    readonly planarEntity: core.Base
    /**
      Redefines the input geometry of the construction plane.
      @param planarEntity A planar BRepFace or ConstructionPlane that the new construction plane will be offset from.
      @param point A BRepVertex, SketchPoint, or ConstructionPoint that defines the offset distance.
      @returns Returns true is the operation is successful
    */
    redefine(planarEntity: core.Base, point: core.Base): boolean
  }

  /**
    Provides access to the construction axes within a component and provides
    methods to create new construction axes.
  */
  abstract class ConstructionAxes extends core.Base {
    /**
      Function that returns the specified construction axis using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConstructionAxis | null
    /**
      Returns the specified construction axis using the name of the construction
      axis as it is displayed in the browser.
      @param name The name of the axis as it is displayed in the browser
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): ConstructionAxis | null
    /**
      The number of construction axes in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Create a ConstructionAxisInput object that is in turn used to create a ConstructionAxis.
      @param occurrenceForCreation A creation occurrence is needed if the input is in another component AND the
      construction axis is not in the root component. The occurrenceForCreation is analogous
      to the active occurrence in the UI.
      @returns Returns a ConstructionAxisInput object
    */
    createInput(occurrenceForCreation?: Occurrence/* = null*/): ConstructionAxisInput
    /**
      Creates and adds a new ConstructionAxis using the creation parameters in the ConstructionAxisInput.
      If the ConstructionAxisInput was defined using the setByLine method then
      the add will only work in the direct modeling mode and will fail in the parametric modeling mode.
      @param input A ConstructionAxisInput object
      @returns Returns the newly created construction axis or null if the creation failed.
    */
    add(input: ConstructionAxisInput): ConstructionAxis | null
    /**
      The component that owns this collection.
    */
    readonly component: Component
  }

  /**
    A ConstructionAxisInput is a throwaway object used to create a ConstructionAxis
    The usage pattern is:
    a. create a ConstructionAxisInput (ConstructionAxes.CreateInput)
    b. call one of the member functions to specify how the ConstructionAxis is created
    c. create the ConstructionAxis (call ConstructionAxes.Add)
    d. stop referencing the ConstructionAxisInput (so it gets deleted).
  */
  abstract class ConstructionAxisInput extends core.Base {
    /**
      This input method is for creating a non-parametric construction axis whose position
      in space is defined by an InfiniteLine3D object.
      This method of defining a construction axis is only valid when working in the direct modeling mode.
      This is not valid when working in the parametric modeling mode and will fail.
      @param line An InFiniteLine3D object
      @returns Returns true if the creation of the ConstructionAxisInput is successful.
    */
    setByLine(line: core.InfiniteLine3D): boolean
    /**
      This input method is for creating an axis coincident with the axis of a
      cylindrical, conical or torus face.
      This can result in a parametric or non-parametric construction axis depending
      on whether the parent component is parametric or is a direct edit component.
      @param circularFace The face from a cylinder, cone, or torus.
      @returns Returns true if the creation of the ConstructionAxisInput is successful.
    */
    setByCircularFace(circularFace: BRepFace): boolean
    /**
      This input method is for creating an axis that is normal to a face
      at a specified point.
      @param face A face (BRepFace object) to create the axis normal to.
      @param pointEntity A construction point, sketch point or vertex the axis is to pass through.
      @returns Returns true if the creation of the ConstructionAxisInput is successful.
    */
    setByPerpendicularAtPoint(face: BRepFace, pointEntity: core.Base): boolean
    /**
      This input method is for creating a construction axis coincident with the
      intersection of two planes or planar faces.
      This will fail if the two planes are parallel.
      This can result in a parametric or non-parametric construction axis depending
      on whether the parent component is parametric or is a direct edit component.
      @param planarEntityOne The first planar face or construction plane to intersect
      @param planarEntityTwo The second planar face or construction plane to intersect
      @returns Returns true if the creation of the ConstructionAxisInput is successful.
    */
    setByTwoPlanes(planarEntityOne: core.Base, planarEntityTwo: core.Base): boolean
    /**
      This input method is for creating a construction axis that passes through the two points
      (work points, sketch points or vertices).
      This will fail if the two points are coincident.
      This can result in a parametric or non-parametric construction axis depending
      on whether the parent component is parametric or is a direct edit component.
      @param pointEntityOne The first construction point, sketch point or vertex the axis passes through
      @param pointEntityTwo The second construction point, sketch point or vertex the axis passes through
      @returns Returns true if the creation of the ConstructionAxisInput is successful.
    */
    setByTwoPoints(pointEntityOne: core.Base, pointEntityTwo: core.Base): boolean
    /**
      This input method is for creating a construction axis from a specified linear/circular edge
      or sketch curve.
      This can result in a parametric or non-parametric construction axis depending
      on whether the parent component is parametric or is a direct edit component.
      @param edgeEntity A linear/circular edge, construction line, or sketch line
      @returns Returns true if the creation of the ConstructionAxisInput is successful.
    */
    setByEdge(edgeEntity: core.Base): boolean
    /**
      This input method if for creating a construction axis normal to a specified face
      or sketch profile and that passes through a specified point.
      This can result in a parametric or non-parametric construction axis depending
      on whether the parent component is parametric or is a direct edit component.
      @param face The face (BRepFace object) to create the axis normal to.
      @param pointEntity A construction point, sketch point or vertex the axis passes through.
      This point does not have to lie on the face.
      @returns Returns true if the creation of the ConstructionAxisInput is successful.
    */
    setByNormalToFaceAtPoint(face: BRepFace, pointEntity: core.Base): boolean
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs
      to be specified when the ConstructionAxis is created based on geometry
      (e.g. a straight edge) in another component AND (the ConstructionAxis) is not in the
      root component. The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      When creating a construction axis that is owned by a base or form feature, set this property to the
      base or form feature you want to associate the new construction plane with. By default, this is null,
      meaning it will not be associated with a base or form feature.
      Because of a current limitation, if you want to create a construction axis associated with a base
      or form feature, you must set this property AND call the startEdit method of the base or form feature,
      create the feature, and then call the finishEdit method of the base or form feature. The base or form
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseOrFormFeature: core.Base
  }

  /**
    ConstructionAxis Object
  */
  abstract class ConstructionAxis extends core.Base {
    /**
      Returns an infinite line that represents the position and orientation of the
      construction axis. This geometry is defined in the AssemblyContext of this
      ConstructionAxis.
    */
    readonly geometry: core.InfiniteLine3D
    /**
      The name of the construction axis as it is shown in the browser.
    */
    name: string
    /**
      Returns the construction axis definition object which provides access to the information
      defining the construction axis.
    */
    readonly definition: ConstructionAxisDefinition
    /**
      Deletes the construction axis.
      @returns Returns a bool indicating if the delete was successful or not.
    */
    deleteMe(): boolean
    /**
      Indicates if this construction axis is parametric or not.
    */
    readonly isParametric: boolean
    /**
      Indicates if this construction axis can be deleted. Base
      construction axes can not be deleted.
    */
    readonly isDeletable: boolean
    /**
      Indicates if the light bulb (as displayed in the browser) is on.
      A construction axis will only be visible if it's light bulb, and that of it's
      containing folder and parent component/s are also on.
    */
    isLightBulbOn: boolean
    /**
      Gets if the construction plane is visible.
      This property is affected by the AssemblyContext of the construction axis.
    */
    readonly isVisible: boolean
    /**
      Returns the parent component or base feature. If both the design and the construction
      axis are parametric, the parent will be a component. If the design is parametric and
      the construction axis is not, the parent will be a base feature. If
      the design is not parametric the parent will be a component.
    */
    readonly parent: core.Base
    /**
      Returns the component this construction plane belongs to.
    */
    readonly component: Component
    /**
      Returns the timeline object associated with this construction axis.
    */
    readonly timelineObject: TimelineObject
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ConstructionAxis
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ConstructionAxis | null
    /**
      If this construction axis is associated with a base feature, this property will return that base feature.
      If it's not associated with a base feature, this property will return null.
    */
    readonly baseFeature: BaseFeature
    /**
      Returns the collection of attributes associated with this construction axis.
    */
    readonly attributes: core.Attributes
    /**
      Returns the current health state of this construction axis.
    */
    readonly healthState: FeatureHealthStates
    /**
      Returns the error or warning message in the case where the healthState property returns either
      WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
    */
    readonly errorOrWarningMessage: string
    /**
      Returns a token for the ConstructionAxis object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same construction axis.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
  }

  /**
    A Base class to return the information (possibly parametric) used to
    define a ConstructionAxis.
  */
  abstract class ConstructionAxisDefinition extends core.Base {
    /**
      Returns the ConstructionAxis object
    */
    readonly parentConstructionAxis: ConstructionAxis
  }

  /**
    The definition for a non-parametric construction axis. In a non-parametric design
    all construction planes will return this type of definition regardless of how they
    were initially created.
  */
  abstract class ConstructionAxisByLineDefinition extends ConstructionAxisDefinition {
    /**
      Gets and sets the infinite line that defines the position and direction of the axis
    */
    axis: core.InfiniteLine3D
  }

  /**
    The definition for a parametric construction axis created using the SetbyCircularFace method
  */
  abstract class ConstructionAxisCircularFaceDefinition extends ConstructionAxisDefinition {
    /**
      Gets and sets the cylinder, cone, or torus this work axis
      is parametrically dependent on.
    */
    circularFace: BRepFace
  }

  /**
    The definition for a parametric construction axis created using the
    SetByPerpendicularAtPoint method
  */
  abstract class ConstructionAxisPerpendicularAtPointDefinition extends ConstructionAxisDefinition {
    /**
      Returns the face the construction axis is perpendicular to.
    */
    readonly face: BRepFace
    /**
      Returns the point (construction or sketch point) that positions the axis.
    */
    readonly point: core.Base
    /**
      Redefines the input geometry of the construction axis.
      @param face The face (BRepFace object) to create the axis perpendicular to.
      @param pointEntity The point (sketch point, vertex, construction point) used to position the axis.
      @returns Returns true if the redefinition of the axis is successful.
    */
    redefine(face: BRepFace, pointEntity: core.Base): boolean
  }

  /**
    The definition for a parametric construction axis created using the SetByTwoPlanes method
  */
  abstract class ConstructionAxisTwoPlaneDefinition extends ConstructionAxisDefinition {
    /**
      Gets the first planar face or construction plane
    */
    readonly planarEntityOne: core.Base
    /**
      Gets the second planar face or construction plane
    */
    readonly planarEntityTwo: core.Base
    /**
      Redefines the input geometry of the construction axis.
      @param planarEntityOne The first planar face or construction plane
      @param planarEntityTwo The second planar face or construction plane
      @returns Returns true if the redefinition of the axis is successful.
    */
    redefine(planarEntityOne: core.Base, planarEntityTwo: core.Base): boolean
  }

  /**
    The definition for a parametric construction axis created using the SetbyTwoPoints method
  */
  abstract class ConstructionAxisTwoPointDefinition extends ConstructionAxisDefinition {
    /**
      Gets the first point.
    */
    readonly pointEntityOne: core.Base
    /**
      Gets the second point.
    */
    readonly pointEntityTwo: core.Base
    /**
      Redefines the input geometry of the construction axis.
      @param pointEntityOne The first point
      @param pointEntityTwo The second point
      @returns Returns true if the redefinition of the construction axis is successful.
    */
    redefine(pointEntityOne: core.Base, pointEntityTwo: core.Base): boolean
  }

  /**
    The definition for a parametric construction axis created using the SetbyEdge method
  */
  abstract class ConstructionAxisEdgeDefinition extends ConstructionAxisDefinition {
    /**
      Gets and sets the linear edge, construction line, or sketch line that defines
      the construction axis.
    */
    edgeEntity: core.Base
  }

  /**
    The definition for a parametric construction axis created using the
    SetByNormalToFaceAtPoint method
  */
  abstract class ConstructionAxisNormalToFaceAtPointDefinition extends ConstructionAxisDefinition {
    /**
      Gets the face the axis is normal to
    */
    readonly face: core.Base
    /**
      Gets the point that positions the axis
    */
    readonly pointEntity: core.Base
    /**
      Redefines the input geometry of the construction axis.
      @param face The face the axis is normal to
      @param pointEntity The point that positions the axis
      @returns Returns true if the redefinition of the construction axis is successful.
    */
    redefine(face: core.Base, pointEntity: core.Base): boolean
  }

  /**
    Provides access to the construction points within a component and provides
    methods to create new construction points.
  */
  abstract class ConstructionPoints extends core.Base {
    /**
      Function that returns the specified construction point using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ConstructionPoint | null
    /**
      Returns the specified construction point using the name of the construction
      point as it is displayed in the browser.
      @param name The name of the construction point as it is displayed in the browser.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): ConstructionPoint | null
    /**
      The number of construction points in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Create a ConstructionPointInput object that is in turn used
      to create a ConstructionPoint.
      @param occurrenceForCreation A creation occurrence is needed if the input is in another component AND the
      construction point is not in the root component. The occurrenceForCreation is analogous
      to the active occurrence in the UI.
      @returns Returns a ConstructionPointInput object
    */
    createInput(occurrenceForCreation?: Occurrence/* = null*/): ConstructionPointInput
    /**
      Creates a new construction point.
      If the ConstructionPointInput was defined using the setByPoint method using a Point3D object then
      the add will only work in the direct modeling mode and will fail in the parametric modeling mode.
      @param input A ConstructionPointInput object
      @returns Returns the newly created construction point or null if the creation failed.
    */
    add(input: ConstructionPointInput): ConstructionPoint | null
    /**
      The component that owns this collection.
    */
    readonly component: Component
  }

  /**
    A ConstructionPointInput is a throwaway object used to create a ConstructionPoint
    The usage pattern is
    a. create a ConstructionPointInput (ConstructionPoints.CreateInput)
    b. call one of the member functions to specify how the ConstructionPoint is created
    c. create the ConstructionPoint (call ConstructionPoints.Add)
    d. stop referencing the ConstructionPointInput (so it gets deleted).
  */
  abstract class ConstructionPointInput extends core.Base {
    /**
      This input method is for creating a construction point at the intersection of
      the two linear edges or sketch lines.
      The edges can be B-Rep edges or sketch lines.
      This can result in a parametric or non-parametric construction point depending
      on whether the parent component is parametric or is a direct edit component.
      @param edgeOne The first B-Rep edge or sketch line
      @param edgeTwo The second B-Rep edge or sketch line
      @returns Returns true if the creation of the ConstructionPointInput is successful.
    */
    setByTwoEdges(edgeOne: core.Base, edgeTwo: core.Base): boolean
    /**
      This input method is for creating a construction point at the intersection of the
      three planes or planar faces.
      This can result in a parametric or non-parametric construction point depending
      on whether the parent component is parametric or is a direct edit component.
      @param planeOne The first plane or planar face to intersect
      @param planeTwo The second plane or planar face to intersect
      @param planeThree The third plane or planar face to intersect
      @returns Returns true if the creation of the ConstructionPointInput is successful.
    */
    setByThreePlanes(planeOne: core.Base, planeTwo: core.Base, planeThree: core.Base): boolean
    /**
      This input method is for creating a construction point at the intersection of a
      construction plane, planar face or sketch profile and a linear edge, construction axis
      or sketch line.
      This can result in a parametric or non-parametric construction point depending
      on whether the parent component is parametric or is a direct edit component.
      @param edge A linear B-Rep edge, construction axis or sketch line.
      @param plane A plane, planar B-Rep face or construction plane.
      @returns Returns true if the creation of the ConstructionPointInput is successful.
    */
    setByEdgePlane(edge: core.Base, plane: core.Base): boolean
    /**
      This input method is for creating a construction point at the center of a spherical
      face (sphere or torus), circular edge or sketch arc/circle
      This can result in a parametric or non-parametric construction point depending
      on whether the parent component is parametric or is a direct edit component.
      @param circularEntity A spherical face (sphere or torus), circular edge or sketch arc/circle
      @returns Returns true if the creation of the ConstructionPointInput is successful.
    */
    setByCenter(circularEntity: core.Base): boolean
    /**
      This input method is for creating a construction point on the specified point
      or vertex. The point can be either a B-Rep vertex, SketchPoint, or a Point3D object.
      Providing a Point3D object is only valid when working in the direct edit modeling mode.
      This is not valid when working in the parametric modeling mode and will fail.
      Even when providing a B-Rep vertex, or SketchPoint the result will be non-parametric
      if the parent component is a direct edit component.
      @param point A B-Rep vertex, SketchPoint, or Point object
      @returns Returns true if the creation of the ConstructionPointInput is successful.
    */
    setByPoint(point: core.Base): boolean
    /**
      In order for geometry to be transformed correctly, an occurrence for creation needs
      to be specified when the ConstructionPoint is created based on geometry
      (e.g. a sketch point) in another component AND (the ConstructionPoint) is not in the
      root component. The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      When creating a construction point that is owned by a base or form feature, set this property to the
      base or form feature you want to associate the new construction point with. By default, this is null,
      meaning it will not be associated with a base or form feature.
      Because of a current limitation, if you want to create a construction point associated with a base
      or form feature, you must set this property AND call the startEdit method of the base or form feature,
      create the feature, and then call the finishEdit method of the base or form feature. The base or form
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseOrFormFeature: core.Base
  }

  /**
    ConstructionPoint Object
  */
  abstract class ConstructionPoint extends core.Base {
    /**
      Returns a Point3D object that represents the position of the construction point.
      The returned geometry is in the AssemblyContext of this ConstructionPoint.
    */
    readonly geometry: core.Point3D
    /**
      The name of the construction point as it is displayed in the browser.
    */
    name: string
    /**
      Returns the construction point definition object which provides access to the
      information defining the construction point.
    */
    readonly definition: ConstructionPointDefinition
    /**
      Deletes the construction point.
      @returns Returns a bool indicating if the delete was successful or not.
    */
    deleteMe(): boolean
    /**
      Indicates if this construction point can be deleted. The base
      construction point cannot be deleted.
    */
    readonly isDeletable: boolean
    /**
      Indicates if the light bulb (as displayed in the browser) is on.
      A construction point will only be visible if it's light bulb, and that of it's
      containing folder and parent component/s are also on.
    */
    isLightBulbOn: boolean
    /**
      Gets if the construction point is visible.
      This property is affected by the AssemblyContext of the construction point.
    */
    readonly isVisible: boolean
    /**
      Returns the parent component or base feature. If both the design and the construction
      point are parametric, the parent will be a component. If the design is parametric and
      the construction point is not, the parent will be a base feature. If
      the design is not parametric the parent will be a component.
    */
    readonly parent: core.Base
    /**
      Returns the component this construction point belongs to.
    */
    readonly component: Component
    /**
      Indicates if the construction point is parametric.
    */
    readonly isParametric: boolean
    /**
      Returns the timeline object associated with this construction point.
    */
    readonly timelineObject: TimelineObject
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ConstructionPoint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ConstructionPoint | null
    /**
      If this construction point is associated with a base feature, this property will return that base feature.
      If it's not associated with a base feature, this property will return null.
    */
    readonly baseFeature: BaseFeature
    /**
      Returns the collection of attributes associated with this construction point.
    */
    readonly attributes: core.Attributes
    /**
      Returns the current health state of this construction point.
    */
    readonly healthState: FeatureHealthStates
    /**
      Returns the error or warning message in the case where the healthState property returns either
      WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
    */
    readonly errorOrWarningMessage: string
    /**
      Returns a token for the ConstructionPoint object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same construction point.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
  }

  /**
    A Base class to return the information (possibly parametric) used to
    define a ConstructionPoint.
  */
  abstract class ConstructionPointDefinition extends core.Base {
    /**
      Returns the ConstructionPoint object
    */
    readonly parentConstructionPoint: ConstructionPoint
  }

  /**
    The definition for a parametric construction point created using the SetbyTwoEdges method
  */
  abstract class ConstructionPointTwoEdgesDefinition extends ConstructionPointDefinition {
    /**
      Returns a B-Rep edge or sketch line
    */
    readonly edgeOne: core.Base
    /**
      Returns a B-Rep edge or sketch line
    */
    readonly edgeTwo: core.Base
    /**
      Redefines the input geometry of the construction point.
      @param edgeOne The first B-Rep edge or sketch line
      @param edgeTwo The second B-Rep edge or sketch line
      @returns Returns true if the redefinition of the Construction Point is successful.
    */
    redefine(edgeOne: core.Base, edgeTwo: core.Base): boolean
  }

  /**
    The definition for a parametric construction point created using the SetbyThreePlanes method
  */
  abstract class ConstructionPointThreePlanesDefinition extends ConstructionPointDefinition {
    /**
      The first plane or planar face
    */
    readonly planeOne: core.Base
    /**
      The second plane or planar face
    */
    readonly planeTwo: core.Base
    /**
      The third plane or planar face
    */
    readonly planeThree: core.Base
    /**
      Redefines the input geometry of the construction point.
      @param planeOne The first plane or planar face to intersect
      @param planeTwo The second plane or planar face to intersect
      @param planeThree The third plane or planar face to intersect
      @returns Returns true if the redefinition of the Construction Point is successful.
    */
    redefine(planeOne: core.Base, planeTwo: core.Base, planeThree: core.Base): boolean
  }

  /**
    The definition for a parametric construction point created using the SetbyEdgePlane method
  */
  abstract class ConstructionPointEdgePlaneDefinition extends ConstructionPointDefinition {
    /**
      A linear B-Rep edge, construction axis or sketch line.
    */
    readonly edge: core.Base
    /**
      A plane, planar B-Rep face or construction plane.
    */
    readonly plane: core.Base
    /**
      Redefines the input geometry of the construction point.
      @param edge A linear B-Rep edge, construction axis or sketch line.
      @param plane A plane, planar B-Rep face or construction plane.
      @returns Returns true if the redefinition of the Construction Point is successful.
    */
    redefine(edge: core.Base, plane: core.Base): boolean
  }

  /**
    The definition for a parametric construction point created using the SetbyCenter method
  */
  abstract class ConstructionPointCenterDefinition extends ConstructionPointDefinition {
    /**
      Gets and sets the spherical face (sphere or torus), circular edge or sketch arc/circle
      whose center defines the location for the construction point.
    */
    circularEntity: core.Base
  }

  /**
    The definition for a parametric construction point created using the SetbyPoint method
    All non-parametric constructions points will return this type of definition regardless
    of the method used to initially create them.
  */
  abstract class ConstructionPointPointDefinition extends ConstructionPointDefinition {
    /**
      Gets and sets the position of the point using a construction point, sketch point or
      vertex.
      Non-parametric points will always return a Point3D object
    */
    pointEntity: core.Base
  }

  /**
    The features collection which provides access to all existing features. This collection
    provides direct access to all features regardless of type. It also provides access
    to type specific collections where you can get features of a specific type and also create
    new features of that type.
  */
  abstract class Features extends core.Base {
    /**
      Function that returns the specified feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Feature | null
    /**
      Returns the number of features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the collection that provides access to the extrude features within the component
      and supports the creation of new extrude features.
    */
    readonly extrudeFeatures: ExtrudeFeatures
    /**
      Returns the collection that provides access to the revolve features within the component
      and supports the creation of new revolved features.
    */
    readonly revolveFeatures: RevolveFeatures
    /**
      Returns the collection that provides access to the hole features within the component
      and supports the creation of new hole features.
    */
    readonly holeFeatures: HoleFeatures
    /**
      Returns the collection that provides access to the fillet features within the component
      and supports the creation of new fillet features.
    */
    readonly filletFeatures: FilletFeatures
    /**
      Returns the collection that provides access to the sweep features within the component
      and supports the creation of new sweep features.
    */
    readonly sweepFeatures: SweepFeatures
    /**
      Returns the collection that provides access to the chamfer features within the component
      and supports the creation of new chamfer features.
    */
    readonly chamferFeatures: ChamferFeatures
    /**
      Returns the collection that provides access to the shell features within the component
      and supports the creation of new shell features.
    */
    readonly shellFeatures: ShellFeatures
    /**
      Returns the collection that provides access to the mirror features within the component
      and supports the creation of new mirror features.
    */
    readonly mirrorFeatures: MirrorFeatures
    /**
      Returns the collection that provides access to the circular pattern features within the component
      and supports the creation of new circular pattern features.
    */
    readonly circularPatternFeatures: CircularPatternFeatures
    /**
      Returns the collection that provides access to the rectangular pattern features within the component
      and supports the creation of new rectangular pattern features.
    */
    readonly rectangularPatternFeatures: RectangularPatternFeatures
    /**
      Returns the collection that provides access to the path pattern features within the component
      and supports the creation of new path pattern features.
    */
    readonly pathPatternFeatures: PathPatternFeatures
    /**
      Returns the collection that provides access to the combine features within the component
      and supports the creation of new combine features.
    */
    readonly combineFeatures: CombineFeatures
    /**
      Returns the collection that provides access to the thread features within the component
      and supports the creation of new thread features.
    */
    readonly threadFeatures: ThreadFeatures
    /**
      Returns the collection that provides access to the draft features within the component
      and supports the creation of new draft features.
    */
    readonly draftFeatures: DraftFeatures
    /**
      Returns the collection that provides access to the scale features within the component
      and supports the creation of new scale features.
    */
    readonly scaleFeatures: ScaleFeatures
    /**
      Method that creates a Path used to define the shape of a Sweep feature. A Path is a contiguous
      set of curves that can be a combination of sketch curves and model edges.
      @param curve A SketchCurve or an ObjectCollection containing multiple sketch entities and/or BRepEdge objects. If a single sketch curve
      or edge is input the isChain argument is checked to determine if connected curves (they do not need to be tangent)
      should be automatically found. If multiple curves are provided the isChain argument is always
      treated as false so you must provide all of the curves in the object collection that you want included in the path.
      The provided curves must all connect together in a single path.
      The input curves can be from multiple sketches and bodies and they need to geometrically connect for
      a valid path to be created.
      @param isChain Optional argument, that defaults to true. If this argument is set to true, all curves and edges that are end point
      connected to the single input curve will be found and used to create the path.
      This argument is only used when the first argument is a single SketchCurve/BRepEdge object.
      @returns Returns the newly created Path.
    */
    createPath(curve: core.Base, isChain?: boolean/* = true*/): Path
    /**
      Returns the collection that provides access to the replaceFace features within the component
      and supports the creation of new replaceFace features.
    */
    readonly replaceFaceFeatures: ReplaceFaceFeatures
    /**
      Returns the collection that provides access to the Move features within the component
      and supports the creation of new Move features.
    */
    readonly moveFeatures: MoveFeatures
    /**
      Returns the collection that provides access to the SplitFace features within the component and supports the creation
      of new SplitFace features
    */
    readonly splitFaceFeatures: SplitFaceFeatures
    /**
      Returns the collection that provides access to the SplitBody features within the component and supports the creation
      of new SplitBody features
    */
    readonly splitBodyFeatures: SplitBodyFeatures
    /**
      Returns the collection that provides access to the Parting Line Split features within the component and supports
      the creation of new Parting Line Split features
    */
    readonly silhouetteSplitFeatures: SilhouetteSplitFeatures
    /**
      Returns the collection that provides access to the Offset features within the component
      and supports the creation of new Offset features.
    */
    readonly offsetFeatures: OffsetFeatures
    /**
      Returns the collection that provides access to the Extend features within the component
      and supports the creation of new Extend features.
    */
    readonly extendFeatures: ExtendFeatures
    /**
      Returns the collection that provides access to the Stitch features within the component
      and supports the creation of new Stitch features.
    */
    readonly stitchFeatures: StitchFeatures
    /**
      Returns the collection that provides access to the Boundary Fill features within the component
      and supports the creation of new Boundary Fill features.
    */
    readonly boundaryFillFeatures: BoundaryFillFeatures
    /**
      Returns the collection that provides access to the Trim features within the component
      and supports the creation of new Trim features.
    */
    readonly trimFeatures: TrimFeatures
    /**
      Returns the collection that provides access to the Thicken features within the component
      and supports the creation of new Thicken features.
    */
    readonly thickenFeatures: ThickenFeatures
    /**
      Returns the collection that provides access to the Unstitch features within the component
      and supports the creation of new Unstitch features.
    */
    readonly unstitchFeatures: UnstitchFeatures
    /**
      Returns the collection that provides access to the Remove features within the component
      and supports the creation of new Remove features.
    */
    readonly removeFeatures: RemoveFeatures
    /**
      Returns the collection that provides access to the existing base features
      and supports the creation of new base features. A base feature represents
      a body that is non-parametric.
    */
    readonly baseFeatures: BaseFeatures
    /**
      Returns the collection that provides access to the Coil Primitive features within the component.
    */
    readonly coilFeatures: CoilFeatures
    /**
      Returns the collection that provides access to the existing box features.
    */
    readonly boxFeatures: BoxFeatures
    /**
      Returns the collection that provides access to the existing cylinder features.
    */
    readonly cylinderFeatures: CylinderFeatures
    /**
      Returns the collection that provides access to the existing sphere features.
    */
    readonly sphereFeatures: SphereFeatures
    /**
      Returns the collection that provides access to the existing torus features.
    */
    readonly torusFeatures: TorusFeatures
    /**
      Returns the collection that provides access to the existing pipe features.
    */
    readonly pipeFeatures: PipeFeatures
    /**
      Returns the collection that provides access to the existing rib features.
    */
    readonly ribFeatures: RibFeatures
    /**
      Returns the collection that provides access to the existing web features.
    */
    readonly webFeatures: WebFeatures
    /**
      Returns the collection that provides access to the existing form features.
    */
    readonly formFeatures: FormFeatures
    /**
      Returns the collection that provides access to the Reverse Normal features within the component
      and supports the creation of new Reverse Normal features.
    */
    readonly reverseNormalFeatures: ReverseNormalFeatures
    /**
      Returns the collection that provides access to the Patch features within the component
      and supports the creation of new Patch features.
    */
    readonly patchFeatures: PatchFeatures
    /**
      Returns the collection that provides access to the existing loft features and
      supports the creation of new loft features.
    */
    readonly loftFeatures: LoftFeatures
    /**
      Returns the collection that provides access to the existing form features.
    */
    readonly ruleFilletFeatures: RuleFilletFeatures
    /**
      Function that returns the specified feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the same name seen in the timeline.
      @returns Returns the specified item or null if a feature matching the name was not found.
    */
    itemByName(name: string): Feature | null
    /**
      Returns the collection that provides access to the existing Surface Delete Face features.
    */
    readonly surfaceDeleteFaceFeatures: SurfaceDeleteFaceFeatures
    /**
      Returns the collection that provides access to the existing Delete Face features.
    */
    readonly deleteFaceFeatures: DeleteFaceFeatures
    /**
      Returns the collection that provides access to the existing Offset Face features.
    */
    readonly offsetFacesFeatures: OffsetFacesFeatures
    /**
      Returns the collection that provides access to the existing copy-paste features
      and supports the creation of new copy-paste features.
    */
    readonly copyPasteBodies: CopyPasteBodies
    /**
      Returns the collection that provides access to the existing cut-paste features
      and supports the creation of new cut-paste features.
    */
    readonly cutPasteBodies: CutPasteBodies
    /**
      Returns the collection that provides access to the existing flange features.
    */
    readonly flangeFeatures: FlangeFeatures
    /**
      Returns the collection that provides access to the existing unfold features.
    */
    readonly unfoldFeatures: UnfoldFeatures
    /**
      Returns the collection that provides access to the existing refold features.
    */
    readonly refoldFeatures: RefoldFeatures
    /**
      Returns the collection that provides access to the Ruled Surface features within the component
      and supports the creation of new Ruled Surface features.
    */
    readonly ruledSurfaceFeatures: RuledSurfaceFeatures
    /**
      Returns the collection that provides access to the custom features within the component
      and supports the creation of new custom features.
      @experimental
    */
    readonly customFeatures: CustomFeatures
    /**
      Returns the collection that provides access to the Untrim features within the component
      and supports the creation of new Untrim features.
    */
    readonly untrimFeatures: UntrimFeatures
    /**
      Returns the collection that provides access to the boss features within the component
      and supports the creation of new boss features.
    */
    readonly bossFeatures: BossFeatures
    /**
      Returns the collection that provides access to the mesh repair features within the component
      and supports the creation of new mesh repair features.
      @experimental
    */
    readonly meshRepairFeatures: MeshRepairFeatures
    /**
      Returns the collection that provides access to the mesh smooth features within the component
      and supports the creation of new mesh smooth features.
      @experimental
    */
    readonly meshSmoothFeatures: MeshSmoothFeatures
    /**
      Returns the collection that provides access to the mesh reduce features within the component
      and supports the creation of new mesh reduce features.
      @experimental
    */
    readonly meshReduceFeatures: MeshReduceFeatures
    /**
      Returns the collection that provides access to the mesh remesh features within the component
      and supports the creation of new mesh remesh features.
      @experimental
    */
    readonly meshRemeshFeatures: MeshRemeshFeatures
    /**
      Returns the collection that provides access to the mesh generate facegroup features
      within the component and supports the creation of new mesh generate facegroup features.
      @experimental
    */
    readonly meshGenerateFaceGroupsFeatures: MeshGenerateFaceGroupsFeatures
    /**
      Returns the collection that provides access to the mesh shell features
      within the component and supports the creation of new mesh shell features.
      @experimental
    */
    readonly meshShellFeatures: MeshShellFeatures
    /**
      Returns the collection that provides access to the tessellate features
      within the component and supports the creation of new tessellate features.
      @experimental
    */
    readonly tessellateFeatures: TessellateFeatures
    /**
      Returns the collection that provides access to the mesh combine features
      within the component and supports the creation of new mesh combine features.
      @experimental
    */
    readonly meshCombineFeatures: MeshCombineFeatures
    /**
      Returns the collection that provides access to the existing Rip features.
    */
    readonly ripFeatures: RipFeatures
    /**
      Returns the collection that provides access to the mesh convert features
      within the component and supports the creation of new mesh convert features.
      @experimental
    */
    readonly meshConvertFeatures: MeshConvertFeatures
    /**
      Returns the collection that provides access to the mesh combine face groups features
      within the component and supports the creation of new mesh combine face groups features.
      @experimental
    */
    readonly meshCombineFaceGroupsFeatures: MeshCombineFaceGroupsFeatures
    /**
      Returns the collection object that supports the ability to merge faces.
      Merging faces is currently limited to a Direct Modeling design or a body in a base feature.
      The result of merging faces is a direct B-Rep modification, and the change is not represented
      as a feature in the browser.
    */
    readonly mergeFacesFeatures: MergeFacesFeatures
    /**
      Returns the collection that provides access to the mesh separate features
      within the component and supports the creation of new mesh separate features.
      @experimental
    */
    readonly meshSeparateFeatures: MeshSeparateFeatures
    /**
      Returns the collection that provides access to the mesh reverse normal features
      within the component and supports the creation of new mesh reverse normal features.
      @experimental
    */
    readonly meshReverseNormalFeatures: MeshReverseNormalFeatures
    /**
      Returns the collection that provides access to the Arrange features
      within the component and supports the creation of new Arrange features.
      @experimental
    */
    readonly arrangeFeatures: ArrangeFeatures
    /**
      Returns the collection that provides access to volumetric custom features within the component
      and supports the creation of new volumetric custom features.
      @experimental
    */
    readonly volumetricCustomFeatures: VolumetricCustomFeatures
    /**
      Returns the collection that provides access to the Volumetric Model to Mesh features
      within the component and supports the creation of new Volumetric Model to Mesh features.
      @experimental
    */
    readonly volumetricModelToMeshFeatures: VolumetricModelToMeshFeatures
  }

  /**
    Base class object representing all features.
  */
  abstract class Feature extends core.Base {
    /**
      Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric).
    */
    name: string
    /**
      Deletes the feature.
      This works for both parametric and non-parametric features.
      @returns Returns a bool indicating if the delete was successful or not.
    */
    deleteMe(): boolean
    /**
      Dissolves the feature so that the feature information is lost
      and only the B-Rep geometry defined by the feature remains.
      This is only valid for non-parametric features.
      @returns Returns a bool indicating if the dissolve was successful or not.
    */
    dissolve(): boolean
    /**
      Gets and sets if this feature is suppressed. This is only valid
      for parametric features.
    */
    isSuppressed: boolean
    /**
      Indicates if this feature is parametric or not.
    */
    readonly isParametric: boolean
    /**
      Returns the faces that were created by this feature. This works for
      both parametric and non-parametric features.
      Depending on the modifications made to the body after the feature was
      created, this may not return all of the faces. For example, when a
      component is created from a body, the original body and its faces
      no longer exist, so this won't return any faces. However, you can
      roll the timeline to immediately after the feature, and all the
      original faces will be available.
    */
    readonly faces: BRepFaces
    /**
      Returns the parent component that owns this feature.
    */
    readonly parentComponent: Component
    /**
      Returns the set of features that are linked to this feature. The set of linked features
      are all of the features that were created in various components as the result of a
      single feature being created in the user interface.
    */
    readonly linkedFeatures: FeatureList
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      Returns the timeline object associated with this feature.
    */
    readonly timelineObject: TimelineObject
    /**
      Returns the bodies that were modified or created by this feature.
      This property works for both parametric and non-parametric features.
      For a BaseFeature, this property has two different behaviors depending
      on if the BaseFeature is active for edit or not. When the base feature is
      active, this property returns the bodies owned by the base feature or the
      source bodies. When the base feature is not active, this property returns
      the result bodies.
      When a body is added to a base feature, that body is owned by the base feature
      and is only seen in the UI when the base feature is active. This body is referred
      to as a "source body". Fusion creates a parametric copy of the body when you
      exit the base feature. This copy is referred to as the "result body," and it
      is used for subsequent modeling operations.
      You can map between the source and result bodies by using their position
      within the bodies returned. To get a valid list of result bodies, you should
      roll the timeline to immediately after the base feature node in the timeline.
      Otherwise, subsequent operations could have done something to cause one or
      more bodies to no longer be available.
    */
    readonly bodies: BRepBodies
    /**
      Returns the collection of attributes associated with this face.
    */
    readonly attributes: core.Attributes
    /**
      If this feature is associated with a base feature, this property will return that base feature.
      If it's not associated with a base feature, this property will return null.
    */
    readonly baseFeature: BaseFeature
    /**
      Returns the current health state of the feature.
    */
    readonly healthState: FeatureHealthStates
    /**
      Returns the error or warning message in the case where the healthState property returns either
      WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
    */
    readonly errorOrWarningMessage: string
    /**
      Returns a token for the Feature object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same feature.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
  }

  /**
    Provides access to a list of features. This is used in the API to return
    a list of features from an API call.
  */
  abstract class FeatureList extends core.Base {
    /**
      Returns the specified folder.
      @param index The index of the feature to return. The first feature in the list has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Feature | null
    /**
      The number of features in this collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    List of the valid extent directions.
  */
  const enum ExtentDirections {
    /**
      Feature extent in the positive direction. For sketch based features this is typically in
      the same direction as the sketch normal.
    */
    PositiveExtentDirection,
    /**
      Feature extent in the negative direction. For sketch based features this is typically in
      the direction opposite the sketch normal.
    */
    NegativeExtentDirection,
    /**
      Feature extent in both directions.
    */
    SymmetricExtentDirection,
  }

  /**
    List of the different operations a feature can perform.
  */
  const enum FeatureOperations {
    /**
      The feature joins or adds material.
    */
    JoinFeatureOperation,
    /**
      The feature cuts or removes materials.
    */
    CutFeatureOperation,
    /**
      The feature intersects with an existing body and the result is the intersecting volume.
    */
    IntersectFeatureOperation,
    /**
      Results in the creation of a new body.
    */
    NewBodyFeatureOperation,
    /**
      Results in the creation of a new component that contains the new body.
    */
    NewComponentFeatureOperation,
  }

  /**
    Specifies the different types of entities that can be patterned.
  */
  const enum PatternEntityTypes {
    /**
      Pattern of faces
    */
    FacesPatternType,
    /**
      Pattern of features
    */
    FeaturesPatternType,
    /**
      Pattern of bodies
    */
    BodiesPatternType,
    /**
      Pattern of occurrences
    */
    OccurrencesPatternType,
  }

  /**
    Collection that provides access to all of the existing extrude features in a design
    and supports the ability to create new extrude features.
  */
  abstract class ExtrudeFeatures extends core.Base {
    /**
      Function that returns the specified extrude feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ExtrudeFeature | null
    /**
      The number of extrude features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new ExtrudeFeatureInput object that is used to specify the input needed
      to create a new extrude feature.
      @param profile The profile argument can be a single Profile, a single planar face, a single SketchText object,
      or an ObjectCollection consisting of multiple profiles, planar faces, and sketch texts.
      When an ObjectCollection is used all of the profiles, faces, and sketch texts must be co-planar.
      To create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile
      methods of the Component object to create an open profile. You also need to set the isSolid property
      of the returned ExtrudeFeatureInput property to False.
      @param operation The feature operation to perform.
      @returns Returns the newly created ExtrudeFeatureInput object or null if the creation failed.
    */
    createInput(profile: core.Base, operation: FeatureOperations): ExtrudeFeatureInput | null
    /**
      Creates a new extrude feature based on the information defined by the provided ExtrudeFeatureInput object.
      To create a new extrusion use the createInput function to create a new input object and use the methods and
      properties on that object to define the required input for an extrusion. Once the information is defined on the
      input object you can pass it to the Add method to create the extrusion.
      @param input The ExtrudeFeatureInput object that specifies the input needed to create a new extrude
      feature.
      @returns Returns the newly created ExtrudeFeature or null if the creation failed.
    */
    add(input: ExtrudeFeatureInput): ExtrudeFeature | null
    /**
      Function that returns the specified extrude feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): ExtrudeFeature | null
    /**
      Creates a basic extrusion that goes from the profile plane the specified distance.
      @param profile The profile argument can be a single Profile, a single planar face, a single SketchText object,
      or an ObjectCollection consisting of multiple profiles, planar faces, and sketch texts.
      When an ObjectCollection is used all of the profiles, faces, and sketch texts must be co-planar.
      This method can only be used to create solid extrusions. To create a surface extrusion you need
      to use the add method.
      @param distance ValueInput object that defines the extrude distance. A positive value extrudes in the positive direction
      of the sketch plane and negative value is in the opposite direction.
      @param operation The feature operation to perform.
      @returns Returns the newly created ExtrudeFeature or null if the creation failed.
    */
    addSimple(profile: core.Base, distance: core.ValueInput, operation: FeatureOperations): ExtrudeFeature | null
  }

  /**
    Object that represents an existing extrude feature in a design.
  */
  abstract class ExtrudeFeature extends Feature {
    /**
      Gets and sets the profiles or planar faces used to define the shape of the extrude.
      This property can return or be set with a single Profile, a single planar face, or
      an ObjectCollection consisting of multiple profiles and planar faces. When an
      ObjectCollection is used all of the profiles and faces must be co-planar.
      When setting this property of a surface (non-solid) extrusion, you can use the
      createOpenProfile and createBRepEdgeProfile methods of the Component object to create
      an open profile.
      This property returns null in the case where the feature is non-parametric.
    */
    profile: core.Base
    /**
      Gets and sets the type of operation performed by the extrusion.
    */
    operation: FeatureOperations
    /**
      Property that returns the set of faces that cap the end of the extrusion and are coincident
      with the sketch plane. In the case of a symmetric extrusion, these faces are the ones on the
      positive normal side of the sketch plane. In the case where there are no start faces,
      this property will return null.
    */
    readonly startFaces: BRepFaces
    /**
      Property that returns the set of faces that cap the end of the extrusion, opposite the
      start faces. In the case where there are no end faces, this property will return null.
    */
    readonly endFaces: BRepFaces
    /**
      Property that returns all of the side faces (i.e. those running perpendicular to the extrude direction)
      of the feature.
    */
    readonly sideFaces: BRepFaces
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ExtrudeFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ExtrudeFeature | null
    /**
      Indicates if this feature was initially created as a solid or a surface.
    */
    readonly isSolid: boolean
    /**
      Gets and sets the extent used to define the start of the extrusion. You can set this property
      with either a ProfilePlaneStartDefinition, OffsetStartDefinition or a
      EntityStartDefinition object. You can get any of those objects by using the static create method on the class.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    startExtent: ExtentDefinition
    /**
      Redefines the extrusion to go in one direction from the profile. The extent of the extrusion is
      defined by the extent argument.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param extent An ExtentDefinition object that defines how the extent of the extrusion is defined. This can be
      a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
      These objects can be obtained by using the static create method on the appropriate class.
      @param direction Specifies the direction of the extrusion. PositiveExtentDirection and NegativeExtentDirection
      are valid values. PositiveExtentDirection is in the same direction as the normal of the profile's
      parent sketch plane.
      @param taperAngle Optional argument that specifies the taper angle. If omitted a taper angle of 0 is used.
      @returns Returns true is setting the input to a one sided extent was successful.
    */
    setOneSideExtent(extent: ExtentDefinition, direction: ExtentDirections, taperAngle?: core.ValueInput/* = null*/): boolean
    /**
      Redefines the extrusion to go in both directions from the profile. The extent is defined independently
      for each direction using the input arguments.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param sideOneExtent An ExtentDefinition object that defines how the extent of the extrusion towards side one is defined. This can be
      a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
      These objects can be obtained by using the static create method on the appropriate class.
      @param sideTwoExtent An ExtentDefinition object that defines how the extent of the extrusion towards side two is defined. This can be
      a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
      These objects can be obtained by using the static create method on the appropriate class.
      @param sideOneTaperAngle Optional argument that specifies the taper angle for side one. If omitted a taper angle of 0 is used.
      @param sideTwoTaperAngle Optional argument that specifies the taper angle for side two. If omitted a taper angle of 0 is used.
      @returns Returns true, if the call was successful.
    */
    setTwoSidesExtent(sideOneExtent: ExtentDefinition, sideTwoExtent: ExtentDefinition, sideOneTaperAngle?: core.ValueInput/* = null*/, sideTwoTaperAngle?: core.ValueInput/* = null*/): boolean
    /**
      Redefines the extrusion to go symmetrically in both directions from the profile.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param distance The distance of the extrusions. This is either the full length of half of the length of the final extrusion
      depending on the value of the isFullLength property.
      @param isFullLength Defines if the value defines the full length of the extrusion or half of the length. A value of true indicates
      it defines the full length.
      @param taperAngle Optional argument that specifies the taper angle. The same taper angle is used for both sides for a symmetric
      extrusion. If omitted a taper angle of 0 is used.
      @returns Returns true, if the call was successful.
    */
    setSymmetricExtent(distance: core.ValueInput, isFullLength: boolean, taperAngle?: core.ValueInput/* = null*/): boolean
    /**
      Gets and sets the extent used for a single sided extrude or side one of a two-sided extrusion. Valid
      inputs are DistanceExtentDefinition, ToEntityExtentDefinition, and ThroughAllExtentDefinition object,
      which can be created statically using the create method on the classes.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    extentOne: ExtentDefinition
    /**
      Gets and sets the extent used for side two of the extrusion. If the extrude is a single sided extrude this
      property will return null and will fail if set. The hasTwoExtents property can be used to determine if
      there are two sides or not. When setting this property, valid inputs are DistanceExtentDefinition,
      ToEntityExtentDefinition, and ThroughAllExtentDefinition object, which can be created
      statically using the create method on the classes.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    extentTwo: ExtentDefinition
    /**
      Gets the parameter controlling the taper angle for a single sided extrusion or side one of a two-sided
      extrusion. To edit the angle, use properties on the parameter to change the value of the parameter.
    */
    readonly taperAngleOne: ModelParameter
    /**
      Gets the parameter controlling the taper angle for side two of a two-sided extrusion. if the extrusion is
      single-sided, this property will return null. The hasTwoExtents property can be used to determine if there
      are two sides or not. To edit the angle, use properties on the parameter to change the value of the parameter.
    */
    readonly taperAngleTwo: ModelParameter
    /**
      Property that indicates if the extrusion is a single or two-sided extrusion. If false, the extentTwo
      and taperAngleTwo properties should not be used.
    */
    readonly hasTwoExtents: boolean
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    participantBodies: BRepBody[]
    /**
      Returns a value indicating how the extent is defined for this extrude.
    */
    readonly extentType: FeatureExtentTypes
    /**
      If the current extent of the feature is defined as a symmetric extent, this property
      returns the SymmericExtentDefinition object that provides access to the information
      defining the symmetric extent. If the current extent is not symmetric, this property
      returns null. You can determine the type of extent by using the extentType property.
      To change the extent of a feature to symmetric extent you can use the setSymmetricExtent
      method.
    */
    readonly symmetricExtent: SymmetricExtentDefinition
    /**
      Sets or returns whether the extrude is a thin extrude.
      Setting it as false will make it a regular extrude.
    */
    isThinExtrude: boolean
    /**
      Changes the extrude feature to be a thin extrude. This is only valid if the isThinExtrude property
      is False. If the extrusion is already a thin extrude, you can use the properties on the ExtrudeFeature
      to modify the thin extrude specific values.
      @param thinExtrudeWallLocationOne Specifies the position of the thin wall extrude with respect to the profile being extruded. This defines
      the direction for a single sided thin extrude or side one of a two-sided extrusion.
      @param thinExtrudeWallThicknessOne A ValueInput object that defines the thickness for a single sided thin extrude or side one of a two-sided
      extrusion .
      @param thinExtrudeWallLocationTwo Optional argument that specifies the position of side two of a two-sided extrusion. This argument is ignored
      for a single sided thin extrude.
      @param thinExtrudeWallThicknessTwo Optional argument that is a ValueInput object that defines the thickness for side two of a
      two-sided extrusion. This argument is ignored for a single sided thin extrude.
      @returns Returns true if successful.
    */
    setThinExtrude(thinExtrudeWallLocationOne: ThinExtrudeWallLocation, thinExtrudeWallThicknessOne: core.ValueInput, thinExtrudeWallLocationTwo?: ThinExtrudeWallLocation/* = ThinExtrudeWallLocation.Side1*/, thinExtrudeWallThicknessTwo?: core.ValueInput/* = null*/): boolean
    /**
      Gets and sets the wall location for a one sided thin extrude or side one of a two sided thin extrude
    */
    thinExtrudeWallLocationOne: ThinExtrudeWallLocation
    /**
      Gets and sets the wall location for side two of a two sided thin extrude
    */
    thinExtrudeWallLocationTwo: ThinExtrudeWallLocation
    /**
      Gets and sets the wall thickness for a one sided thin extrude or side one of a two sided thin extrude
    */
    readonly thinExtrudeWallThicknessOne: ModelParameter
    /**
      Gets and sets the wall thickness for side two of a two sided thin extrude
    */
    readonly thinExtrudeWallThicknessTwo: ModelParameter
  }

  /**
    Used to indicate which type of extent is used for a feature.
  */
  const enum FeatureExtentTypes {
    /**
      Specifies a feature extent that is defined in a single direction.
    */
    OneSideFeatureExtentType,
    /**
      Specifies a feature extent that is defined in two directions.
    */
    TwoSidesFeatureExtentType,
    /**
      Specifies a feature extent that is defined symmetrically in two directions.
    */
    SymmetricFeatureExtentType,
  }

  /**
    This class defines the methods and properties that pertain to the definition of an extrude
    feature. This class also provides properties for setting/getting the Profile and Operation
    of the extrude. The Profile and Operation are defined when the ExtrudeFeatures.createInput
    method is called so they do not exist as properties on this class.
  */
  abstract class ExtrudeFeatureInput extends core.Base {
    /**
      Gets and sets the profiles or planar faces used to define the shape of the extrude.
      This property can return or be set with a single profile, a single planar face, or
      an ObjectCollection consisting of multiple profiles and planar faces. When an
      ObjectCollection is used all of the profiles and faces must be co-planar.
      To create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile
      methods of the Component object to create an open profile. The isSolid property of the
      ExtrudeFeatureInput property must also be False.
    */
    profile: core.Base
    /**
      Gets and sets the type of operation performed by the extrusion.
    */
    operation: FeatureOperations
    /**
      Gets and sets the taper angle of the extrusion. This is used to define the
      taper angle for a single sided and symmetric and defines the angle for side one
      of a two sided extrusion. This property is initialized with a taper angle of zero.
      A negative angle will taper the extrusion inward while a positive value will taper
      the extrusion outward. This property is valid for both parametric and non-parametric extrusions.
      @remarks
      This property has been retired and is replaced by getting the extent definition for each
      direction and using it to set the taper angle.
      @deprecated
    */
    taperAngle: core.ValueInput
    /**
      Sets the extrusion extents option to 'Distance'.
      @remarks
      This method has been retired and is replaced with the new SetOneSideExtent and passing in either a
      DistanceExtentDefinition or SymmetricExtentDefinition. This method continues to work for the API to remain
      backward compatible but it is not longer officially supported.
      @param isSymmetric Set to 'true' for an extrusion symmetrical about the profile plane
      @param distance ValueInput object that defines the extrude distance.
      If the isSymmetric argument is 'false', a positive or negative distance can be used to control the direction.
      @returns Returns true if successful
      @deprecated
    */
    setDistanceExtent(isSymmetric: boolean, distance: core.ValueInput): boolean
    /**
      Sets the extrusion extents option to 'Two Side'.
      This method will fail in the case of a non-parametric extrusion.
      @remarks
      This method has been retired and is replaced with the new SetTwoSidesExtent, passing in a
      DistanceExtentDefinition for both sides. This method continues to work to allow the API to remain
      backward compatible, but it is no longer officially supported.
      @param distanceOne ValueInput object that defines the extrude distance for the first side.
      @param distanceTwo ValueInput object that defines the extrude distance for the second side.
      @returns Returns true if successful
      @deprecated
    */
    setTwoSidesDistanceExtent(distanceOne: core.ValueInput, distanceTwo: core.ValueInput): boolean
    /**
      Sets the extrusion extents option to 'All' (i.e. the extrusion is through-all, in both directions.)
      This method will fail in the case of a non-parametric extrusion.
      @remarks
      This method has been retired and is replaced with the setOneSideExtent and SetTwoSidesExtent,
      passing in a ThroughAllExtentDefinition. This method continues to work to allow the API to remain
      backward compatible, but it is no longer officially supported.
      @param direction The direction can be either positive, negative, or symmetric.
      @returns Returns true if successful
      @deprecated
    */
    setAllExtent(direction: ExtentDirections): boolean
    /**
      Sets the extrusion Direction option to 'One Side' and the Extents option to 'To' (a specified face)
      @remarks
      This method has been retired and is replaced with the new setOneSideExtent and passing in a
      ToEntityExtentDefinition. This method continues to work to allow the API to remain backward compatible, but
      it is no longer officially supported.
      @param toEntity The entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @param matchShape If the matchShape argument is 'true', the toEntity is extended to fully intersect the extrusion.
      @param directionHint Specifies the direction of the extrusion. This is only used in the case where there are two possible solutions and the extrusion can
      hit the toEntity in either direction. An example is if the profile of the extrusion is within a hole.
      The extrusion will intersect the cylinder of the hole in either direction.
      Typically there is only a single solution and the direction is determined automatically.
      @returns Returns true if successful.
      @deprecated
    */
    setOneSideToExtent(toEntity: core.Base, matchShape: boolean, directionHint?: core.Vector3D/* = null*/): boolean
    /**
      Set the extrusion Direction option to 'Two Side'. This method will fail in the case of a non-parametric extrusion.
      @remarks
      This method has been retired and is replaced with the new setTwoSidesExtent and passing in a
      ToEntityExtentDefinition for both sides. This method continues to work to allow the API to remain backward compatible, but
      it is no longer officially supported.
      @param toEntityOne The first entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @param toEntityTwo The second entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @param matchShape If the matchShape argument is 'true', the toEntity is extended to fully intersect the extrusion.
      @returns Returns true if successful.
      @deprecated
    */
    setTwoSidesToExtent(toEntityOne: core.Base, toEntityTwo: core.Base, matchShape: boolean): boolean
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the Extrusion is created based on geometry (e.g. a profile and/or face(s))
      in another component AND (the Extrusion) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      Specifies if the extrusion should be created as a solid or surface. If
      it's a surface then there aren't any end caps and it's open. When an ExtrudeFeature
      input is created, this is initialized to true so a solid will be created if it's not changed.
    */
    isSolid: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets the extent used to define the start of the extrusion. When a new ExtrudeFeatureInput
      object is created the start extent is initialized to be the profile plane but you can change it
      to a profile plane with offset or from an object by setting this property with either a
      OffsetStartDefinition or an EntityStartDefinition object. You can get either one
      of those objects by using the static create method on the class.
    */
    startExtent: ExtentDefinition
    /**
      Defines the extrusion to go in one direction from the profile. The extent of the extrusion is
      defined by the extent argument.
      @param extent An ExtentDefinition object that defines how the extent of the extrusion is defined. This can be
      a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
      These objects can be obtained by using the static create method on the appropriate class.
      @param direction Specifies the direction of the extrusion. PositiveExtentDirection and NegativeExtentDirection
      are valid values. PositiveExtentDirection is in the same direction as the normal of the profile's
      parent sketch plane.
      @param taperAngle Optional argument that specifies the taper angle. If omitted a taper angle of 0 is used.
      @returns Returns true is setting the input to a one sided extent was successful.
    */
    setOneSideExtent(extent: ExtentDefinition, direction: ExtentDirections, taperAngle?: core.ValueInput/* = null*/): boolean
    /**
      Defines the extrusion to go in both directions from the profile. The extent is defined independently
      for each direction using the input arguments.
      @param sideOneExtent An ExtentDefinition object that defines how the extent of the extrusion towards side one is defined. This can be
      a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
      These objects can be obtained by using the static create method on the appropriate class.
      @param sideTwoExtent An ExtentDefinition object that defines how the extent of the extrusion towards side two is defined. This can be
      a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
      These objects can be obtained by using the static create method on the appropriate class.
      @param sideOneTaperAngle Optional argument that specifies the taper angle for side one. If omitted a taper angle of 0 is used.
      @param sideTwoTaperAngle Optional argument that specifies the taper angle for side two. If omitted a taper angle of 0 is used.
      @returns Returns true is setting the extent was successful.
    */
    setTwoSidesExtent(sideOneExtent: ExtentDefinition, sideTwoExtent: ExtentDefinition, sideOneTaperAngle?: core.ValueInput/* = null*/, sideTwoTaperAngle?: core.ValueInput/* = null*/): boolean
    /**
      Defines the extrusion to go symmetrically in both directions from the profile.
      @param distance The distance of the extrusions. This is either the full length of half of the length of the final extrusion
      depending on the value of the isFullLength property.
      @param isFullLength Defines if the value defines the full length of the extrusion or half of the length. A value of true indicates
      it defines the full length.
      @param taperAngle Optional argument that specifies the taper angle. The same taper angle is used for both sides for a symmetric
      extrusion. If omitted a taper angle of 0 is used.
      @returns Returns true is setting the extent was successful.
    */
    setSymmetricExtent(distance: core.ValueInput, isFullLength: boolean, taperAngle?: core.ValueInput/* = null*/): boolean
    /**
      Gets the extent assigned for a single sided extrude or side one of a two-sided extrusion. To set the extent, use
      one of the set methods on the ExtrudeFeatureInput object.
    */
    readonly extentOne: ExtentDefinition
    /**
      Gets the extent assigned for side two of the extrusion. If the extrude is single sided extrude this
      property will return null. The hasTwoExtents property can be used to determine if there
      are two sides or not. To set the extent, use one of the set methods on the ExtrudeFeatureInput object.
    */
    readonly extentTwo: ExtentDefinition
    /**
      Gets the value that will be used as the taper angle for a single sided extrusion or side one of a two-sided
      extrusion. To set the taper angle, use one of the set methods on the ExtrudeFeatureInput object.
    */
    readonly taperAngleOne: core.ValueInput
    /**
      Gets the value that will be used as the taper angle for side two of a two-sided extrusion. If the extrusion is
      single-sided, this property will return null. The hasTwoExtents property can be used to determine if there
      are two sides or not. To set the taper angle, use one of the set methods on the ExtrudeFeatureInput object.
    */
    readonly taperAngleTwo: core.ValueInput
    /**
      Property that indicates if the extrusion is a single or two-sided extrusion. If false, the extentTwo
      and taperAngleTwo properties should not be used.
    */
    readonly hasTwoExtents: boolean
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      If this property has not been set, the default behavior is that all bodies that are intersected by the
      feature will participate.
      This property can return null in the case where the feature has not been fully defined so that
      possible intersecting bodies can be computed.
    */
    participantBodies: BRepBody[]
    /**
      Sets or returns whether the extrude is a thin extrude.
      Setting it as false will make it a regular extrude.
    */
    isThinExtrude: boolean
    /**
      Changes the extrude feature to be a thin extrude. This is only valid if the isThinExtrude property
      is False. If the extrusion is already a thin extrude, you can use the properties on the ExtrudeFeature
      to modify the thin extrude specific values.
      @param thinExtrudeWallLocationOne Specifies the position of the thin wall extrude with respect to the profile being extruded. This defines
      the direction for a single sided thin extrude or side one of a two-sided extrusion.
      @param thinExtrudeWallThicknessOne A ValueInput object that defines the thickness for a single sided thin extrude or side one of a two-sided
      extrusion .
      @param thinExtrudeWallLocationTwo Optional argument that specifies the position of side two of a two-sided extrusion. This argument is ignored
      for a single sided thin extrude.
      @param thinExtrudeWallThicknessTwo Optional argument that is a ValueInput object that defines the thickness for side two of a
      two-sided extrusion. This argument is ignored for a single sided thin extrude.
      @returns Returns true if successful.
    */
    setThinExtrude(thinExtrudeWallLocationOne: ThinExtrudeWallLocation, thinExtrudeWallThicknessOne: core.ValueInput, thinExtrudeWallLocationTwo?: ThinExtrudeWallLocation/* = ThinExtrudeWallLocation.Side1*/, thinExtrudeWallThicknessTwo?: core.ValueInput/* = null*/): boolean
    /**
      Gets and sets the wall location for a one sided thin extrude or side one of a two sided thin extrude
    */
    thinExtrudeWallLocationOne: ThinExtrudeWallLocation
    /**
      Gets and sets the wall location for side two of a two sided thin extrude
    */
    thinExtrudeWallLocationTwo: ThinExtrudeWallLocation
    /**
      Gets and sets the wall thickness for a one sided thin extrude or side one of a two sided thin extrude
    */
    thinExtrudeWallThicknessOne: core.ValueInput
    /**
      Gets and sets the wall thickness for side two of a two sided thin extrude
    */
    thinExtrudeWallThicknessTwo: core.ValueInput
  }

  /**
    List of Thin Extrude Wall Locations
  */
  const enum ThinExtrudeWallLocation {
    /**
      The wall location type where the thin extrude is offset towards one side of the profile
    */
    Side1,
    /**
      The wall location type where the thin extrude is centered on the profile
    */
    Center,
    /**
      The wall location type where the thin extrude is offset towards one side of the profile
    */
    Side2,
  }

  /**
    The base class for the various definition objects used to define the extent of a feature.
  */
  abstract class ExtentDefinition extends core.Base {
    /**
      Returns the parent feature that this definition is associated with. If this definition has been created
      statically and is not associated with a feature this property will return null.
    */
    readonly parentFeature: Feature
  }

  /**
    A definition object that is used to define a feature whose start plane is the sketch plane of the profile.
  */
  abstract class ProfilePlaneStartDefinition extends ExtentDefinition {
    /**
      Statically creates a new ProfilePlaneStartDefinition object. This is used as input when creating a new
      feature and defining the starting condition.
      @returns Returns the newly created ProfilePlaneStartDefinition object or null in the case of a failure.
    */
    static create(): ProfilePlaneStartDefinition | null
    /**
      Returns the geometric definition of the profile plane.
    */
    readonly profilePlane: core.Plane
  }

  /**
    A definition object that is used to define a feature whose start plane is defined as plane that is
    offset from the sketch plane of the profile.
  */
  abstract class OffsetStartDefinition extends ExtentDefinition {
    /**
      Statically creates a new OffsetStartDefinition object. This is used as input when
      create a new feature and defining the starting condition.
      @param offset An input ValueInput objects that defines the offset distance. The offset can be positive or
      negative. A positive value indicates an offset in the same direction as the z axis of the
      profile plane.
      @returns Returns the newly created OffsetStartDefinition object or null in the case of failure.
    */
    static create(offset: core.ValueInput): OffsetStartDefinition | null
    /**
      Gets the currently defined offset value. If the ProfilePlaneWithOffsetDefinition object was
      created statically and is not associated with a feature, this will return a ValueInput object.
      if the ProfilePlaneWithOffsetDefinition is associated with an existing feature, this will return
      the parameter that was created when the feature was created. To edit the offset, use properties
      on the parameter to change the value of the parameter.
    */
    readonly offset: core.Base
    /**
      Returns the geometric definition of the profile plane.
    */
    readonly profilePlane: core.Plane
  }

  /**
    A definition object that is used to define a feature whose start is defined by a specified construction
    plane or face. If a face is specified it must be large enough to completely contain the projected profile.
  */
  abstract class FromEntityStartDefinition extends ExtentDefinition {
    /**
      Statically creates a new FromEntityStartDefinition object. This is used as input when
      create a new feature and defining the starting condition.
      @param entity An input construction plane or face that defines the start of the feature. If a face is specified it
      must be large enough to completely contain the projected profile.
      @param offset An input ValueInput objects that defines the offset distance from the specified entity. The offset can be positive or
      negative. A positive value indicates an offset in the same direction as the positive normal direction of the face.
      @returns Returns the newly created FromEntityStartDefinition or null in the case of a failure.
    */
    static create(entity: core.Base, offset: core.ValueInput): FromEntityStartDefinition | null
    /**
      Gets the currently defined offset value. If the FromEntityStartDefinition object was
      created statically and is not associated with a feature, this will return a ValueInput object.
      if the FromEntityStartDefinition is associated with an existing feature, this will return
      the parameter that was created when the feature was created. To edit the offset, use properties
      on the parameter to change the value of the parameter.
    */
    readonly offset: core.Base
    /**
      Gets and sets the entity defining the start of the feature.
    */
    entity: core.Base
  }

  /**
    A definition object that is used to define the extents of a feature to be symmetric.
  */
  abstract class SymmetricExtentDefinition extends ExtentDefinition {
    /**
      Statically creates a new SymmetricExtentDefinition object. This is used as input when
      create a new feature and defining the starting condition.
      @param distance An input ValueInput objects that defines either half the extent of the extrude or the full extent, depending
      on the value of the isFullLength argument.
      @param isFullLength An input boolean that specifies if the distance specified defines the full or half length of the extrusion.
      @returns Returns the newly created SymmetricExtentDefinition or null in the case of a failure.
    */
    static create(distance: core.ValueInput, isFullLength: boolean): SymmetricExtentDefinition | null
    /**
      Gets and sets if the distance defines the full extent length or half the length. A value of
      True indicates if defines the full length.
    */
    isFullLength: boolean
    /**
      Returns the current extent distance. If the SymmetricExtentDefinition object has been created statically and isn't associated with
      a feature this will return a ValueInput object. If the SymmetricExtentDefinition object is obtained from a feature this
      will return a ModelParameter object. You can use properties of the parameter to edit its value which will result in
      the feature updating.
    */
    readonly distance: core.Base
    /**
      Returns the current taper angle. If the SymmetricExtentDefinition object has been created statically and isn't associated with
      a feature this will return a ValueInput object. If the SymmetricExtentDefinition object is obtained from a feature this
      will return a ModelParameter object. You can use properties of the parameter to edit its value which will result in
      the feature updating.
    */
    readonly taperAngle: core.Base
  }

  /**
    A definition object that is used to define the extents of a feature to be up to a specified
    construction plane or face.
  */
  abstract class ToEntityExtentDefinition extends ExtentDefinition {
    /**
      Statically creates a new ToEntityExtentDefinition object. This is used as input when
      defining the extents of a feature to be up to a construction plane or face.
      @param entity The construction plane or face that the feature extent it up to.
      @param isChained 
      @param offset A optional input value that defines an offset distance of the entity that will be used
      for the extent. Positive and negative values can be used to offset in both directions.
      If this argument is not provided a value of zero will be used.
      @returns Returns the newly created ToEntityExtentDefinition object or null if the creation failed.
    */
    static create(entity: core.Base, isChained: boolean, offset?: core.ValueInput/* = null*/): ToEntityExtentDefinition | null
    /**
      Gets and sets the entity that the feature extent is defined up to. This can be a ConstructionPlane, Profile, BrepFace,
      BrepBody, or BRepVertex.
    */
    entity: core.Base
    /**
      Returns the current offset. If the EntityExtentDefinition object has been created statically and isn't associated with
      a feature this will return a ValueInput object. If the EntityExtentDefinition object is obtained from a feature this
      will return a ModelParameter object. You can use properties of the parameter to edit its value which will result in
      the feature updating.
    */
    readonly offset: core.Base
    /**
      Gets and sets whether connected faces to the input entity should also be used when calculating the extent or if the
      input entity should be extended. A value of true indicates that connected entities should be used.
    */
    isChained: boolean
    /**
      Gets and sets a direction that is used when the result is ambiguous. For example, if you have a profile in
      the center of a torus and are extruding to the torus, the extrusion can go in either direction. When needed,
      this provides the information to tell Fusion which direction to go. In most cases this is not needed and
      the property will be null.
    */
    directionHint: core.Vector3D
    /**
      Gets and sets if the minimum or maximum solution is calculated. This is only used when the input entity is
      a body and defines if the extrusion to go to the near side (minimum solution) of the body or the far side.
      When a new ToEntityExtentDefinition object is created, this property defaults to True.
    */
    isMinimumSolution: boolean
  }

  /**
    A definition object that is used to define the extents of a feature to be through all.
  */
  abstract class ThroughAllExtentDefinition extends ExtentDefinition {
    /**
      Statically creates a new ThroughAllExtentDefinition object. This is used as input when
      defining the extents of a feature to be through all.
      @returns Returns the newly created ThroughAllExtentDefinition or null in the case of a failure.
    */
    static create(): ThroughAllExtentDefinition | null
    /**
      Gets and sets if the direction is positive or negative. A value of true indicates it is
      in the same direction as the z direction of the profile's sketch plane.
      This is only used when the extrusion is only defined in a single direction from the
      profile plane. If it's a two sided extrusion, this value is ignored.
    */
    isPositiveDirection: boolean
  }

  /**
    Defines the inputs for a distance ExtentDefinition object.
    This feature extent type defines the distance as well as whether the extent is symmetric
    or in only one direction. If the extent is not symmetric, a positive or negative distance
    can be used to control the direction.
    For a hole, the IsSymmetric property value will always be false.
  */
  abstract class DistanceExtentDefinition extends ExtentDefinition {
    /**
      Returns the parameter controlling the distance. You can edit the distance
      by editing the value of the parameter object.
    */
    readonly distance: ModelParameter
    /**
      Statically creates a new DistanceExtentDefinition object. This is used as input when
      defining the extents of a feature to be a specified distance.
      @param distance A ValueInput that defines the distance of the extrusion.
      @returns Returns the newly created DistanceExtentDefinition or null in the case of failure.
    */
    static create(distance: core.ValueInput): DistanceExtentDefinition | null
  }

  /**
    Defines the inputs for a TwoSidesDistanceExtentDefinition object.
    This defines a feature extent where the distance in each direction can be a different value.
    @remarks
    This object is retired. Extents are now defined independently for both directions. To get
    the equivalent of what this object provided, you will create a DistanceExtentDefinition for each direction
    and use the when creating the extrusion.
    @deprecated
  */
  abstract class TwoSidesDistanceExtentDefinition extends ExtentDefinition {
    /**
      Gets the ModelParameter that defines the first distance
    */
    readonly distanceOne: ModelParameter
    /**
      Gets the ModelParameter that defines the second distance
    */
    readonly distanceTwo: ModelParameter
  }

  /**
    Defines the inputs for an AllExtentDefinition object.
    This defines a feature extent where the direction can be positive, negative, or symmetric.
    Setting the direction to Symmetric specifies that the extrusion is through-all,
    and goes in both directions.
    @remarks
    This object is retired. Extents are now defined independently for both directions. To get
    the equivalent of what this object provided, you will create a ThroughAllExtentDefinition and apply
    it for the extent direction you want a through all type of extrusion.
    @deprecated
  */
  abstract class AllExtentDefinition extends ExtentDefinition {
    /**
      Gets and sets the direction of the extent.
    */
    direction: ExtentDirections
  }

  /**
    Defines the inputs for a OneSideToExtentDefinition object.
    This defines a feature extent that goes up to a face or construction plane in one direction.
    @remarks
    This object is retired. Extents are now defined independently for both directions. To get
    the equivalent of what this object provided, you will create a ToEntityExtentDefinition and use
    it for the extent direction you want to go to an entity.
    @deprecated
  */
  abstract class OneSideToExtentDefinition extends ExtentDefinition {
    /**
      Gets and sets the entity that defines the extent. The valid types of entities can vary depending on
      the type of feature this is being used with.
    */
    toEntity: core.Base
    /**
      Specifies if the face should be extended or use adjacent faces if necessary to define the termination
      of the extrusion.
      When used for a revolve feature this is ignored and is always treated as true.
    */
    matchShape: boolean
  }

  /**
    Defines the inputs for a TwoSidesToExtentDefinition object.
    This defines a feature extent where the extents of feature go up to faces or construction planes in both directions.
    @remarks
    This object is retired. Extents are now defined independently for both directions. To get
    the equivalent of what this object provided, you will create two ToEntityExtentDefinition objects and use
    one for each direction of the extrusion.
    @deprecated
  */
  abstract class TwoSidesToExtentDefinition extends ExtentDefinition {
    /**
      Gets and sets the entity that defines the extent on side one. The valid types of entities can vary depending on
      the type of feature this is being used with.
    */
    toEntityOne: core.Base
    /**
      Gets and sets the entity that defines the extent on side two. The valid types of entities can vary depending on
      the type of feature this is being used with.
    */
    toEntityTwo: core.Base
    /**
      Gets and sets whether the toEntity is extended to fully intersect the extrusion.
    */
    matchShape: boolean
  }

  /**
    Defines the inputs for an AngleExtentDefinition object.
    This feature extent is defined by an angle as well as whether the extent is symmetric or only in one direction.
    If the extent is not symmetric, a positive or negative angle can be used to control the direction.
  */
  abstract class AngleExtentDefinition extends ExtentDefinition {
    /**
      Gets and sets if the angle extent is in one direction or symmetric.
      For a hole this property will always return false and setting it is ignored.
    */
    isSymmetric: boolean
    /**
      Gets the ModelParameter that defines the angle. The value of the angle can be edited
      by using the properties on the ModelParameter object to edit the parameter.
    */
    readonly angle: ModelParameter
  }

  /**
    Defines the inputs for a TwoSidesAngleExtentDefinition object.
    This feature extent type defines the extents of the feature using angle extents on two sides.
  */
  abstract class TwoSidesAngleExtentDefinition extends ExtentDefinition {
    /**
      Gets the ModelParameter that defines the angle on the first side.
      The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
    */
    readonly angleOne: ModelParameter
    /**
      Gets the ModelParameter that defines the angle on the second side.
      The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
    */
    readonly angleTwo: ModelParameter
  }

  /**
    Collection that provides access to all of the existing revolve features in a design
    and supports the ability to create new revolve features.
  */
  abstract class RevolveFeatures extends core.Base {
    /**
      Function that returns the specified revolve feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): RevolveFeature | null
    /**
      The number of revolve features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new RevolveFeatureInput object that is used to specify the input needed
      to create a new revolve feature.
      @param profile The profile argument can be a single Profile, a single
      planar face, or an ObjectCollection consisting of multiple profiles and planar faces.
      When an ObjectCollection is used all of the profiles and faces must be co-planar.
      To create a surface (non-solid) revolution, you can use the createOpenProfile and createBRepEdgeProfile
      methods of the Component object to create an open profile. You also need to set the isSolid property
      of the returned RevolveFeatureInput property to False.
      @param axis The axis can be a sketch line, construction axis, linear edge or a face that defines an
      axis (cylinder, cone, torus, etc.). If it is not in the same plane as the profile, it is
      projected onto the profile plane.
      @param operation The operation type to perform.
      @returns Returns the newly created RevolveFeatureInput object or null if the creation failed.
    */
    createInput(profile: core.Base, axis: core.Base, operation: FeatureOperations): RevolveFeatureInput | null
    /**
      Creates a new revolve feature based on the information provided by the provided
      RevolveFeatureInput object.
      To create a new revolve, use the createInput function to create a new input object
      and then use the methods and properties on that object to define the required input
      for a revolve. Once the information is defined on the input object you can pass it
      to the Add method to create the revolve.
      @param input The RevolveFeatureInput object that specifies the input needed to create a new extrude
      @returns Returns the newly created RevolveFeature or null if the creation failed.
    */
    add(input: RevolveFeatureInput): RevolveFeature | null
    /**
      Function that returns the specified revolve feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): RevolveFeature | null
  }

  /**
    Object that represents an existing revolve feature in a design.
  */
  abstract class RevolveFeature extends Feature {
    /**
      Gets and sets the profiles or planar faces used to define the shape of the revolve.
      This property can return or be set with a single Profile, a single planar face, or
      an ObjectCollection consisting of multiple profiles and planar faces. When an
      ObjectCollection is used all of the profiles and faces must be co-planar.
      When setting this property of a surface (non-solid) extrusion, you can use the
      createOpenProfile and createBRepEdgeProfile methods of the Component object to create
      an open profile.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      This property returns null in the case where the feature is non-parametric.
    */
    profile: core.Base
    /**
      Gets and sets the entity used to define the axis of revolution.
      The axis can be a sketch line, construction axis, linear edge or a face that defines an
      axis (cylinder, cone, torus, etc.). If it is not in the same plane as the profile, it is
      projected onto the profile plane.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    axis: core.Base
    /**
      Gets and sets the type of operation performed by the revolve.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    operation: FeatureOperations
    /**
      Gets the definition object that is defining the extent of the revolve. Modifying the
      definition object will cause the revolve to recompute. Various types of objects can
      be returned depending on the type of extent currently defined for the revolve.
      This property returns nothing in the case where the feature is non-parametric.
    */
    readonly extentDefinition: ExtentDefinition
    /**
      Defines the extent of the revolution to be at a defined angle.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param isSymmetric Boolean that specifies if the extent is symmetric or not.
      @param angle ValueInput object that defines the angle. This can be a string or a value. If
      it's a string it is interpreted using the current document units and can include
      equations. For example all of the following are valid as long as they result in
      angle units "45", "45 deg", "a1 / 2". If a value is input it is interpreted
      as radians.
      If isSymmetric is false a positive or negative angle can be
      used to control the direction. If isSymmetric is true, the angle is the extent in one
      direction so the entire angle of the revolution will be twice the specified angle.
      Use an angle of 360 deg or 2 pi radians to create a full revolve.
      @returns Returns true if successful
    */
    setAngleExtent(isSymmetric: boolean, angle: core.ValueInput): boolean
    /**
      Changes the extent of the revolve to be defined as a two sided angle extent.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param angleOne ValueInput object that defines the first angle. This can be a string or a value. If
      it's a string it is interpreted using the current document units and can include
      equations. For example all of the following are valid as long as they result in
      angle units "45", "45 deg", "a1 / 2". If a value is input it is interpreted
      as radians.
      @param angleTwo ValueInput object that defines the second angle. This can be a string or a value. If
      it's a string it is interpreted using the current document units and can include
      equations. For example all of the following are valid as long as they result in
      angle units "45", "45 deg", "a1 / 2". If a value is input it is interpreted
      as radians.
      @returns Returns true if successful
    */
    setTwoSideAngleExtent(angleOne: core.ValueInput, angleTwo: core.ValueInput): boolean
    /**
      Changes the extent of the revolve to be from the sketch plane to the specified "to" face.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param toEntity The entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @param directionHint Specifies the direction of the revolve.
      @returns Returns true if successful.
    */
    setOneSideToExtent(toEntity: core.Base, directionHint?: core.Vector3D/* = null*/): boolean
    /**
      Changes the extent of the revolve to be defined as a two sided to extent.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param toEntityOne The first entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @param toEntityTwo The second entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @returns Returns true if successful
    */
    setTwoSidesToExtent(toEntityOne: core.Base, toEntityTwo: core.Base): boolean
    /**
      Property that returns the set of faces that cap one end of the revolve and are coincident
      with the sketch plane. In the case of a symmetric revolve these faces are the ones on the
      positive normal side of the sketch plane. In the case where there aren't any start faces,
      this property will return null.
    */
    readonly startFaces: BRepFaces
    /**
      Property that returns the set of faces that cap the end of the revolve opposite the
      start faces. In the case where there aren't any start faces, this property will return null.
    */
    readonly endFaces: BRepFaces
    /**
      Property that returns all of the faces created around the perimeter of the feature.
    */
    readonly sideFaces: BRepFaces
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: RevolveFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): RevolveFeature | null
    /**
      Indicates if this feature was initially created as a solid or a surface.
    */
    readonly isSolid: boolean
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    participantBodies: BRepBody[]
    /**
      Specifies if the axis should be projected on the same plane as the profile sketch plane or not.
      Setting this to true will use a projected axis, while setting it to false will keep it in its original location.
      This is initialized to false so the selected axis will be used in the feature.
    */
    isProjectAxis: boolean
  }

  /**
    This class defines the methods and properties that pertain to the definition of a revolve
    feature.
  */
  abstract class RevolveFeatureInput extends core.Base {
    /**
      Gets and sets the profiles or planar faces used to define the shape of the revolve.
      This property can return or be set with a single Profile, a single planar face, or
      an ObjectCollection consisting of multiple profiles and planar faces. When an
      ObjectCollection is used all of the profiles and faces must be co-planar.
      This property returns null in the case where the feature is non-parametric.
      To create a surface (non-solid) revolution, you can use the createOpenProfile and createBRepEdgeProfile
      methods of the Component object to create an open profile. The isSolid property of the
      RevolveFeatureInput property must also be False.
    */
    profile: core.Base
    /**
      Gets and sets the type of operation performed by the revolve.
    */
    operation: FeatureOperations
    /**
      Gets and sets the entity used to define the axis of revolution.
      The axis can be a sketch line, construction axis, linear edge or a face that defines an
      axis (cylinder, cone, torus, etc.). If it is not in the same plane as the profile, it is
      projected onto the profile plane.
    */
    axis: core.Base
    /**
      Defines the extent of the revolution to be at a specified angle.
      An angle and whether the extent is symmetric or only in one direction
      is specified. If it's not symmetric a positive or negative angle can be
      used to control the direction. If symmetric, the angle is the angle on one
      side so the entire angle of the revolution will be twice the specified angle.
      Use an angle of 360 deg or 2 pi radians to create a full revolve.
      @param isSymmetric Set to 'true' for a revolve symmetrical about the profile plane
      @param angle The ValueInput object that defines the angle of the revolution
      @returns Returns true if successful
    */
    setAngleExtent(isSymmetric: boolean, angle: core.ValueInput): boolean
    /**
      Defines the angle of the revolve to be to applied to both sides of the profile
      at the specified angles.
      @param angleOne The ValueInput object that defines the angle for the first side of the revolution
      @param angleTwo The ValueInput object that defines the angle for the second side of the revolution
      @returns Returns true if successful
    */
    setTwoSideAngleExtent(angleOne: core.ValueInput, angleTwo: core.ValueInput): boolean
    /**
      Defines the extent of the revolve to be from the sketch or profile plane to the
      specified "To" face.
      @param toEntity The entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @param directionHint Specifies the direction of the revolve.
      @returns Returns true if successful.
    */
    setOneSideToExtent(toEntity: core.Base, directionHint?: core.Vector3D/* = null*/): boolean
    /**
      Defines the extents of the revolve to be from the sketch plane to specified
      faces in both directions. If the matchShape argument is true, the faces to revolve to
      are extended to fully intersect the revolve.
      @param toEntityOne The first entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @param toEntityTwo The second entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @returns Returns true if successful.
    */
    setTwoSideToExtent(toEntityOne: core.Base, toEntityTwo: core.Base): boolean
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the Revolve is created based on geometry (e.g. a profile and/or face(s))
      in another component AND (the Revolve) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      Specifies if the revolution should be created as a solid or surface. If
      it's a surface then there aren't any end caps and it's open. This is
      initialized to true so a solid will be created if it's not changed.
    */
    isSolid: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      If this property has not been set, the default behavior is that all bodies that are intersected by the
      feature will participate.
      This property can return null in the case where the feature has not been fully defined so that
      possible intersecting bodies can be computed.
    */
    participantBodies: BRepBody[]
    /**
      Specifies if the axis should be projected on the same plane as the profile sketch plane or not.
      Setting this to true will use a projected axis, while setting it to false will keep it in its original location.
      This is initialized to false so the selected axis will be used in the feature.
    */
    isProjectAxis: boolean
  }

  /**
    Collection that provides access to all of the existing hole features in a component
    and supports the ability to create new hole features.
  */
  abstract class HoleFeatures extends core.Base {
    /**
      Function that returns the specified hole feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): HoleFeature | null
    /**
      The number of hole features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a HoleFeatureInput object that defines a simple hole (a single diameter).
      This is not a hole feature, but an object used to create a hole feature. Functionality
      on the returned HoleFeatureInput object is used to define the position and extent
      of the hole.
      @param holeDiameter A ValueInput object that defines the diameter of the hole. If the ValueInput uses
      a real, it is interpreted as centimeters. If it is a string, the units
      can be defined as part of the string (i.e. "3 in") If no units are specified,
      it is interpreted using the current default units for length.
      If tap information is added to the hole using the returned HoleFeatureInput, it will
      override this diameter, and the hole will be the correct size for the specified tap.
      @returns Returns the newly created HoleFeatureInput object or null if the creation failed.
    */
    createSimpleInput(holeDiameter: core.ValueInput): HoleFeatureInput | null
    /**
      Creates a HoleFeatureInput object that defines a counterbore hole. This is not
      a hole feature but an object used to create a hole feature. Functionality
      on the returned HoleFeatureInput object is used to define the position and extent
      of the hole.
      @param holeDiameter A ValueInput object that defines the diameter of the hole. If the ValueInput uses
      a real, it is interpreted as centimeters. If it is a string, the units
      can be defined as part of the string (i.e. "3 in") If no units are specified,
      it is interpreted using the current default units for length.
      If tap information is added to the hole using the returned HoleFeatureInput, it will
      override this diameter, and the hole will be the correct size for the specified tap.
      @param counterboreDiameter A ValueInput object that defines the counterbore diameter of the hole. If the ValueInput uses
      a real, it is interpreted as centimeters. If it is a string, the units
      can be defined as part of the string (i.e. "3 in") If no units are specified,
      it is interpreted using the current default units for length.
      @param counterboreDepth A ValueInput object that defines the counterbore depth of the hole. If the ValueInput uses
      a real, it is interpreted as centimeters. If it is a string, the units
      can be defined as part of the string (i.e. "3 in") If no units are specified,
      it is interpreted using the current default units for length.
      @returns Returns the newly created HoleFeatureInput object or null if the creation failed.
    */
    createCounterboreInput(holeDiameter: core.ValueInput, counterboreDiameter: core.ValueInput, counterboreDepth: core.ValueInput): HoleFeatureInput | null
    /**
      Creates a HoleFeatureInput object that defines a countersink hole. This is not
      a hole feature but an object used to create a hole feature. Functionality
      on the returned HoleFeatureInput object is used to define the position and extent of the hole.
      @param holeDiameter A ValueInput object that defines the diameter of the hole. If the ValueInput uses
      a real, it is interpreted as centimeters. If it is a string, the units
      can be defined as part of the string (i.e. "3 in") If no units are specified,
      it is interpreted using the current default units for length.
      If tap information is added to the hole using the returned HoleFeatureInput, it will
      override this diameter, and the hole will be the correct size for the specified tap.
      @param countersinkDiameter A ValueInput object that defines the diameter of the countersink. If the ValueInput uses
      a real, it is interpreted as centimeters. If it is a string, the units
      can be defined as part of the string (i.e. "3 in") If no units are specified,
      it is interpreted using the current default units for length.
      @param countersinkAngle A ValueInput object that defines the angle of the countersink. If the ValueInput uses
      a real then it is interpreted as radians. If it is a string then the units
      can be defined as part of the string (i.e. "120 deg"). If no units are specified
      it is interpreted using the current default units for angles.
      @returns Returns the newly created HoleFeatureInput object or null if the creation failed.
    */
    createCountersinkInput(holeDiameter: core.ValueInput, countersinkDiameter: core.ValueInput, countersinkAngle: core.ValueInput): HoleFeatureInput | null
    /**
      Creates a new hole feature based on the information provided by a HoleFeatureInput object.
      To create a new hole, use one of the createInput functions to define a new input object for
      the type of hole you want to create. Use the methods and properties on the input object
      to define any additional input. Once the information is defined on the input object, you
      can pass it to the Add method to create the hole.
      @param input The HoleFeatureInput object that defines the hole you want to create.
      @returns Returns the newly created HoleFeature or null if the creation failed.
    */
    add(input: HoleFeatureInput): HoleFeature | null
    /**
      Function that returns the specified hole feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): HoleFeature | null
  }

  /**
    List of the different types of holes.
  */
  const enum HoleTypes {
    /**
      A simple drilled hole.
    */
    SimpleHoleType,
    /**
      A counterbore hole.
    */
    CounterboreHoleType,
    /**
      a countersink hole.
    */
    CountersinkHoleType,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a hole
    feature.
  */
  abstract class HoleFeatureInput extends core.Base {
    /**
      Defines the position of a the hole using a point. The point can be a vertex on the face
      or it can be a Point3D object to define any location on the face. If a Point3D object is
      provided it will be projected onto the plane along the planes normal. The orientation of the
      hole is defined by the planar face or construction plane. If a vertex is used, the position of
      the hole is associative to that vertex. If a Point3D object is used the position of the hole
      is not associative.
      @param planarEntity The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
      The natural direction of the hole will be opposite the normal of the face or construction plane.
      @param point A Point3D object or vertex that defines the position of the hole. The point will be projected
      onto the plane along the normal of the plane.
      @returns Returns true if successful.
    */
    setPositionByPoint(planarEntity: core.Base, point: core.Base): boolean
    /**
      Defines the position of the hole at the center of a circular or elliptical edge of the face.
      @param planarEntity The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
      The natural direction of the hole will be opposite the normal of the face or construction plane.
      @param centerEdge A circular or elliptical edge whose center point will be the position of the hole.
      @returns Returns true if successful.
    */
    setPositionAtCenter(planarEntity: core.Base, centerEdge: BRepEdge): boolean
    /**
      Defines the position and orientation of the hole using a sketch point.
      @param sketchPoint The sketch point that defines the position of the hole. The orientation is
      inferred from the normal of the point's parent sketch. The natural direction will be
      opposite the normal of the sketch.
      @returns Returns true if successful.
    */
    setPositionBySketchPoint(sketchPoint: SketchPoint): boolean
    /**
      Defines the orientation of the hole using a planar face or construction plane.
      The position of the hole is defined by the distance from one or two edges.
      @param planarEntity The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
      The natural direction of the hole will be opposite the normal of the face or construction plane.
      @param point A Point3D object that defines the approximate initial position of the hole. The point will be
      projected onto the plane. This point should be close to the final position of the hole and
      is used to determine which solution out of several possible solutions should be chosen
      for the hole location.
      This point is defined in the coordinate system of the native entity used for the planarEntity
      argument. For example, if the planarEntity argument is a proxy to a BRepFace, the point argument
      must be in the coordinate system of the component of the native face, not the proxy.
      @param edgeOne A linear BRepEdge object that the position of the hole will be measured from. The position
      of the hole will be measured along a perpendicular from this edge.
      @param offsetOne A ValueInput object that defines the offset distance from edgeOne. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "3 in"). If no units are specified
      it is interpreted using the current default units for length.
      @param edgeTwo You can optionally define a second edge and offset to specify the position of the hole. If you use a
      second edge it has the same requirements as the edgeOne argument. If you provide a second edge you
      must also provide the offsetTwo argument.
      @param offsetTwo If edgeTwo is defined, you must provide this argument which is a ValueInput object that
      defines the offset from the edgeTwo. If the ValueInput uses a real then it is interpreted
      as centimeters. If it is a string then the units can be defined as part of the string
      (i.e. "3 in"). If no units are specified it is interpreted using the current default units
      for length.
      @returns Returns true if successful.
    */
    setPositionByPlaneAndOffsets(planarEntity: core.Base, point: core.Point3D, edgeOne: BRepEdge, offsetOne: core.ValueInput, edgeTwo?: BRepEdge/* = null*/, offsetTwo?: core.ValueInput/* = null*/): boolean
    /**
      Defines the position and orientation of the hole to be on the start, end or center of an edge.
      @param planarEntity The planar BRepFace or ConstructionPlane object that defines the orientation of the hole
      and start of the hole. The natural direction of the hole will be opposite the normal of
      the face or construction plane.
      @param edge The edge to position the hole on.
      @param position The position along the edge to place the hole.
      @returns Returns true if successful.
    */
    setPositionOnEdge(planarEntity: core.Base, edge: BRepEdge, position: HoleEdgePositions): boolean
    /**
      Gets the ValueInput object that defines the angle of the tip of the hole. The default
      is "118.0 deg" but can be modified by setting it using another Value object.
    */
    tipAngle: core.ValueInput
    /**
      Gets or sets if the hole goes in the default direction or is reversed.
    */
    isDefaultDirection: boolean
    /**
      Defines the depth of the hole using a specified distance.
      @param distance The depth of the hole. If a real is specified the value is in centimeters.
      If a string is specified the units are derived from the string. If no units are specified,
      the default units of the document are used.
      @returns Returns true if setting the extent was successful.
    */
    setDistanceExtent(distance: core.ValueInput): boolean
    /**
      Defines the extent of the hole to be through-all. The direction can be
      either positive, negative.
      @param direction The direction of the hole relative to the normal of the sketch plane.
      @returns Returns true if successful.
    */
    setAllExtent(direction: ExtentDirections): boolean
    /**
      Sets the extent of the hole to be from the sketch plane to the specified "to" face.
      @param toEntity The entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For a hole it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @param matchShape Indicates if the hole is not contained on the face that the hole should match
      the shape of the entity as if it extended beyond its current boundaries.
      @param directionHint Specifies the direction of the hole. This is only used in the case where there are two possible solutions and the hole can
      hit the toEntity in either direction.
      Typically there is only a single solution and the direction is determined automatically.
      @returns Returns true if successful.
    */
    setOneSideToExtent(toEntity: core.Base, matchShape: boolean, directionHint?: core.Vector3D/* = null*/): boolean
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the Hole is created based on geometry (e.g. a face or point)
      in another component AND (the Hole) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
      A value of null indicates that everything is in the context of a single component.
    */
    creationOccurrence: Occurrence
    /**
      Defines the position and orientation of the hole using a set of sketch points.
      @param sketchPoints A collection of sketch points that defines the positions of the holes. The orientation is
      inferred from the normal of the point's parent sketch. The natural direction will be
      opposite the normal of the sketch. The points can be from multiple sketches but they
      must all be co-planar.
      @returns Returns true if successful.
    */
    setPositionBySketchPoints(sketchPoints: core.ObjectCollection): boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets the list of bodies that will participate in the hole.
      If this property has not been set, the default behavior is that all bodies that are intersected by the
      hole will participate.
      This property can return null in the case where the feature has not been fully defined so that
      possible intersecting bodies can be computed.
    */
    participantBodies: BRepBody[]
  }

  /**
    List of the different types of fit that a clearance hole can be.
  */
  const enum ClearanceHoleFits {
    /**
      The clearance hole is a tight or close fit around the fastener.
    */
    CloseClearanceHoleFit,
    /**
      The clearance hole is a normal fit around the fastener.
    */
    NormalClearanceHoleFit,
    /**
      The clearance hole is a loose fit around the fastener.
    */
    LooseClearanceHoleFit,
  }

  /**
    List of the valid tap types for holes.
  */
  const enum HoleTapTypes {
    /**
      A simple (no threads) hole tap type.
    */
    SimpleHoleTapType,
    /**
      A clearance hole tap type.
    */
    ClearanceHoleTapType,
    /**
      A tapped hole tap type.
    */
    TappedHoleTapType,
    /**
      A taper tapped hole tap type.
    */
    TaperTappedHoleTapType,
  }

  /**
    Object that represents an existing hole feature in a design.
  */
  abstract class HoleFeature extends Feature {
    /**
      Returns the position of the hole.
    */
    readonly position: core.Point3D
    /**
      Returns the direction of the hole.
    */
    readonly direction: core.Vector3D
    /**
      Returns the current type of hole this feature represents.
    */
    readonly holeType: HoleTypes
    /**
      Returns the model parameter controlling the hole diameter. The diameter of
      the hole can be edited through the returned parameter object.
      If there is a thread associated with the hole the thread definition controls
      the diameter of the hole. Even though there is a parameter for the diameter,
      its value is ignored when there is a thread.
    */
    readonly holeDiameter: ModelParameter
    /**
      Returns the model parameter controlling the angle of the tip of the hole. The tip angle of
      the hole can be edited through the returned parameter object.
    */
    readonly tipAngle: ModelParameter
    /**
      Returns the model parameter controlling the counterbore diameter.
      This will return null in the case the hole type is not a counterbore.
      The diameter of the counterbore can be edited through the returned parameter.
    */
    readonly counterboreDiameter: ModelParameter
    /**
      Returns the model parameter controlling the counterbore depth.
      This will return null in the case the hole type is not a counterbore.
      The depth of the counterbore can be edited through the returned parameter.
    */
    readonly counterboreDepth: ModelParameter
    /**
      Returns the model parameter controlling the countersink diameter.
      This will return null in the case the hole type is not a countersink.
      The diameter of the countersink can be edited through the returned parameter.
    */
    readonly countersinkDiameter: ModelParameter
    /**
      Returns the model parameter controlling the countersink angle.
      This will return null in the case the hole type is not a countersink.
      The angle of the countersink can be edited through the returned parameter.
    */
    readonly countersinkAngle: ModelParameter
    /**
      Gets and sets if the hole is in the default direction or not.
    */
    isDefaultDirection: boolean
    /**
      Calling this method will change the hole to a simple hole.
      @returns Returns true if changing the hole was successful.
    */
    setToSimple(): boolean
    /**
      Calling this method will change the hole to a counterbore hole.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param counterboreDiameter A ValueInput object that defines the counterbore diameter. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "3 in"). If no units are specified
      it is interpreted using the current default units for length.
      @param counterboreDepth A ValueInput object that defines the counterbore depth. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "3 in"). If no units are specified
      it is interpreted using the current default units for length.
      @returns Returns true if changing the hole was successful.
    */
    setToCounterbore(counterboreDiameter: core.ValueInput, counterboreDepth: core.ValueInput): boolean
    /**
      Calling this method will change the hole to a countersink hole.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param countersinkDiameter A ValueInput object that defines the countersink diameter. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "3 in"). If no units are specified
      it is interpreted using the current default units for length.
      @param countersinkAngle A ValueInput object that defines the countersink angle. If the ValueInput uses
      a real then it is interpreted as radians. If it is a string then the units
      can be defined as part of the string (i.e. "120 deg"). If no units are specified
      it is interpreted using the current default units for length.
      @returns Returns true if changing the hole was successful.
    */
    setToCountersink(countersinkDiameter: core.ValueInput, countersinkAngle: core.ValueInput): boolean
    /**
      Gets the definition object that is defining the extent of the hole. Modifying the
      definition object will cause the hole to recompute. The extent type of a hole
      is currently limited to a distance extent.
    */
    readonly extentDefinition: ExtentDefinition
    /**
      Defines the depth of the hole using a specific distance.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param distance The depth of the hole. If a real is specified the value is in centimeters. If a string is
      specified the units are derived from the string. If no units are specified, the default
      units of the document are used.
      @returns Returns true if setting the extent was successful.
    */
    setDistanceExtent(distance: core.ValueInput): boolean
    /**
      Defines the extent of the hole to be through-all. The direction can be
      either positive, negative.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param direction The direction of the hole relative to the normal of the sketch plane.
      @returns Returns true if successful.
    */
    setAllExtent(direction: ExtentDirections): boolean
    /**
      Sets the extent of the hole to be from the sketch plane to the specified "to" face.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param toEntity The entity that defines the "to" extent. The valid types of entities can vary depending on
      the type of feature this is being used with. For a hole it can be a BRepBody, BRepFace,
      BRepVertex, ConstructionPlane, or ConstructionPoint.
      @param matchShape Indicates if the hole is not contained on the face that the hole should match
      the shape of the entity as if it extended beyond its current boundaries.
      @param directionHint Specifies the direction of the hole. This is only used in the case where there are two possible solutions and the hole can
      hit the toEntity in either direction.
      Typically there is only a single solution and the direction is determined automatically.
      @returns Returns true if successful.
    */
    setOneSideToExtent(toEntity: core.Base, matchShape: boolean, directionHint?: core.Vector3D/* = null*/): boolean
    /**
      Property that returns the faces at the bottom of the hole. This will typically be a single face
      but could return more than one face in the case where the bottom of the hole is uneven.
    */
    readonly endFaces: BRepFaces
    /**
      Property that returns all of the side faces of the hole.
    */
    readonly sideFaces: BRepFaces
    /**
      Redefines the position of a the hole using a point. The point can be a vertex on the face
      or it can be a Point3D object to define any location on the face. If a Point3D object is
      provided it will be projected onto the plane along the planes normal. The orientation of the
      hole is defined by the planar face or construction plane. If a vertex is used, the position of
      the hole is associative to that vertex. If a Point3D object is used the position of the hole
      is not associative.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param planarEntity The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
      The natural direction of the hole will be opposite the normal of the face or construction plane.
      @param point A Point3D object or vertex that defines the position of the hole. The point will be projected
      onto the plane along the normal of the plane.
      @returns Returns true if successful.
    */
    setPositionByPoint(planarEntity: core.Base, point: core.Base): boolean
    /**
      Redefines the position of the hole at the center of a circular or elliptical edge of the face.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param planarEntity The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
      The natural direction of the hole will be opposite the normal of the face or construction plane.
      @param centerEdge A circular or elliptical edge whose center point will be the position of the hole.
      @returns Returns true if successful.
    */
    setPositionAtCenter(planarEntity: core.Base, centerEdge: BRepEdge): boolean
    /**
      Redefines the position and orientation of the hole using a sketch point.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param sketchPoint The sketch point that defines the position of the hole. The orientation is
      inferred from the normal of the point's parent sketch. The natural direction will be
      opposite the normal of the sketch.
      @returns Returns true if successful.
    */
    setPositionBySketchPoint(sketchPoint: SketchPoint): boolean
    /**
      Redefines the position and orientation of the hole using a set of points.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param sketchPoints A collection of sketch points that defines the positions of the holes. The orientation is
      inferred from the normal of the point's parent sketch. The natural direction will be
      opposite the normal of the sketch. All of the points must be in the same sketch.
      @returns Returns true if successful.
    */
    setPositionBySketchPoints(sketchPoints: core.ObjectCollection): boolean
    /**
      Redefines the orientation of the hole using a planar face or construction plane.
      The position of the hole is defined by the distance from one or two edges.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param planarEntity The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
      The natural direction of the hole will be opposite the normal of the face or construction plane.
      @param point A Point3D object that defines the approximate initial position of the hole. The point will be
      projected onto the plane. This point should be close to the final position of the hole and
      is used to determine which solution out of several possible solutions should be chosen
      for the hole location.
      @param edgeOne A linear BRepEdge object that the position of the hole will be measured from. The position
      of the hole will be measured along a perpendicular from this edge.
      @param offsetOne A ValueInput object that defines the offset distance from edgeOne. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "3 in"). If no units are specified
      it is interpreted using the current default units for length.
      @param edgeTwo You can optionally define a second edge and offset to specify the position of the hole. If you use a
      second edge it has the same requirements as the edgeOne argument. If you provide a second edge you
      must also provide the offsetTwo argument.
      @param offsetTwo If edgeTwo is defined, you must provide this argument which is a ValueInput object that
      defines the offset from the edgeTwo. If the ValueInput uses a real then it is interpreted
      as centimeters. If it is a string then the units can be defined as part of the string
      (i.e. "3 in"). If no units are specified it is interpreted using the current default units
      for length.
      @returns Returns true if successful.
    */
    setPositionByPlaneAndOffsets(planarEntity: core.Base, point: core.Point3D, edgeOne: BRepEdge, offsetOne: core.ValueInput, edgeTwo?: BRepEdge/* = null*/, offsetTwo?: core.ValueInput/* = null*/): boolean
    /**
      Redefines the position and orientation of the hole to be on the start, end or center of an edge.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param planarEntity The planar BRepFace or ConstructionPlane object that defines the orientation of the hole
      and start of the hole. The natural direction of the hole will be opposite the normal of
      the face or construction plane.
      @param edge The edge to position the hole on.
      @param position The position along the edge to place the hole.
      @returns Returns true if successful.
    */
    setPositionOnEdge(planarEntity: core.Base, edge: BRepEdge, position: HoleEdgePositions): boolean
    /**
      Returns a HolePositionDefinition object that provides access to the information used
      to define the position of the hole. This returns null in the case where IsParametric
      is false.
    */
    readonly holePositionDefinition: HolePositionDefinition
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: HoleFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): HoleFeature | null
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    participantBodies: BRepBody[]
  }

  /**
    The base class for the classes that define how a hole can be positioned.
  */
  abstract class HolePositionDefinition extends core.Base {
  }

  /**
    Provides positioning information for a hole that is positioned relative to a 3D coordinate
    point.
  */
  abstract class PointHolePositionDefinition extends HolePositionDefinition {
    /**
      Returns the plane that defines the orientation and start of the hole.
    */
    readonly planarEntity: core.Base
    /**
      Returns the coordinates defining the position of the hole.
    */
    readonly point: core.Base
  }

  /**
    Provides positioning information for a hole that is positioned at the center of a
    circular or elliptical edge.
  */
  abstract class AtCenterHolePositionDefinition extends HolePositionDefinition {
    /**
      Returns the plane that defines the orientation and start of the hole.
    */
    readonly planarEntity: core.Base
    /**
      Returns the circular or elliptical edge the hole is centered at.
    */
    readonly centerEdge: BRepEdge
  }

  /**
    Provides positioning information for a hole that is positioned by a sketch point.
  */
  abstract class SketchPointHolePositionDefinition extends HolePositionDefinition {
    /**
      Returns the sketch point that defines the center of the hole.
    */
    readonly sketchPoint: SketchPoint
  }

  /**
    Provides positioning information for a hole that is positioned by a sketch point.
  */
  abstract class SketchPointsHolePositionDefinition extends HolePositionDefinition {
    /**
      Returns the sketch point that defines the center of the hole.
    */
    readonly sketchPoints: core.ObjectCollection
  }

  /**
    Provides positioning information for a hole that is positioned on a plane
    and at a distance from one or two edges.
  */
  abstract class PlaneAndOffsetsHolePositionDefinition extends HolePositionDefinition {
    /**
      Returns the plane that defines the orientation and start of the hole.
    */
    readonly planarEntity: core.Base
    /**
      The first of 2 edges the hole position is measured from. OffsetOne provides access to
      the model parameter controlling the offset distance.
    */
    readonly edgeOne: BRepEdge
    /**
      Returns the model parameter controlling the distance from the center of the hole
      to EdgeOne.
    */
    readonly offsetOne: ModelParameter
    /**
      The second of two edges the hole position is measured from. OffsetTwo provides access
      to the model parameter controlling the offset distance. This property can return null
      in the case where only one edge is used.
    */
    readonly edgeTwo: BRepEdge
    /**
      Returns the model parameter controlling the distance from the center of the hole
      to EdgeTwo. This property returns null in the case where only one edge is used.
    */
    readonly offsetTwo: ModelParameter
  }

  /**
    Provides positioning information for a hole that is positioned
    on the start, end or center of an edge.
  */
  abstract class OnEdgeHolePositionDefinition extends HolePositionDefinition {
    /**
      Returns the plane that defines the orientation and start of the hole.
    */
    readonly planarEntity: core.Base
    /**
      Returns the edge the hole is positioned on.
    */
    readonly edge: BRepEdge
    /**
      Returns the position of the hole on the edge.
      The hole can be at the start, midpoint, or end of the edge.
    */
    readonly position: HoleEdgePositions
  }

  /**
    List of the valid edge positions for holes.
  */
  const enum HoleEdgePositions {
    /**
      The start point of an Edge.
    */
    EdgeStartPointPosition,
    /**
      The midpoint of an Edge.
    */
    EdgeMidPointPosition,
    /**
      The end point of an Edge.
    */
    EdgeEndPointPosition,
  }

  /**
    Collection that provides access to all of the existing fillet features in a component
    and supports the ability to create new fillet features.
  */
  abstract class FilletFeatures extends core.Base {
    /**
      Function that returns the specified fillet feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): FilletFeature | null
    /**
      The number of fillet features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a FilletFeatureInput object. Use properties and methods on this object
      to define the fillet you want to create and then use the Add method, passing in
      the FilletFeatureInput object.
      @returns Returns the newly created FilletFeatureInput object or null if the creation failed.
    */
    createInput(): FilletFeatureInput | null
    /**
      Creates a new fillet feature.
      @param input A FilletFeatureInput object that defines the desired fillet. Use the createInput
      method to create a new FilletFeatureInput object and then use methods on it
      (the FilletFeatureInput object) to define the fillet.
      @returns Returns the newly created FilletFeature object or null if the creation failed.
    */
    add(input: FilletFeatureInput): FilletFeature | null
    /**
      Function that returns the specified fillet feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): FilletFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a fillet
    feature.
  */
  abstract class FilletFeatureInput extends core.Base {
    /**
      Adds a set of edges with a constant radius to this input.
      @remarks
      This method is obsolete. You should now use the methods on the EdgeSetInputs objects to
      define new fillets.
      @param edges An ObjectCollection containing the edges to be filleted. If the isTangentChain argument is true
      additional edges may also get filleted if they are tangentially connected to any of the
      input edges.
      @param radius A ValueInput object that defines the radius of the fillet. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param isTangentChain A boolean value for setting whether or not edges that are tangentially connected to
      the input edges (if any) will also be filleted.
      @returns Returns true if the set of edges was successfully added to the FilletFeatureInput.
      @deprecated
    */
    addConstantRadiusEdgeSet(edges: core.ObjectCollection, radius: core.ValueInput, isTangentChain: boolean): boolean
    /**
      Adds a single edge or set of tangent edges along with variable radius information to this input.
      @remarks
      This method is obsolete. You should now use the methods on the EdgeSetInputs objects to
      define new fillets.
      @param tangentEdges An object collection containing a single edge or multiple edges. Multiple edges
      must be tangentially connected and added to the collection in order.
      @param startRadius A ValueInput object that defines the starting radius of the fillet. If a single edge is
      being filleted, the start radius is at the start end of the edge. If multiple tangent
      edges are being filleted the start radius is the open end of the first edge in the
      collection.
      If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then
      the units can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param endRadius A ValueInput object that defines the ending radius of the fillet. If a single edge is
      being filleted, the end radius is at the end of the edge. If multiple tangent
      edges are being filleted the end radius is the open end of the last edge in the
      collection.
      If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then
      the units can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param positions An array of ValueInput objects that defines the positions of any additional radii
      along the edge(s). The value must be between 0 and 1 and defines the percentage along the
      curve where a radius is defined. The value is unitless. This array must have the same
      number of values as the array passed in for the radii argument.
      @param radii An array of ValueInput objects that define the radii at positions along the edge(s).
      This array must have the same number of values as the array passed in for
      the positions argument. If the ValueInput uses a real then it is interpreted as centimeters.
      If it is a string then the units can be defined as part of the string (i.e. "2 in").
      If no units are specified it will be interpreted using the current default units for length.
      @returns Returns true if the edge set was successfully added to the FilletFeatureInput.
      @deprecated
    */
    addVariableRadiusEdgeSet(tangentEdges: core.ObjectCollection, startRadius: core.ValueInput, endRadius: core.ValueInput, positions: core.ValueInput[], radii: core.ValueInput[]): boolean
    /**
      Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option.
      @remarks
      This property is obsolete. You should now use the continuity property on the EdgeSetInput object
      to control the continuity.
      define new fillets.
      @deprecated
    */
    isG2: boolean
    /**
      Gets and sets if a rolling ball or setback solution is to be used in any corners.
    */
    isRollingBallCorner: boolean
    /**
      Gets and sets if any edges that are tangentially connected to any of filleted
      edges will also be included in the fillet.
      @remarks
      This property is obsolete. You should now use the FilletEdgeSet object to define if the tangency
      chaining should be used for entities in that edge set.
      @deprecated
    */
    isTangentChain: boolean
    /**
      Adds a set of edges with a chord length to this input.
      @remarks
      This method is obsolete. You should now use the methods on the EdgeSetInputs objects to
      define new fillets.
      @param edges An ObjectCollection containing the edges to be filleted. If the isTangentChain argument is true
      additional edges may also get filleted if they are tangentially connected to any of the
      input edges.
      @param chordLength A ValueInput object that defines the chord length of the fillet. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param isTangentChain A boolean value for setting whether or not edges that are tangentially connected to
      the input edges (if any) will also be filleted.
      @returns Returns true if the set of edges was successfully added to the FilletFeatureInput.
      @deprecated
    */
    addChordLengthEdgeSet(edges: core.ObjectCollection, chordLength: core.ValueInput, isTangentChain: boolean): boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets the FilletEdgeSetInputs object that provides support to create the various types of edge
      sets that will be used to create the fillet.
    */
    readonly edgeSetInputs: FilletEdgeSetInputs
  }

  /**
    Collection of edge sets associated with the input object that will be used
    to create the new fillet feature. Use the various add methods on this object
    to add new edge sets to the input object.
  */
  abstract class FilletEdgeSetInputs extends core.Base {
    /**
      Function that returns the specified fillet edge set input using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      The edge sets are returned in the same order they were created in.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): FilletEdgeSetInput | null
    /**
      The number of fillet edge set input objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a constant radius fillet edge set to the fillet feature input. Some settings are initialized
      with a default value and can be set by modifying properties on the returned ConstantRadiusFilletEdgeSetInput object.
      @param entities An ObjectCollection containing the BRepEdge, BRepFace, and Feature objects to be filleted. If the isTangentChain argument is true
      additional edges or faces may also get filleted if they are tangentially connected to any of the
      input edges or faces.
      @param radius A ValueInput object that defines the radius of the fillet. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param isTangentChain A boolean value for setting whether or not edges that are tangentially connected to
      the input edges (if any) will also be filleted.
      @returns Returns the newly created ConstantRadiusFilletEdgeSetInput. This object provides access to additional settings.
    */
    addConstantRadiusEdgeSet(entities: core.ObjectCollection, radius: core.ValueInput, isTangentChain: boolean): ConstantRadiusFilletEdgeSetInput
    /**
      Adds a single edge or set of tangent edges to the fillet feature input. Some settings are initialized
      with a default value and can be set by modifying properties on the returned VariableRadiusFilletEdgeSetInput object.
      @param tangentEdges An object collection containing a single edge or multiple edges. Multiple edges
      must be tangentially connected and added to the collection in their connected order. If a single edge
      is input, you can use the isTangentChain argument to automatically find any tangentially connected edges.
      @param startRadius A ValueInput object that defines the starting radius of the fillet. If a single edge is
      being filleted, the start radius is at the start end of the edge. If multiple tangent
      edges are being filleted the start radius is the start end of the first edge in the
      collection.
      If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then
      the units can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param endRadius A ValueInput object that defines the ending radius of the fillet. If a single edge is
      being filleted, the end radius is at the end of the edge. If multiple tangent
      edges are being filleted the end radius is the open end of the last edge in the
      collection.
      If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then
      the units can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param isTangentChain A boolean value for setting whether or not edges that are tangentially connected to the single
      input edge will also be filleted.
      @returns Returns the newly created VariableRadiusFilletEdgeSetInput. This object provides access to additional settings.
    */
    addVariableRadiusEdgeSet(tangentEdges: core.ObjectCollection, startRadius: core.ValueInput, endRadius: core.ValueInput, isTangentChain: boolean): VariableRadiusFilletEdgeSetInput
    /**
      Adds a set of edges to be filleted with a chord length fillet to the fillet feature input. Some settings are
      initialized with a default value and can be set by modifying properties on the returned ChordLengthFilletEdgeSetInput object.
      @param entities An ObjectCollection containing the BRepEdge, BRepFace, and Feature objects to be filleted. If the isTangentChain argument is true
      additional edges or faces may also get filleted if they are tangentially connected to any of the
      input edges or faces.
      @param chordLength A ValueInput object that defines the chord length of the fillet. If the ValueInput uses
      a real value then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current document units for length.
      @param isTangentChain A boolean value for setting whether or not edges or faces that are tangentially connected to
      the input edges or faces (if any) will also be filleted.
      @returns Returns the newly created ChordLengthFilletEdgeSetInput. This object provides access to additional settings.
    */
    addChordLengthEdgeSet(entities: core.ObjectCollection, chordLength: core.ValueInput, isTangentChain: boolean): ChordLengthFilletEdgeSetInput
  }

  /**
    Represents the input to define a fillet edge set.
  */
  abstract class FilletEdgeSetInput extends core.Base {
    /**
      Gets and sets the entities associated with this fillet edge set. For constant radius and chord length
      edge sets, this can be edges, faces, and features. For variable radius edges sets, this must be edges.
    */
    entities: core.ObjectCollection
    /**
      Gets and sets the continuity of the fillet edge set. Valid values are
      TangentSurfaceContinuityType and CurvatureSurfaceContinuityType. The default
      is TangentSurfaceContinuityType.
    */
    continuity: SurfaceContinuityTypes
    /**
      Gets and sets the tangency weight for the given edge set. The tangency weight controls the influence
      of the continuity (G1 or G2) on the fillet. The ValueInput must be a real value between 0.1 and 2.0 inclusive,
      with no units. The default value is 1.0.
    */
    tangencyWeight: core.ValueInput
  }

  /**
    Provides access to the edges and the parameter associated with a constant radius fillet.
  */
  abstract class ConstantRadiusFilletEdgeSetInput extends FilletEdgeSetInput {
    /**
      Gets and sets ValueInput object that defines the radius of the fillet. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
    */
    radius: core.ValueInput
  }

  /**
    Provides access to the edges and the parameters associated with a variable radius fillet.
  */
  abstract class VariableRadiusFilletEdgeSetInput extends FilletEdgeSetInput {
    /**
      Gets and sets a ValueInput object that defines the starting radius of the fillet.
      If a single edge is being filleted, the start radius is at the start end of the edge.
      If multiple tangent edges are being filleted the start radius is the start end of the
      first edge in the collection.
      If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then
      the units can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
    */
    startRadius: core.ValueInput
    /**
      Gets and sets a ValueInput object that defines the ending radius of the fillet.
      If a single edge is being filleted, the end radius is at the end of the edge.
      If multiple tangent edges are being filleted the end radius is the open end of the
      last edge in the collection.
      If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then
      the units can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
    */
    endRadius: core.ValueInput
    /**
      Defines any additional points along the fillet where a radius is specified.
      @param radii An array of ValueInput objects that define the radii at positions along the edge(s).
      This array must have the same number of values as the positions argument.
      If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then the
      the units can be defined as part of the string (i.e. "2 in"). If no units are specified it will
      be interpreted using the current default units for length.
      @param positions An array of ValueInput objects that defines the positions of any additional radii
      along the edge(s). The value must be between 0 and 1 and defines the percentage along the curve
      where a radius is defined. This array must have the same number of values as the radii argument.
      If the ValueInput uses a real then it is interpreted as a unitless number. If it is a string then the
      the string must evaluate to a unitless number.
      @returns Returns true if successful.
    */
    setMidRadii(radii: core.ValueInput[], positions: core.ValueInput[]): boolean
  }

  /**
    Provides access to the edges and the parameter associated with a chord length fillet.
  */
  abstract class ChordLengthFilletEdgeSetInput extends FilletEdgeSetInput {
    /**
      Gets and sets a ValueInput object that defines the chord length of the fillet. If the
      ValueInput uses a real value then it is interpreted as centimeters. If it is a string
      then the units can be defined as part of the string (i.e. "2 in") or if no units are
      specified it is interpreted using the current document units for length.
    */
    chordLength: core.ValueInput
  }

  /**
    Object that represents an existing fillet feature in a design.
  */
  abstract class FilletFeature extends Feature {
    /**
      Returns the edge sets collection associated with this fillet.
    */
    readonly edgeSets: FilletEdgeSets
    /**
      Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option.
      @remarks
      This property is obsolete. You should now use the continuity property on the FilletEdgeSet object
      to control the continuity.
      @deprecated
    */
    isG2: boolean
    /**
      Gets and sets if a rolling ball solution is to be used in any corners.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isRollingBallCorner: boolean
    /**
      Gets and sets whether or not edges that are tangentially connected to
      the input edges (if any) will also be filleted.
      @remarks
      This property is obsolete. You should now use the isTangentChain property on the FilletEdgeSet object.
      @deprecated
    */
    isTangentChain: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: FilletFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): FilletFeature | null
  }

  /**
    Collection that provides access to all of the existing fillet edge sets associated with a fillet feature.
  */
  abstract class FilletEdgeSets extends core.Base {
    /**
      Function that returns the specified fillet edge set using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): FilletEdgeSet | null
    /**
      The number of fillet edge sets in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a set of edges with a constant radius to this fillet feature.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param entities An ObjectCollection containing the BRepEdge, BRepFace, and Feature objects to be filleted. If the isTangentChain argument is true
      additional edges or faces may also get filleted if they are tangentially connected to any of the
      input edges or faces.
      @param radius A ValueInput object that defines the radius of the fillet. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param isTangentChain A boolean value for setting whether or not edges that are tangentially connected to
      the input edges (if any) will also be filleted.
      @returns Returns the newly created FilletEdgeSet.
    */
    addConstantRadiusEdgeSet(entities: core.ObjectCollection, radius: core.ValueInput, isTangentChain: boolean): ConstantRadiusFilletEdgeSet
    /**
      Adds a single edge or set of tangent edges along with variable radius information to this fillet feature.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param tangentEdges An object collection containing a single edge or multiple edges. Multiple edges
      must be tangentially connected and added to the collection in their connected order. If a single edge
      is input, you can use the isTangentChain argument to automatically find any tangentially connected edges.
      @param startRadius A ValueInput object that defines the starting radius of the fillet. If a single edge is
      being filleted, the start radius is at the start end of the edge. If multiple tangent
      edges are being filleted the start radius is the open end of the first edge in the
      collection.
      If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then
      the units can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param endRadius A ValueInput object that defines the ending radius of the fillet. If a single edge is
      being filleted, the end radius is at the end of the edge. If multiple tangent
      edges are being filleted the end radius is the open end of the last edge in the
      collection.
      If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then
      the units can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param positions An array of ValueInput objects that defines the positions of any additional radii
      along the edge(s). The value must be between 0 and 1 and defines the percentage along the
      curve where a radius is defined. The value is unitless. This array must have the same
      number of values as the array passed in for the radii argument.
      @param radii An array of ValueInput objects that define the radii at positions along the edge(s).
      This array must have the same number of values as the array passed in for
      the positions argument. If the ValueInput uses a real then it is interpreted as centimeters.
      If it is a string then the units can be defined as part of the string (i.e. "2 in").
      If no units are specified it will be interpreted using the current default units for length.
      @param isTangentChain A boolean value for setting whether or not edges that are tangentially connected to the single
      input edge will also be filleted.
      @returns Returns the newly created FilletEdgeSet.
    */
    addVariableRadiusEdgeSet(tangentEdges: core.ObjectCollection, startRadius: core.ValueInput, endRadius: core.ValueInput, positions: core.ValueInput[], radii: core.ValueInput[], isTangentChain: boolean): VariableRadiusFilletEdgeSet
    /**
      Adds a set of edges with a chord length to this fillet feature.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param entities An ObjectCollection containing the BRepEdge, BRepFace, and Feature objects to be filleted. If the isTangentChain argument is true
      additional edges or faces may also get filleted if they are tangentially connected to any of the
      input edges or faces.
      @param chordLength A ValueInput object that defines the chord length of the fillet. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param isTangentChain A boolean value for setting whether or not edges that are tangentially connected to
      the input edges (if any) will also be filleted.
      @returns Returns the newly created FilletEdgeSet.
    */
    addChordLengthEdgeSet(entities: core.ObjectCollection, chordLength: core.ValueInput, isTangentChain: boolean): ChordLengthFilletEdgeSet
  }

  /**
    The base class for the classes that define the different types of fillet edge sets.
  */
  abstract class FilletEdgeSet extends core.Base {
    /**
      Gets and sets the Tangent chain for fillet. This enables tangent chain option for fillet.
    */
    isTangentChain: boolean
    /**
      Gets and sets the continuity of the fillet edge set. Valid values are
      TangentSurfaceContinuityType and CurvatureSurfaceContinuityType.
    */
    continuity: SurfaceContinuityTypes
    /**
      Returns the model parameter that controls the G1 or G2 tangency weight of the fillet.
      It must be a real value between 0.1 and 2.0 inclusive. You can edit the tangency weight
      by using the properties on the returned ModelParameter object.
    */
    readonly tangencyWeight: ModelParameter
    /**
      Deletes the fillet edge set from the fillet.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @returns Returns true if the operation was successful.
    */
    deleteMe(): boolean
  }

  /**
    Provides access to the edges and the parameter associated with a constant radius fillet.
  */
  abstract class ConstantRadiusFilletEdgeSet extends FilletEdgeSet {
    /**
      Gets and sets an ObjectCollection containing the BRepEdge, BRepFace, and Feature that are filleted.
      If the isTangentChain argument is true additional edges or faces may also get filleted if they are tangentially
      connected to any of the input edges or faces.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    edges: core.ObjectCollection
    /**
      Returns the model parameter that controls the radius of the fillet. You can edit
      the radius by using the properties on the returned ModelParameter object.
    */
    readonly radius: ModelParameter
  }

  /**
    Provides access to the edges and the parameters associated with a variable radius fillet.
  */
  abstract class VariableRadiusFilletEdgeSet extends FilletEdgeSet {
    /**
      Gets and sets an ObjectCollection containing the edges that are filleted.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    edges: core.ObjectCollection
    /**
      Returns the model parameter that controls the start radius of the fillet. You can edit
      the start radius by using the properties on the returned ModelParameter object.
    */
    readonly startRadius: ModelParameter
    /**
      Returns the model parameter that controls the end radius of the fillet. You can edit
      the end radius by using the properties on the returned ModelParameter object.
    */
    readonly endRadius: ModelParameter
    /**
      Returns a list of model parameters that control radius of the fillet at each position defined along the edge set.
      You can edit any of these radii by using the properties on its returned ModelParameter object. This list does
      not include the parameters for the start and end radii. Use the startRadius and endRadius properties to get those.
    */
    readonly midRadii: ParameterList
    /**
      Returns a list of model parameters that control the location of each mid point radius. These positions are defined
      from 0 to 1 where 0 is at the start of the edge and 1 is at the end. You can edit any of these positions by
      using the properties on its returned ModelParameter object.
    */
    readonly midPositions: ParameterList
    /**
      Creates a new mid position radius on the variable radius edge set.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param position The position where the new radius is to be created. This is a value between 0 and 1 where 0 is at the start of the
      edge and 1 is at the end. If the ValueInput uses a real then it is interpreted as a unitless value. If it is a string
      then it must resolve to a unitless value.
      @param radius A ValueInput object that defines the radius at the defined position. If the ValueInput uses a real
      then it is interpreted as centimeters. If it is a string then the units can be defined as part of
      the string (i.e. "2 in"). If no units are specified it will be interpreted using the current
      default units for length.
      @returns Returns true if successful.
    */
    addMidPosition(position: core.ValueInput, radius: core.ValueInput): boolean
    /**
      Deletes the specified mid position from the variable radius fillet.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param positionIndex The index of the mid position to delete. The points are in the order they appear along the edge
      where the first point has an index of 0. The number of mid positions and their locations can be
      obtained by getting the list of mid positions using the midPositions property.
      @returns Returns true if successful.
    */
    deleteMidPosition(positionIndex: number /*unsigned int*/): boolean
  }

  /**
    Provides access to the edges and the parameter associated with a chord length fillet.
  */
  abstract class ChordLengthFilletEdgeSet extends FilletEdgeSet {
    /**
      Gets and sets an ObjectCollection containing the BRepEdge, BRepFace, and Feature that are filleted.
      If the isTangentChain argument is true additional edges or faces may also get filleted if they are tangentially
      connected to any of the input edges or faces.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    edges: core.ObjectCollection
    /**
      Returns the model parameter that controls the chord length of the fillet. You can edit
      the chord length by using the properties on the returned ModelParameter object.
    */
    readonly chordLength: ModelParameter
  }

  /**
    List of the fillet feature types.
  */
  const enum FilletFeatureTypes {
    /**
      The fillet feature type.
    */
    FilletFeatureType = 0,
    /**
      The rule fillet feature type.
    */
    RuleFilletFeatureType = 1,
    /**
      The full round fillet feature type.
    */
    FullRoundFilletFeatureType = 2,
  }

  /**
    Collection that provides access to all of the existing chamfer features in a component
    and supports the ability to create new chamfer features.
  */
  abstract class ChamferFeatures extends core.Base {
    /**
      Function that returns the specified chamfer feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ChamferFeature | null
    /**
      The number of chamfer features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a ChamferFeatureInput object. Use properties and methods on this object
      to define the chamfer you want to create and then use the Add method, passing in
      the ChamferFeatureInput object.
      @param edges The collection of edges that will be chamfered.
      @param isTangentChain Boolean indicating if all edges that are tangentially connected to any of the input edges should be included in the chamfer or not.
      @returns Returns the newly created ChamferFeatureInput object or null if the creation failed.
      @deprecated
    */
    createInput(edges: core.ObjectCollection, isTangentChain: boolean): ChamferFeatureInput | null
    /**
      Creates a new chamfer feature.
      @param input A ChamferFeatureInput object that defines the desired chamfer. Use the createInput
      method to create a new ChamferFeatureInput object and then use methods on it
      (the ChamferFeatureInput object) to define the chamfer.
      @returns Returns the newly created ChamferFeature object or null if the creation failed.
    */
    add(input: ChamferFeatureInput): ChamferFeature | null
    /**
      Function that returns the specified chamfer feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): ChamferFeature | null
    /**
      Creates a ChamferFeatureInput object. Use properties and methods on this object
      to define the chamfer you want to create and then use the Add method, passing in
      the ChamferFeatureInput object.
      @returns Returns the newly created ChamferFeatureInput object or null if the creation failed.
    */
    createInput2(): ChamferFeatureInput | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a chamfer
    feature.
  */
  abstract class ChamferFeatureInput extends core.Base {
    /**
      Gets and sets the collection of edges that will be chamfered.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @deprecated
    */
    edges: core.ObjectCollection
    /**
      Adds a set of edges to this input.
      @param distance A ValueInput object that defines the size of the chamfer. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in"). If no units are specified
      it is interpreted using the current default units for length.
      @returns Returns true if the set of edges was successfully added to the ChamferFeatureInput.
      @deprecated
    */
    setToEqualDistance(distance: core.ValueInput): boolean
    /**
      Adds a set of edges to this input.
      @param distanceOne A ValueInput object that defines the distanceOne of the chamfer. This distance
      is along the face which is on the left of the selected edge.
      If the ValueInput uses a real then it is interpreted as centimeters.
      If it is a string then the units can be defined as part of the string (i.e. "2 in").
      If no units are specified it is interpreted using the current default units for length.
      @param distanceTwo A ValueInput object that defines the distanceTwo of the chamfer. This distance
      is along the face which is on the right of the selected edge.
      If the ValueInput uses a real then it is interpreted as centimeters.
      If it is a string then the units can be defined as part of the string (i.e. "2 in").
      If no units are specified it is interpreted using the current default units for length.
      @returns Returns true if successful.
      @deprecated
    */
    setToTwoDistances(distanceOne: core.ValueInput, distanceTwo: core.ValueInput): boolean
    /**
      Adds a set of edges to this input.
      @param distance A ValueInput object that defines the distance of the chamfer. This distance
      is along the face which is on the right of the selected edge.
      If the ValueInput uses a real then it is interpreted as centimeters.
      If it is a string then the units can be defined as part of the string (i.e. "2 in").
      If no units are specified it is interpreted using the current default units for length.
      @param angle A valueInput object that defines the angle. The direction will be towards to the face
      which is on the left of the selected edge. This can be a string or a value.
      If it's a string it is interpreted using the current document units and can include
      equations. For example all of the following are valid as long as they result in
      angle units "45", "45 deg", "a1 / 2". If a value is input it is interpreted
      as radians. It cannot be negative.
      @returns Returns true if successful.
      @deprecated
    */
    setToDistanceAndAngle(distance: core.ValueInput, angle: core.ValueInput): boolean
    /**
      Gets and sets if any edges that are tangentially connected to any of chamfered
      edges will also be included in the chamfer.
      @deprecated
    */
    isTangentChain: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets the type of corner to be modeled when multiple edges connect at a vertex.
    */
    cornerType: ChamferCornerTypes
    /**
      Returns the collection of edge sets for this chamfer feature input.
    */
    readonly chamferEdgeSets: ChamferEdgeSets
  }

  /**
    Specifies the type of corner to model when multiple edges come together at a vertex.
  */
  const enum ChamferCornerTypes {
    /**
      The default corner type, where a small patch is created at the corner.
    */
    ChamferCornerType,
    /**
      The chamfer surfaces extend and intersect one another to create the corner.
    */
    MiterCornerType,
    /**
      A blend surface is created to define the corner.
    */
    BlendCornertype,
  }

  /**
    Object that represents an existing chamfer feature in a design.
  */
  abstract class ChamferFeature extends Feature {
    /**
      Gets and sets the edges being chamfered. Specific edges can be defined using one or more BRepEdge
      objects or BRepFace objects can be used to chamfer all edges of the face or Feature objects can
      be used to chamfer all edges associated with the input features. If BRepEdge objects are provided
      and the isTangentChain argument is true additional edges may also get chamfered if they are
      tangentially connected to any of the input edges. When getting the property, your
      code should check for the different types in the returned collection and handle it appropriately.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      This property returns nothing in the case where the feature is non-parametric.
      @deprecated
    */
    edges: core.ObjectCollection
    /**
      Gets and sets whether or not edges that are tangentially connected to
      the input edges (if any) will also be chamfered.
      @deprecated
    */
    isTangentChain: boolean
    /**
      Gets an enum indicating how the chamfer was defined. The valid return values are
      EqualDistanceType, TwoDistancesType and DistanceAndAngleType.
      This property returns nothing in the case where the feature is non-parametric.
      @deprecated
    */
    readonly chamferType: ChamferTypes
    /**
      Gets the definition object that is defining the type of chamfer. Modifying the
      definition object will cause the chamfer to recompute. Various types of definition objects can
      be returned depending on how the chamfer is defined. The ChamferType property can
      be used to determine which type of definition will be returned.
      This property returns nothing in the case where the feature is non-parametric.
      @deprecated
    */
    readonly chamferTypeDefinition: ChamferTypeDefinition
    /**
      Changes the type of chamfer to be an equal distance chamfer.
      @param distance A ValueInput object that defines the distance of the chamfer. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in"). If no units are specified
      it is interpreted using the current default units for length.
      @returns Returns true if the feature is successfully changed
      @deprecated
    */
    setEqualDistance(distance: core.ValueInput): boolean
    /**
      Changes the type of chamfer to be a two distances chamfer.
      @param distanceOne A ValueInput object that defines the distanceOne of the chamfer. This distance
      is along the face which is on the left of the selected edge.
      If the ValueInput uses a real then it is interpreted as centimeters.
      If it is a string then the units can be defined as part of the string (i.e. "2 in").
      If no units are specified it is interpreted using the current default units for length.
      @param distanceTwo A ValueInput object that defines the distanceTwo of the chamfer. This distance
      is along the face which is on the right of the selected edge.
      If the ValueInput uses a real then it is interpreted as centimeters.
      If it is a string then the units can be defined as part of the string (i.e. "2 in").
      If no units are specified it is interpreted using the current default units for length.
      @returns Returns true if the feature is successfully changed
      @deprecated
    */
    setTwoDistances(distanceOne: core.ValueInput, distanceTwo: core.ValueInput): boolean
    /**
      Changes the type of chamfer to be a distance and angle chamfer.
      @param distance A ValueInput object that defines the distance of the chamfer. This distance
      is along the face which is on the right of the selected edge.
      If the ValueInput uses a real then it is interpreted as centimeters.
      If it is a string then the units can be defined as part of the string (i.e. "2 in").
      If no units are specified it is interpreted using the current default units for length.
      @param angle A valueInput object that defines the angle. The direction will be towards to the face
      which is on the left of the selected edge. This can be a string or a value.
      If it's a string it is interpreted using the current document units and can include
      equations. For example all of the following are valid as long as they result in
      angle units "45", "45 deg", "a1 / 2". If a value is input it is interpreted
      as radians.
      It cannot be negative.
      @returns Returns true if the feature is successfully changed
      @deprecated
    */
    setDistanceAndAngle(distance: core.ValueInput, angle: core.ValueInput): boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ChamferFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ChamferFeature | null
    /**
      Gets and sets the type of corner to be modeled when multiple edges connect at a vertex.
    */
    cornerType: ChamferCornerTypes
    /**
      Returns the edge sets associated with this chamfer.
    */
    readonly edgeSets: ChamferEdgeSets
  }

  /**
    The base class for the classes that define how a chamfer can be defined.
    @deprecated
  */
  abstract class ChamferTypeDefinition extends core.Base {
    /**
      Returns the feature that owns this chamfer type definition
    */
    readonly parentFeature: ChamferFeature
  }

  /**
    Provides information to create a chamfer that is defined by a single distance and has an equal offset from the edge.
    @deprecated
  */
  abstract class EqualDistanceChamferTypeDefinition extends ChamferTypeDefinition {
    /**
      Returns the parameter controlling the distance. You can edit the distance
      by editing the value of the parameter object.
    */
    readonly distance: ModelParameter
  }

  /**
    Provides information to create a chamfer that is defined by a two distances from the edge.
    @deprecated
  */
  abstract class TwoDistancesChamferTypeDefinition extends ChamferTypeDefinition {
    /**
      Returns the parameter controlling the first distance. You can edit the distance
      by editing the value of the parameter object.
    */
    readonly distanceOne: ModelParameter
    /**
      Returns the parameter controlling the second distance. You can edit the distance
      by editing the value of the parameter object.
    */
    readonly distanceTwo: ModelParameter
  }

  /**
    Provides information to create a chamfer that is defined by a distance from the edge and an angle.
    @deprecated
  */
  abstract class DistanceAndAngleChamferTypeDefinition extends ChamferTypeDefinition {
    /**
      Returns the parameter controlling the distance. You can edit the distance
      by editing the value of the parameter object.
    */
    readonly distance: ModelParameter
    /**
      Returns the parameter controlling the angle. You can edit the angle
      by editing the value of the parameter object.
    */
    readonly angle: ModelParameter
  }

  /**
    List of the different ways a chamfer can be defined.
    @deprecated
  */
  const enum ChamferTypes {
    /**
      chamfer feature created using one equal distance
    */
    EqualDistanceChamferType,
    /**
      chamfer feature created using two distances
    */
    TwoDistancesChamferType,
    /**
      chamfer feature created using a distance and an angle
    */
    DistanceAndAngleChamferType,
  }

  /**
    Collection that provides access to all of the existing chamfer edge sets associated with a chamfer feature.
  */
  abstract class ChamferEdgeSets extends core.Base {
    /**
      Function that returns the specified chamfer edge set using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ChamferEdgeSet | null
    /**
      The number of chamfer edge sets in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a set of edges an equal distance offset to this chamfer feature.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param edges An ObjectCollection containing the edges to be chamfered. Edges can be defined by passing in BrepEdge,
      BRepFace, or Feature objects. If BRepFace or Feature objects are passed in all of the edges associated
      with those objects will be chamfered. If BRepEdge objects are provided and the isTangentChain argument is true
      additional edges may also get chamfered if they are tangentially connected to any of the input edges.
      @param distance A ValueInput object that defines the distance offset of the chamfer. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param isTangentChain A boolean value for setting whether or not edges that are tangentially connected to
      the input edges (if any) will also be chamfered.
      @returns Returns true if the set of edges was successfully added to the ChamferFeatureInput.
    */
    addEqualDistanceChamferEdgeSet(edges: core.ObjectCollection, distance: core.ValueInput, isTangentChain: boolean): boolean
    /**
      Adds a set of edges an equal distance offset to this chamfer feature.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param edges An ObjectCollection containing the edges to be chamfered. Edges can be defined by passing in BrepEdge,
      BRepFace, or Feature objects. If BRepFace or Feature objects are passed in all of the edges associated
      with those objects will be chamfered. If BRepEdge objects are provided and the isTangentChain argument is true
      additional edges may also get chamfered if they are tangentially connected to any of the input edges.
      @param distanceOne A ValueInput object that defines the first distance offset of the chamfer. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param distanceTwo A ValueInput object that defines the second distance offset of the chamfer. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param isFlipped Swaps the directions for distance one and two.
      @param isTangentChain A boolean value for setting whether or not edges that are tangentially connected to
      the input edges (if any) will also be chamfered.
      @returns Returns true if the set of edges was successfully added to the ChamferFeatureInput.
    */
    addTwoDistancesChamferEdgeSet(edges: core.ObjectCollection, distanceOne: core.ValueInput, distanceTwo: core.ValueInput, isFlipped: boolean, isTangentChain: boolean): boolean
    /**
      Adds a set of edges an equal distance offset to this chamfer feature.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param edges An ObjectCollection containing the edges to be chamfered. Edges can be defined by passing in BrepEdge,
      BRepFace, or Feature objects. If BRepFace or Feature objects are passed in all of the edges associated
      with those objects will be chamfered. If BRepEdge objects are provided and the isTangentChain argument is true
      additional edges may also get chamfered if they are tangentially connected to any of the input edges.
      @param distance A ValueInput object that defines the distance offset of the chamfer. If the ValueInput uses
      a real then it is interpreted as centimeters. If it is a string then the units
      can be defined as part of the string (i.e. "2 in") or if no units are specified
      it is interpreted using the current default units for length.
      @param angle A ValueInput object that defines the angle of the chamfer. If the ValueInput uses
      a real then it is interpreted as radians. If it is a string then the units
      can be defined as part of the string (i.e. "2 rad") or if no units are specified
      it is interpreted as degrees.
      @param isFlipped Swaps the directions for distance one and two.
      @param isTangentChain A boolean value for setting whether or not edges that are tangentially connected to
      the input edges (if any) will also be chamfered.
      @returns Returns true if the set of edges was successfully added to the ChamferFeatureInput.
    */
    addDistanceAndAngleChamferEdgeSet(edges: core.ObjectCollection, distance: core.ValueInput, angle: core.ValueInput, isFlipped: boolean, isTangentChain: boolean): boolean
  }

  /**
    The base class for the classes that define the different types of chamfer edge sets.
  */
  abstract class ChamferEdgeSet extends core.Base {
    /**
      Deletes the chamfer edge set from the chamfer.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @returns Returns true if the operation was successful.
    */
    deleteMe(): boolean
    /**
      Gets and sets the Tangent chain for chamfer. This enables tangent chain option for chamfer.
    */
    isTangentChain: boolean
  }

  /**
    Provides access to the edges and the parameter associated with a equal distance offset chamfer.
  */
  abstract class EqualDistanceChamferEdgeSet extends ChamferEdgeSet {
    /**
      Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,
      and Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated
      with those objects will be chamfered.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    edges: core.ObjectCollection
    /**
      Returns the model parameter that controls the offset distance of the chamfer. You can edit
      the distance by using the properties on the returned ModelParameter object.
    */
    readonly distance: ModelParameter
  }

  /**
    Provides access to the edges and the parameters associated with a two distances chamfer.
  */
  abstract class TwoDistancesChamferEdgeSet extends ChamferEdgeSet {
    /**
      Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,
      and Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated
      with those objects will be chamfered.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    edges: core.ObjectCollection
    /**
      Returns the model parameter that controls the first offset distance of the chamfer.
      You can edit the distance by using the properties on the returned ModelParameter object.
    */
    readonly distanceOne: ModelParameter
    /**
      Returns the model parameter that controls the first offset distance of the chamfer.
      You can edit the distance by using the properties on the returned ModelParameter object.
    */
    readonly distanceTwo: ModelParameter
    /**
      Gets and sets if the chamfer is flipped. This swaps the directions for distance one and two.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isFlipped: boolean
  }

  /**
    Provides access to the edges and the parameter associated with a chord length fillet.
  */
  abstract class DistanceAndAngleChamferEdgeSet extends ChamferEdgeSet {
    /**
      Gets and sets the edges that will be chamfered. This collection can contain BRepEdge, BRepFace,
      and Feature objects. If BRepFace or Feature are objects are provided, all of the edges associated
      with those objects will be chamfered.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    edges: core.ObjectCollection
    /**
      Returns the model parameter that controls the offset distance of the chamfer.
      You can edit the distance by using the properties on the returned ModelParameter object.
    */
    readonly distance: ModelParameter
    /**
      Returns the model parameter that controls the angle of the chamfer.
      You can edit the distance by using the properties on the returned ModelParameter object.
    */
    readonly angle: ModelParameter
    /**
      Gets and sets if the chamfer is flipped. This swaps the directions for distance one and two.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isFlipped: boolean
  }

  /**
    The Path object represents a single set of connected curves. The order of the objects within the collection is the same as the connection order of the entities.
    When using a Path to create a feature, the Path serves as a way to pass in the set of sketch entities and edges. When
    getting the Path of an existing feature it returns the actual path used to define the feature geometry. In cases like a
    sweep feature, this can result in using portions of the original input sketch curves or edges and the returned path
    will provide these "partial" curves as the PathEntity objects.
  */
  abstract class Path extends core.Base {
    /**
      Function that returns the specified PathEntity using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): PathEntity | null
    /**
      The number of curves in the path.
    */
    readonly count: number /*unsigned int*/
    /**
      Indicates if the path is closed or not. Returns True in the case of a closed path.
    */
    readonly isClosed: boolean
    /**
      This property is not supported for the Path object.
    */
    readonly assemblyContext: Occurrence
    /**
      This property is not supported for the Path object.
    */
    readonly nativeObject: Path
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence 
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): Path | null
    /**
      Creates a new Path that can be used as input to various features. For example, it is used
      to create an open set of curves to create surfaces using extrude, revolve, and sweep.
      It is also used to create the path for a sweep and sections and profiles and rails for lofts. And
      it is used to define the boundary of a patch feature.
      Although the creation of a path is very flexible as far as the types of entities and whether they
      are planar or not, each of the features have specific requirements and the path must meet those
      requirements. For example, a path for an extrusion can only contain sketch curves and must be planar,
      whereas the path for a sweep can contain a mix of sketch curves and edges and can be in three dimensions.
      @param curves A SketchCurve, BRepEdge, or an ObjectCollection containing multiple sketch entities and/or BRepEdges. If a single sketch curve
      or BRepEdge is input the chainCurves argument is used to determine if connected curves or edges (they do not need to be tangent)
      should be automatically found. Searching for connected curves is only performed within the same sketch or open edges on the same
      body. If multiple curves are provided the chainCurves argument is treated as false so only the specified input curves are
      used. The input curves need to geometrically connect for a path to be created.
      @param chainOptions If a single SketchCurve or BRepEdge is input, this argument is used to specify the rules in how chained entities should be found. If
      an ObjectCollection is input, this argument is ignored.
      @returns Returns the new Path object or null in the case of a failure.
    */
    static create(curves: core.Base, chainOptions: ChainedCurveOptions): Path | null
    /**
      Adds additional curves to the existing path. This can be useful when creating a complex path for a sweep and you
      want to include sets of curves from multiple sketches and edges from multiple bodies.
      @param curves A SketchCurve, BRepEdge, or an ObjectCollection containing multiple sketch entities and/or BRepEdges. If a single sketch curve
      or BRepEdge is input the chainCurves argument is used to determine if connected curves or edges (they do not need to be tangent)
      should be automatically found. Searching for connected curves is only performed within the same sketch or open edges on the same
      body. If multiple curves are provided the chainCurves argument is treated as false so only the specified input curves are
      used. The input curves need to geometrically connect for a path to be created.
      @param chainOptions If a single SketchCurve or BRepEdge is input, this argument is used to specify the rules in how chained entities should be found. If
      an ObjectCollection is input, this argument is ignored.
      @returns Returns a bool indicating if the process was successful or not.
    */
    addCurves(curves: core.Base, chainOptions: ChainedCurveOptions): boolean
  }

  /**
    Controls options used when creating a Path and determining the rules for how curves are
    considered to be chained or connected.
  */
  const enum ChainedCurveOptions {
    /**
      No chaining is done. This is useful when inputting a single entity and you don't want any chaining to be done.
    */
    noChainedCurves,
    /**
      Will find curves that are geometrically connected without regards to the
      geometry condition at the connection. This is limited to sketch curves.
    */
    connectedChainedCurves,
    /**
      Will find curves that are geometrically connected and tangent at the connection.
      This will work for both sketch curves and edges.
    */
    tangentChainedCurves,
    /**
      Will find edges that are geometrically end connected and are open edges of an open BRepBody.
    */
    openEdgesChainedCurves,
    /**
      Will find edges that are geometrically end connected, are tangent at the connection, and are
      open edges of an open BRepBody.
    */
    tangentAndOpenEdgesChainedCurves,
  }

  /**
    The PathEntity object represents a curve within a path
  */
  abstract class PathEntity extends core.Base {
    /**
      Property that returns the geometry of the entity.
      This is different from the original path curve if the true start point is not the same as the start point of the original path curve.
    */
    readonly curve: core.Curve3D
    /**
      Property that returns the type of the curve referenced by the path entity. This property allows you to determine what type of object will be returned by the Curve property.
    */
    readonly curveType: core.Curve3DTypes
    /**
      Property that gets the sketch curve or edge this entity was derived from.
    */
    readonly entity: core.Base
    /**
      Property that returns the parent Path of the entity.
    */
    readonly parentPath: Path
    /**
      This property is not supported for a PathEntity object.
    */
    readonly assemblyContext: Occurrence
    /**
      This property is not supported for a PathEntity object.
    */
    readonly nativeObject: PathEntity
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence 
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): PathEntity | null
    /**
      Indicates if the orientation of this PathEntity is in the same direction or opposed to the natural direction
      of the SketchCurve or BRepEdge object it is derived from.
    */
    readonly isOpposedToEntity: boolean
  }

  /**
    Collection that provides access to all of the existing sweep features in a component
    and supports the ability to create new sweep features.
  */
  abstract class SweepFeatures extends core.Base {
    /**
      Function that returns the specified sweep feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SweepFeature | null
    /**
      The number of sweep features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a SweepFeatureInput object for defining a simple sweep feature with only a path and no guide rail or surface.
      Use properties and methods on this object to define the sweep you want to create and then use the Add method,
      passing in the SweepFeatureInput object.
      @param profile The profile argument can be a single Profile, a single
      planar face, or an ObjectCollection consisting of multiple profiles and planar faces.
      When an ObjectCollection is used all of the profiles and faces must be co-planar.
      @param path The path to create the sweep.
      @param operation The feature operation to perform
      @returns Returns the newly created SweepFeatureInput object or null if the creation failed.
    */
    createInput(profile: core.Base, path: Path, operation: FeatureOperations): SweepFeatureInput | null
    /**
      Creates a new sweep feature.
      @param input A SweepFeatureInput object that defines the desired sweep. Use the createInput
      method to create a new SweepFeatureInput object and then use methods on it
      (the SweepFeatureInput object) to define the sweep.
      @returns Returns the newly created SweepFeature object or null if the creation failed.
    */
    add(input: SweepFeatureInput): SweepFeature | null
    /**
      Function that returns the specified sweep feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): SweepFeature | null
    /**
      Creates a SweepFeatureInput object for defining a simple sweep feature from a B-Rep
      solid with a path. Use properties and methods on this object to define the sweep you
      want to create, and then use the Add method, passing in the SweepFeatureInput object.
      @param solidBody The BRepBody object to sweep. It must be a solid body.
      @param path The Path object that defines the path the body will be swept along.
      @param operation The type of feature operation to perform.
      @returns Returns the newly created SweepFeatureInput object or null if the creation fails.
    */
    createInputForSolid(solidBody: BRepBody, path: Path, operation: FeatureOperations): SweepFeatureInput | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a sweep
    feature.
  */
  abstract class SweepFeatureInput extends core.Base {
    /**
      Gets and sets the profiles or planar faces used to define the shape of the sweep.
      This property can return or be set with a single Profile, a single planar face, or
      an ObjectCollection consisting of multiple profiles and planar faces. When an
      ObjectCollection is used all of the profiles and faces must be co-planar.
    */
    profile: core.Base
    /**
      Gets and sets the type of operation performed by the sweep.
    */
    operation: FeatureOperations
    /**
      Gets and sets the path to create the sweep.
    */
    path: Path
    /**
      Gets and sets the distance for the first side.
      The distance is a value from 0 to 1 indicating the position along the path where 0
      is at the start and 1 is at the end. The value is default to 1.0.
    */
    distanceOne: core.ValueInput
    /**
      Gets and sets the distance for the second side.
      The distance is a value from 0 to 1 indicating the position along the path where 0
      is at the start and 1 is at the end. The value defaults to 0 in the case where the path is closed, otherwise it defaults to 1.0.
      It is ignored if the path is only on one side of the profile or if the sweep definition includes a guide rail.
      It's always the distance against the normal of the profile if available.
    */
    distanceTwo: core.ValueInput
    /**
      Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.
      This property is ignored when sweeping a solid or a guide rail or surface has been specified.
    */
    orientation: SweepOrientationTypes
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the sweep is created based on geometry (e.g. a profile and/or face(s))
      in another component AND (the sweep) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      Specifies if the sweep should be created as a solid or surface. If
      it's a surface then there aren't any end caps and it's open. This is
      initialized to true so a solid will be created if it's not changed.
    */
    isSolid: boolean
    /**
      Gets and sets the guide rail to create the sweep. This can be set to
      null to remove the guide rail definition and have a single path sweep feature.
    */
    guideRail: Path
    /**
      Gets and sets if the direction of the sweep is flipped.
      This property only applies to sweep features that include a guide rail and whose path runs on both
      sides of the profile.
    */
    isDirectionFlipped: boolean
    /**
      Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption.
      This property is only used when a guide rail has been specified.
    */
    profileScaling: SweepProfileScalingOptions
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      If this property has not been set, the default behavior is that all bodies that are intersected by the
      feature will participate.
      This property can return null in the case where the feature has not been fully defined so that
      possible intersecting bodies can be computed.
    */
    participantBodies: BRepBody[]
    /**
      Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.
      A negative angle will taper the sweep inward while a positive value will taper
      the sweep outward.
      This property is ignored if sweeping a solid or a guide rail or surface has been specified.
      This property is valid for both parametric and non-parametric extrusions.
    */
    taperAngle: core.ValueInput
    /**
      Gets and sets the twist angle of the sweep. This property is initialized with a twist angle of zero.
      When sweeping a solid setting the twist angle requires the solid twist axis to be set.
      This property is ignored if a guide rail or surface has been specified.
      This property is valid for both parametric and non-parametric extrusions.
    */
    twistAngle: core.ValueInput
    /**
      Gets and sets the sweep extent type. It defaults to PerpendicularToPathExtentType.
      This property is ignored when a guide rail has not been specified.
    */
    extent: SweepExtentTypes
    /**
      Gets and sets the guide surfaces to create the sweep. This can be set to
      an empty array to remove the guide surfaces and have a single path sweep feature.
      By default connected faces that are tangent to any of the guide faces are set as guide faces.
      Use the isChainSelection property to disable the use of tangent faces.
    */
    guideSurfaces: BRepFace[]
    /**
      Get and sets whether faces that are tangentially connected to the guide surfaces are also made guide surfaces.
    */
    isChainSelection: boolean
    /**
      Gets and sets the BRepBody object to sweep. It must be a solid body.
      Setting this property results in the type being a single path sweep, and
      if the profile, guide path, or surface are set, they are set to null.
    */
    solidBody: BRepBody
    /**
      Gets and sets the solid sweep orientation. It defaults to PerpendicularSolidOrientationType.
      Setting the solid orientation to AlignedSolidOrientationType requires the solid aligned axis to be set.
      This property is ignored if sweeping a profile.
    */
    solidOrientation: SweepSolidOrientationTypes
    /**
      Gets and sets the axis to align the solid being swept with. The axis is used when sweeping a solid,
      and the solid orientation is set to AlignedSolidOrientationType. It can be a sketch line, linear edge,
      or construction axis.
    */
    solidAlignedAxis: core.Base
    /**
      Gets and sets the twist axis of the solid being swept. The axis is used when sweeping a solid,
      and the twist angle is set. It can be a sketch line, linear edge, construction axis, or a face
      that defines an axis (cylinder, cone, torus, etc.).
    */
    solidTwistAxis: core.Base
  }

  /**
    Object that represents an existing sweep feature in a design.
  */
  abstract class SweepFeature extends Feature {
    /**
      Gets and sets the profiles or planar faces used to define the shape of the sweep.
      This property can return or be set with a single Profile, a single planar face, or
      an ObjectCollection consisting of multiple profiles and planar faces. When an
      ObjectCollection is used all of the profiles and faces must be co-planar.
      This property returns nothing in the case where the feature is non-parametric.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    profile: core.Base
    /**
      Gets and sets the type of operation performed by the sweep.
    */
    operation: FeatureOperations
    /**
      Gets and sets the path to create the sweep.
      This property returns nothing in the case where the feature is non-parametric.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    path: Path
    /**
      Gets the distance for the first side.
      This property returns nothing in the case where the feature is non-parametric.
    */
    readonly distanceOne: ModelParameter
    /**
      Gets the distance for the second side.
      Returns nothing if the path is only on one side of the profile or if the sweep definition includes a guide rail or surface.
      It's always the distance against the normal of the profile if available.
      This property returns nothing in the case where the feature is non-parametric.
    */
    readonly distanceTwo: ModelParameter
    /**
      Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.
      This property is ignored if sweeping a solid or a guide rail or surface has been specified.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    orientation: SweepOrientationTypes
    /**
      Property that returns the set of that cap one end of the sweep that are coincident with the sketch plane.
      In the cases where there aren't any start faces this property will return Nothing.
    */
    readonly startFaces: BRepFaces
    /**
      Property that returns the set of that cap one end of the sweep that are coincident with the sketch plane.
      The end faces are those not coincident to the sketch plane of the feature's profile.
      In the case of a symmetric revolution these faces are the ones on the negative normal side of the sketch plane.
      In the cases where there aren't any end faces this property will return Nothing.
    */
    readonly endFaces: BRepFaces
    /**
      Property that returns an object that provides access to all of the faces created around the perimeter of the feature.
    */
    readonly sideFaces: BRepFaces
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SweepFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SweepFeature | null
    /**
      Indicates if this feature was initially created as a solid or a surface.
    */
    readonly isSolid: boolean
    /**
      Gets and sets the guide rail to create the sweep. This can be set to null
      to have a path only sweep.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    guideRail: Path
    /**
      Gets and sets if the direction of the sweep is flipped.
      This property only applies to sweep features that include a guide rail and whose path runs on both
      sides of the profile.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isDirectionFlipped: boolean
    /**
      Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption.
      This property is only used when a guide rail has been specified.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    profileScaling: SweepProfileScalingOptions
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    participantBodies: BRepBody[]
    /**
      Gets the ModelParameter that defines the taper angle of the sweep feature.
      The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
      This property is ignored if sweeping a solid or a guide rail or surface has been specified.
    */
    readonly taperAngle: ModelParameter
    /**
      Gets the ModelParameter that defines the twist angle of the sweep feature.
      The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
      When sweeping a solid setting the twist angle requires the solid twist axis to be set.
      This property is ignored if a guide rail or surface has been specified.
    */
    readonly twistAngle: ModelParameter
    /**
      Gets and sets the sweep extent type. It defaults to PerpendicularToPathExtentType.
      When sweeping a solid setting the twist angle requires the solid twist axis to be set.
      This property is ignored when a guide rail has not been specified.
    */
    extent: SweepExtentTypes
    /**
      Gets and sets the guide surfaces to create the sweep. This can be set to
      an empty array to remove the guide surfaces and have a single path sweep feature.
      The isChainSelection property controls whether tangentially connected faces to
      the guide surfaces are also made guide surfaces.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    guideSurfaces: BRepFace[]
    /**
      Get and sets whether faces that are tangentially connected to the guide surfaces are also made guide surfaces.
    */
    isChainSelection: boolean
    /**
      Gets and sets the BRepBody object to sweep. It must be a solid body.
      Setting this property results in the type being a single path sweep, and
      if the profile, guide path, or surface are set, they are set to null.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    solidBody: BRepBody
    /**
      Gets and sets the sweep solid orientation. It defaults to PerpendicularSolidOrientationType.
      Setting the solid orientation to AlignedSolidOrientationType requires the solid aligned axis to be set.
      This property is ignored if sweeping a profile.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    solidOrientation: SweepSolidOrientationTypes
    /**
      Gets and sets the axis to align the solid being swept with. The axis is used when sweeping a solid,
      and the solid orientation is set to AlignedSolidOrientationType. It can be a sketch line, linear edge,
      or construction axis.
    */
    solidAlignedAxis: core.Base
    /**
      Gets and sets the twist axis of the solid being swept. The axis is used when sweeping a solid,
      and the twist angle is set. It can be a sketch line, linear edge, construction axis, or a face
      that defines an axis (cylinder, cone, torus, etc.).
    */
    solidTwistAxis: core.Base
  }

  /**
    List of the types of sweep orientation.
  */
  const enum SweepOrientationTypes {
    /**
      Parallel orientation type.
    */
    ParallelOrientationType,
    /**
      Perpendicular orientation type.
    */
    PerpendicularOrientationType,
  }

  /**
    List of the types of sweep extent.
  */
  const enum SweepExtentTypes {
    /**
      Perpendicular to Path extent type.
    */
    PerpendicularToPathExtentType,
    /**
      Full extents extent type.
    */
    FullExtentsExtentType,
  }

  /**
    List of the sweep profile scaling options.
  */
  const enum SweepProfileScalingOptions {
    /**
      Scale profile option.
    */
    SweepProfileScaleOption,
    /**
      Stretch profile option.
    */
    SweepProfileStretchOption,
    /**
      Stretch profile option.
    */
    SweepProfileNoScalingOption,
  }

  /**
    The various orientation types when doing a solid sweep.
  */
  const enum SweepSolidOrientationTypes {
    /**
      Maintain the orientation of the tool body relative to the sweep path. As the tool body
      sweeps along the path, it will rotate to maintain the same relative angle to the path.
    */
    PerpendicularSolidOrientationType,
    /**
      The orientation of the tool body does not change as it is swept along the path.
      The tool will be translated but not rotated.
    */
    RigidSolidOrientationType,
    /**
      Keep the orientation of the tool body aligned to a direction vector. The tool
      may rotate around this vector as it is swept along the path.
    */
    AlignedSolidOrientationType,
  }

  /**
    Collection that provides access to all of the existing shell features in a component
    and supports the ability to create new shell features.
  */
  abstract class ShellFeatures extends core.Base {
    /**
      Function that returns the specified shell feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ShellFeature | null
    /**
      The number of shell features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a ShellFeatureInput object. Use properties and methods on this object
      to define the shell you want to create and then use the Add method, passing in
      the ShellFeatureInput object.
      @param inputEntities The collection contains the faces to remove and the bodies to perform shell.
      Fails if any faces are input, and the owning bodies of the faces are also input.
      @param isTangentChain A boolean value for setting whether or not faces that are tangentially connected to
      the input faces (if any) will also be included. It defaults to true.
      @returns Returns the newly created ShellFeatureInput object or null if the creation failed.
    */
    createInput(inputEntities: core.ObjectCollection, isTangentChain?: boolean/* = true*/): ShellFeatureInput | null
    /**
      Creates a new shell feature.
      @param input A ShellFeatureInput object that defines the desired shell. Use the createInput
      method to create a new ShellFeatureInput object and then use methods on it
      (the ShellFeatureInput object) to define the shell.
      @returns Returns the newly created ShellFeature object or null if the creation failed.
    */
    add(input: ShellFeatureInput): ShellFeature | null
    /**
      Function that returns the specified shell feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): ShellFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a shell
    feature.
  */
  abstract class ShellFeatureInput extends core.Base {
    /**
      Gets and sets the input faces/bodies.
      If IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
      Fails if any faces are input, and the owning bodies of the faces are also input.
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets if any faces that are tangentially connected to any of
      the input faces will also be included in setting InputEntities. It defaults to true.
    */
    isTangentChain: boolean
    /**
      Gets and sets the inside thickness.
    */
    insideThickness: core.ValueInput
    /**
      Gets and sets the outside thickness.
    */
    outsideThickness: core.ValueInput
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the shell is created based on geometry (e.g. a profile and/or face(s))
      in another component AND (the shell) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      The shell type used when creating a shell.
      The default value is SharpOffsetShellType.
    */
    shellType: ShellTypes
  }

  /**
    Object that represents an existing shell feature in a design.
  */
  abstract class ShellFeature extends Feature {
    /**
      Method that sets faces to remove and bodies to preform shell. Return false if any faces are input, and the owning bodies of the faces are also input.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param inputEntities The collection contains the faces to remove and the bodies to perform shell.
      Fails if any faces are input, and the owning bodies of the faces are also input.
      @param isTangentChain A boolean value for setting whether or not faces that are tangentially connected to
      the input faces (if any) will also be included. It defaults to true.
      @returns Returns true if successful
    */
    setInputEntities(inputEntities: core.ObjectCollection, isTangentChain?: boolean/* = true*/): boolean
    /**
      Method that sets the inside and outside thicknesses of the shell.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param insideThickness ValueInput object that defines the inside thickness. If set to null, the inside thickness is removed.
      @param outsideThickness ValueInput object that defines the outside thickness. If set to null, the outside thickness is removed.
      @returns Returns true if successful
    */
    setThicknesses(insideThickness: core.ValueInput, outsideThickness: core.ValueInput): boolean
    /**
      Gets the input faces/bodies.
    */
    readonly inputEntities: core.ObjectCollection
    /**
      Gets if any faces that are tangentially connected to any of
      the input faces will also be included in setting InputEntities.
    */
    readonly isTangentChain: boolean
    /**
      Gets the inside thickness.
      Edit the thickness through ModelParameter.
      This property returns nothing in the case where the feature is non-parametric.
    */
    readonly insideThickness: ModelParameter
    /**
      Gets the outside thickness.
      Edit the thickness through ModelParameter.
      This property returns nothing in the case where the feature is non-parametric.
    */
    readonly outsideThickness: ModelParameter
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ShellFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ShellFeature | null
    /**
      The shell type used when creating a shell.
      The default value is SharpOffsetShellType.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    shellType: ShellTypes
  }

  /**
    List of Shell Types
  */
  const enum ShellTypes {
    /**
      Use sharp corners when creating the shell. (Legacy)
    */
    SharpOffsetShellType,
    /**
      Use rounded corners when creating the shell.
    */
    RoundedOffsetShellType,
  }

  /**
    Collection that provides access to pattern elements of mirror and pattern features.
  */
  abstract class PatternElements extends core.Base {
    /**
      Function that returns the specified pattern element using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): PatternElement | null
    /**
      The number of pattern elements in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    This class defines the properties that pertain to the pattern element.
  */
  abstract class PatternElement extends core.Base {
    /**
      Gets the faces generated as a result of this particular element.
    */
    readonly faces: BRepFace[]
    /**
      Gets the id of this element within the pattern.
    */
    readonly id: number /*unsigned int*/
    /**
      Gets the feature pattern this element is a member of.
    */
    readonly parentFeature: Feature
    /**
      Gets and sets whether the element is suppressed or not. A value of True indicates it is suppressed
    */
    isSuppressed: boolean
    /**
      Get the transform that describes this elements relative position to the parent object(s).
      The transform returned for the first element in a pattern will be an identity matrix.
    */
    readonly transform: core.Matrix3D
    /**
      Get the name of the pattern element.
    */
    readonly name: string
    /**
      If the patternEntityType property of the parent feature returns OccurrencesPatternType
      then this property will return the occurrences associated with this particular pattern
      element.
    */
    readonly occurrences: Occurrence[]
  }

  /**
    Collection that provides access to all of the existing mirror features in a component
    and supports the ability to create new mirror features.
  */
  abstract class MirrorFeatures extends core.Base {
    /**
      Function that returns the specified mirror feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MirrorFeature | null
    /**
      The number of mirror features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MirrorFeatureInput object. Use properties and methods on this object
      to define the mirror you want to create and then use the Add method, passing in
      the MirrorFeatureInput object.
      @param inputEntities A collection of the entities to mirror. It can contain faces, features, bodies, or components.
      The input must all be of a single type. For example, you can't provide a body and a component but
      the collection must be either all bodies or all components.
      @param mirrorPlane Input planar entity that defines the mirror plane. This can be either a planar face or a construction plane.
      @returns Returns the newly created MirrorFeatureInput object or null if the creation failed.
    */
    createInput(inputEntities: core.ObjectCollection, mirrorPlane: core.Base): MirrorFeatureInput | null
    /**
      Creates a new mirror feature.
      @param input A MirrorFeatureInput object that defines the desired mirror. Use the createInput
      method to create a new MirrorFeatureInput object and then use methods on it
      (the MirrorFeatureInput object) to define the mirror.
      @returns Returns the newly created MirrorFeature object or null if the creation failed.
    */
    add(input: MirrorFeatureInput): MirrorFeature | null
    /**
      Function that returns the specified mirror feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MirrorFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a mirror
    feature.
  */
  abstract class MirrorFeatureInput extends core.Base {
    /**
      Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components.
      The input must all be of a single type. For example, you can't provide a body and a component but
      the collection must be either all bodies or all components.
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the mirror plane. This can be either a planar face or construction plane.
    */
    mirrorPlane: core.Base
    /**
      Gets and sets the compute option when mirroring features. The default value for this is AdjustPatternCompute.
      This property only applies when mirroring features and is ignored in the direct modeling environment.
    */
    patternComputeOption: PatternComputeOptions
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets whether the mirrored bodies should be combined with the original bodies.
      When true, the mirrored geometry will be Boolean unioned with the original solid or surface body(s)
      when they connect within the stitch tolerance defined with the stitchTolerance property. If the bodies
      cannot be unioned or stitched the result will be separate bodies.
      If any input object is not a body, then this setting is ignored.
      Default is false.
    */
    isCombine: boolean
    /**
      Gets and sets the ValueInput object that defines the Stitching Tolerance (length)
      to use when doing a mirror and combine for surface bodies.
    */
    stitchTolerance: core.ValueInput
  }

  /**
    Object that represents an existing mirror feature in a design.
  */
  abstract class MirrorFeature extends Feature {
    /**
      Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components.
      The input must all be of a single type. For example, you can't provide a body and a component but
      the collection must be either all bodies or all components.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the mirror plane. This can be either a planar face or construction plane.
      This works only for parametric features.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    mirrorPlane: core.Base
    /**
      Gets the PatternElements collection that contains the elements created by this pattern.
    */
    readonly patternElements: PatternElements
    /**
      Get the features that were created for this mirror.
      Returns null in the case where the feature is not parametric.
    */
    readonly resultFeatures: core.ObjectCollection
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MirrorFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MirrorFeature | null
    /**
      Gets and sets the compute option for this mirror feature.
      This property only applies when mirroring features and is ignored in the direct modeling environment.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    patternComputeOption: PatternComputeOptions
    /**
      Gets and sets whether combine is set when doing the Mirror.
      When true, the mirrored geometry will be Boolean unioned with the original solid or surface body(s)
      when they connect within the stitch tolerance defined with the stitchTolerance property. If the bodies
      cannot be unioned or stitched the result will be separate bodies.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isCombine: boolean
    /**
      Returns the parameter controlling the Stitch tolerance to use when stitching mirrored
      surface bodies with the original bodies. You can edit the tolerance by
      editing the value of the parameter object.
    */
    readonly stitchTolerance: ModelParameter
  }

  /**
    List of the compute options for mirroring and patterning features in the parametric modeling environment.
  */
  const enum PatternComputeOptions {
    /**
      Optimized pattern compute. This is the fastest of all compute options. This option may fail or give wrong results in
      some very rare cases (e.g. when patterning a Split feature)
    */
    OptimizedPatternCompute,
    /**
      Identical pattern compute. Used when you want force the resulting mirror or pattern to create identical results
      regardless of the dependencies that define the feature being copied.
    */
    IdenticalPatternCompute,
    /**
      Adjust pattern compute. This is the slowest of all compute options. It can almost never produce a wrong result
      (e.g. works well even on Split features)
    */
    AdjustPatternCompute,
  }

  /**
    Collection that provides access to all of the existing Combine features in a component
    and supports the ability to create new Combine features.
  */
  abstract class CombineFeatures extends core.Base {
    /**
      Function that returns the specified combine feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
      This property returns nothing in the case where the feature is non-parametric.
    */
    item(index: number /*unsigned int*/): CombineFeature | null
    /**
      The number of combine features in the collection.
      This property returns nothing in the case where the feature is non-parametric.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a CombineFeatureInput object. Use properties and methods on this object
      to define the combine you want to create and then use the Add method, passing in
      the CombineFeatureInput object.
      @param targetBody A BRep body that represents the blank body.
      @param toolBodies An ObjectCollection containing one or more BRep bodies that represent tool bodies.
      @returns Returns the newly created CombineFeatureInput object or null if the creation failed.
    */
    createInput(targetBody: BRepBody, toolBodies: core.ObjectCollection): CombineFeatureInput | null
    /**
      Creates a new combine feature.
      @param input A CombineFeatureInput object that defines the desired combine. Use the createInput
      method to create a new CombineFeatureInput object and then use methods on it
      (the CombineFeatureInput object) to define the combine.
      @returns Returns the newly created CombineFeature object or null if the creation failed.
      This function returns nothing in the case where the feature is non-parametric.
    */
    add(input: CombineFeatureInput): CombineFeature | null
    /**
      Function that returns the specified combine feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): CombineFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a combine
    feature.
  */
  abstract class CombineFeatureInput extends core.Base {
    targetBody: BRepBody
    toolBodies: adsk.core.ObjectCollection
    /**
      Gets and sets the type of operation performed by the combine.
      The valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.
      The default value is JoinFeatureOperation.
    */
    operation: FeatureOperations
    /**
      Gets and sets a boolean value for whether or not a new component will be created with the results. The default value is false.
      In Base feature environment NewComponent does not work.
    */
    isNewComponent: boolean
    /**
      Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results. The default value is false.
    */
    isKeepToolBodies: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing Combine feature in a design.
    In non-parametric environment this object does not exist.
  */
  abstract class CombineFeature extends Feature {
    targetBody: BRepBody
    toolBodies: adsk.core.ObjectCollection
    /**
      Gets and sets the type of operation performed by the combine.
      The valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    operation: FeatureOperations
    /**
      Gets a boolean value for whether or not a new component was created when this feature was created.
    */
    readonly isNewComponent: boolean
    /**
      Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isKeepToolBodies: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: CombineFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): CombineFeature | null
  }

  /**
    Collection that provides access to all of the existing circular pattern features in a component
    and supports the ability to create new circular pattern features.
  */
  abstract class CircularPatternFeatures extends core.Base {
    /**
      Function that returns the specified circular pattern feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CircularPatternFeature | null
    /**
      The number of circular pattern features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a CircularPatternFeatureInput object. Use properties and methods on this object
      to define the circular pattern you want to create and then use the Add method, passing in
      the CircularPatternFeatureInput object.
      @param inputEntities The collection can contain faces, features, bodies or occurrences.
      All of the entities must be of a single type. For example, it can't contain features and occurrences
      but only features or occurrences.
      @param axis Input linear entity or the entity has axis that defines axis of circular pattern. This can be a sketch line, linear edge,
      construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
      @returns Returns the newly created CircularPatternFeatureInput object or null if the creation failed.
    */
    createInput(inputEntities: core.ObjectCollection, axis: core.Base): CircularPatternFeatureInput | null
    /**
      Creates a new circular pattern feature.
      @param input A CircularPatternFeatureInput object that defines the desired circular pattern. Use the createInput
      method to create a new CircularPatternFeatureInput object and then use methods on it
      (the CircularPatternFeatureInput object) to define the circular pattern.
      @returns Returns the newly created CircularPatternFeature object or null if the creation failed.
    */
    add(input: CircularPatternFeatureInput): CircularPatternFeature | null
    /**
      Function that returns the specified circular pattern feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): CircularPatternFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a circular pattern
    feature.
  */
  abstract class CircularPatternFeatureInput extends core.Base {
    /**
      Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
      All of the entities must be of a single type. For example, it can't contain features and occurrences
      but only features or occurrences.
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,
      construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
    */
    axis: core.Base
    /**
      Gets and sets quantity of the elements.
    */
    quantity: core.ValueInput
    /**
      Gets and sets total angle. A negative angle can be used to reverse the direction.
      An angle of 360 degrees or 2 pi radians will create a full circular pattern.
    */
    totalAngle: core.ValueInput
    /**
      Gets and sets if the angle extent is in one direction or symmetric.
    */
    isSymmetric: boolean
    /**
      Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
      This property only applies when patterning features and is ignored in the direct modeling environment.
    */
    patternComputeOption: PatternComputeOptions
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing circular pattern feature in a design.
  */
  abstract class CircularPatternFeature extends Feature {
    /**
      Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
      All of the entities must be of a single type. For example, it can't contain features and occurrences
      but only features or occurrences.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,
      construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    axis: core.Base
    /**
      Returns the parameter controlling the total angle.
      To edit the angle use properties on the parameter to edit its value.
      This property returns null in the case where the feature is non-parametric.
      A negative value can be used to change the direction of the pattern.
    */
    readonly totalAngle: ModelParameter
    /**
      Gets and sets if the angle extent is in one direction or symmetric.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isSymmetric: boolean
    /**
      Returns the parameter controlling the number of pattern elements, including any suppressed elements.
      To edit the quantity use properties on the parameter to edit its value.
      This property returns null in the case where the feature is non-parametric.
    */
    readonly quantity: ModelParameter
    /**
      Gets the PatternElements collection that contains the elements created by this pattern.
    */
    readonly patternElements: PatternElements
    /**
      Returns the features that were created as a result of this pattern.
      This is only valid for a direct edit model and this returns null
      in the case where the feature is parametric.
    */
    readonly resultFeatures: core.ObjectCollection
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: CircularPatternFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): CircularPatternFeature | null
    /**
      Returns the type of entities the pattern consists of. This can be used to help
      determine the type of results that will be found in the pattern elements.
    */
    readonly patternEntityType: PatternEntityTypes
    /**
      Gets and sets the compute option for this pattern feature.
      This property only applies when patterning features and is ignored in the direct modeling environment.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    patternComputeOption: PatternComputeOptions
  }

  /**
    Collection that provides access to all of the existing rectangular pattern features in a component
    and supports the ability to create new rectangular pattern features.
  */
  abstract class RectangularPatternFeatures extends core.Base {
    /**
      Function that returns the specified rectangular pattern feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): RectangularPatternFeature | null
    /**
      The number of rectangular pattern features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a RectangularPatternFeatureInput object. Use properties and methods on this object
      to define the rectangular pattern you want to create and then use the Add method, passing in
      the RectangularPatternFeatureInput object.
      @param inputEntities The collection can contain faces, features, bodies or occurrences.
      All of the entities must be of a single type. For example, it can't contain features and occurrences
      but only features or occurrences.
      @param directionOneEntity Specifies the entity used to define the first direction entity. This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
      If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
      @param quantityOne Specifies the number of instances in the first direction.
      @param distanceOne Specifies the distance in the first direction. How this value is used depends on the value of the PatternDistanceType property. A
      negative value can be used to change the direction.
      If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
      If the value is SpacingPatternDistanceType then it defines the distance between each element.
      @param patternDistanceType Specifies how the distance between elements is computed.
      @returns Returns the newly created RectangularPatternFeatureInput object or null if the creation failed.
    */
    createInput(inputEntities: core.ObjectCollection, directionOneEntity: core.Base, quantityOne: core.ValueInput, distanceOne: core.ValueInput, patternDistanceType: PatternDistanceType): RectangularPatternFeatureInput | null
    /**
      Creates a new rectangular pattern feature.
      @param input A RectangularPatternFeatureInput object that defines the desired rectangular pattern. Use the createInput
      method to create a new RectangularPatternFeatureInput object and then use methods on it
      (the RectangularPatternFeatureInput object) to define the rectangular pattern.
      @returns Returns the newly created RectangularPatternFeature object or null if the creation failed.
    */
    add(input: RectangularPatternFeatureInput): RectangularPatternFeature | null
    /**
      Function that returns the specified rectangular pattern feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): RectangularPatternFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a rectangular pattern
    feature.
  */
  abstract class RectangularPatternFeatureInput extends core.Base {
    /**
      Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
      All of the entities must be of a single type. For example, it can't contain features and occurrences
      but only features or occurrences.
    */
    inputEntities: core.ObjectCollection
    /**
      Sets all of the input required to define the pattern in the second direction.
      @param directionTwoEntity Specifies the entity used to define the second direction entity. This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
      If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
      This argument can be null to indicate that the default second direction is to be used, which is 90 degrees to the first direction.
      @param quantityTwo Specifies the number of instances in the second direction.
      @param distanceTwo Specifies the distance in the second direction. How this value is used depends on the value of the PatternDistanceType property.
      If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
      If the value is SpacingPatternDistanceType then it defines the distance between each element.
      @returns Returns true if it was successful.
    */
    setDirectionTwo(directionTwoEntity: core.Base, quantityTwo: core.ValueInput, distanceTwo: core.ValueInput): boolean
    /**
      Gets and sets the first direction entity.
      This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
      If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
    */
    directionOneEntity: core.Base
    /**
      Gets and sets the second direction entity.
      This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
      If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
    */
    directionTwoEntity: core.Base
    /**
      Gets and sets the number of instances in the first direction.
    */
    quantityOne: core.ValueInput
    /**
      Gets and sets the number of instances in the second direction.
    */
    quantityTwo: core.ValueInput
    /**
      Gets and sets the distance in the first direction.
    */
    distanceOne: core.ValueInput
    /**
      Gets and sets the distance in the second direction.
    */
    distanceTwo: core.ValueInput
    /**
      Returns a Vector3D indicating the positive direction of direction one.
    */
    readonly directionOne: core.Vector3D
    /**
      Returns a Vector3D indicating the positive direction of direction two.
    */
    readonly directionTwo: core.Vector3D
    /**
      Gets and sets if the pattern in direction one is in one direction or symmetric.
    */
    isSymmetricInDirectionOne: boolean
    /**
      Gets and sets if the pattern in direction two is in one direction or symmetric.
    */
    isSymmetricInDirectionTwo: boolean
    /**
      Gets and sets how the distance between elements is computed.
    */
    patternDistanceType: PatternDistanceType
    /**
      Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
      This property only applies when patterning features and is ignored in the direct modeling environment.
    */
    patternComputeOption: PatternComputeOptions
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Defines the different ways to specify the spacing between elements in a pattern.
  */
  const enum PatternDistanceType {
    /**
      The total distance of the pattern is specified with the quantity evenly spaced within that distance.
    */
    ExtentPatternDistanceType,
    /**
      The distance between each pattern element is specified.
    */
    SpacingPatternDistanceType,
  }

  /**
    Object that represents an existing rectangular pattern feature in a design.
  */
  abstract class RectangularPatternFeature extends Feature {
    /**
      Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
      All of the entities must be of a single type. For example, it can't contain features and occurrences
      but only features or occurrences.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the first direction entity.
      This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
      If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    directionOneEntity: core.Base
    /**
      Gets and sets the second direction entity.
      This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
      If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
      This can be null when not entity has been specified to control the second direction. In this case Fusion will compute a default direction which is
      90 degrees to the direction one.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    directionTwoEntity: core.Base
    /**
      Returns a Vector3D indicating the positive direction of direction one.
    */
    readonly directionOne: core.Vector3D
    /**
      Returns a Vector3D indicating the positive direction of direction two.
    */
    readonly directionTwo: core.Vector3D
    /**
      Gets the number of instances in the first direction.
      Edit the value through ModelParameter.
      Returns nothing in the case where the feature is non-parametric.
    */
    readonly quantityOne: ModelParameter
    /**
      Gets the number of instances in the second direction.
      Edit the value through ModelParameter.
      Returns nothing in the case where the feature is non-parametric.
    */
    readonly quantityTwo: ModelParameter
    /**
      Gets the distance in the first direction.
      Edit the value through ModelParameter.
      Returns nothing in the case where the feature is non-parametric.
    */
    readonly distanceOne: ModelParameter
    /**
      Gets the distance in the second direction.
      Edit the value through ModelParameter.
      Returns nothing in the case where the feature is non-parametric.
    */
    readonly distanceTwo: ModelParameter
    /**
      Gets and sets if the pattern in direction one is in one direction or symmetric.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isSymmetricInDirectionOne: boolean
    /**
      Gets and sets if the pattern in direction two is in one direction or symmetric.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isSymmetricInDirectionTwo: boolean
    /**
      Gets and sets how the distance between elements is computed. Is initialized to ExtentPatternDistanceType when a new
      RectangularPatternFeatureInput has been created.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    patternDistanceType: PatternDistanceType
    /**
      Gets the PatternElements collection that contains the elements created by this pattern.
    */
    readonly patternElements: PatternElements
    /**
      Get the features that were created for this pattern.
      Returns null in the case where the feature is parametric.
    */
    readonly resultFeatures: core.ObjectCollection
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: RectangularPatternFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): RectangularPatternFeature | null
    /**
      Returns the type of entities the pattern consists of. This can be used to help
      determine the type of results that will be found in the pattern elements.
    */
    readonly patternEntityType: PatternEntityTypes
    /**
      Gets and sets the compute option for this pattern feature.
      This property only applies when patterning features and is ignored in the direct modeling environment.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    patternComputeOption: PatternComputeOptions
  }

  /**
    Collection that provides access to all of the existing path pattern features in a component
    and supports the ability to create new path pattern features.
  */
  abstract class PathPatternFeatures extends core.Base {
    /**
      Function that returns the specified path pattern feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): PathPatternFeature | null
    /**
      The number of path pattern features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a PathPatternFeatureInput object. Use properties and methods on this object
      to define the path pattern you want to create and then use the Add method, passing in
      the PathPatternFeatureInput object.
      @param inputEntities The collection can contain faces, features, bodies or occurrences.
      All of the entities must be of a single type. For example, it can't contain features and occurrences
      but only features or occurrences.
      @param path The Path object that represents a single set of connected curves along which to drive the pattern.
      @param quantity Specifies the number of instances in the first direction.
      @param distance Specifies the distance. How this value is used depends on the value of the PatternDistanceType property. A
      negative value can be used to change the direction.
      If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
      If the value is SpacingPatternDistanceType then it defines the distance between each element.
      @param patternDistanceType Specifies how the distance between elements is computed.
      @returns Returns the newly created PathPatternFeatureInput object or null if the creation failed.
    */
    createInput(inputEntities: core.ObjectCollection, path: Path, quantity: core.ValueInput, distance: core.ValueInput, patternDistanceType: PatternDistanceType): PathPatternFeatureInput | null
    /**
      Creates a new path pattern feature.
      @param input A PathPatternFeatureInput object that defines the desired path pattern. Use the createInput
      method to create a new PathPatternFeatureInput object and then use methods on it
      (the PathPatternFeatureInput object) to define the path pattern.
      @returns Returns the newly created PathPatternFeature object or null if the creation failed.
    */
    add(input: PathPatternFeatureInput): PathPatternFeature | null
    /**
      Function that returns the specified path pattern feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): PathPatternFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a path pattern
    feature.
  */
  abstract class PathPatternFeatureInput extends core.Base {
    /**
      Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
      All of the entities must be of a single type. For example, it can't contain features and occurrences
      but only features or occurrences.
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the path to create the pattern on path.
    */
    path: Path
    /**
      Gets and sets quantity of the elements.
    */
    quantity: core.ValueInput
    /**
      Gets and sets the distance.
    */
    distance: core.ValueInput
    /**
      Gets and sets the start point on the path to count the distance.
      It's between 0 and 1. 0 means start point of the path, 1 means end point of the path.
    */
    startPoint: number
    /**
      Gets and sets if flip the direction from start point.
    */
    isFlipDirection: boolean
    /**
      Gets and sets how the distance between elements is computed.
    */
    patternDistanceType: PatternDistanceType
    /**
      Gets and sets if the pattern is in one direction or symmetric.
    */
    isSymmetric: boolean
    /**
      Gets and sets if the orientation is along path.
      If false, the orientation is identical.
    */
    isOrientationAlongPath: boolean
    /**
      Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
      This property only applies when patterning features and is ignored in the direct modeling environment.
    */
    patternComputeOption: PatternComputeOptions
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing path pattern feature in a design.
  */
  abstract class PathPatternFeature extends Feature {
    /**
      Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
      All of the entities must be of a single type. For example, it can't contain features and occurrences
      but only features or occurrences.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the path to create the pattern on path.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    path: Path
    /**
      Gets the quantity of the elements.
      Edit the value through ModelParameter.
      Returns nothing in the case where the feature is non-parametric.
    */
    readonly quantity: ModelParameter
    /**
      Gets the distance.
      Edit the value through ModelParameter.
      Returns nothing in the case where the feature is non-parametric.
    */
    readonly distance: ModelParameter
    /**
      Gets and sets the start point on the path to count the distance.
      It's between 0 and 1. 0 means start point of the path, 1 means end point of the path.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    startPoint: number
    /**
      Gets and sets if flip the direction from start point.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isFlipDirection: boolean
    /**
      Gets and sets how the distance between elements is computed.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    patternDistanceType: PatternDistanceType
    /**
      Gets and sets if the pattern is in one direction or symmetric.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isSymmetric: boolean
    /**
      Gets and sets if the orientation is along path.
      If false, the orientation is identical.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isOrientationAlongPath: boolean
    /**
      Gets the PatternElements collection that contains the elements created by this pattern.
    */
    readonly patternElements: PatternElements
    /**
      Get the features that were created for this mirror.
      Returns null in the case where the feature is parametric.
    */
    readonly resultFeatures: core.ObjectCollection
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: PathPatternFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): PathPatternFeature | null
    /**
      Returns the type of entities the pattern consists of. This can be used to help
      determine the type of results that will be found in the pattern elements.
    */
    readonly patternEntityType: PatternEntityTypes
    /**
      Gets and sets the compute option for this pattern feature.
      This property only applies when patterning features and is ignored in the direct modeling environment.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    patternComputeOption: PatternComputeOptions
  }

  /**
    Collection that provides access to all of the existing thread features in a component
    and supports the ability to create new thread features.
    The creation of a tapped hole also results in the creation of a thread feature. These
    thread features are also returned by this collection, even though they aren't present
    in the timeline and are represented by the hole feature.
  */
  abstract class ThreadFeatures extends core.Base {
    /**
      Function that returns the specified thread feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ThreadFeature | null
    /**
      The number of thread features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Property that returns the ThreadDataQuery object. When creating a thread, the type and size of the thread
      is specified by referencing thread information defined in one of the XML files in the ThreadData folder.
      The ThreadDataQuery is an object that supports methods to query the existing threads defined in these files.
      @remarks
      This method has been replaced by the ThreadDataQuery.create method.
      @deprecated
    */
    readonly threadDataQuery: ThreadDataQuery
    /**
      Creates a ThreadFeatureInput object. This object is the API equivalent of the Thread feature dialog. It collects
      the required input and once fully defined you can pass this object to the ThreadFeatures.add method to create
      the thread feature.
      @param inputCylindricalFaces A single cylindrical BRep face or a collection of cylindrical BRep faces to thread.
      A collection of faces must all be from either holes (for internal threading) or all from cylinders (for external threading).
      Both internal and external threads cannot be created in the same feature.
      The faces in a collection can come from different bodies or components.
      @param threadInfo The ThreadInfo object that defines the type and size of the thread to create. When creating a thread, the type and size
      of the thread is specified by referencing thread information defined in one of the XML files in the ThreadData folder within
      the Fusion install folder. You can use the ThreadDataQuery object to query these XML files to find the specific thread you
      want to create. The ThreadDataQuery object can be obtained by using the ThreadFeatures.threadDataQuery property. You then use
      this information to create a ThreadInfo object using the ThreadFeatures.createThreadInfo method.
      @returns Returns the newly created ThreadFeatureInput object or null/None if the creation failed.
    */
    createInput(inputCylindricalFaces: core.Base, threadInfo: ThreadInfo): ThreadFeatureInput
    /**
      Method that creates a new ThreadInfo object that can be used in creating thread features.
      The ThreadInfo object that defines the type and size of the thread to create. When creating a thread, the type and size
      of the thread is specified by referencing thread information defined in one of the XML files in the ThreadData folder within
      the Fusion install folder. You can use the ThreadDataQuery object to query these XML files to find the specific thread you
      want to create. The ThreadDataQuery object can be obtained by using the ThreadFeatures.threadDataQuery property.
      @remarks
      This method has been replaced by the ThreadInfo.create method.
      @param isInternal Input Boolean that indicates if the thread is an internal or external thread. A value of true indicates an internal thread.
      @param threadType Input string that defines the thread type.
      @param threadDesignation Input string that contains the thread designation.
      This is input as the full thread designation that will be used in a drawing for the thread call-out.
      The nominal size and pitch information are extracted from the designation.
      @param threadClass Input string that defines the thread class.
      @returns Returns the newly created ThreadInfo object or null if the creation failed.
      @deprecated
    */
    createThreadInfo(isInternal: boolean, threadType: string, threadDesignation: string, threadClass: string): ThreadInfo | null
    /**
      Creates a new thread feature.
      @param input A ThreadFeatureInput object that defines the desired thread. Use the createInput
      method to create a new ThreadFeatureInput object and then use methods on it
      (the ThreadFeatureInput object) to define the thread.
      @returns Returns the newly created ThreadFeature object or null if the creation failed.
    */
    add(input: ThreadFeatureInput): ThreadFeature | null
    /**
      Function that returns the specified thread feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): ThreadFeature | null
  }

  /**
    This object provides methods to query the thread data contained in the XML files in ThreadData folder within the
    Fusion install folder. You can use the queried values to create a ThreadInfo object that is then used to
    create a thread feature.
  */
  abstract class ThreadDataQuery extends core.Base {
    /**
      This method returns an array of all the available thread types (families). The type names are always
      English. This English name should be used in the other methods that take the type as an input argument.
      If you need to display the type name to the user, you can use the threadTypeCustomName method To get
      the localized name.
    */
    readonly allThreadTypes: string[]
    /**
      Returns an array/list of all the available thread sizes for a given thread type. You can
      use the allThreadTypes property to get the available thread types.
      @param threadType Specify the thread type.
      @returns Returns the specified thread sizes or an empty array/list if an invalid thread type was specified.
    */
    allSizes(threadType: string): string[]
    /**
      returns an array/list of all the available thread designations for a thread type of a given size. Valid
      thread types and sizes and be obtained by using the allThreadTypes and allSizes functions.
      @param threadType The thread type of the designation you want.
      @param size The thread size of the designation you want.
      @returns Returns the specified thread designations or empty array/list if an invalid thread type or size was specified.
    */
    allDesignations(threadType: string, size: string): string[]
    /**
      Returns and array/list of all the available classes for a thread type of a given thread designation.
      @param isInternal Indicates if the thread is an internal or external thread.
      @param threadType The thread type of the thread class you want.
      @param designation The thread designation of the thread class you want.
      @returns Returns the specified thread classes or empty array/list if an invalid thread type or designation was specified.
    */
    allClasses(isInternal: boolean, threadType: string, designation: string): string[]
    /**
      Method that returns the custom name for a given thread type. The custom name is the localized name
      of the thread type using the current language specified for Fusion.
      @param threadType The thread type you want to get the custom name for.
      @returns Returns the specified custom name or an empty string if an invalid thread type was specified.
    */
    threadTypeCustomName(threadType: string): string
    /**
      Method that returns the unit for a given thread type.
      @param threadType The thread type you want to get the thread unit type for.
      @returns Returns the specified unit or an empty string if an invalid thread type was specified.
    */
    threadTypeUnit(threadType: string): string
    /**
      Method that gets the recommended thread data for a given cylinder diameter. This method
      is only valid for straight threads and will fail for tapered threads.
      @param modelDiameter The diameter of the cylinder the thread will be placed on. The units are centimeters.
      @param isInternal Indicates if the thread is an internal or external thread.
      @param threadType Specifies the thread type to query the thread data.
      @param designation The output thread designation.
      @param threadClass The output thread class.
      @returns Returns true if successful.
    */
    recommendThreadData(modelDiameter: number, isInternal: boolean, threadType: string): [designation: string, threadClass: string]
    /**
      Gets the default thread type for inch threads.
    */
    readonly defaultInchThreadType: string
    /**
      Gets the default thread type for metric threads.
    */
    readonly defaultMetricThreadType: string
  }

  /**
    This class defines the methods and properties that define the type and size of a thread. This object is used
    to create and query thread and tapped (straight and tapered) hole features. A new ThreadInfo object is
    created by using the ThreadInfo.create method. If the ThreadInfo object is obtained from
    an existing thread or hole feature, modifying the ThreadInfo object will modify the feature.
  */
  abstract class ThreadInfo extends core.Base {
    /**
      Returns and sets the string that defines the thread type.
    */
    threadType: string
    /**
      Returns the string that defines the thread size.
    */
    readonly threadSize: string
    /**
      Returns and sets the string that defines the thread designation.
    */
    threadDesignation: string
    /**
      Returns and sets the string that defines the thread class.
    */
    threadClass: string
    /**
      Returns and sets if the thread is an internal or external thread. A value of true indicates an internal thread.
      It defaults to true.
    */
    isInternal: boolean
    /**
      Returns the value that defines the thread angle. The units are degrees.
    */
    readonly threadAngle: number
    /**
      Returns the value that defines the thread pitch. The units are centimeters.
    */
    readonly threadPitch: number
    /**
      Returns the value that defines the major diameter. The units are centimeters.
    */
    readonly majorDiameter: number
    /**
      Returns the value that defines the minor diameter. The units are centimeters.
    */
    readonly minorDiameter: number
    /**
      Returns the value that defines the pitch diameter. The units are centimeters.
    */
    readonly pitchDiameter: number
  }

  /**
    List of the positions of a thread feature when it is not full length.
  */
  const enum ThreadLocations {
    /**
      Position thread at the high end of the cylinder. You can determine the high end in the model by using the geometry
      property of the cylindrical BRepFace object, which will return a Cylinder object. The axis property of the Cylinder
      is a vector and the high end of the cylinder is at the far end of the cylinder with respect to the axis vector.
    */
    HighEndThreadLocation,
    /**
      Position thread at the low end of the cylinder. You can determine the low end in the model by using the geometry
      property of the cylindrical BRepFace object, which will return a Cylinder object. The axis property of the Cylinder
      is a vector and the low end of the cylinder is at the near end of the cylinder with respect to the axis vector.
    */
    LowEndThreadLocation,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a thread
    feature.
  */
  abstract class ThreadFeatureInput extends core.Base {
    /**
      Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.
      Setting this results in a thread being applied to only a single face.
      It is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces
      to be threaded.
    */
    inputCylindricalFace: BRepFace
    /**
      Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.
      It defaults to false.
    */
    isModeled: boolean
    /**
      Gets and sets if this thread is the full length of the cylinder.
      It defaults to true.
    */
    isFullLength: boolean
    /**
      Gets and sets the thread length.
      It is only used in the case where the isFullLength property is false.
    */
    threadLength: core.ValueInput
    /**
      Gets and sets the thread offset.
      The offset is the distance along the axis of the cylinder from the edge to the start of the thread.
      It is only used in the case where the isFullLength property is false.
      Returns nothing in the case where the feature is non-parametric.
    */
    threadOffset: core.ValueInput
    /**
      Gets and sets which end of the cylinder the thread is measured from when it's not full
      length. The thread position and length can be measured from either the "low" or "high" end.
      You can determine the low and high end by using the Cylinder associated with the cylindrical
      BRepFace the thread is being added to. The BRepFace.geometry which will return a Cylinder object.
      The axis property of the Cylinder is a vector and the high end of the cylinder is at the far end
      of the cylinder with respect to the axis vector.
      This property is only used in the case where the isFullLength property is false and is otherwise ignored.
      It defaults to creating a thread at the high end.
    */
    threadLocation: ThreadLocations
    /**
      Gets and sets the information that defines the thread.
    */
    threadInfo: ThreadInfo
    /**
      Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.
      It defaults to true.
      @remarks
      The direction of the thread is now controlled through the isRightHanded property of the ThreadInfo object.
      @deprecated
    */
    isRightHanded: boolean
    /**
      Gets and sets the cylindrical input faces.
    */
    inputCylindricalFaces: core.ObjectCollection
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing thread feature in a design. The creation of a tapped
    hole also results in the creation of a thread feature. There are some limitation when the
    thread feature is associated with a hole, which are described in the documentation for the
    property or method where the limitation exists.
  */
  abstract class ThreadFeature extends Feature {
    /**
      Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.
      Setting this results in a thread being applied to only a single face.
      It is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces
      to be threaded.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      If the thread feature is associated with a hole (the hole property is not null), this property will
      always return null and will fail if set.
    */
    inputCylindricalFace: BRepFace
    /**
      Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.
      It defaults to false.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isModeled: boolean
    /**
      Gets and sets if this thread is the full length of the cylinder.
      It only can be set to true.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isFullLength: boolean
    /**
      Sets the thread offset, length and location.
      Calling this method will cause the isFullLength property to be set to false.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param threadOffset A ValueInput object that defines the thread offset.
      @param threadLength A ValueInput object that defines the thread length.
      @param threadLocation Indicates where the thread length is measured from.
      @returns Returns true if successful.
    */
    setThreadOffsetLength(threadOffset: core.ValueInput, threadLength: core.ValueInput, threadLocation: ThreadLocations): boolean
    /**
      Gets the parameter that controls the depth of the thread.
      Even though the parameter for the thread depth is always created and accessible through this property,
      it is only used in the case where the isFullLength property is false.
      Returns nothing in the case where the feature is non-parametric.
    */
    readonly threadLength: ModelParameter
    /**
      Gets the parameter that controls the offset value of the thread.
      The offset is the distance along the axis of the cylinder from the edge to the start of the thread,
      it is only used in the case where the isFullLength property is false.
      Returns nothing in the case where the feature is non-parametric.
    */
    readonly threadOffset: ModelParameter
    /**
      Gets and sets where the thread length is measured from.
      This property is only used in the case where the isFullLength property is false.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      If the thread feature is associated with a hole (the hole property is not null), this property will
      always return null and will always return LowEndThreadLocation and will fail if set.
    */
    threadLocation: ThreadLocations
    /**
      Gets and sets the thread data.
      Also can edit the thread through the properties and methods on the ThreadInfo object.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    threadInfo: ThreadInfo
    /**
      Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.
      It defaults to true.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isRightHanded: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ThreadFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ThreadFeature | null
    /**
      Gets and sets the cylindrical input faces.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      If the thread feature is associated with a hole (the hole property is not null), this property will
      always return null and will fail if set.
    */
    inputCylindricalFaces: core.ObjectCollection
  }

  /**
    Collection that provides access to all of the existing draft features in a component
    and supports the ability to create new draft features.
  */
  abstract class DraftFeatures extends core.Base {
    /**
      Function that returns the specified draft feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): DraftFeature | null
    /**
      The number of draft features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a DraftFeatureInput object. Use properties and methods on this object
      to define the draft you want to create and then use the Add method, passing in
      the DraftFeatureInput object.
      @param inputFaces BRepFace array that contains the faces to which draft will be applied.
      The picked point on face is always the point returned from pointOnFace property of the first BRepFace in this collection.
      @param plane Input object that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane.
      @param isTangentChain A boolean value for setting whether or not faces that are tangentially connected to
      any of the input faces (if any) will also be included. It defaults to true.
      @returns Returns the newly created DraftFeatureInput object or null if the creation failed.
    */
    createInput(inputFaces: BRepFace[], plane: core.Base, isTangentChain?: boolean/* = true*/): DraftFeatureInput | null
    /**
      Creates a new draft feature.
      @param input A DraftFeatureInput object that defines the desired draft. Use the createInput
      method to create a new DraftFeatureInput object and then use methods on it
      (the DraftFeatureInput object) to define the draft.
      @returns Returns the newly created DraftFeature object or null if the creation failed.
    */
    add(input: DraftFeatureInput): DraftFeature | null
    /**
      Function that returns the specified draft feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): DraftFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a draft
    feature.
  */
  abstract class DraftFeatureInput extends core.Base {
    /**
      Gets and sets the input faces.
      If IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
    */
    inputFaces: BRepFace[]
    /**
      Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane.
    */
    plane: core.Base
    /**
      Gets and sets if any faces that are tangentially connected to any of
      the input faces will also be included in setting InputEntities. It defaults to true.
    */
    isTangentChain: boolean
    /**
      Gets and sets if the direction of the draft is flipped.
    */
    isDirectionFlipped: boolean
    /**
      Defines the draft to be defined so that a single angle is used for all drafts.
      If the isSymmetric is true then the faces are split along the parting plane and drafted
      independently using the same angle.
      @param isSymmetric Set to 'true' if the faces are to be split along the plane and drafted symmetrically. This
      will have the side effect of setting the isSymmetric property to the same value.
      @param angle The ValueInput object that defines the angle of the draft. This can be a positive or negative
      value which will affect the direction of the draft along with the isDirectionFlipped property.
      @returns Returns true if successful
    */
    setSingleAngle(isSymmetric: boolean, angle: core.ValueInput): boolean
    /**
      Defines both angles to use when the surfaces are split along the draft plane and
      the faces on each side of the plane are drafted independently from the other side.
      @param angleOne The ValueInput object that defines the angle for the faces on the first side of the draft plane.
      @param angleTwo The ValueInput object that defines the angle for the faces on the second side of the draft plane.
      @returns Returns true if successful
    */
    setTwoAngles(angleOne: core.ValueInput, angleTwo: core.ValueInput): boolean
    /**
      Gets the first, or the only angle in the case of a single angle definition.
    */
    readonly angleOne: core.ValueInput
    /**
      Gets the second angle. This can be null in the case where a single angle definition is used.
    */
    readonly angleTwo: core.ValueInput
    /**
      Gets if the draft is symmetric from the draft plane. This only applies in the case where two
      angles have been specified and should be ignored otherwise.
    */
    readonly isSymmetric: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing draft feature in a design.
  */
  abstract class DraftFeature extends Feature {
    /**
      Gets and sets the input faces.
      If isTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    inputFaces: BRepFace[]
    /**
      Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    plane: core.Base
    /**
      Gets and sets if any faces that are tangentially connected to any of
      the input faces will also be included in setting InputEntities. It defaults to true.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isTangentChain: boolean
    /**
      Gets and sets if the direction of the draft is flipped.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isDirectionFlipped: boolean
    /**
      Gets the definition object that specifies how the draft is defined. Modifying the
      definition object will cause the draft to recompute. This can return either an
      AngleExtentDefinition or TwoSidesAngleExtentDefinition object. This property
      returns nothing in the case where the feature is non-parametric. Use this property
      to access the parameters controlling the draft and whether the draft is symmetric or not.
    */
    readonly draftDefinition: ExtentDefinition
    /**
      Changes the definition of the feature so that a single angle is used for all drafts.
      If the isSymmetric is true then the faces are split along the parting plane and drafted
      independently using the same angle.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param isSymmetric Set to 'true' if the faces are to be split along the plane and drafted symmetrically. This
      will have the side effect of setting the isSymmetric property to the same value.
      @param angle The ValueInput object that defines the angle of the draft. This can be a positive or negative
      value which will affect the direction of the draft along with the isDirectionFlipped property.
      @returns Returns true if successful
    */
    setSingleAngle(isSymmetric: boolean, angle: core.ValueInput): boolean
    /**
      Changes the definition of the feature so that the surfaces are split along the draft plane and
      the faces on each side of the plane are drafted independently from the other side.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param angleOne The ValueInput object that defines the angle for the faces on the first side of the draft plane.
      @param angleTwo The ValueInput object that defines the angle for the faces on the second side of the draft plane.
      @returns Returns true if successful
    */
    setTwoAngles(angleOne: core.ValueInput, angleTwo: core.ValueInput): boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: DraftFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): DraftFeature | null
  }

  /**
    Collection that provides access to all of the existing scale features in a component
    and supports the ability to create new scale features.
  */
  abstract class ScaleFeatures extends core.Base {
    /**
      Function that returns the specified scale feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ScaleFeature | null
    /**
      The number of scale features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a ScaleFeatureInput object. Use properties and methods on this object
      to define the scale you want to create and then use the Add method, passing in
      the ScaleFeatureInput object.
      @param inputEntities This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
      It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
      @param point Input a point as reference to scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint.
      @param scaleFactor The ValueInput object that defines the scale factor for uniform scale.
      @returns Returns the newly created ScaleFeatureInput object or null if the creation failed.
    */
    createInput(inputEntities: core.ObjectCollection, point: core.Base, scaleFactor: core.ValueInput): ScaleFeatureInput | null
    /**
      Creates a new scale feature.
      @param input A ScaleFeatureInput object that defines the desired scale. Use the createInput
      method to create a new ScaleFeatureInput object and then use methods on it
      (the ScaleFeatureInput object) to define the scale.
      @returns Returns the newly created ScaleFeature object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: ScaleFeatureInput): ScaleFeature | null
    /**
      Function that returns the specified scale feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): ScaleFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a scale
    feature.
  */
  abstract class ScaleFeatureInput extends core.Base {
    /**
      Gets and sets the input entities.
      This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
      It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
      If the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the origin point of the scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint.
    */
    point: core.Base
    /**
      Gets and sets the scale factor used for a uniform scale.
      Setting this value will cause the isUniform property to be set to true.
    */
    scaleFactor: core.ValueInput
    /**
      Gets if the scale is uniform.
    */
    readonly isUniform: boolean
    /**
      Sets the scale factor for the x, y, z directions to define a non-uniform scale.
      Calling this method will cause the isUniform property to be set to false.
      This will fail if the inputEntities collection contains sketches or components.
      @param xScale A ValueInput object that defines the scale in the X direction.
      @param yScale A ValueInput object that defines the scale in the Y direction.
      @param zScale A ValueInput object that defines the scale in the Z direction.
      @returns Returns true if successful.
    */
    setToNonUniform(xScale: core.ValueInput, yScale: core.ValueInput, zScale: core.ValueInput): boolean
    /**
      Gets the scale in X direction.
    */
    readonly xScale: core.ValueInput
    /**
      Gets the scale in Y direction.
    */
    readonly yScale: core.ValueInput
    /**
      Gets the scale in Z direction.
    */
    readonly zScale: core.ValueInput
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing scale feature in a design.
  */
  abstract class ScaleFeature extends Feature {
    /**
      Gets and sets the input entities.
      This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
      It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
      If the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the point as reference to scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    point: core.Base
    /**
      Calling this method will change to a uniform scale.
      The isUniform is set to true if successful.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param scaleFactor A ValueInput object that defines the scale factor.
      @returns Returns true if successful.
    */
    setToUniform(scaleFactor: core.ValueInput): boolean
    /**
      Calling this method will change to a non-uniform scale.
      Fails of the inputEntities collection contains sketches or components.
      The isUniform is set to false if successful.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param xScale A ValueInput object that defines the scale in the X direction.
      @param yScale A ValueInput object that defines the scale in the Y direction.
      @param zScale A ValueInput object that defines the scale in the Z direction.
      @returns Returns true if successful.
    */
    setToNonUniform(xScale: core.ValueInput, yScale: core.ValueInput, zScale: core.ValueInput): boolean
    /**
      Gets if it's uniform scale.
    */
    readonly isUniform: boolean
    /**
      Returns the parameter that controls the uniform scale factor. This will return null in the case
      where isUniform is false or the feature is non-parametric. You can use the properties and
      methods on the ModelParameter object to get and set the value.
    */
    readonly scaleFactor: ModelParameter
    /**
      Returns the parameter that controls the X scale factor. This will return null in the case
      where isUniform is false or the feature is non-parametric. You can use the properties and
      methods on the ModelParameter object to get and set the value.
    */
    readonly xScale: ModelParameter
    /**
      Returns the parameter that controls the Y scale factor. This will return null in the case
      where isUniform is false or the feature is non-parametric. You can use the properties and
      methods on the ModelParameter object to get and set the value.
    */
    readonly yScale: ModelParameter
    /**
      Returns the parameter that controls the Z scale factor. This will return null in the case
      where isUniform is false or the feature is non-parametric. You can use the properties and
      methods on the ModelParameter object to get and set the value.
    */
    readonly zScale: ModelParameter
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ScaleFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ScaleFeature | null
  }

  /**
    Collection that provides access to all of the existing move features in a component
    and supports the ability to create new move features.
  */
  abstract class MoveFeatures extends core.Base {
    /**
      Function that returns the specified move feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MoveFeature | null
    /**
      The number of move features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MoveFeatureInput object. Use properties and methods on this object
      to define the move feature you want to create and then use the Add method, passing in
      the MoveFeatureInput object.
      @remarks
      This method is obsolete. You should use the createInput2 method instead.
      @param inputEntities An ObjectCollection containing the entities to move. This collection can only contain
      BRepBody objects in parametric modeling. It can be BRep bodies, T-Spline bodies,
      mesh bodies mixed or faces and features mixed in non-parametric modeling.
      @param transform The transform to apply to the input entities. This can describe a move (translation) or a rotation. The
      matrix must define an orthogonal transform. That is the axes must be perpendicular to each other and there
      can't be any scaling or mirroring defined.
      @returns Returns the newly created MoveFeatureInput object or null if the creation failed.
      @deprecated
    */
    createInput(inputEntities: core.ObjectCollection, transform: core.Matrix3D): MoveFeatureInput | null
    /**
      Creates a new move feature.
      @param input A MoveFeatureInput object that defines the desired move feature. Use the createInput2
      method to create a new MoveFeatureInput object and then use methods on the MoveFeatureInput
      object to define the move feature.
      @returns Returns the newly created MoveFeature object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MoveFeatureInput): MoveFeature | null
    /**
      Function that returns the specified move feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MoveFeature | null
    /**
      Creates a MoveFeatureInput object. Use properties and methods on this object
      to define how the move is defined and then use the MoveFeatues.add method, passing in
      the MoveFeatureInput object to create a move feature.
      @param inputEntities An ObjectCollection containing the objects to move. For a parametric model, the collection can contain
      BRepBody or BRepFace objects but not a combination of both.
      @returns Returns the newly created MoveFeatureInput object or null if the creation failed.
    */
    createInput2(inputEntities: core.ObjectCollection): MoveFeatureInput | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a move feature.
  */
  abstract class MoveFeatureInput extends core.Base {
    /**
      An ObjectCollection containing the objects to move. The collection can contain
      BRepBody or BRepFace objects but not a mixture of the two types.
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the transform to apply to the input entities. This can describe a move (translation)
      or a rotation. The matrix must define an orthogonal transform. That is the axes remain
      perpendicular to each other and there isn't any scale or mirror defined.
      @remarks
      This property is obsolete. You should now use the setToFreeMove for the equivalent functionality.
      @deprecated
    */
    transform: core.Matrix3D
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      This method will define a move feature whose translation and orientation
      is defined using a transformation matrix. A matrix can define any translation and
      orientation.
      @param transform The transformation matrix that defines the transform to apply. The matrix must
      be an orthogonal matrix that is the axes are perpendicular to each other
      and there isn't any scaling or mirroring defined.
      @returns Returns true if defining the type of move is successful.
    */
    defineAsFreeMove(transform: core.Matrix3D): boolean
    /**
      This method will define a move feature that defines a translation in X, Y, and Z.
      @param xDistance A ValueInput object that defines the offset in the X direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units are used.
      @param yDistance A ValueInput object that defines the offset in the Y direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units are used.
      @param zDistance A ValueInput object that defines the offset in the Z direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units are used.
      @param isDesignSpace Defines if the translation is defined with respect to the design or component space.
      Design space is the same as the root component space.
      @returns Returns true if defining the type of move is successful.
    */
    defineAsTranslateXYZ(xDistance: core.ValueInput, yDistance: core.ValueInput, zDistance: core.ValueInput, isDesignSpace: boolean): boolean
    /**
      This method will define a move feature that defines a translation along a specified entity.
      @param linearEntity A linear entity that defines the direction of the move. This can be a linear BRepEdge,
      ConstructionAxis, or a SketchLine. The entity defines the direction, not the distance.
      The natural direction of the entity defines the translation direction.
      @param distance A ValueInput object that defines the offset distance. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units are used.
      @returns Returns true if defining the type of move is successful.
    */
    defineAsTranslateAlongEntity(linearEntity: core.Base, distance: core.ValueInput): boolean
    /**
      This method defines a move feature that is described by an axis and rotation angle.
      @param axisEntity A linear entity that defines the axis of rotation. This can be a linear BRepEdge,
      ConstructionAxis, or a SketchLine. The natural direction of the entity defines a
      right-hand rule for the rotation direction.
      @param angle A ValueInput object that defines the rotation angle. If the ValueInput
      is created using a real value, the angle is in radians. If it's defined using
      a string, the default document units will be used.
      @returns Returns true if defining the type of move is successful.
    */
    defineAsRotate(axisEntity: core.Base, angle: core.ValueInput): boolean
    /**
      This method defines a move feature described by a translation from one point to another.
      @param originPoint The first point that defines the start position of the move.
      @param targetPoint The second point that defines the direction and distance of the move.
      @returns Returns true if defining the type of move is successful.
    */
    defineAsPointToPoint(originPoint: core.Base, targetPoint: core.Base): boolean
    /**
      This method defines a move feature described by a point and an offset. The distances
      define offsets in the X, Y, and Z directions in either design or component space. To
      not move the input entities at all the offset distances should be set to the current
      location of the point in either design or component space. Adding or subtracting to
      those values will then move the entities that distance. It's best to experiment with
      the command interactively to understand the behavior.
      @param point An entity that defines a point in space. This can be a sketch point, a construction point,
      or a BRepVertex.
      @param xDistance A ValueInput object that defines the offset in the X direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units will be used.
      @param yDistance A ValueInput object that defines the offset in the Y direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units will be used.
      @param zDistance A ValueInput object that defines the offset in the Z direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units will be used.
      @param isDesignSpace Defines if the translation is defined with respect to the design or component space.
      Design space is the same as the root component space.
      @returns Returns true if defining the type of move is successful.
    */
    defineAsPointToPosition(point: core.Base, xDistance: core.ValueInput, yDistance: core.ValueInput, zDistance: core.ValueInput, isDesignSpace: boolean): boolean
  }

  /**
    Object that represents an existing move feature in a design.
  */
  abstract class MoveFeature extends Feature {
    /**
      Gets and sets the entities to move. This is done by using an ObjectCollection
      containing the objects to move. For a parametric model, the collection can contain
      BRepBody or BRepFace objects but not a combination of both.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    inputEntities: core.ObjectCollection
    /**
      Gets and sets the move transform of the input bodies or faces.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @remarks
      This property is obsolete. The move feature now supports more than a
      simple transform. This property can still work in the case where a
      move feature was created using the FreeMove type of move but will
      fail in all other cases.
      @deprecated
    */
    transform: core.Matrix3D
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MoveFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MoveFeature | null
    /**
      Returns the MoveFeatureDefinition object which provides access to the information
      that specifies how this MoveFeature is defined.
    */
    readonly definition: MoveFeatureDefinition
    /**
      Redefines the move feature to be described by an arbitrary translation and orientation
      which is defined using a transformation matrix.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param transform The transformation matrix that defines the transform to apply. The matrix must
      be an orthogonal matrix that is the axes are perpendicular to each other
      and there isn't any scaling or mirroring defined.
      @returns Returns true if the re-definition is successful.
    */
    redefineAsFreeMove(transform: core.Matrix3D): boolean
    /**
      Redefines the move feature to be described by a translation in X, Y, and Z.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param xDistance A ValueInput object that defines the offset in the X direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units will be used.
      @param yDistance A ValueInput object that defines the offset in the Y direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units will be used.
      @param zDistance A ValueInput object that defines the offset in the Z direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units will be used.
      @param isDesignSpace Defines if the translation is defined with respect to the design or component space.
      Design space is the same as the root component space.
      @returns Returns true if the re-definition is successful.
    */
    redefineAsTranslateXYZ(xDistance: core.ValueInput, yDistance: core.ValueInput, zDistance: core.ValueInput, isDesignSpace: boolean): boolean
    /**
      Redefines the move feature to be a translation along a specified entity.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param linearEntity A linear entity that defines the direction of the move. This can be a linear BRepEdge,
      ConstructionAxis, or a SketchLine. The entity defines the direction, not the distance.
      The natural direction of the entity defines the translation direction.
      @param distance A ValueInput object that defines the offset distance. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units will be used.
      @returns Returns true if the redefinition is successful.
    */
    redefineAsTranslateAlongEntity(linearEntity: core.Base, distance: core.ValueInput): boolean
    /**
      Redefines the move feature to be described by an axis and rotation angle.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param axisEntity A linear entity that defines the axis of rotation. This can be a linear BRepEdge,
      ConstructionAxis, or a SketchLine. The natural direction of the entity defines a
      right-hand rule for the rotation direction.
      @param angle A ValueInput object that defines the rotation angle. If the ValueInput
      is created using a real value, the angle is in radians. If it's defined using
      a string, the default document units will be used.
      @returns Returns true if the redefinition is successful.
    */
    redefineAsRotate(axisEntity: core.Base, angle: core.ValueInput): boolean
    /**
      Redefines the move feature to be a translation from one point to another.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param originPoint The first point that defines the start position of the move.
      @param targetPoint The second point that defines the direction and distance of the move.
      @returns Returns true if the redefinition is successful.
    */
    redefineAsPointToPoint(originPoint: core.Base, targetPoint: core.Base): boolean
    /**
      Redefines a move feature to be described by a point and an offset. The distances
      define offsets in the X, Y, and Z directions in either design or component space. To
      not move the input entities at all the offset distances should be set to the current
      location of the point in either design or component space. Adding or subtracting to
      those values will then move the entities that distance. It's best to experiment with
      the command interactively to understand the behavior.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param point An entity that defines a point in space. This can be a sketch point, a construction point,
      or a BRepVertex.
      @param xDistance A ValueInput object that defines the offset in the X direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units will be used.
      @param yDistance A ValueInput object that defines the offset in the Y direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units will be used.
      @param zDistance A ValueInput object that defines the offset in the Z direction. If the ValueInput
      is created using a real value, the distance is in centimeters. If it's defined using
      a string, the default document units will be used.
      @param isDesignSpace Defines if the translation is defined with respect to the design or component space.
      Design space is the same as the root component space.
      @returns Returns true if the redefinition is successful.
    */
    redefineAsPointToPosition(point: core.Base, xDistance: core.ValueInput, yDistance: core.ValueInput, zDistance: core.ValueInput, isDesignSpace: boolean): boolean
  }

  /**
    A Base class to return the information used to define a Move feature.
  */
  abstract class MoveFeatureDefinition extends core.Base {
    /**
      Returns the parent MoveFeature object
    */
    readonly parentMoveFeature: MoveFeature
  }

  /**
    The MoveFeatureFreeMoveDefinition object defines a move feature described by a transformation matrix.
  */
  abstract class MoveFeatureFreeMoveDefinition extends MoveFeatureDefinition {
    /**
      Gets and sets the transform that's applied to the face or body.
      The matrix must be an orthogonal matrix that is the axes are
      perpendicular to each other and there isn't any scaling or mirroring defined.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    transform: core.Matrix3D
  }

  /**
    The MoveFeatureTranslateXYZDefinition object defines a move feature described by
    offsets in the X, Y, and Z directions.
  */
  abstract class MoveFeatureTranslateXYZDefinition extends MoveFeatureDefinition {
    /**
      Gets the model parameter that controls the X distance of the translation. You
      can use properties on the returned ModelParameter object to edit the offset distance.
    */
    readonly xDistance: ModelParameter
    /**
      Gets the model parameter that controls the Y distance of the translation. You
      can use properties on the returned ModelParameter object to edit the offset distance.
    */
    readonly yDistance: ModelParameter
    /**
      Gets the model parameter that controls the Z distance of the translation. You
      can use properties on the returned ModelParameter object to edit the offset distance.
    */
    readonly zDistance: ModelParameter
    /**
      Gets and sets if the translation is defined with respect to the design or component space.
      Design space is the same as the root component space.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isDesignSpace: boolean
  }

  /**
    The MoveFeatureTranslateAlongEntityDefinition object defines a move feature described by a
    translation in the direction defined by a specified entity.
  */
  abstract class MoveFeatureTranslateAlongEntityDefinition extends MoveFeatureDefinition {
    /**
      Gets and sets the linear entity that defines the direction of the move. This can be a linear BRepEdge,
      ConstructionAxis, or a SketchLine. The entity defines the direction, not the distance.
      The natural direction of the entity defines the translation direction.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    linearEntity: core.Base
    /**
      Gets the model parameter that controls the offset distance. You can use properties
      on the returned ModelParameter object to edit the offset distance.
    */
    readonly distance: ModelParameter
  }

  /**
    The MoveFeatureRotateDefinition object defines a move feature described by a rotation
    around a specified entity.
  */
  abstract class MoveFeatureRotateDefinition extends MoveFeatureDefinition {
    /**
      Gets and sets the linear entity that defines the axis of rotation. This can be a linear BRepEdge,
      ConstructionAxis, or a SketchLine. The natural direction of the entity defines a
      right-hand rule for the rotation direction.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    axisEntity: core.Base
    /**
      Gets the model parameter that controls the rotation angle. You can use properties
      on the returned ModelParameter object to edit the offset distance.
    */
    readonly angle: ModelParameter
  }

  /**
    The MoveFeaturePointToPointDefinition object defines a move feature described by the
    translation from one point to another.
  */
  abstract class MoveFeaturePointToPointDefinition extends MoveFeatureDefinition {
    /**
      Gets and sets the first point that defines the start position of the move.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    originPoint: core.Base
    /**
      Gets and sets the second point that defines the direction and distance of the move.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    targetPoint: core.Base
  }

  /**
    The MoveFeaturePointToPositionDefinition object defines a move feature described
    by a point and an offset. The distances define offsets in the X, Y, and Z directions
    in either design or component space. To not move the input entities at all the offset
    distances should be set to the current location of the point in either design or component
    space. Adding or subtracting to those values will then move the entities that distance.
    It's best to experiment with the command interactively to understand the behavior.
  */
  abstract class MoveFeaturePointToPositionDefinition extends MoveFeatureDefinition {
    /**
      Gets and sets the entity that defines a point in space. This can be a sketch point,
      a construction point, or a BRepVertex.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    point: core.Base
    /**
      Gets the model parameter that controls the offset in the X direction. You can use properties
    */
    readonly xDistance: ModelParameter
    /**
      Gets the model parameter that controls the offset in the Y direction. You can use properties
    */
    readonly yDistance: ModelParameter
    /**
      Gets the model parameter that controls the offset in the Z direction. You can use properties
    */
    readonly zDistance: ModelParameter
    /**
      Gets and sets if the translation is defined with respect to the design or component space.
      Design space is the same as the root component space.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isDesignSpace: boolean
  }

  /**
    Collection that provides access to all of the existing replace face features in a component
    and supports the ability to create new replace face features.
  */
  abstract class ReplaceFaceFeatures extends core.Base {
    /**
      Function that returns the specified replace face feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ReplaceFaceFeature | null
    /**
      The number of replace face features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a ReplaceFaceFeatureInput object. Use properties and methods on this object
      to define the replace face you want to create and then use the Add method, passing in
      the ReplaceFaceFeatureInput object.
      @param sourceFaces Input the entities that define the source faces (the faces to be replaced).
      The collection can contain the faces from a solid and/or features. All the faces must be on the same body.
      @param isTangentChain A boolean value for setting whether or not faces that are tangentially connected to
      the input faces (if any) will also be included. A value of true indicates that tangent
      faces will be included.
      @param targetFaces Input the entities that define the target faces. The new faces must completely intersect the part.
      The collection can contain the surface faces, surface bodies and construction planes.
      @returns Returns the newly created ReplaceFaceFeatureInput object or null if the creation failed.
    */
    createInput(sourceFaces: core.ObjectCollection, isTangentChain: boolean, targetFaces: core.Base): ReplaceFaceFeatureInput | null
    /**
      Creates a new replace face feature.
      @param input A ReplaceFaceFeatureInput object that defines the desired replace face. Use the createInput
      method to create a new ReplaceFaceFeatureInput object and then use methods on it
      (the ReplaceFaceFeatureInput object) to define the replace face.
      @returns Returns the newly created ReplaceFaceFeature object or null if the creation failed.
    */
    add(input: ReplaceFaceFeatureInput): ReplaceFaceFeature | null
    /**
      Function that returns the specified replace face feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): ReplaceFaceFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a replace face feature.
  */
  abstract class ReplaceFaceFeatureInput extends core.Base {
    /**
      Gets and sets the entities that define the source faces to perform replace.
      The collection can contain the faces from a solid and/or from features. All the faces must be on the same body.
    */
    sourceFaces: core.ObjectCollection
    /**
      Gets and sets the entities that define the target faces. The new faces must completely intersect the part.
      The collection can contain the surface faces, surface bodies and construction planes.
    */
    targetFaces: core.Base
    /**
      Gets and sets if any faces that are tangentially connected to any of
      the input faces will also be included in setting InputEntities. It defaults to true.
    */
    isTangentChain: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing replace face feature in a design.
  */
  abstract class ReplaceFaceFeature extends Feature {
    /**
      Method that sets faces to replace.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param sourceFaces The collection can contain the faces from a solid and/or from features. All the faces must be on the same body.
      @param isTangentChain A boolean value for setting whether or not faces that are tangentially connected to
      the input faces (if any) will also be included. A value of true indicates that tangent
      faces will be included.
      @returns Returns true if successful.
    */
    setInputEntities(sourceFaces: core.ObjectCollection, isTangentChain: boolean): boolean
    /**
      Gets and sets the entities that define the target faces. The new faces must completely intersect the part.
      The collection can contain the surface faces, surface bodies and construction planes.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    targetFaces: core.Base
    /**
      Gets if any faces that are tangentially connected to any of
      the input faces will also be included in setting InputEntities.
    */
    readonly isTangentChain: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ReplaceFaceFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ReplaceFaceFeature | null
  }

  /**
    Collection that provides access to all of the existing split face features in a component
    and supports the ability to create new split face features.
  */
  abstract class SplitFaceFeatures extends core.Base {
    /**
      Function that returns the specified split face feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SplitFaceFeature | null
    /**
      The number of split face features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a SplitFaceFeatureInput object. Use properties and methods on this object
      to define the split face you want to create and then use the Add method, passing in
      the SplitFaceFeatureInput object.
      A newly created SplitFaceFeatureInput object defaults to creating a split face feature
      using the "Split with Surface" option. You can use functions on the SplitFaceFeatureInput
      object to define a different type of split type.
      @param facesToSplit Input the faces to be split. The collection can contain one or more faces from solid and/or open bodies.
      @param splittingTool Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
      containing solid and/or open bodies, construction planes, faces, or sketch curves that partially or fully intersect
      the faces that are being split.
      @param isSplittingToolExtended A boolean value for setting whether or not the splittingTool is to be automatically extended (if possible) so as to
      completely intersect the faces that are to be split. This is only used when the split type is "split with surface"
      which is the default type when a new createInput is created. Use functions on the returned SplitFaceFeatureInput
      to define a different type of split type.
      @returns Returns the newly created SplitFaceFeatureInput object or null if the creation failed.
    */
    createInput(facesToSplit: core.ObjectCollection, splittingTool: core.Base, isSplittingToolExtended: boolean): SplitFaceFeatureInput | null
    /**
      Creates a new split face feature.
      @param input A SplitFaceFeatureInput object that defines the desired split face feature. Use the createInput
      method to create a new SplitFaceFeatureInput object and then use methods on it
      (the SplitFaceFeatureInput object) to define the split face.
      @returns Returns the newly created SplitFaceFeature object or null if the creation failed.
    */
    add(input: SplitFaceFeatureInput): SplitFaceFeature | null
    /**
      Function that returns the specified split face feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): SplitFaceFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a split face feature.
  */
  abstract class SplitFaceFeatureInput extends core.Base {
    /**
      Gets and sets the faces to be split.
      The collection can contain one or more faces selected from solid and/or open bodies.
    */
    facesToSplit: core.ObjectCollection
    /**
      Gets and sets the entity(s) that define the splitting tool(s). The splitting tool can be a single entity or an
      ObjectCollection containing solid and/or open bodies, construction planes, faces, or sketch curves that partially
      or fully intersect the faces that are being split.
    */
    splittingTool: core.Base
    /**
      Gets and sets whether or not the splittingTool is to be automatically extended (if possible) so as to
      completely intersect the facesToSplit.
    */
    isSplittingToolExtended: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Sets the split type to project the splitting tool along the direction defined by the
      specified entity.
      @param directionEntity An entity that defines the direction of projection of the splitting tool. This can be
      a linear BRepEdge, SketchLine, ConstructionLine, or a planar face where the face
      normal is used.
      @returns Returns true is setting the split type was successful.
    */
    setAlongVectorSplitType(directionEntity: core.Base): boolean
    /**
      Sets the split type to be a curve that defined by projecting the splitting curve to the
      closest point on the surface.
      @returns Returns true is setting the split type was successful.
    */
    setClosestPointSplitType(): boolean
    /**
      Set the split type to be a surface to surface intersection. If the split tool is a curve
      it will be extruded into a surface to use in the split. If it's a surface, the surface will
      be used and optionally extended to fully intersect the faces to be split.
      @param isSplittingToolExtended Specifies if the splitting tool should be extended so that is fully intersects the faces to be split.
      @returns Returns true is setting the split type was successful.
    */
    setSurfaceIntersectionSplitType(isSplittingToolExtended: boolean): boolean
    /**
      Returns the type of split type currently defined.
    */
    readonly splitType: SplitFaceSplitTypes
  }

  /**
    Object that represents an existing split face feature in a design.
  */
  abstract class SplitFaceFeature extends Feature {
    /**
      Gets and sets the faces to be split.
      The collection can contain one or more faces selected from solid and/or open bodies.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    facesToSplit: core.ObjectCollection
    /**
      Gets the entity(s) that define the splitting tool(s). The splitting tool can consist of one or more of
      the following: BRepBody, ConstructionPlane, BRepFace, sketch curve that extends or can
      be extended beyond the extents of the face. To set the splitting tool, use one of the set methods to
      also define the split type.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    readonly splittingTool: core.ObjectCollection
    /**
      Gets whether or not the setting to automatically extend the splittingTool was set when the feature was created.
      This property is valid only when the splitType property returns surfaceIntersectionSplitType.
    */
    readonly isSplittingToolExtended: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SplitFaceFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SplitFaceFeature | null
    /**
      Set the split type to be a surface to surface intersection. If the split tool is a curve
      it will be extruded into a surface to use in the split. If it's a surface, the surface will
      be used and optionally extended to fully intersect the faces to be split.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param splittingTool Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
      containing solid and/or open bodies, construction planes, faces, or sketch curves that partially or fully intersect
      the faces that are being split.
      @param isSplittingToolExtended Specifies if the splitting tool should be extended so that is fully intersects the faces to be split.
      @returns Returns true is setting the split type was successful.
    */
    setAsSurfaceIntersectionSplitType(splittingTool: core.Base, isSplittingToolExtended: Boolean): boolean
    /**
      Sets the split type to project the splitting tool along the direction defined by the
      specified entity.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param splittingTool Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
      containing faces or sketch curves. If faces are input, the edges of the face are used as the splitting tool.
      @param directionEntity An entity that defines the direction of projection of the splitting tool. This can be
      a linear BRepEdge, SketchLine, ConstructionLine, or a planar face where the face
      normal is used.
      @returns Returns true is setting the split type was successful.
    */
    setAsAlongVectorSplitType(splittingTool: core.Base, directionEntity: core.Base): boolean
    /**
      Sets the split type to be a curve that defined by projecting the splitting curve to the
      closest point on the surface.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param splittingTool Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
      containing faces or sketch curves. If faces are input, the edges of the face are used as the splitting tool.
      @returns Returns true if setting the closest point split type was successful.
    */
    setAsClosestPointSplitType(splittingTool: core.Base): boolean
    /**
      Gets the direction entity when the split type is along a vector. If the split type
      is not alongVectorSplitType this property will return null.
      To set the direction entity use the setAsAlongVectorSplitType method.
    */
    readonly directionEntity: core.Base
    /**
      Returns the type of split type currently defined. To change the split type, use
      one of the set methods.
    */
    readonly splitType: SplitFaceSplitTypes
  }

  /**
    List of the ways to split a face using the split face feature.
  */
  const enum SplitFaceSplitTypes {
    /**
      Split face using a surface-to-surface intersection as the
      split curve.
    */
    surfaceIntersectionSplitType,
    /**
      Split a face using a projection of the split tool along a
      specified direction.
    */
    alongVectorSplitType,
    /**
      Split a face by projecting the split tool to the closest
      point on the faces being split.
    */
    closestPointSplitType,
  }

  /**
    Collection that provides access to all of the existing split body features in a component
    and supports the ability to create new split body features.
  */
  abstract class SplitBodyFeatures extends core.Base {
    /**
      Function that returns the specified split body feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SplitBodyFeature | null
    /**
      The number of split body features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a SplitBodyFeatureInput object. Use properties and methods on this object
      to define the split body you want to create and then use the Add method, passing in
      the SplitBodyFeatureInput object.
      @param splitBodies Input solid body or open bodies to be split. This can be a single BRepBody or an ObjectCollection if multiple
      bodies are to be split.
      @param splittingTool Input entity that defines the splitting tool. The splitting tool is a single entity that can be either a solid or open BRepBody,
      construction plane, profile, or a face.
      @param isSplittingToolExtended A boolean value for setting whether or not the splitting tool is to be automatically extended (if possible) so as to
      completely intersect the bodyToSplit.
      @returns Returns the newly created SplitBodyFeatureInput object or null if the creation failed.
    */
    createInput(splitBodies: core.Base, splittingTool: core.Base, isSplittingToolExtended: boolean): SplitBodyFeatureInput | null
    /**
      Creates a new split body feature.
      @param input A SplitBodyFeatureInput object that defines the desired split body feature. Use the createInput
      method to create a new SplitBodyFeatureInput object and then use methods on it
      (the SplitBodyFeatureInput object) to define the split body.
      @returns Returns the newly created SplitBodyFeature object or null if the creation failed.
    */
    add(input: SplitBodyFeatureInput): SplitBodyFeature | null
    /**
      Function that returns the specified split body feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): SplitBodyFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a split body feature.
  */
  abstract class SplitBodyFeatureInput extends core.Base {
    /**
      Gets and sets the input solid or open bodies to be split. This can be a
      single BRepBody or an ObjectCollection if multiple bodies are to be split.
    */
    splitBodies: core.Base
    /**
      Gets and sets the entity that defines the splitting tool. The splitting tool is a single
      entity that can be either a solid or open BRepBody, construction plane, profile, or a face.
    */
    splittingTool: core.Base
    /**
      Gets and sets whether or not the splitting tool is to be automatically extended (if possible) so as to
      completely intersect the bodyToSplit.
    */
    isSplittingToolExtended: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing split body feature in a design.
  */
  abstract class SplitBodyFeature extends Feature {
    /**
      Gets and sets the input solid or open bodies that are split.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    splitBodies: core.ObjectCollection
    /**
      Sets the splitting tool used for the feature.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param splittingTool Input entity that defines the splitting tool. The splitting tool is a single entity that can be either a solid body,
      open body, construction plane, face, or sketch curve that partially or fully intersects the body to split.
      @param isSplittingToolExtended A boolean value for setting whether or not the splittingTool is to be automatically extended (if possible) so as to
      completely intersect the facesToSplit.
      @returns Returns true if successful.
    */
    setSplittingTool(splittingTool: core.Base, isSplittingToolExtended: boolean): boolean
    /**
      Gets the entity that defines the splitting tool. The splitting tool is a single entity that can be either a
      solid body, open body, plane, sketch curve or face that partially or fully intersects the bodyToSplit.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    readonly splittingTool: core.Base
    /**
      Gets whether or not the splitting tool is to be automatically extended (if possible) so as to
      completely intersect the bodyToSplit.
    */
    readonly isSplittingToolExtended: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SplitBodyFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SplitBodyFeature | null
  }

  /**
    Collection that provides access to all of the existing Silhouette Split features in a component
    and supports the ability to create new Silhouette Split features.
  */
  abstract class SilhouetteSplitFeatures extends core.Base {
    /**
      Function that returns the specified silhouette split feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SilhouetteSplitFeature | null
    /**
      The number of Silhouette Split features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a SilhouetteSplitFeatureInput object. Use properties and methods on this object
      to define the silhouette split you want to create and then use the Add method, passing in
      the SilhouetteSplitFeatureInput object.
      @param viewDirection A construction axis, linear BRepEdge, planar BRepFace or a construction plane that defines the view direction
      where the silhouette is calculated.
      @param targetBody Input the single solid body to split
      @param operation The type of silhouette split operation to perform.
      @returns Returns the newly created SilhouetteSplitFeatureInput object or null if the creation failed.
    */
    createInput(viewDirection: core.Base, targetBody: BRepBody, operation: SilhouetteSplitOperations): SilhouetteSplitFeatureInput | null
    /**
      Creates a new silhouette split feature.
      @param input A SilhouetteSplitFeatureInput object that defines the desired silhouette split feature. Use the createInput
      method to create a new SilhouetteSplitFeatureInput object and then use methods on it
      (the SilhouetteSplitFeatureInput object) to define the silhouette split.
      @returns Returns the newly created SilhouetteSplitFeature object or null if the creation failed.
    */
    add(input: SilhouetteSplitFeatureInput): SilhouetteSplitFeature | null
    /**
      Function that returns the specified silhouette split feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): SilhouetteSplitFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a silhouette split feature.
  */
  abstract class SilhouetteSplitFeatureInput extends core.Base {
    /**
      Gets and sets the solid body to split.
    */
    targetBody: BRepBody
    /**
      Gets and sets the entity that defines the silhouette view direction, which can be a
      construction axis, linear BRepEdge, planar BRepFace or a construction plane.
    */
    viewDirection: core.Base
    /**
      Gets and sets the type of silhouette split operation to perform.
    */
    operation: SilhouetteSplitOperations
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing silhouette split feature in a design.
  */
  abstract class SilhouetteSplitFeature extends Feature {
    /**
      Gets and sets the entity that defines the silhouette view direction, which can be a
      construction axis, linear BRepEdge, planar BRepFace or a construction plane.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    viewDirection: core.Base
    /**
      Gets and sets the solid body to split.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    targetBody: BRepBody
    /**
      Gets the type of silhouette split operation.
    */
    readonly operation: SilhouetteSplitOperations
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SilhouetteSplitFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SilhouetteSplitFeature | null
  }

  /**
    List of Silhouette Split feature operations.
  */
  const enum SilhouetteSplitOperations {
    /**
      Split only the faces of a solid
    */
    SilhouetteSplitFacesOnlyOperation,
    /**
      Split a shelled body
    */
    SilhouetteSplitShelledBodyOperation,
    /**
      Split a solid body
    */
    SilhouetteSplitSolidBodyOperation,
  }

  /**
    Collection that provides access to all of the existing box features in a design.
  */
  abstract class BoxFeatures extends core.Base {
    /**
      Function that returns the specified box feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BoxFeature | null
    /**
      Function that returns the specified box feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): BoxFeature | null
    /**
      The number of box features in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that represents an existing box feature in a design.
  */
  abstract class BoxFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing cylinder features in a design.
  */
  abstract class CylinderFeatures extends core.Base {
    /**
      Function that returns the specified cylinder feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CylinderFeature | null
    /**
      Function that returns the specified cylinder feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): CylinderFeature | null
    /**
      The number of cylinder features in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that represents an existing cylinder feature in a design.
  */
  abstract class CylinderFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing torus features in a design.
  */
  abstract class TorusFeatures extends core.Base {
    /**
      Function that returns the specified torus feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): TorusFeature | null
    /**
      Function that returns the specified torus feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): TorusFeature | null
    /**
      The number of torus features in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that represents an existing torus feature in a design.
  */
  abstract class TorusFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing torus features in a design.
  */
  abstract class SphereFeatures extends core.Base {
    /**
      Function that returns the specified sphere feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SphereFeature | null
    /**
      Function that returns the specified sphere feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): SphereFeature | null
    /**
      The number of sphere features in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that represents an existing sphere feature in a design.
  */
  abstract class SphereFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing Pipe features in a design.
  */
  abstract class PipeFeatures extends core.Base {
    /**
      Function that returns the specified Pipe feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): PipeFeature | null
    /**
      Function that returns the specified Pipe feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): PipeFeature | null
    /**
      The number of Pipe features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a PipeFeatureInput object for defining a simple Pipe feature with only a path.
      Use properties and methods on this object to define the Pipe you want to create and then use the Add method,
      passing in the PipeFeatureInput object.
      @param path The path to create the Pipe.
      @param operation The feature operation to perform.
      @returns Returns the newly created PipeFeatureInput object or null if the creation failed.
    */
    createInput(path: Path, operation: FeatureOperations): PipeFeatureInput | null
    /**
      Creates a new Pipe feature.
      @param input A PipeFeatureInput object that defines the desired Pipe. Use the createInput
      method to create a new PipeFeatureInput object and then use methods on it
      (the PipeFeatureInput object) to define the Pipe.
      @returns Returns the newly created PipeFeature object or null if the creation failed.
    */
    add(input: PipeFeatureInput): PipeFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a Pipe
    feature.
  */
  abstract class PipeFeatureInput extends core.Base {
    /**
      Gets and sets the type of operation performed by the Pipe.
    */
    operation: FeatureOperations
    /**
      Gets and sets the path to create the Pipe.
    */
    path: Path
    /**
      Gets and sets the section type of the Pipe.
      The type can be: Circular, Square, Triangular.
    */
    sectionType: PipeSectionTypes
    /**
      Gets and sets the section size of the Pipe.
    */
    sectionSize: core.ValueInput
    /**
      Specifies if the Pipe is hollow or not.
      Setting this to true will default the sectionThickness to 0.1 cm.
    */
    isHollow: boolean
    /**
      Gets and sets the section thickness of the Pipe.
      Setting this will also set the isHollow setting to true.
    */
    sectionThickness: core.ValueInput
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the Pipe is created based on geometry (e.g. a path)
      in another component AND (the Pipe) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets the distance for the pipe created while following the path given as input, in the same order.
      This value defaults to 1.0 if not set.
      If the path is open, setting this to a value between 0.0 and 1.0 decides the length of the created Pipe.
      If the path is closed, setting this value should not be higher than 1.0 - distanceTwo.
      Ex: Path is made of curves A-B-C-A. The distanceOne returns and sets the length of the pipe going from A-B-C-A.
      This property returns null in the case where the feature is non-parametric.
    */
    distanceOne: core.ValueInput
    /**
      Gets and sets the distance for the pipe created while following the reversed path given as input.
      Before setting this value, distanceOne must be set.
      If the path is open, getting this value returns null, and setting the value is ignored.
      If the path is closed, setting this value should not be higher than 1.0 - distanceOne.
      Ex: Path is made of curves A-B-C-A. The distanceTwo returns and sets the length of the pipe going from A-C-B-A.
      This property returns null in the case where the feature is non-parametric.
    */
    distanceTwo: core.ValueInput
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      If this property has not been set, the default behavior is that all bodies that are intersected by the
      feature will participate.
      This property can return null in the case where the feature has not been fully defined so that
      possible intersecting bodies can be computed.
    */
    participantBodies: BRepBody[]
  }

  /**
    Object that represents an existing pipe feature in a design.
  */
  abstract class PipeFeature extends Feature {
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: PipeFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): PipeFeature | null
    /**
      Gets and sets the type of operation performed by the Pipe.
    */
    operation: FeatureOperations
    /**
      Gets and sets the path to create the Pipe.
      This property returns null in the case where the feature is non-parametric.
      The path can be either closed (you can reach again the starting point by following the curves) or open (the starting point and end point are different in the path).
      The starting point of the Pipe will be the starting point of the first curve in the Path, regardless of it being open or closed.
      When the desired Pipe has a section that includes the starting point and the path is closed, the curves should be shifted in a circular pattern.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    path: Path
    /**
      Gets the distance for the pipe created while following the path given as input, in the same order.
      If the path is open, this value returns the length of Pipe relative to the length of the path.
      If the path is closed, this value returns the length of the Pipe from the start point going along the curves.
      Ex: Path is made of curves A-B-C-A. The distanceOne returns the length of the pipe going from A-B-C-A.
      This property returns null in the case where the feature is non-parametric.
    */
    readonly distanceOne: ModelParameter
    /**
      Gets the distance for the pipe created while following the reversed path given as input.
      If the path is open, getting this value returns null, and setting the value is ignored.
      If the path is closed, this value returns the length of the Pipe from the start point going in the reverse order of the path.
      Ex: Path is made of curves A-B-C-A. The distanceTwo returns the length of the pipe going from A-C-B-A.
      This property returns null in the case where the feature is non-parametric.
    */
    readonly distanceTwo: ModelParameter
    /**
      Gets and sets the section type of the Pipe.
      The type can be: Circular, Square, Triangular.
    */
    sectionType: PipeSectionTypes
    /**
      Gets and sets the section size of the Pipe.
    */
    readonly sectionSize: ModelParameter
    /**
      Specifies if the Pipe is hollow or not.
      Setting this to true will default the sectionThickness to 0.1 cm.
    */
    isHollow: boolean
    /**
      Gets the section thickness of the Pipe.
      If the pipe is not hollow, this will return null.
    */
    readonly sectionThickness: ModelParameter
    /**
      Defines the section thickness of the Pipe.
      In case the pipe is not already hollow, this also sets the isHollow to true.
    */
    setThickness(value: core.ValueInput): boolean
    /**
      Property that returns the set of faces that cap one end of the Pipe that are coincident with the sketch plane.
      In the cases where there aren't any start faces this property will return null.
    */
    readonly startFaces: BRepFaces
    /**
      Property that returns the set of faces that cap one end of the Pipe that are coincident with the sketch plane.
      The end faces are those not coincident to the sketch plane of the feature's profile.
      In the case of a symmetric Pipe these faces are the ones on the negative normal side of the sketch plane.
      In the cases where there aren't any end faces this property will return null.
    */
    readonly endFaces: BRepFaces
    /**
      Property that returns an object that provides access to all of the faces created around the perimeter of the feature.
    */
    readonly sideFaces: BRepFaces
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    participantBodies: BRepBody[]
  }

  /**
    List of the different section types of a Pipe.
  */
  const enum PipeSectionTypes {
    /**
      Pipe section has a circular shape.
    */
    CircularPipeSectionType,
    /**
      Pipe section has a square shape.
    */
    SquarePipeSectionType,
    /**
      Pipe section has a triangular shape.
    */
    TriangularPipeSectionType,
  }

  /**
    Collection that provides access to all of the existing rib features in a design.
  */
  abstract class RibFeatures extends core.Base {
    /**
      Function that returns the specified Rib feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): RibFeature | null
    /**
      Function that returns the specified Rib feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): RibFeature | null
    /**
      The number of Rib features in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that represents an existing Rib feature in a design.
  */
  abstract class RibFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing web features in a design.
  */
  abstract class WebFeatures extends core.Base {
    /**
      Function that returns the specified web feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): WebFeature | null
    /**
      Function that returns the specified web feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): WebFeature | null
    /**
      The number of web features in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that represents an existing web feature in a design.
  */
  abstract class WebFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing coil features in a design
    and supports the ability to create new coil features.
  */
  abstract class CoilFeatures extends core.Base {
    /**
      Function that returns the specified coil feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CoilFeature | null
    /**
      Function that returns the specified coil feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): CoilFeature | null
    /**
      The number of coil features in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    List of the coil types.
  */
  const enum CoilFeatureTypes {
    /**
      Coil is defined by specifying revolutions, height and angle.
    */
    RevolutionsAndHeightCoilFeatureType,
    /**
      Coil is defined by specifying revolutions, pitch and angle.
    */
    RevolutionsAndPitchCoilFeatureType,
    /**
      Coil is defined by specifying height, pitch and angle.
    */
    HeightAndPitchCoilFeatureType,
    /**
      Coil is defined by specifying revolutions and pitch.
    */
    SpiralCoilFeatureType,
  }

  /**
    List of the section types of coil primitive feature.
  */
  const enum CoilFeatureSectionTypes {
    /**
      The coil section is circular.
    */
    CircularCoilFeatureSectionType,
    /**
      The coil section is square.
    */
    SquareCoilFeatureSectionType,
    /**
      The coil section is triangular (external).
    */
    TriangularExternalCoilFeatureSectionType,
    /**
      The coil section is triangular (internal).
    */
    TriangularInternalCoilFeatureSectionType,
  }

  /**
    List of the section positions of coil feature.
  */
  const enum CoilFeatureSectionPositions {
    /**
      The coil section is inside of the profile.
    */
    InsideCoilFeatureSectionPosition,
    /**
      The coil section center is on the profile.
    */
    OnCenterCoilFeatureSectionPosition,
    /**
      The coil section is outside of the profile.
    */
    OutsideCoilFeatureSectionPosition,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a coil feature.
  */
  abstract class CoilFeatureInput extends core.Base {
    /**
      Sets the coil type to RevolutionsAndHeightCoilType.
      @param revolutions A ValueInput object that defines the number of revolutions.
      @param height A ValueInput object that defines the height.
      @param angle A ValueInput object that defines angle.
      @returns Returns true if successful.
    */
    setToRevolutionAndHeight(revolutions: core.ValueInput, height: core.ValueInput, angle: core.ValueInput): boolean
    /**
      Sets the coil type to RevolutionsAndPitchCoilType.
      @param revolutions A ValueInput object that defines the number of revolutions.
      @param pitch A ValueInput object that defines the pitch.
      @param angle A ValueInput object that defines angle.
      @returns Returns true if successful.
    */
    setToRevolutionsAndPitch(revolutions: core.ValueInput, pitch: core.ValueInput, angle: core.ValueInput): boolean
    /**
      Sets the coil type to HeightAndPitchCoilType.
      @param height A ValueInput object that defines the height.
      @param pitch A ValueInput object that defines the pitch.
      @param angle A ValueInput object that defines angle.
      @returns Returns true if successful.
    */
    setToHeightAndPitchCoil(height: core.ValueInput, pitch: core.ValueInput, angle: core.ValueInput): boolean
    /**
      Sets the coil type to SpiralCoilType.
      @param revolutions A ValueInput object that defines the number of revolutions.
      @param pitch A ValueInput object that defines the pitch.
      @returns Returns true if successful.
    */
    setToSpiral(revolutions: core.ValueInput, pitch: core.ValueInput): boolean
    /**
      Specifies if the coil should be created as a solid or surface. This is
      initialized to true so a solid will be created if it's not changed.
      It only can be set to false in non-parametric modeling.
    */
    isSolid: boolean
    /**
      Gets the revolutions number. Returns null in the case where the coilType property returns HeightAndPitchCoilType.
    */
    readonly revolutions: core.ValueInput
    /**
      Gets the height. Returns null in the case where the coilType property returns RevolutionsAndPitchCoilType.
    */
    readonly height: core.ValueInput
    /**
      Gets the pitch. Returns null in the case where the coilType property returns RevolutionsAndHeightCoilType or SpiralCoilType.
    */
    readonly pitch: core.ValueInput
    /**
      Gets the angle. Returns null in the case where the coilType property returns SpiralCoilType.
    */
    readonly angle: core.ValueInput
    /**
      Gets the type of the coil.
    */
    readonly coilType: CoilFeatureTypes
    /**
      Gets and sets the type of operation performed by the coil.
    */
    operation: FeatureOperations
    /**
      Gets and sets the base plane.
    */
    basePlane: core.Base
    /**
      Gets and sets whether the rotation is clockwise or counter-clockwise. A value of true indicates clockwise rotation.
      It defaults to true.
    */
    isClockwiseRotation: boolean
    /**
      Gets and sets the diameter.
    */
    diameter: core.ValueInput
    /**
      Gets the section type of the coil.
      It defaults to CircularCoilSectionType.
    */
    coilSectionType: CoilFeatureSectionTypes
    /**
      Gets the section position of the coil.
      It defaults to InsideCoilSectionPosition.
    */
    coilSectionPosition: CoilFeatureSectionPositions
    /**
      Gets and sets the section size.
    */
    sectionSize: core.ValueInput
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing coil primitive feature in a design.
  */
  abstract class CoilFeature extends Feature {
  }

  /**
    The BaseFeature class represents a direct edit feature within a parametric design.
  */
  abstract class BaseFeatures extends core.Base {
    /**
      Function that returns the specified base feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BaseFeature | null
    /**
      Function that returns the specified base feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): BaseFeature | null
    /**
      The number of base features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new empty base feature in the parent component.
      @returns Returns the new BaseFeature or null in the case of an error.
    */
    add(): BaseFeature | null
  }

  /**
    The BaseFeature class represents a direct edit feature within a parametric design.
  */
  abstract class BaseFeature extends Feature {
    /**
      Returns an array of the construction planes associated with this base feature.
    */
    readonly constructionPlanes: ConstructionPlane[]
    /**
      Returns an array of the construction axes associated with this base feature.
    */
    readonly constructionAxes: ConstructionAxis[]
    /**
      Returns an array of the construction points associated with this base feature.
    */
    readonly constructionPoints: ConstructionPoint[]
    /**
      Returns an array of the sketches associated with this base feature.
    */
    readonly sketches: Sketch[]
    /**
      Returns an array of the mesh bodies associated with this base feature.
    */
    readonly meshBodies: MeshBody[]
    /**
      Set the user-interface so that the base body is in edit mode.
      @returns Returns true if successful.
    */
    startEdit(): boolean
    /**
      Exits from edit mode in the user-interface. If this base feature in not
      in edit mode, then nothing happens.
      @returns Returns true if successful.
    */
    finishEdit(): boolean
    /**
      Update an existing source BRepBody created by this BaseFeature.
      The input BRepBody definition will be copied into the existing BRepBody.
      @param sourceBody The source BRepBody to update. The source bodies of a BaseFeature are only available
      from the bodies collection of the BaseFeature when the BaseFeature is in edit mode.
      @param newBody The BRepBody whose definition will be used to replace the existing source body's definition.
      @returns Returns true if the body was updated, or false if the update failed.
    */
    updateBody(sourceBody: BRepBody, newBody: BRepBody): boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BaseFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BaseFeature | null
    /**
      Returns the B-Rep bodies owned by the base feature.
      When a body is added to a base feature, that body is owned by the base feature
      and is only seen in the UI when the base feature is active. This body is referred
      to as a "source body". Fusion creates a parametric copy of the body when you
      exit the base feature. This copy is referred to as the "result body," and it
      is used for subsequent modeling operations. The result bodies can be obtained by
      using the bodies property of the BaseFeature object.
      You can map between the source and result bodies by using their position
      within the bodies returned. To get a valid list of result bodies, you should
      roll the timeline to immediately after the base feature node in the timeline.
      Otherwise, subsequent operations could have done something to cause one or
      more bodies to no longer be available.
    */
    readonly sourceBodies: BRepBody[]
  }

  /**
    Collection that provides access to all of the existing Patch features in a component
    and supports the ability to create new Patch features.
  */
  abstract class PatchFeatures extends core.Base {
    /**
      Function that returns the specified patch feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): PatchFeature | null
    /**
      Function that returns the specified patch feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): PatchFeature | null
    /**
      The number of Patch features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a PatchFeatureInput object. Use properties and methods on the returned PatchFeatureInput
      object to set other settings. The PatchFeatureInput object is used as input to the add method
      to create the patch feature.
      @param boundaryCurve Defines the input geometry that will be used to define the boundary. This can be a sketch profile,
      a single sketch curve, a single B-Rep edge, an ObjectCollection, or a Path object.
      If a single sketch curve or B-Rep edge is an input that is not closed Fusion will automatically find connected sketch curves
      or B-Rep edges to define a closed loop.
      If an ObjectCollection is an input, it must be a set of curves that define a closed shape.
      If a Path is an input, it must define a closed shape.
      @param operation The feature operation to perform. Only 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are
      valid operations for patch features.
      @returns Returns the newly created PatchFeatureInput object or null if the creation fails.
    */
    createInput(boundaryCurve: core.Base, operation: FeatureOperations): PatchFeatureInput | null
    /**
      Creates a new patch feature.
      @param input A PatchFeatureInput object that defines the desired patch feature. Use the createInput
      method to create a new PatchFeatureInput object and then use methods on it
      (the PatchFeatureInput object) to define the patch feature.
      @returns Returns the newly created PatchFeature object or null if the creation failed.
    */
    add(input: PatchFeatureInput): PatchFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a patch feature.
  */
  abstract class PatchFeatureInput extends core.Base {
    /**
      Gets and sets the input geometry that will be used to define the boundary. This can be a sketch profile,
      a single sketch curve, a single B-Rep edge, an ObjectCollection, or a Path object.
      If a single open sketch curve or B-Rep edge is input, Fusion will automatically find connected sketch curves
      or B-Rep edges to define a closed loop.
      If an ObjectCollection is used as input, it must be a set of curves that define a closed shape.
      If a Path is used as input, it must define a closed shape.
    */
    boundaryCurve: core.Base
    /**
      Gets and sets the type of operation performed by the patch feature. Only 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are
      valid operations for patch features.
    */
    operation: FeatureOperations
    /**
      Gets and sets the type of surface continuity to use when matching boundary edges to face edges. When a new PatchFeatureInput is
      created, this is initialized to ConnectedSurfaceContinuityType. This value is ignored when creating a patch for sketch curves.
      @remarks
      This property has been retired and replaced by either the groupContinuity property or setContinuity method, depending on
      if the isGroupEdges property is true or not.
      @deprecated
    */
    continuity: SurfaceContinuityTypes
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      For geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the Patch feature is created based on geometry (e.g., a profile, edges, faces)
      in another component AND (the Patch feature) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      Gets and sets any interior curves or points the patch should fit
      through. Valid entities include object collections of connected curves, paths, sketch curves,
      sketch points, B-Rep edges, and construction points.
      When getting this property, the returned ObjectCollection can contain individual edges, sketch curves,
      sketch points, construction points, vertices, and ObjectCollection objects that represent a group
      of the curves and points listed above.
      Can be set to null to remove any interior rails and points from the patch.
    */
    interiorRailsAndPoints: core.ObjectCollection
    /**
      Gets and sets if the edges in the boundary curve are treated as a group,
      and they all use the same continuity. If this property is True (which is the default),
      the continuity property controls the continuity for all edges. If
      this property is false the continuity is set for each edge using the
      setContinuity method.
      When this property is set to true, the continuity and weight of the first edge
      will be used for all edges. When set to false, each edge will initially have
      the same continuity and weight. This is typically set to false as a side-effect
      of calling the setContinuity method.
    */
    isGroupEdges: boolean
    /**
      Gets and sets the type of surface continuity to use for all edges when the isGroupEdges property is true. The continuity
      is used to determine how the patch connects to any B-Rep edges in the boundary. It is ignored for any sketch curves in the
      boundary. The property defaults to ConnectedSurfaceContinuityType. The value of this property is ignored if the isGroupEdges property is false.
    */
    groupContinuity: SurfaceContinuityTypes
    /**
      Gets and sets the weight to use for all edges when the isGroupEdges property is true. It is ignored for any sketch curves
      in the boundary. The property defaults to 0.5. The value of this property is ignored if the isGroupEdges property is false.
    */
    groupWeight: number
    /**
      Gets and sets the continuity direction for all edges when the isGroupEdges property is true. It is ignored for any sketch curves
      in the boundary. The property defaults to false. The value of this property is ignored if the isGroupEdges property is false.
    */
    groupIsContinuityDirectionFlipped: boolean
    /**
      Sets the continuity to use for each edge in the boundary. The arrays for the arguments correspond
      to B-Rep edges in the boundary. You can use the getContinuity method to get the list of edges to
      know their order. This order applies to the arrays provided for the arguments.
      @param continuity An array whose size of the number of B-Rep edges in the boundary. You can use the getContinuity
      method to get the list of edges, so you know the number and order of the edges. The continuity array defines the
      type of continuity to apply to the edge at the same index. The values are obtained from the SurfaceContinuityTypes
      enum and passed in as an integer.
      @param weight An array whose size is the number of B-Rep edges in the boundary. You can use the getContinuity
      method to get the list of edges, so you know the number and order of the edges. The weight array defines the
      weight to apply to the edge at the same index. If the continuity of an edge is ConnectedSurfaceContinuityType,
      the weight value is ignored.
      @param isContinuityDirectionFlipped An array whose size is the number of B-Rep edges in the boundary. You can use the getContinuity
      method to get the list of edges, so you know the number and order of the edges. The isContinuityDirectionFlipped
      array defines which of the two faces the edge connects to and is used in computing the continuity direction. If the
      continuity is ConnectedSurfaceContinuityType, or the edge is an open edge and only connected to a single face,
      the value is ignored.
      If false, the face associated with the first co-edge returned by the edge is used.
      @returns Returns true if successful.
    */
    setContinuity(continuity: number[] /*int[]*/, weight: number[], isContinuityDirectionFlipped: boolean[]): boolean
    /**
      Gets the continuity used for each edge in the boundary.
      @param edges Output array containing all of the BRepEdge objects in the boundary.
      @param continuity Output array the same size as the edges array that defines the continuity
      to apply to the edge in the same index in the edges array. The values are obtained
      from the SurfaceContinuityTypes enum and passed in as an integers.
      @param weight Output array the same size as the edges array that defines the weight applied
      to the edge in the same index in the edges array. If the continuity
      of an edge is ConnectedSurfaceContinuityType, the weight value should be ignored.
      @param isContinuityDirectionFlipped Output array the same size as the edges array that defines which of the two faces the
      edge connects to is used in computing the continuity direction. If the continuity is
      ConnectedSurfaceContinuityType or the edge is an open edge and only connected to a
      single face, the value should be ignored.
      If false, the face associated with the first co-edge returned by the edge is used.
      @returns Returns true if successful.
    */
    getContinuity(): [edges: BRepEdge[], continuity: number[] /*int[]*/, weight: number[], isContinuityDirectionFlipped: boolean[]]
  }

  /**
    An object that represents an existing patch feature in a design.
  */
  abstract class PatchFeature extends Feature {
    /**
      Returns an ObjectCollection that contains all of the sketch curves or B-Rep edges
      that defines the closed outer boundary of the patch feature.
      When setting this property, the input can be a sketch profile, a single sketch curve, a single B-Rep edge,
      or an ObjectCollection of sketch curves and B-Rep edges.
      If a single open sketch curve or B-Rep edge is input, Fusion will automatically find connected sketch curves
      or B-Rep edges to define a closed loop.
      If an ObjectCollection of sketch curves or B-Rep edges is input, they must define a closed shape.
      To get or set this property, you need to position the timeline marker immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    boundaryCurve: core.Base
    /**
      Gets the type of operation performed by the patch feature.
    */
    readonly operation: FeatureOperations
    /**
      Gets and sets the type of surface continuity used when creating the patch face. This value is only used when BRepEdges are input and
      defines the continuity of how the patch face connects to the face adjacent to each of the input edges.
      To set this property, you need to position the timeline marker immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @remarks
      This property has been retired and replaced by either the groupContinuity property or setContinuity method, depending on
      if the isGroupEdges property is true or not.
      @deprecated
    */
    continuity: SurfaceContinuityTypes
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: PatchFeature
    /**
      Creates or returns a proxy for the native object
      - i.e., a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): PatchFeature | null
    /**
      Gets and sets any interior curves or points the patch should fit
      through. Valid entities include object collections of connected curves, paths, sketch curves,
      sketch points, B-Rep edges, and construction points.
      When getting this property, the returned ObjectCollection can contain individual edges, sketch curves,
      sketch points, construction points, vertices, and ObjectCollection objects that represent a group
      of the curves and points listed above.
      Can be set to null to remove any interior rails and points from the patch.
      To get or set this property, you need to position the timeline marker immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    interiorRailsAndPoints: core.ObjectCollection
    /**
      Gets and sets if the edges in the boundary curve are treated as a group
      , and they all use the same continuity. If this property is True (which is the default),
      the continuity for all edges is controlled by the continuity property. If
      this property is false the continuity is set for each edge using the
      setContinuity method.
      When this property is set to true, the continuity and weight of the first edge
      will be used for all edges. When set to false, each edge will initially have
      the same continuity and weight. This property is typically set to false by calling the
      setContinuity method, which has the side effect of changing this to false.
      To get or set this property, you need to position the timeline marker immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isGroupEdges: boolean
    /**
      Gets and sets the type of surface continuity to use for all edges when the isGroupEdges property is true.
      The continuity is used to determine how the patch connects to any B-Rep edges in the boundary. It is
      ignored for any sketch curves in the boundary. The property defaults to ConnectedSurfaceContinuityType.
      The value of this property is ignored if the isGroupEdges property is false.
      To get or set this property, you need to position the timeline marker immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    groupContinuity: SurfaceContinuityTypes
    /**
      Gets and sets the weight to use for all edges when the isGroupEdges property is true. It is ignored for any sketch curves
      in the boundary. The property defaults to 0.5. The value of this property is ignored if the isGroupEdges property is false.
      To get or set this property, you need to position the timeline marker immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    groupWeight: number
    /**
      Gets and sets the continuity direction for all edges when the isGroupEdges property is true. It is ignored for any sketch curves
      in the boundary. The property defaults to false. The value of this property is ignored if the isGroupEdges property is false.
      To get or set this property, you need to position the timeline marker immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    groupIsContinuityDirectionFlipped: boolean
    /**
      Sets the continuity to use for each edge in the boundary. The arrays for the arguments correspond
      to B-Rep edges in the boundary. You can use the getContinuity method to get the list of edges to
      know their order. This order applies to the arrays provided for the arguments.
      @param continuity An array whose size of the number of B-Rep edges in the boundary. You can use the getContinuity
      method to get the list of edges, so you know the number and order of the edges. The continuity array defines the
      type of continuity to apply to the edge at the same index. The values are obtained from the SurfaceContinuityTypes
      enum and passed in as an integer.
      @param weight An array whose size is the number of B-Rep edges in the boundary. You can use the getContinuity
      method to get the list of edges, so you know the number and order of the edges. The weight array defines the
      weight to apply to the edge at the same index. If the continuity of an edge is ConnectedSurfaceContinuityType,
      the weight value is ignored.
      @param isContinuityDirectionFlipped An array whose size is the number of B-Rep edges in the boundary. You can use the getContinuity
      method to get the list of edges, so you know the number and order of the edges. The isContinuityDirectionFlipped
      array defines which of the two faces the edge connects to and is used in computing the continuity direction. If the
      continuity is ConnectedSurfaceContinuityType, or the edge is an open edge and only connected to a single face,
      the value is ignored.
      If false, the face associated with the first co-edge returned by the edge is used.
      @returns Returns true if successful.
    */
    setContinuity(continuity: number[] /*int[]*/, weight: number[], isContinuityDirectionFlipped: boolean[]): boolean
    /**
      Gets the continuity used for each edge in the boundary.
      To call this method, you need to position the timeline marker immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param edges Output array containing all of the BRepEdge objects in the boundary.
      @param continuity Output array the same size as the edges array that defines the continuity
      to apply to the edge in the same index in the edges array. The values are obtained
      from the SurfaceContinuityTypes enum and passed in as an integers.
      @param weight Output array the same size as the edges array that defines the weight applied
      to the edge in the same index in the edges array. If the continuity
      of an edge is ConnectedSurfaceContinuityType, the weight value should be ignored.
      @param isContinuityDirectionFlipped Output array the same size as the edges array that defines which of the two faces the
      edge connects to is used in computing the continuity direction. If the continuity is
      ConnectedSurfaceContinuityType or the edge is an open edge and only connected to a
      single face, the value should be ignored.
      If false, the face associated with the first co-edge returned by the edge is used.
      @returns Returns true if successful.
    */
    getContinuity(): [edges: BRepEdge[], continuity: number[] /*int[]*/, weight: number[], isContinuityDirectionFlipped: boolean[]]
  }

  /**
    List of Surface Continuity Types.
  */
  const enum SurfaceContinuityTypes {
    /**
      Creates a surface with G0 edges (connected at an angle).
    */
    ConnectedSurfaceContinuityType,
    /**
      Creates a surface with G1 edges (tangential).
    */
    TangentSurfaceContinuityType,
    /**
      Creates a surface with G2 edges (blended with continuous curvature).
    */
    CurvatureSurfaceContinuityType,
  }

  /**
    Collection that provides access to all of the existing Offset features in a component
    and supports the ability to create new Offset features.
  */
  abstract class OffsetFeatures extends core.Base {
    /**
      Function that returns the specified offset feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): OffsetFeature | null
    /**
      The number of Offset features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates an OffsetFeatureInput object. Use properties and methods on this object
      to define the offset feature you want to create and then use the Add method, passing in
      the OffsetFeatureInput object to create the feature.
      @param entities An ObjectCollection containing the BRepFace objects to offset. Additional faces may be
      automatically used depending on the value of the isChainSelection argument.
      Input faces need not be from the same body.
      @param distance ValueInput object that defines the offset distance. A positive value is in the positive
      normal direction of the face being offset.
      @param operation The feature operation to perform. 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are the
      options supported.
      @param isChainSelection A boolean value for setting whether or not faces that are tangentially connected to
      the input faces (if any) will be included in the offset. The default value is true.
      @returns Returns the newly created OffsetFeatureInput object or null if the creation failed.
    */
    createInput(entities: core.ObjectCollection, distance: core.ValueInput, operation: FeatureOperations, isChainSelection?: boolean/* = true*/): OffsetFeatureInput | null
    /**
      Creates a new offset feature.
      @param input A FeatureInput object that defines the desired offset feature. Use the createInput
      method to create a new OffsetFeatureInput object and then use methods on it
      (the OffsetFeatureInput object) to define the offset feature.
      @returns Returns the newly created OffsetFeature object or null if the creation failed.
    */
    add(input: OffsetFeatureInput): OffsetFeature | null
    /**
      Function that returns the specified offset feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): OffsetFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of an offset feature.
  */
  abstract class OffsetFeatureInput extends core.Base {
    /**
      An ObjectCollection containing the BRepFace objects being offset.
    */
    entities: core.ObjectCollection
    /**
      Get and sets whether faces that are tangentially connected to the input faces will be included in the offset.
    */
    isChainSelection: boolean
    /**
      Gets and sets the ValueInput object that defines the offset distance. A positive distance value results
      in an offset in the positive normal direction of the faces.
    */
    distance: core.ValueInput
    /**
      Gets and sets the feature operation to perform. Can be 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'.
    */
    operation: FeatureOperations
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing offset feature in a design.
  */
  abstract class OffsetFeature extends Feature {
    /**
      Sets the faces and sheet bodies to offset.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param entities An ObjectCollection containing the BRepFace objects to offset. Additional faces may be
      automatically used depending on the value of the isChainSelection argument.
      Input faces need not be from the same body.
      @param isChainSelection A boolean value for setting whether or not faces that are tangentially connected to
      the input faces (if any) will also be offset. The default value is true.
      @returns Returns true if successful
    */
    setInputEntities(entities: core.ObjectCollection, isChainSelection?: boolean/* = true*/): boolean
    /**
      Gets and sets the faces to be offset.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    entities: core.ObjectCollection
    /**
      Get if the faces that are tangentially connected to the input faces (if any) are also offset.
    */
    readonly isChainSelection: boolean
    /**
      Returns the parameter controlling the offset distance. You can edit the distance
      by editing the value of the parameter object. A positive value specifies that the offset
      is in the same direction as the normal direction of the face.
    */
    readonly distance: ModelParameter
    /**
      Gets the feature operation that was performed when the feature was created,
      (either 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'.
    */
    readonly operation: FeatureOperations
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: OffsetFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): OffsetFeature | null
  }

  /**
    Collection that provides access to all of the existing Offset Faces features in a design.
    Offset Face features are created in the UI using the "Press Pull" command.
  */
  abstract class OffsetFacesFeatures extends core.Base {
    /**
      Function that returns the specified Offset Face feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): OffsetFacesFeature | null
    /**
      Function that returns the specified Offset Face feature using the name of the feature.
      Offset Face features are created in the UI using the "Press Pull" command.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): OffsetFacesFeature | null
    /**
      The number of Offset Face features in the collection.
      Offset Face features are created in the UI using the "Press Pull" command.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that represents an existing Offset Faces feature in a design.
    Offset Face features are created in the UI using the "Press Pull" command.
  */
  abstract class OffsetFacesFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing Extend features in a component
    and supports the ability to create new Extend features.
  */
  abstract class ExtendFeatures extends core.Base {
    /**
      Function that returns the specified extend feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ExtendFeature | null
    /**
      The number of Extend features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates an ExtendFeatureInput object. Use properties and methods on this object
      to define the extend feature you want to create and then use the Add method, passing in
      the ExtendFeatureInput object.
      @param edges The surface edges to extend.
      Only the outer edges from an open body can be extended. The edges must all be from the same body.
      Depending on the extend type there can also be some limitations on the edges being input as described below
      for the extendType argument.
      @param distance ValueInput object that defines the distance to extend the face/s.
      Natural and Tangent Extend types require a positive distance value.
      Perpendicular Extend Type supports either a positive or negative value to
      control the direction of the extend. A positive number results in the
      perpendicular extension being in the same direction as the positive normal
      of the connected faces.
      @param extendType The extension type to use when extending the face(s).
      Input edges must be connected at endpoints when Tangent or Perpendicular Extend Types are used.
      Input edges need not be connected when Natural Extend type is used.
      @param isChainingEnabled An optional boolean argument whose default is true. If this argument is true, all edges that are
      tangent or curvature continuous, and end point connected, will be found automatically and include
      in the set of edges to extend.
      @returns Returns the newly created ExtendFeatureInput object or null if the creation failed.
    */
    createInput(edges: core.ObjectCollection, distance: core.ValueInput, extendType: SurfaceExtendTypes, isChainingEnabled?: boolean/* = true*/): ExtendFeatureInput | null
    /**
      Creates a new extend feature.
      @param input An ExtendFeatureInput object that defines the desired extend feature. Use the createInput
      method to create a new ExtendFeatureInput object and then use methods on it
      (the ExtendFeatureInput object) to define the desired options for the extent feature.
      @returns Returns the newly created ExtendFeature object or null if the creation failed.
    */
    add(input: ExtendFeatureInput): ExtendFeature | null
    /**
      Function that returns the specified extend feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): ExtendFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of an extend feature.
  */
  abstract class ExtendFeatureInput extends core.Base {
    /**
      Gets and sets the edges to extend
    */
    edges: core.ObjectCollection
    /**
      Gets and sets the ValueInput object that defines the extend distance
    */
    distance: core.ValueInput
    /**
      Gets and sets surface extend type to use
    */
    extendType: SurfaceExtendTypes
    /**
      Gets and sets if all edges that are tangent or curvature continuous, and end point connected, will be found
      automatically and extended.
    */
    isChainingEnabled: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets surface extend alignment to use.
    */
    extendAlignment: SurfaceExtendAlignment
  }

  /**
    Object that represents an existing extend feature in a design.
  */
  abstract class ExtendFeature extends Feature {
    /**
      Sets the edges for the extend feature.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param edges The surface edges to extend.
      Only the surface edges from an open body can be extended.
      The edges must all be from the same open body.
      @param isChainingEnabled An optional boolean argument whose default is true. If this argument is set to true, all edges that are
      tangent or curvature continuous, and end point connected, will be found automatically and extended.
      @returns Returns true if successful
    */
    setInputEntities(edges: core.ObjectCollection, isChainingEnabled?: boolean/* = true*/): boolean
    /**
      Gets the edges that were extended. In many cases the extend operation results in
      the edges being consumed so they're no longer available after the feature is created.
      in this case you need to reposition the timeline marker to just before this feature
      when the edges do exist.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    readonly edges: core.ObjectCollection
    /**
      Returns the parameter controlling the extend distance. You can edit the distance
      by editing the value of the parameter object.
    */
    readonly distance: ModelParameter
    /**
      Gets and sets surface extend type to use.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    extendType: SurfaceExtendTypes
    /**
      Gets if all edges that are tangent or curvature continuous, and end point connected, will be found
      automatically and extended.
    */
    readonly isChainingEnabled: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ExtendFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ExtendFeature | null
    /**
      Gets and sets surface extend alignment to use.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    extendAlignment: SurfaceExtendAlignment
  }

  /**
    List of Surface Extend Types.
  */
  const enum SurfaceExtendTypes {
    /**
      Extends the current faces.
    */
    NaturalSurfaceExtendType,
    /**
      Creates new faces tangent to the current faces.
    */
    TangentSurfaceExtendType,
    /**
      Creates new faces perpendicular to the current faces.
    */
    PerpendicularSurfaceExtendType,
  }

  /**
    List of Surface Extend Alignments
  */
  const enum SurfaceExtendAlignment {
    /**
      The extended edges are not aligned with the existing surface edges.
    */
    FreeEdges,
    /**
      The extended edges are aligned with the natural direction of the existing surface edges.
    */
    AlignEdges,
  }

  /**
    Collection that provides access to all of the existing Stitch features in a component
    and supports the ability to create new Stitch features.
  */
  abstract class StitchFeatures extends core.Base {
    /**
      Function that returns the specified stitch feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): StitchFeature | null
    /**
      The number of Stitch features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a StitchFeatureInput object. Use properties and methods on this object
      to define the stitch feature you want to create and then use the Add method, passing in
      the StitchFeatureInput object.
      @param stitchSurfaces The surfaces (open BRepBodies) to stitch together.
      Stitching surfaces can form multiple closed volumes resulting in multiple solids.
      Stitch Surfaces can form multiple BRepShells (entirely connected set of entities) that would result in a
      single non-solid BRepBody.
      @param tolerance ValueInput object that defines the stitching tolerance. It must define a distance value.
      @param operation Specifies the operation type for the result when the final result is a closed solid. Otherwise
      this argument is ignored.
      @returns Returns the newly created StitchFeatureInput object or null if the creation failed.
    */
    createInput(stitchSurfaces: core.ObjectCollection, tolerance: core.ValueInput, operation?: FeatureOperations/* = FeatureOperations.NewBodyFeatureOperation*/): StitchFeatureInput | null
    /**
      Creates a new stitch feature.
      @param input A StitchFeatureInput object that defines the desired stitch feature. Use the createInput
      method to create a new StitchFeatureInput object and then use methods on it
      (the StitchFeatureInput object) to define the stitch feature.
      @returns Returns the newly created StitchFeature object or null if the creation failed.
    */
    add(input: StitchFeatureInput): StitchFeature | null
    /**
      Function that returns the specified stitch feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): StitchFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a stitch feature.
  */
  abstract class StitchFeatureInput extends core.Base {
    /**
      Gets and sets the surfaces to stitch together.
    */
    stitchSurfaces: core.ObjectCollection
    /**
      Gets and sets the ValueInput object that defines the stitching tolerance. It must define a length.
    */
    tolerance: core.ValueInput
    /**
      Gets and sets the feature operation to perform. This property value is only valid if the isSolid property returns
      true. Otherwise the value of this property is ignored.
    */
    operation: FeatureOperations
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing stitch feature in a design.
  */
  abstract class StitchFeature extends Feature {
    /**
      Gets and sets the surfaces to stitch together. In some cases the stitch operation results in
      faces being merged so the original faces are no longer available after the feature is created.
      in this case you need to reposition the timeline marker to just before this feature
      when the faces do exist.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    stitchSurfaces: core.ObjectCollection
    /**
      Returns the parameter controlling the tolerance. You can edit the tolerance
      by editing the value of the parameter object.
    */
    readonly tolerance: ModelParameter
    /**
      Gets and sets the feature operation to perform. This property value is ignored if the stitched result does not
      form a solid body.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    operation: FeatureOperations
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: StitchFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): StitchFeature | null
  }

  /**
    Collection that provides access to all of the existing boundary fill features in a component
    and supports the ability to create new boundary fill features.
  */
  abstract class BoundaryFillFeatures extends core.Base {
    /**
      Function that returns the specified boundary fill feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BoundaryFillFeature | null
    /**
      The number of boundary fill features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a BoundaryFillFeatureInput object. Use properties and methods on this object
      to define the boundary fill you want to create and then use the Add method, passing in
      the BoundaryFillFeatureInput object.
      To determine the possible boundaries and allow you to choose which cells to keep, the boundary
      fill feature does a partial compute when the input object is created. To do this it starts a boundary
      fill feature transaction and completes the transaction when you call the add method. If you don't
      call the add method to finish the transaction it leaves Fusion in a bad state and there will be undo
      problems and possibly a crash. If you have created a BoundFillFeatureInput object and don't want to finish
      the feature creation, you need to call the cancel method on the BoundaryFillFeatureInput object to
      safely abort the current boundary fill transaction.
      @param tools A collection of one or more construction planes and open or closed BRepBody objects that will be
      used in calculating the possible closed boundaries.
      @param operation The operation type to perform.
      @returns Returns the newly created BoundaryFillFeatureInput object or null if the creation failed.
    */
    createInput(tools: core.ObjectCollection, operation: FeatureOperations): BoundaryFillFeatureInput | null
    /**
      Creates a new boundary fill feature.
      @param input A BoundaryFillFeatureInput object that defines the desired boundary fill feature. Use the createInput
      method to create a new BoundaryFillFeatureInput object and then use methods on it
      (the BoundaryFillFeatureInput object) to define the boundary fill feature.
      @returns Returns the newly created BoundaryFillFeature object or null if the creation failed.
    */
    add(input: BoundaryFillFeatureInput): BoundaryFillFeature | null
    /**
      Function that returns the specified boundary fill feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): BoundaryFillFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a BoundaryFillFeatureInput.
  */
  abstract class BoundaryFillFeatureInput extends core.Base {
    /**
      Returns the collection of the valid cells that have been calculated based on the set of input tools.
      You use this collection to specify which cells you want included in the output.
    */
    readonly bRepCells: BRepCells
    /**
      Gets and sets the type of operation performed by the boundary fill feature.
    */
    operation: FeatureOperations
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the Boundary Fill is created based on geometry (e.g. a profile and/or face(s))
      in another component AND (the Boundary Fill) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      Gets and sets the collection of one or more construction planes and open or closed
      BRepBody objects that are used in calculating the possible closed boundaries.
    */
    tools: core.ObjectCollection
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      To determine the possible boundaries and allow you to choose which cells to keep, the boundary
      fill feature does a partial compute when the input object is created. To do this it starts a boundary
      fill feature transaction and completes the transaction when you call the add method. If you don't
      call the add method to finish the transaction it leaves Fusion in a bad state and there will be undo
      problems and possibly a crash. If you have created a BoundFillFeatureInput object and don't want to finish
      the feature creation, you need to call the cancel method on the BoundaryFillFeatureInput object to
      safely abort the current boundary fill transaction.
      @returns Returns true if successful.
    */
    cancel(): boolean
    /**
      Gets and sets whether any BRepBodys that were used as tools should be removed as part of the feature creation.
    */
    isRemoveTools: boolean
  }

  /**
    Object that represents an existing boundary fill feature in a design.
  */
  abstract class BoundaryFillFeature extends Feature {
    /**
      A collection of construction planes and open or closed BRepBody objects that define the
      set of boundaries that have been used in the calculation of available closed boundaries.
      Setting this property will clear all currently selected tools.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    tools: core.ObjectCollection
    /**
      Gets the set of closed boundaries that have been calculated based on the current set of
      tools. To get this collection the model must be in the state it was when the feature
      was initially computed, which means the timeline marker must be positioned to immediately
      before this feature.
      After changing any selected cells you must call the applyCellChanges method to update
      the feature with the changes.
    */
    readonly bRepCells: BRepCells
    /**
      Gets and sets the type of operation performed by the boundary fill feature.
    */
    operation: FeatureOperations
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BoundaryFillFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BoundaryFillFeature | null
    /**
      After making any changes to the set of selected cells you must call this method to
      indicate all changes have been made and to apply those changes to the feature.
      @returns Returns true if the apply was successful.
    */
    applyCellChanges(): boolean
    /**
      Gets and sets whether any BRepBodys that were used as tools should be removed as part of the feature creation.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isRemoveTools: boolean
  }

  /**
    Collection that provides access to all of the existing BRepCells defined by a BoundaryFillFeatureInput
  */
  abstract class BRepCells extends core.Base {
    /**
      Function that returns the specified BRepCell using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BRepCell | null
    /**
      The number of BRepCells in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that represents an existing BRepCell.
  */
  abstract class BRepCell extends core.Base {
    /**
      Gets and sets whether the cell is selected. For a Trim feature a selected cell is removed,
      whereas for a boundary fill feature, a selected cell is kept and used in the feature operation.
    */
    isSelected: boolean
    /**
      Returns the tools that we're using in the definition of this cell.
    */
    readonly sourceTools: core.ObjectCollection
    /**
      Returns a BRepBody that represents this cell. This is a transient B-Rep body.
    */
    readonly cellBody: BRepBody
  }

  /**
    Collection that provides access to all of the existing trim features in a component
    and supports the ability to create new trim features.
  */
  abstract class TrimFeatures extends core.Base {
    /**
      Function that returns the specified trim feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): TrimFeature | null
    /**
      The number of trim features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a TrimFeatureInput object. Use properties and methods on this object
      to define the trim feature you want to create and then use the Add method, passing in
      the TrimFeatureInput object.
      To determine the possible boundaries and allow you to choose which cells to keep, the trim
      feature does a partial compute when the input object is created. To do this it starts a trim
      feature transaction and completes the transaction when you call the add method. If you don't call
      the add method to finish the transaction it leaves Fusion in a bad state and there will be undo
      problems and possibly a crash. If you have created a TrimFeatureInput object and don't want to
      finish the feature creation, you need to call the cancel method on the TrimFeatureInput object to
      safely abort the current boundary fill transaction.
      @param trimTool A patch body, B-Rep face, construction plane or sketch curve that intersects the surface or surfaces to be trimmed
      @returns Returns the newly created TrimFeatureInput object or null if the creation failed.
    */
    createInput(trimTool: core.Base): TrimFeatureInput | null
    /**
      Creates a new trim feature.
      @param input A TrimFeatureInput object that defines the desired trim feature. Use the createInput
      method to create a new TrimFeatureInput object and then use methods on it
      (the TrimFeatureInput object) to define the trim feature.
      @returns Returns the newly created TrimFeature object or null if the creation failed.
    */
    add(input: TrimFeatureInput): TrimFeature | null
    /**
      Function that returns the specified trim feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): TrimFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a TrimFeatureInput.
  */
  abstract class TrimFeatureInput extends core.Base {
    /**
      Returns the collection of the valid cells that have been calculated based on the trim tool.
      Use this collection to specify which cells to trim away.
    */
    readonly bRepCells: BRepCells
    /**
      Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool
    */
    trimTool: core.Base
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      To determine the possible boundaries and allow you to choose which cells to keep, the trim
      feature does a partial compute when the input object is created. To do this it starts a trim
      feature transaction and completes the transaction when you call the add method. If you don't
      call the add method it leaves Fusion in a bad state and there will be undo problems and it
      will possibly crash. If you have created a TrimFeatureInput object and don't want to finish
      the feature creation, you need to call the cancel method on the TrimFeatureInput object to
      safely abort the current trim feature transaction.
    */
    cancel(): boolean
  }

  /**
    Object that represents an existing trim feature in a design.
  */
  abstract class TrimFeature extends Feature {
    /**
      Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    trimTool: core.Base
    /**
      Gets the set of valid cells that have been calculated based on the current inputs.
      To get this collection the model must be in the state it was when the feature
      was initially computed, which means the timeline marker must be positioned to immediately
      before this feature.
      After changing any selected cells you must call the applyCellChanges method to update
      the feature with the changes.
    */
    readonly bRepCells: BRepCells
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: TrimFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): TrimFeature | null
    /**
      After making any changes to the set of selected cells you must call this method to
      indicate all changes have been made and to apply those changes to the feature.
      @returns Returns true if the apply was successful.
    */
    applyCellChanges(): boolean
  }

  /**
    Collection that provides access to all of the existing Thicken features in a component
    and supports the ability to create new Thicken features.
  */
  abstract class ThickenFeatures extends core.Base {
    /**
      Function that returns the specified Thicken feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ThickenFeature | null
    /**
      The number of Thicken features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a ThickenFeatureInput object. Use properties and methods on this object
      to define the Thicken feature you want to create and then use the Add method, passing in
      the ThickenFeatureInput object to create the feature.
      @param inputFaces The faces or patch bodies to thicken. Faces need not be from the same component or body, nor do they need to be
      connected or touching one another.
      @param thickness ValueInput object that defines the thickness.
      @param isSymmetric A boolean value for setting whether to add thickness symmetrically or only on one side of the face/s to thicken
      @param operation The feature operation to perform.
      @param isChainSelection A boolean value for setting whether or not faces that are tangentially connected to
      the input faces (if any) will be included in the thicken. The default value is true.
      @returns Returns the newly created ThickenFeatureInput object or null if the creation failed.
    */
    createInput(inputFaces: core.ObjectCollection, thickness: core.ValueInput, isSymmetric: boolean, operation: FeatureOperations, isChainSelection?: boolean/* = true*/): ThickenFeatureInput | null
    /**
      Creates a new Thicken feature.
      @param input A FeatureInput object that defines the desired Thicken feature. Use the createInput
      method to create a new ThickenFeatureInput object and then use methods on it
      (the ThickenFeatureInput object) to define the Thicken feature.
      @returns Returns the newly created ThickenFeature object or null if the creation failed.
    */
    add(input: ThickenFeatureInput): ThickenFeature | null
    /**
      Function that returns the specified thicken feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): ThickenFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a Thicken feature.
  */
  abstract class ThickenFeatureInput extends core.Base {
    /**
      An ObjectCollection containing the face and/or patch bodies to thicken.
    */
    inputFaces: core.ObjectCollection
    /**
      Gets and sets the ValueInput object that defines the thickness distance.
    */
    thickness: core.ValueInput
    /**
      Gets and sets whether to add thickness symmetrically or only on one side of the face/s to thicken
    */
    isSymmetric: boolean
    /**
      Gets and sets the feature operation to perform.
    */
    operation: FeatureOperations
    /**
      Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature.
    */
    isChainSelection: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the Thicken feature is created based on geometry (e.g. a profile and/or face(s))
      in another component AND (the Thicken feature) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
  }

  /**
    List of Thicken Types
  */
  const enum ThickenTypes {
    /**
      Use sharp corners when creating the thicken.
    */
    SharpThickenType,
    /**
      Use rounded corners when creating the thicken.
    */
    RoundedThickenType,
  }

  /**
    Object that represents an existing Thicken feature in a design.
  */
  abstract class ThickenFeature extends Feature {
    /**
      Sets the faces and patch bodies to thicken.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param inputFaces The faces or patch bodies to thicken. Faces need not be from the same component or body, nor do they need to be
      connected or touching one another.
      @param isChainSelection A boolean value for setting whether or not faces that are tangentially connected to
      the input faces (if any) will be included in the offset. The default value is true.
      @returns Returns true if successful
    */
    setInputEntities(inputFaces: core.ObjectCollection, isChainSelection?: boolean/* = true*/): boolean
    /**
      Gets and sets the ObjectCollection containing the face and/or patch bodies to thicken.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    inputFaces: core.ObjectCollection
    /**
      Returns the parameter controlling the thickness. You can edit the thickness value
      by editing the value of the parameter object.
    */
    readonly thickness: ModelParameter
    /**
      Gets and sets whether to add thickness symmetrically or only on one side of the face/s to thicken.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isSymmetric: boolean
    /**
      Gets and sets the feature operation to perform.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    operation: FeatureOperations
    /**
      Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature.
    */
    readonly isChainSelection: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ThickenFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ThickenFeature | null
  }

  /**
    Collection that provides access to all of the existing Form features in a component.
  */
  abstract class FormFeatures extends core.Base {
    /**
      Function that returns the specified Form feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): FormFeature | null
    /**
      Function that returns the specified form feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): FormFeature | null
    /**
      The number of Form features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new empty form feature in the parent component.
      @returns Returns the new FormFeature or null in the case of an error.
    */
    add(): FormFeature | null
  }

  /**
    Object that represents an existing Form feature in a design.
  */
  abstract class FormFeature extends Feature {
    /**
      Returns a TSplineBodies collection where you can access any existing
      T-Spline bodies and through it create new T-Spline bodies.
    */
    readonly tSplineBodies: TSplineBodies
    /**
      Set the user-interface so that the form body is in edit mode.
      @returns Returns true if successful.
    */
    startEdit(): boolean
    /**
      Exits from edit mode in the user-interface. If this form feature in not
      in edit mode, then nothing happens.
      @returns Returns true if successful.
    */
    finishEdit(): boolean
  }

  /**
    Collection that provides access to all of the existing Unstitch features in a component
    and supports the ability to create new Unstitch features.
  */
  abstract class UnstitchFeatures extends core.Base {
    /**
      Function that returns the specified Unstitch feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): UnstitchFeature | null
    /**
      The number of Unstitch features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new Unstitch feature.
      @param faces The faces and/or bodies to Unstitch. Individual faces can be unstitched from solid and/or patch bodies. The faces being unstitched
      need not all come from the same body.
      @param isChainSelection A boolean value for setting whether or not faces that are connected and adjacent to
      the input faces will be included in the selection. The default value is true.
      @returns Returns the newly created UnstitchFeature object or null if the creation failed.
    */
    add(faces: core.ObjectCollection, isChainSelection?: boolean/* = true*/): UnstitchFeature | null
    /**
      Function that returns the specified unstitch feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): UnstitchFeature | null
  }

  /**
    Object that represents an existing Unstitch feature in a design.
  */
  abstract class UnstitchFeature extends Feature {
    /**
      Sets the faces and/or bodies to be unstitched.
      To use this method, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param faces The faces and/or bodies to Unstitch. Individual faces can be unstitched from solids and/or patch bodies.
      The faces being unstitched need not all come from the same body.
      @param isChainSelection A boolean value for setting whether or not faces that are connected and adjacent to
      the input faces will be included in the selection. The default value is true.
      @returns Returns true if successful.
    */
    setInputFaces(faces: core.ObjectCollection, isChainSelection?: boolean/* = true*/): boolean
    /**
      Gets the faces that were input to be unstitched.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    readonly inputFaces: core.ObjectCollection
    /**
      A boolean value for setting whether or not faces that are connected and adjacent to
      the input faces will be included in the selection. The default value is true.
    */
    readonly isChainSelection: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: UnstitchFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): UnstitchFeature | null
  }

  /**
    Collection that provides access to all of the existing Reverse Normal features in a component
    and supports the ability to create new Reverse Normal features.
  */
  abstract class ReverseNormalFeatures extends core.Base {
    /**
      Function that returns the specified Reverse Normal feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ReverseNormalFeature | null
    /**
      Function that returns the specified reverse normal feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): ReverseNormalFeature | null
    /**
      The number of Reverse Normal features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new Reverse Normal feature.
      @param surfaces One or more surface bodies (open BRepBodies) containing the faces whose normals are to be reversed.
      All faces of the input surface bodies get reversed.
      @returns Returns the newly created ReverseNormalFeature object or null if the creation failed.
    */
    add(surfaces: core.ObjectCollection): ReverseNormalFeature | null
  }

  /**
    Object that represents an existing Reverse Normal feature in a design.
  */
  abstract class ReverseNormalFeature extends Feature {
    /**
      Gets and sets the surface bodies (open BRepBodies) whose faces normals are to be reversed.
      All faces of the input surface bodies get reversed.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    surfaces: core.ObjectCollection
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ReverseNormalFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ReverseNormalFeature | null
  }

  /**
    Collection that provides access to all of the existing Remove features in a component
    and supports the ability to create new Remove features.
  */
  abstract class RemoveFeatures extends core.Base {
    /**
      Function that returns the specified Remove feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): RemoveFeature | null
    /**
      Function that returns the specified remove feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): RemoveFeature | null
    /**
      The number of Remove features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new Remove feature.
      @param itemToRemove A single body (solid or surface) or component occurrence to remove.
      @returns Returns the newly created RemoveFeature object or null if the creation failed.
    */
    add(itemToRemove: core.Base): RemoveFeature | null
  }

  /**
    Object that represents an existing Remove feature in a design.
  */
  abstract class RemoveFeature extends Feature {
    /**
      Gets and sets the body or component occurrence to remove.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    readonly itemToRemove: core.Base
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: RemoveFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): RemoveFeature | null
  }

  /**
    Collection that provides access to all of the existing rule fillet features in a design.
  */
  abstract class RuleFilletFeatures extends core.Base {
    /**
      Function that returns the specified rule fillet feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): RuleFilletFeature | null
    /**
      Function that returns the specified rule fillet feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): RuleFilletFeature | null
    /**
      The number of rule fillet features in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that represents an existing rule fillet feature in a design.
  */
  abstract class RuleFilletFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing loft features in a design.
  */
  abstract class LoftFeatures extends core.Base {
    /**
      Function that returns the specified loft feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): LoftFeature | null
    /**
      Function that returns the specified loft feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): LoftFeature | null
    /**
      The number of loft features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a LoftFeatureInput object. Use properties and methods on the returned LoftFeatureInput
      object to provide the required input to create a loft feature. The LoftFeatureInput object can then be used as input to the
      add method to create the loft feature.
      @param operation The feature operation to perform.
      @returns Returns the newly created LoftFeatureInput object or null if the creation failed.
    */
    createInput(operation: FeatureOperations): LoftFeatureInput | null
    /**
      Creates a new loft feature.
      @param input A LoftFeatureInput object that defines the desired loft feature. Use the createInput
      method to create a new LoftFeatureInput object and then use methods on it
      (the LoftFeatureInput object) to define the required input.
      @returns Returns the newly created LoftFeature object or null if the creation failed.
    */
    add(input: LoftFeatureInput): LoftFeature | null
  }

  /**
    This object defines the all of the input necessary to create a loft feature. It is the
    programming equivalent to the Loft command dialog. Through this object you provide
    the input needed to fully define a loft. To create the loft feature you pass
    this object the LoftFeatures.add method.
  */
  abstract class LoftFeatureInput extends core.Base {
    /**
      The set of sections, (or profiles as they're referred to in the user-interface), that the loft will pass through. Use the add method on the LoftSections
      object to specify new sections.
    */
    readonly loftSections: LoftSections
    /**
      The single centerline or set of rails that define the shape of the loft. Use methods on the
      returned LoftCenterLineOrRails object to define the centerline or rails.
    */
    readonly centerLineOrRails: LoftCenterLineOrRails
    /**
      Gets and sets the type of operation performed by the loft.
    */
    operation: FeatureOperations
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the loft is created based on geometry (e.g. a profile and/or face(s))
      when the loft is being created in another component AND the loft is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      Specifies if the loft should be created as a solid or surface. This is
      initialized to true so a solid will attempt to be created if it's not changed.
    */
    isSolid: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      If this property has not been set, the default behavior is that all bodies that are intersected by the
      feature will participate.
      This property can return null in the case where the feature has not been fully defined so that
      possible intersecting bodies can be computed.
    */
    participantBodies: BRepBody[]
    /**
      Specifies if the loft closes back on itself. In other words, the first section is also
      used as the last section and the connection is smooth. This property defaults to false.
    */
    isClosed: boolean
    /**
      Specifies if the loft will keep or merge tangent edges. These are edges between tangent
      faces in the resulting loft surface. If true, the faces will be merged so the connecting
      edge no longer exists
    */
    isTangentEdgesMerged: boolean
    /**
      Specifies the start edge alignment option for the loft feature. The default is Free Edges.
    */
    startLoftEdgeAlignment: LoftEdgeAlignments
    /**
      Specifies the end edge alignment option for the loft feature. The default is Free Edges.
    */
    endLoftEdgeAlignment: LoftEdgeAlignments
  }

  /**
    Defines a single centerline or one or more rails for a loft feature.
  */
  abstract class LoftCenterLineOrRails extends core.Base {
    /**
      The number of centerlines or rails in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified LoftCenterLineOrRail using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*int*/): LoftCenterLineOrRail | null
    /**
      Indicates if a centerline or rails are currently defined.
    */
    readonly isCenterLine: boolean
    /**
      Adds a centerline. A single centerline can be defined for a loft. If a centerline or rails have already
      been defined, they will be removed and the input will become the new single centerline.
      If this LoftCenterLineOrRails object is associated with a created feature,
      @param entity The entity that defines the center line. This can be a single sketch curve, a single BRepEdge, a Path consisting of
      connected B-Rep edges or sketch curves.
      @returns Returns the new LoftCenterLineOrRail object or null in the case of a failure.
    */
    addCenterLine(entity: core.Base): LoftCenterLineOrRail | null
    /**
      Add a rail to the loft definition. Multiple rails can be defined, so each call of this
      method adds a new rail.
      If this LoftCenterLineOrRails object is associated with a created feature, you need to position the timeline
      marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param entity The entity that defines the rail. This can be a single sketch curve, a single BRepEdge, or a Path consisting of
      connected B-Rep edges or sketch curves.
      @returns Returns the new LoftCenterLineOrRail object or null in the case of a failure.
    */
    addRail(entity: core.Base): LoftCenterLineOrRail | null
  }

  /**
    Represent a centerline or a single rail used by a loft feature.
  */
  abstract class LoftCenterLineOrRail extends core.Base {
    /**
      Indicates if this object is a loft centerline (true) or a rail (false).
    */
    readonly isCenterLine: boolean
    /**
      Gets and sets the entity that defines the centerline or rail. This can be a single sketch entity,
      a single BRepEdge, a Path, or a Profile.
      If this LoftCenterLineOrRail object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    entity: core.Base
    /**
      Deletes the centerline or rail.
      If this LoftCenterLineOrRail object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @returns Returns true if the operation was successful.
    */
    deleteMe(): boolean
    /**
      Gets and sets the edge condition for this rail. This value is only
      applicable when a BRepEdge is used as the rail entity. If sketch
      geometry is used, this value is ignored. The property defaults
      to G0LoftRailEdgeCondition.
      If this LoftCenterLineOrRail object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    edgeCondition: LoftRailEdgeConditions
  }

  /**
    Defines the different conditions that can be applied to a loft rail
    when the rail entity is defined by BRepEdge objects.
  */
  const enum LoftRailEdgeConditions {
    /**
      Defines a G0 or connected edge condition.
    */
    G0LoftRailEdgeCondition,
    /**
      Defines a G1 or tangent edge condition.
    */
    G1LoftRailEdgeCondition,
    /**
      Defines a G2 or curvature continuous edge condition.
    */
    G2LoftRailEdgeCondition,
  }

  /**
    The set of two or more sections used to define the shape of the loft.
  */
  abstract class LoftSections extends core.Base {
    /**
      The number of LoftSections in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified LoftSection using an index into the collection. They are returned
      in the same order that they are used in the loft. Their order can be modified using the reorder method
      of the LoftSection object.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*int*/): LoftSection | null
    /**
      Adds a new section to the loft. The initial end condition is "Free". Additional methods on the
      returned LoftSection can be used to further define the section.
      If this LoftSections object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param entity Specifies the BRepFace, Profile, Path, SketchPoint, ConstructionPoint, or an ObjectCollection containing
      a contiguous set of Profile objects that defines the section.
      @returns Returns the newly created LoftSection object.
    */
    add(entity: core.Base): LoftSection
  }

  /**
    A single loft section.
  */
  abstract class LoftSection extends core.Base {
    /**
      Get and sets the entity that defines the section of the loft. This can be a BRepFace, Profile, Path, SketchPoint, ConstructionPoint, or an ObjectCollection
      of contiguous profiles.
      If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    entity: core.Base
    /**
      Deletes this LoftSection.
      If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @returns Returns true if the operation was successful.
    */
    deleteMe(): boolean
    /**
      The position of this LoftSection within the collection. The first section has an index
      of 0. This is also the order of how the section will be used in the loft. The order
      can be modified by using the reorder method.
    */
    readonly index: number /*int*/
    /**
      Repositions this section so that it has the new index specified.
      If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param newIndex The new index value. For example, passing in zero as the new index will make this
      the first section in the loft and (LoftSections.count - 1) will make it the last section.
      All other sections will be maintain their existing order but be shifted to allow space
      for this section.
      @returns Returns true if the reorder operation was successful.
    */
    reorder(newIndex: number /*int*/): boolean
    /**
      Returns the current end condition. This is only valid for the first and last
      section and when the result is not closed. In other cases this will return null.
      This returns one of the several objects derived from LoftEndCondition and represents
      the current end condition. You can edit the existing condition using properties
      on the returned object. You can change the end condition using one of the set methods
      on the LoftSection object.
      If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    readonly endCondition: LoftEndCondition
    /**
      Sets the end condition to be a "Free" end condition. This is the default
      end condition when a new section is added.
      This is valid for sections defined with all curve types.
      If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @returns Returns true if the operation was successful.
    */
    setFreeEndCondition(): boolean
    /**
      Sets the end condition to be defined by a direction and weight.
      This is valid for sections defined with sketch curves.
      If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param angle Input ValueInput object that specifies the direction by using an angle. This defaults to an angle of 0.0.
      If the ValueInput object is a string it must be an valid expression that can be evaluated as an angle.
      If the ValueInput is a value then it is in radians.
      @param weight Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
      This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that
      can be evaluated as a unitless value. In any case, the value must be greater than 0.
      @returns Returns true if the operation was successful.
    */
    setDirectionEndCondition(angle?: core.ValueInput/* = null*/, weight?: core.ValueInput/* = null*/): boolean
    /**
      Sets the end condition to be tangent to the adjacent face. If the section is not defined by a BRepEdge,
      then this is ignored because there is no face to be tangent to.
      This is only valid on the first or last profile.
      If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param weight Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
      This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that
      can be evaluated as a unitless value. In any case, the value must be greater than 0.
      @returns Returns true if the operation was successful.
    */
    setTangentEndCondition(weight: core.ValueInput): boolean
    /**
      Sets the end condition to be smooth to the adjacent face. If the end profile is not defined by a BRepEdge,
      then this is ignored because there is no face to be smooth to.
      This is only valid on the first or last section.
      If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param weight Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
      This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that
      can be evaluated as a unitless value. In any case, the value must be greater than 0.
      @returns Returns true if the operation was successful.
    */
    setSmoothEndCondition(weight: core.ValueInput): boolean
    /**
      Sets the end condition to be sharp where the section is a point. This is the default condition for a point section.
      If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @returns Returns true if the operation was successful.
    */
    setPointSharpEndCondition(): boolean
    /**
      Set the end condition to a tangent condition in the case where the section is a point.
      If this LoftSection object is associated with a created feature, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      @param weight Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
      This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that
      can be evaluated as a unitless value. In any case, the value must be greater than 0.
      @returns Returns true if the operation was successful.
    */
    setPointTangentEndCondition(weight: core.ValueInput): boolean
  }

  /**
    The base class for all loft end conditions.
  */
  abstract class LoftEndCondition extends core.Base {
    /**
      Returns the parent loft section.
    */
    readonly parentLoftSection: LoftSection
  }

  /**
    Represents a "Free" loft end condition.
  */
  abstract class LoftFreeEndCondition extends LoftEndCondition {
  }

  /**
    Represents a "Direction" loft end condition.
  */
  abstract class LoftDirectionEndCondition extends LoftEndCondition {
    /**
      Gets the valueInput or Parameter that defines the angle of the direction of the loft.
      If this object was obtained from a LoftFeatureInput object then this will return a
      valueInput object with the initial value provided. If this object was obtained from
      an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the angle,
      edit the value of the associated parameter.
    */
    readonly angle: core.Base
    /**
      Gets the valueInput or Parameter that defines the weight of the loft.
      If this object was obtained from a LoftFeatureInput object then this will return a
      valueInput object with the initial value provided. If this object was obtained from
      an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,
      edit the value of the associated parameter.
    */
    readonly weight: core.Base
  }

  /**
    Represents a "Tangent" loft end condition.
  */
  abstract class LoftTangentEndCondition extends LoftEndCondition {
    /**
      Gets the valueInput or Parameter that defines the weight of the loft.
      If this object was obtained from a LoftFeatureInput object then this will return a
      valueInput object with the initial value provided. If this object was obtained from
      an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,
      edit the value of the associated parameter.
    */
    readonly weight: core.Base
  }

  /**
    Represents a "Smooth" loft end condition.
  */
  abstract class LoftSmoothEndCondition extends LoftEndCondition {
    /**
      Gets the valueInput or Parameter that defines the weight of the loft.
      If this object was obtained from a LoftFeatureInput object then this will return a
      valueInput object with the initial value provided. If this object was obtained from
      an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,
      edit the value of the associated parameter.
    */
    readonly weight: core.Base
  }

  /**
    Represents a "Point Sharp" loft end condition.
  */
  abstract class LoftPointSharpEndCondition extends LoftEndCondition {
  }

  /**
    Represents a "Point Tangent" loft end condition.
  */
  abstract class LoftPointTangentEndCondition extends LoftEndCondition {
    /**
      Gets the valueInput or Parameter that defines the weight of the loft.
      If this object was obtained from a LoftFeatureInput object then this will return a
      valueInput object with the initial value provided. If this object was obtained from
      an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,
      edit the value of the associated parameter.
    */
    readonly weight: core.Base
  }

  /**
    Object that represents an existing loft feature in a design.
  */
  abstract class LoftFeature extends Feature {
    /**
      Returns the set of sections that the loft passes through.
      This property returns null in the case where the feature is non-parametric.
    */
    readonly loftSections: LoftSections
    /**
      Returns the single centerline or the set of rails that define the shape of the loft.
      This property returns null in the case where the feature is non-parametric.
    */
    readonly centerLineOrRails: LoftCenterLineOrRails
    /**
      Property that returns the face that caps the start of the loft and is coincident
      with the first section. In the case where the loft isn't capped and there isn't
      a start face, this property will return null.
    */
    readonly startFace: BRepFace
    /**
      Property that returns the face that caps the end of the loft and is coincident
      with the last section. In the case where the loft isn't capped and there isn't an end face,
      this property will return null.
    */
    readonly endFace: BRepFace
    /**
      Property that returns all of the side faces (i.e. those running through the sections)
      of the feature.
    */
    readonly sideFaces: BRepFaces
    /**
      Gets and sets the type of operation performed by the extrusion.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    operation: FeatureOperations
    /**
      Indicates if this feature was initially created as a solid or a surface.
    */
    readonly isSolid: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: LoftFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): LoftFeature | null
    /**
      Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    participantBodies: BRepBody[]
    /**
      Specifies if the loft closes back on itself. In other words, the first section is also
      used as the last section.
    */
    isClosed: boolean
    /**
      Specifies if the loft will keep or merge tangent edges. These are edges between tangent
      faces in the resulting loft surface. If true, the faces will be merged so the connecting
      edge no longer exists
    */
    isTangentEdgesMerged: boolean
    /**
      Specifies the start edge alignment option for the loft feature. The default is Free Edges.
    */
    startLoftEdgeAlignment: LoftEdgeAlignments
    /**
      Specifies the end edge alignment option for the loft feature. The default is Free Edges.
    */
    endLoftEdgeAlignment: LoftEdgeAlignments
  }

  /**
    List of Loft Edge Alignment Options
  */
  const enum LoftEdgeAlignments {
    /**
      Specifies the loft edges are not influenced by edges or faces the loft starts or ends at.
    */
    FreeEdgesLoftEdgeAlignment,
    /**
      Specifies the edges of the loft are aligned with the edges of the face the loft starts or ends at.
    */
    AlignEdgesLoftEdgeAlignment,
    /**
      Specifies the edges of the loft are aligned with the face the loft starts or ends at.
    */
    AlignToSurfaceLoftEdgeAlignment,
  }

  /**
    Collection that provides access to all of the existing SurfaceDeleteFaceFeature features in a component
    and supports the ability to create new SurfaceDeleteFaceFeature features.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
  */
  abstract class SurfaceDeleteFaceFeatures extends core.Base {
    /**
      Function that returns the specified SurfaceDeleteFaceFeature object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SurfaceDeleteFaceFeature | null
    /**
      Function that returns the specified SurfaceDeleteFaceFeature object using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): SurfaceDeleteFaceFeature | null
    /**
      The number of SurfaceDeleteFaceFeature objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new SurfaceDeleteFaceFeature feature. This deletes the specified faces
      from their bodies without any attempt to heal the openings. This is equivalent
      to selecting and deleting faces when in the Patch workspace.
      @param facesToDelete A single BRepFace or an ObjectCollection containing multiple BRepFace objects.
      @returns Returns the newly created SurfaceDeleteFaceFeature object or null if the creation failed.
    */
    add(facesToDelete: core.Base): SurfaceDeleteFaceFeature | null
  }

  /**
    Object that represents an existing Surface Delete Face feature in a design.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
  */
  abstract class SurfaceDeleteFaceFeature extends Feature {
    /**
      Gets and sets the set of faces that are deleted by this feature.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    deletedFaces: BRepFace[]
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SurfaceDeleteFaceFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SurfaceDeleteFaceFeature | null
  }

  /**
    Collection that provides access to all of the existing DeleteFaceFeature features in a component
    and supports the ability to create new DeleteFaceFeature features.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
  */
  abstract class DeleteFaceFeatures extends core.Base {
    /**
      Function that returns the specified DeleteFaceFeature object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): DeleteFaceFeature | null
    /**
      Function that returns the specified DeleteFaceFeature object using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): DeleteFaceFeature | null
    /**
      The number of DeleteFaceFeature objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new SurfaceDeleteFace feature. This deletes the specified faces
      from their bodies and attempts to heal the body. The method will fail if
      the body cannot be healed. This is equivalent to selecting and deleting
      faces when in the Patch workspace.
      @param facesToDelete A single BRepFace or an ObjectCollection containing multiple BRepFace objects.
      @returns Returns the newly created DeleteFaceFeature object or null if the creation failed.
    */
    add(facesToDelete: core.Base): DeleteFaceFeature | null
  }

  /**
    Object that represents an existing DeleteFaceFeature object in a design.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
  */
  abstract class DeleteFaceFeature extends Feature {
    /**
      Gets and sets the set of faces that are deleted by this feature.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
      Setting this property can fail if Fusion is unable to heal the body after
      deleting the specified faces.
    */
    deletedFaces: BRepFace[]
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: DeleteFaceFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): DeleteFaceFeature | null
  }

  /**
    Collection that provides access to all of the existing copy-paste features in a design.
    These are created in the UI by copying and then pasting a B-Rep body.
  */
  abstract class CopyPasteBodies extends core.Base {
    /**
      Function that returns the specified Copy/Paste Body feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CopyPasteBody | null
    /**
      Function that returns the specified Copy/Paste Body feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): CopyPasteBody | null
    /**
      The number of Copy/Paste Body features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Copies the specified body into the component that owns this CopyPasteBodies collection.
      @param sourceBody Either an ObjectCollection of BRepBodies or a single BRepBody object to copy.
      @returns Returns the newly created BRepBody object or null in the case of failure.
    */
    add(sourceBody: core.Base): CopyPasteBody | null
  }

  /**
    Object that represents an existing Copy/Paste Body feature in a design.
  */
  abstract class CopyPasteBody extends Feature {
    /**
      Returns the bodies that were copied to create the result bodies of this feature. An ObjectCollection
      is returned that will contain the original bodies. It's possible that the collection can be empty
      or contain less than the number of bodies originally copied. This happens in the case where a body
      has been deleted or consumed by some other operation.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    readonly sourceBody: core.ObjectCollection
  }

  /**
    Collection that provides access to all of the existing cut-paste features in a design.
    These are created in the UI by cutting and then pasting a B-Rep body.
  */
  abstract class CutPasteBodies extends core.Base {
    /**
      Function that returns the specified Cut/Paste Body feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CutPasteBody | null
    /**
      Function that returns the specified Cut/Paste Body feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): CutPasteBody | null
    /**
      The number of Cut/Paste Body features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Cuts and copies the specified body into the component that owns this CutPasteBodies collection.
      This is effectively the equivalent of moving a body.
      @param sourceBody Either an ObjectCollection of BRepBodies or a single BRepBody object to cut.
      @returns Returns the newly created BRepBody object or null in the case of failure.
    */
    add(sourceBody: core.Base): CutPasteBody | null
  }

  /**
    Object that represents an existing Cut/Paste Body feature in a design.
  */
  abstract class CutPasteBody extends Feature {
    /**
      Returns the bodies that were cut to create the result bodies of this feature. An ObjectCollection
      is returned that will contain the original bodies. It's possible that the collection can be empty
      or contain less than the number of bodies originally copied. This happens in the case where a body
      has been deleted or consumed by some other operation.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    readonly sourceBody: core.ObjectCollection
  }

  /**
    Collection that provides access to all of the existing Ruled Surface features in a component
    and supports the ability to create new Ruled Surface features.
  */
  abstract class RuledSurfaceFeatures extends core.Base {
    /**
      Function that returns the specified ruled surface feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): RuledSurfaceFeature | null
    /**
      The number of RuledSurface features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a RuledSurfaceFeatureInput object that defines the input needed to create a ruled surface feature. Use the input
      object to define the input to create the desired feature and then use the Add method, passing in the RuledSurfaceFeatureInput object.
      @param profile A Profile object that defines the sketch geometry or edges that define the shape of the ruled surface. The Component.createBRepEdgeProfile
      method is useful to create a profile defined from edges.
      @param distance ValueInput object that defines the extension distance of the Ruled Surface..
      @param angle ValueInput object that defines angle to use when creating the Ruled Surface. When the input is a real value, the units are radians.
      @param ruledSurfaceType The Ruled Surface type (TangentRuledSurfaceType, NormalRuledSurfaceType, or DirectionRuledSurfaceType).
      @param direction If the ruled surface type is DirectionRuledSurfaceType, you must specify the direction. The direction is specified by
      providing a linear or planar entity. For example, a linear edge, construction axis, planar face, or construction plane can be used as input.
      @returns Returns the newly created RuledSurfaceFeatureInput object or null if the creation failed.
    */
    createInput(profile: core.Base, distance: core.ValueInput, angle: core.ValueInput, ruledSurfaceType: RuledSurfaceTypes, direction?: core.Base/* = null*/): RuledSurfaceFeatureInput | null
    /**
      Creates a new RuledSurface feature.
      @param input An RuledSurfaceFeatureInput object that defines the desired RuledSurface feature. Use the createInput
      method to create a new RuledSurfaceFeatureInput object and then use methods on it
      (the RuledSurfaceFeatureInput object) to define the desired options for the ruled surface feature.
      @returns Returns the newly created RuledSurfaceFeature object or null if the creation failed.
    */
    add(input: RuledSurfaceFeatureInput): RuledSurfaceFeature | null
    /**
      Function that returns the specified RuledSurface feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): RuledSurfaceFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a Ruled Surface feature.
  */
  abstract class RuledSurfaceFeatureInput extends core.Base {
    /**
      Gets and sets the Profile object that defines the sketch geometry or edges that define the shape of
      the ruled surface. The Component.createBRepEdgeProfile method is useful to create a profile defined from edges.
    */
    profile: core.Base
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the Ruled Surface is created based on geometry (e.g. a profile)
      in another component AND (the Ruled Surface) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
    /**
      Gets and sets the ValueInput object that defines the Ruled Surface distance. If the value input is
      a real value it will define the distance in centimeters.
    */
    distance: core.ValueInput
    /**
      Gets and sets the ValueInput object that defines the Ruled Surface angle.
      If the input is a real value, the units are radians.
    */
    angle: core.ValueInput
    /**
      Gets and sets the type of ruled surface to create. To set this to DirectionRuledSurfaceType,
      use the direction property to set the direction entity, which will automatically set
      this to DirectionRuledSurfaceType.
    */
    ruledSurfaceType: RuledSurfaceTypes
    /**
      Gets and sets the entity that defines the direction when the ruled surface type is DirectionRuledSurfaceType.
      The direction is specified by providing a linear or planar entity. For example, a linear edge, construction axis,
      planar face, or construction plane can be used as input.
      If this property is set when the ruledSurfaceType is not DirectionRuledSurfaceType, the type will automatically be
      changed to DirectionRuledSurfaceType. If you get this property when the direction is not DirectionRuledSurfaceType,
      it will return null.
    */
    direction: core.Base
    /**
      Gets and sets if the other face is used for creation of the Ruled Surface.
      When creating a ruled surface using the edges of a solid or the interior edges
      of a surface the angle of the ruled surface is measured with respect to the
      face the selected edge is bounding. For a solid, or an interior edge on a surface,
      the edge connects to two faces. This setting toggles which of the two faces will
      be used for measuring the angle.
    */
    alternateFace: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets the type of operation performed by the ruled surface.
    */
    operation: FeatureOperations
    /**
      Gets and sets the corner type for the ruled surface, indicating if the corners will be rounded or mitered.
      The default value is rounded.
    */
    cornerType: RuledSurfaceCornerTypes
  }

  /**
    Object that represents an existing RuledSurface feature in a design.
  */
  abstract class RuledSurfaceFeature extends Feature {
    /**
      Gets and sets the Profile object that defines the sketch geometry or edges that define the shape of
      the ruled surface. The Component.createBRepEdgeProfile method is useful to create a profile defined from edges.
      In many cases the RuledSurface operation results in the profile being consumed so it is no longer available
      after the feature is created. In this case, you need to reposition the timeline marker to just before this feature,
      when the profile still exists.
    */
    profile: core.Base
    /**
      Returns the parameter controlling the Ruled Surface distance. You can edit the distance
      by editing the value of the parameter object.
    */
    readonly distance: ModelParameter
    /**
      Returns the parameter controlling the Ruled Surface angle. You can edit the angle
      by editing the value of the parameter object.
    */
    readonly angle: ModelParameter
    /**
      Gets and sets the type of ruled surface. To set this to DirectionRuledSurfaceType,
      use the direction property to set the direction entity, which will automatically set
      this to DirectionRuledSurfaceType.
    */
    ruledSurfaceType: RuledSurfaceTypes
    /**
      Gets and sets the entity that defines the direction when the ruled surface type is DirectionRuledSurfaceType.
      The direction is specified by providing a linear or planar entity. For example, a linear edge, construction axis,
      planar face, or construction plane can be used as input.
      If this property is set when the ruledSurfaceType is not DirectionRuledSurfaceType, the type will automatically be
      changed to DirectionRuledSurfaceType. If you get this property when the direction is not DirectionRuledSurfaceType,
      it will return null.
    */
    direction: core.Base
    /**
      Gets and sets if the other face is used for creation of the Ruled Surface.
      When creating a ruled surface using the edges of a solid or the interior edges
      of a surface the angle of the ruled surface is measured with respect to the
      face the selected edge is bounding. For a solid, or an interior edge on a surface,
      the edge connects to two faces. This setting toggles which of the two faces will
      be used for measuring the angle.
    */
    alternateFace: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: RuledSurfaceFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): RuledSurfaceFeature | null
    /**
      Gets and sets the corner type for the ruled surface, indicating if the corners will be rounded or mitered.
      The default value is rounded.
    */
    cornerType: RuledSurfaceCornerTypes
  }

  /**
    List of Ruled Surface Types.
  */
  const enum RuledSurfaceTypes {
    /**
      Create Ruled Surface from edges or sketch curves
    */
    TangentRuledSurfaceType,
    /**
      Creates new faces tangent to the current faces.
    */
    NormalRuledSurfaceType,
    /**
      Creates new faces perpendicular to the current faces.
    */
    DirectionRuledSurfaceType,
  }

  /**
    List of Ruled Surface corner types.
  */
  const enum RuledSurfaceCornerTypes {
    /**
      The corners will be rounded.
    */
    RoundedRuledSurfaceCornerType,
    /**
      The corners will be mitered.
    */
    MiteredRuledSurfaceCornerType,
  }

  /**
    Collection that provides access to all of the existing Untrim features in a component
    and supports the ability to create new Untrim features.
  */
  abstract class UntrimFeatures extends core.Base {
    /**
      Function that returns the specified Untrim feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): UntrimFeature | null
    /**
      The number of Untrim features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates an UntrimFeatureInput object that defines the input needed to create an untrim feature. Use the input
      object to define the input to create the desired feature and then use the Add method, passing in the UntrimFeatureInput object.
      @param faces An array of BRepFace objects that will have the loops of the specified type removed.
      Only loops that do not have a connected face can be removed (the edges in the loop have a single face).
      The array can only contain faces from surface bodies, (the isSolid property of the BRepBody returns false).
      @param untrimLoopType The loop type to be untrimmed (AllLoopUntrimType, InternalLoopUntrimType, or ExternalLoopUntrimType).
      @param extensionDistance If the untrim loop type is AllLoopUntrimType or ExternalLoopUntrimType the untrimmed faces can be extended by a specified distance.
      @returns Returns the newly created UntrimFeatureInput object or null if the creation failed.
    */
    createInputFromFaces(faces: BRepFace[], untrimLoopType: UntrimLoopTypes, extensionDistance?: core.ValueInput/* = null*/): UntrimFeatureInput | null
    /**
      Creates an UntrimFeatureInput object that defines the input needed to create an untrim feature. Use the input
      object to define the input to create the desired feature and then use the Add method, passing in the UntrimFeatureInput object.
      @param loops Input the entities that define loops to remove.
      Only loops that do not have a connected face can be removed (the edges in the loop have a single face)
      The array can only contain loops from surface bodies, (the isSolid property of the BRepBody returns false).
      @param extensionDistance If an external boundary is removed the untrimmed face can be extended by a specified distance.
      @returns Returns the newly created UntrimFeatureInput object or null if the creation failed.
    */
    createInputFromLoops(loops: BRepLoop[], extensionDistance?: core.ValueInput/* = null*/): UntrimFeatureInput | null
    /**
      Creates a new Untrim feature.
      @param input An UntrimFeatureInput object that defines the desired Untrim feature. Use the createInput
      method to create a new UntrimFeatureInput object and then use methods on it
      (the UntrimFeatureInput object) to define the desired options for the Untrim feature.
      @returns Returns the newly created UntrimFeature object or null if the creation failed.
    */
    add(input: UntrimFeatureInput): UntrimFeature | null
    /**
      Function that returns the specified Untrim feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): UntrimFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of an Untrim feature.
  */
  abstract class UntrimFeatureInput extends core.Base {
    /**
      Gets the loop type to be untrimmed. This is only used when faces are being untrimmed and is ignored for loops.
    */
    readonly untrimLoopType: UntrimLoopTypes
    /**
      Gets the face objects to untrim.
      Returns null/None in the case where loops are specified instead of faces.
    */
    readonly facesToUntrim: BRepFace[]
    /**
      Set the loops to be removed from a set of faces.
      @param faces An array of BRepFace objects that will have the loops of the specified types removed.
      Only loops that do not have a connected face can be removed (the edges in the loop have a single face).
      The array can only contain faces from surface bodies, (the isSolid property of the BRepBody returns false).
      @param untrimLoopType The loop type to be untrimmed (AllLoopUntrimType, InternalLoopUntrimType, or ExternalLoopUntrimType).
      @returns Returns whether the operation was successful
    */
    setLoopsFromFaces(faces: BRepFace[], untrimLoopType: UntrimLoopTypes): boolean
    /**
      Gets the loop objects to untrim.
      Returns null/None in the case where faces are specified instead of loops
    */
    readonly loopsToUntrim: BRepLoop[]
    /**
      Set the loops to be removed.
      @param loops Redefines this input to remove loops from the body. If faces were previously defined, that information will be lost.
      Only loops that do not have a connected face can be removed (the edges in the loop have a single face)
      The array can only contain loops from surface bodies, (the isSolid property of the BRepBody returns false).
      @returns Returns whether the operation was successful
    */
    setLoops(loops: BRepLoop[]): boolean
    /**
      Gets and sets the ValueInput object that defines the extension distance applied to faces when an
      external boundary is removed.
    */
    extensionDistance: core.ValueInput
  }

  /**
    Object that represents an existing Untrim feature in a design.
  */
  abstract class UntrimFeature extends Feature {
    /**
      Gets the loop type that was untrimmed. To change the trim type, use one of the redefine methods.
    */
    readonly untrimLoopType: UntrimLoopTypes
    /**
      Gets the face objects to untrim.
      Returns null/None in the case where loops are specified instead of faces.
    */
    readonly facesToUntrim: BRepFace[]
    /**
      Set the loops to be removed from a set of faces.
      @param faces An array of BRepFace objects that will have the loops of the specified types removed.
      Only loops that do not have a connected face can be removed (the edges in the loop have a single face).
      The array can only contain faces from surface bodies, (the isSolid property of the BRepBody returns false).
      @param untrimLoopType The loop type to be untrimmed (AllLoopUntrimType, InternalLoopUntrimType, or ExternalLoopUntrimType).
      @returns Returns whether the operation was successful
    */
    redefineLoopsFromFaces(faces: BRepFace[], untrimLoopType: UntrimLoopTypes): boolean
    /**
      Gets the loop objects to untrim.
      Returns null/None in the case where faces are specified instead of loops
    */
    readonly loopsToUntrim: BRepLoop[]
    /**
      Set the loops to be removed.
      @param loops Input the entities that define loops to remove.
      Only loops that do not have a connected face can be removed (the edges in the loop have a single face)
      The array can only contain loops from surface bodies, (the isSolid property of the BRepBody returns false).
      @returns Returns whether the operation was successful
    */
    redefineLoops(loops: BRepLoop[]): boolean
    /**
      Gets the ModelParameter that defines the extension distance used to extend external boundaries.
      This can return null in the case where only internal boundaries have been removed.
      The value can be edited by using the properties of the returned ModelParameter object.
    */
    readonly extensionDistance: ModelParameter
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: UntrimFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): UntrimFeature | null
  }

  /**
    List of Untrim Loop Types.
  */
  const enum UntrimLoopTypes {
    /**
      Untrim all loops of faces
    */
    AllLoopsUntrimType,
    /**
      Untrim external loops of faces
    */
    ExternalLoopsUntrimType,
    /**
      Untrim internal loops of faces
    */
    InternalLoopsUntrimType,
    /**
      Untrim manually selected loops
    */
    ManualLoopsUntrimType,
  }

  /**
    Collection that provides access to all of the existing custom features in a component
    and supports the ability to create new custom features.
    @experimental
  */
  abstract class CustomFeatures extends core.Base {
    /**
      Function that returns the specified ruled surface feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CustomFeature | null
    /**
      The number of CustomFeature objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified CustomFeature feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): CustomFeature | null
    /**
      Creates a new input object that you use to define a custom feature. Creating an input object doesn't
      create the feature but provides a way to gather all of the input needed to create a custom feature.
      To create the custom feature, the fully defined input object is passed to the add method.
      @param definition The CustomFeatureDefinition for the type of custom feature being created.
      @returns Returns the newly created CustomFeatureInput object or null in the case of invalid input.
    */
    createInput(definition: CustomFeatureDefinition): CustomFeatureInput | null
    /**
      Creates a new custom feature.
      @param input The CustomFeatureInput object that defines the information needed to create a custom feature.
      @returns Returns the newly created CustomFeature.
    */
    add(input: CustomFeatureInput): CustomFeature
  }

  /**
    This class defines the methods and properties that pertain to the definition of a Ruled Surface feature.
    @experimental
  */
  abstract class CustomFeatureInput extends core.Base {
    /**
      Adds an entity or parameter this feature is dependent on. This is used by Fusion to know
      when to recompute this feature and to control the behavior of the feature's node in the timeline.
      @param id An ID for this dependency. This is used to allow you to identify which dependency is which in the future.
      The ID must be unique with respect to the other dependencies of this custom feature.
      @param entity The entity or parameter you want to add as a dependency. This can be a BRepBody, BRepFace, BrepEdge,
      BRepVertex, a sketch, any sketch entities, a profile, any construction geometry, or any parameter.
      @returns Returns true if the dependency was successfully added.
    */
    addDependency(id: string, entity: core.Base): boolean
    /**
      Defines the information needed to create a new custom parameter that will be associated with
      this feature. A custom parameter appears as a model parameter and will be listed as a child of the
      custom feature in the parameter dialog. The custom feature will automatically have a dependency
      on this parameter.
      @param id An id for this parameter. This is used to allow you to identify the parameter in the future. This
      must be unique with respect to all other parameters associated with this custom feature. It's needed
      because the label does not need to be unique and the Fusion auto-generated name can be edited by
      the user.
      @param label The label for this parameter as seen in the parameters dialog. This identifies to the user the purpose
      of this parameter. For example, when you create an extrusion with a specific distance, there are two
      parameters displayed in the parameters dialog with the labels "AlongDistance" and "TaperAngle". This does
      not have to be unique because in the case of a fillet feature there can be multiple parameters all labeled "Radius".
      @param value ValueInput object that specifies the value of the parameter. If the ValueInput was created using a real,
      the value will be interpreted using the internal unit for the unit type specified by the "units" argument.
      For example, if the ValueInput was created using the real value 5 and the input to the "units" argument is
      any valid length unit, the value will be interpreted as 5 centimeters since centimeters is the internal unit
      for lengths. If the "units" argument is a valid angle unit the value will be interpreted as 5 radians.
      If the ValueInput was created using a string, the string is used as-is for the expression of the parameter.
      This means if there are units as part of the string it must evaluate to the same unit type as that specified
      by the "units" argument and if no units are specified it will use the current default units specified for
      the current document. For example, if the ValueInput was created with the string "5 in", then the "units"
      argument must define any valid length so it is compatible. If the ValueInput was created with the string "5",
      any unit type can be used and the result will be 5 of that unit.
      When using a ValueInput created using a string, it's the same as creating a parameter in the user-interface.
      You can specify any valid expression, i.e. "5", "5 in", "5 in / 2", "5 + Length", etc. and you can choose
      from many different types of units. The only requirement is that the units must match in type. For example,
      they must both be lengths, or they must both be angles.
      @param units The units to use for the value of the parameter. Units specified must match the units specified (if any)
      in the ValueInput object.
      To create a parameter with no units (unitless) you can specify either an empty string.
      @param isVisible Optional argument that specifies if the parameter will be visible in the parameters dialog or not. By
      default the parameter will be visible.
      This can be useful in cases where the feature can be edited to be in different states where a parameter
      is only valid in a certain state. You can change the visibility based on the current state of the feature
      and if that parameter should be available for edit. This implies that you create all the parameters that
      might be needed and then change their visibility based on the current state of the feature. The parameters
      that are not visible will not be returned by the ModelParameters collection and are only available through
      the custom feature they're associated with.
      @returns Returns true if the definition of the model parameter was successfully added.
    */
    addCustomParameter(id: string, label: string, value: core.ValueInput, units: string, isVisible?: boolean/* = true*/): boolean
    /**
      Sets the start and end features that the custom feature will group. A "feature" in this
      case is an object that is visible in the timeline, such as modeling features, sketches,
      and construction geometry. The custom feature will group the input start and end features
      and all features between them in the timeline.
      You can determine the current start and end features using the features property and use
      the first and last features returned. If the custom feature contains a single feature,
      you can use the same feature for both the start and end feature arguments. You can also
      use null for both arguments to remove all features from a custom feature. The custom feature
      still exists but will be empty, and the features will be displayed individually within the timeline.
      @param startFeature The first feature in the timeline that the custom feature will group.
      @param endFeature The last feature in the timeline that the custom feature will group. When creating a custom feature
      that contains a single feature, this can be the same feature as the startFeature argument.
      @returns Returns true if setting the start and end features was successful.
    */
    setStartAndEndFeatures(startFeature: adsk.core.Base, endFeature: adsk.core.Base): boolean
    /**
      Returns the features that are grouped by this custom feature. The start and end features and all of
      the features between them in the timeline are returned. This includes all entities represented in
      the timeline including modeling features, construction geometry, sketches, etc.
    */
    readonly features: core.Base[]
  }

  /**
    The CustomFeatureDefinition object defines a specific type of custom feature. It contains
    the settings that apply to all custom features of that type and is used when creating new
    custom features of that type. It also supports the events used to handle changes to custom
    features of that type.
    @experimental
  */
  abstract class CustomFeatureDefinition extends core.Base {
    /**
      A static function that creates a new CustomFeatureDefinition object. The creation of a
      CustomFeatureDefinition object is required to be able to create new custom features and
      for existing custom features to behave correctly. The CustomFeatureDefinition object defines
      all of the information that is common for all custom features of a particular type. For example,
      it defines the icon and the default name. The CustomFeatureDefinition object also supports the
      events that used to react to an existing feature being edited or re-computed.
      The custom feature definition should be created when your add-in is initially loaded to notify
      Fusion that the add-in that supports that custom feature type is available.
      @param id The unique ID for custom features of a particular type. Care must be taken to ensure that this
      is unique and you must be consistent in its use once you've chosen an ID. A good practice to
      help ensure unique naming is to use the name of your company in combination with the name of
      the feature, such as "CompanyName.FeatureName". For example, "WoodTools4U.Dovetail".
      @param defaultName The default name of the feature. Fusion will use this name and append a number to each feature
      instance as it's created. For example, if this is "Dovetail" the first custom feature created
      will be named "Dovetail1" and the second will be "Dovetail2".
      If you want to localize this name you can use the Application.Preferences.generalPreferences.userLanguage
      property to determine what language the user has chosen and use the corresponding name for that language.
      @param iconFolder The folder that contains the image files that will be used for the icon for this feature in
      the timeline. This can be a full path or a relative path where it will be relative to the add-in
      file. The folder should contain the image files named 16x16.png and 32x32.png which should be
      images that are 16 and 32 pixels square.
      @returns Returns the newly created CustomFeatureDefinition or null in the case of failure.
    */
    static create(id: string, defaultName: string, iconFolder: string): CustomFeatureDefinition | null
    /**
      Gets the unique ID used for this type of custom feature.
    */
    readonly id: string
    /**
      Gets and sets the folder that contains the images that are used for the icon in the timeline for
      this custom feature. The folder should contain the image files named 16x16.png and 32x32.png
      which should be images that are 16 and 32 pixels square.
    */
    iconFolder: string
    /**
      Gets and sets the default name of the feature. Fusion will use this name and append a number
      to each feature instance as it's created. For example, if this is "Dovetail" the first
      custom feature created will be named "Dovetail1" and the second will be "Dovetail2".
      If you want to localize this name you can use the Application.Preferences.generalPreferences.userLanguage
      property to determine what language the user has chosen and use the corresponding name for that language.
    */
    defaultName: string
    /**
      Gets and sets which command will be invoked when the feature is edited. This is the id of the
      CommandDefinition object that you have created to do the edit of the feature.
    */
    editCommandId: string
    /**
      The customFeatureCompute event fires when Fusion is computing the timeline and reaches
      the custom feature. The event is fired if any of the dependencies of the custom feature
      have changed. You can modify the results of your custom feature based on the dependencies.
    */
    readonly customFeatureCompute: CustomFeatureEvent
  }

  /**
    A CustomFeature event is an event associated with handling changes to a custom feature.
    @experimental
  */
  abstract class CustomFeatureEvent extends core.Event {
    /**
      Add a handler to be notified when the file event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: CustomFeatureEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: CustomFeatureEventHandler): boolean
  }

  /**
    The CustomFeatureEventArgs provides information associated with a custom feature event.
    @experimental
  */
  abstract class CustomFeatureEventArgs extends core.EventArgs {
    /**
      Provides access to the custom feature that is being recomputed.
    */
    readonly customFeature: CustomFeature
    /**
      Provides access to the Status object associated with this compute. If the compute is successful
      you shouldn't do anything with this property. If the compute is not fully successful, you can
      use this returned Status object to define any errors or warnings that occurred during the compute.
      These warnings and errors will be shown to the user in the Alerts dialog.
    */
    readonly computeStatus: core.Status
  }

  /**
    The CustomFeatureEventHandler is a client implemented class that can be added as
    a handler to a CustomFeatureEvent.
    @experimental
  */
  abstract class CustomFeatureEventHandler extends core.EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: CustomFeatureEventArgs): void
  }

  /**
    Object that represents an existing CustomFeature feature in a design.
    @experimental
  */
  abstract class CustomFeature extends Feature {
    /**
      Gets the CustomFeatureDefinition object associated with this custom feature.
      null/None is returned in the case where the definition does not exist, which is
      typically a result of the owning add-in not being loaded.
    */
    readonly definition: CustomFeatureDefinition
    /**
      Returns the collection of dependencies for this custom feature. You can
      use the collection to query, add, and remove dependencies.
    */
    readonly dependencies: CustomFeatureDependencies
    /**
      Returns the list of parameters associated with this custom feature.
    */
    readonly parameters: CustomFeatureParameters
    /**
      Returns the features combined by this custom feature. The start and end features and all of
      the features between them in the timeline are returned.
    */
    readonly features: core.Base[]
    /**
      Sets the start and end features that will be grouped by the custom feature.
      The "features" in this case can be any object that is visible in the timeline,
      such as modeling features, sketches, and construction geometry. The input features
      and all features between them in the timeline will be grouped by the custom feature.
      The current start and end features can be determined by using the CustomFeature.features property
      and getting the first and last feature from the returned array.
      @param startFeature The first feature in the timeline to be grouped by the custom feature. The start and the end features
      can be null which will result in moving all of the features out of the custom feature. This is useful
      in cases where you need to modify the inputs to a feature contained within a custom feature. You can
      move the features out of the custom feature, move the timeline marker as needed to edit the features,
      and then use this method again to add them back into the custom feature.
      @param endFeature The last feature in the timeline that will be grouped by the custom feature. This can be the same
      feature that is provided as the startFeature argument for the case where the custom feature contains
      a single feature.
      @returns Returns true if setting the start and end features was successful.
    */
    setStartAndEndFeatures(startFeature: adsk.core.Base, endFeature: adsk.core.Base): boolean
    /**
      Returns the set of custom named values associated with this custom feature. These are
      a set of named values that are saved with this feature that you can use to save
      any additional information that is useful for you in managing the custom feature.
      For example, you might have a setting like an option for different shapes that
      the user chooses when creating the feature that are not represented as a parameter.
      You can use this to save the chosen value so when the feature is computed or edited
      you can use the value originally chosen. During an edit, you might allow the user
      to edit this setting and you can update the saved custom value.
    */
    readonly customNamedValues: CustomNamedValues
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: CustomFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): CustomFeature | null
  }

  /**
    A collection of custom parameters associated with a particular custom feature.
    @experimental
  */
  abstract class CustomFeatureParameters extends core.Base {
    /**
      Function that returns the specified custom parameter feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CustomFeatureParameter | null
    /**
      The number of CustomFeatureParameter objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified CustomParameter object given its ID.
      @param id The ID of the custom parameter, which was assigned when the parameter was defined and the custom feature was created.
      @returns Returns the specified item or null if the specified ID was not found.
    */
    itemById(id: string): CustomFeatureParameter | null
  }

  /**
    A custom parameter is a parameter that was created as the result of a custom feature
    being created. It is associated with the custom feature and it's lifetime is the same
    as the custom feature that owns it.
    @experimental
  */
  abstract class CustomFeatureParameter extends ModelParameter {
    /**
      Returns the ID of this custom feature parameter.
    */
    readonly id: string
    /**
      Gets and sets if this parameter is visible in the parameters dialog. By default, all new parameters are visible.
      This can be useful in cases where the feature can be edited to be in different states where a parameter
      is only valid in a certain state. You can change the visibility based on the current state of the feature
      and if that parameter should be available for edit. This implies that you create all the parameters that
      might be needed and then change their visibility based on the current state of the feature. The parameters
      that are not visible will not be returned by the ModelParameters collection and are only available through
      the custom feature they're associated with.
    */
    isVisible: boolean
    /**
      Returns the custom feature this parameter is associated with.
    */
    readonly parentCustomFeature: CustomFeature
  }

  /**
    A collection of dependencies associated with a particular custom feature. These
    are the entities that the custom feature is dependent on. If these entities are
    modified, it will cause the custom feature to recompute so it can be up to date.
    These dependencies are saved with the custom feature and can be accessed at a
    later time, typically during the compute, to access and use the entities.
    @experimental
  */
  abstract class CustomFeatureDependencies extends core.Base {
    /**
      Function that returns the specified custom dependency using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CustomFeatureDependency | null
    /**
      Function that returns the specified custom dependency given its ID.
      @param id The ID of the dependency, which was assigned when the dependency was defined.
      @returns Returns the specified item or null if the specified ID was not found.
    */
    itemById(id: string): CustomFeatureDependency | null
    /**
      The number of CustomFeatureParameter objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds an entity or parameter that this feature is dependent on. This is used by Fusion to know
      when to recompute this feature and to control the behavior of the feature's node in the timeline.
      @param id An ID for this dependency. This is used to allow you to identify which dependency is which in the future.
      The ID must be unique with respect to the other dependencies of this custom feature.
      @param entity The entity or parameter you want to add as a dependency. This can be a BRepBody, BRepFace, BrepEdge,
      BRepVertex, a sketch, any sketch entities, a profile, any construction geometry, or any parameter.
      @returns Returns the created CustomFeatureDependency object and asserts if it failed.
    */
    add(id: string, entity: core.Base): CustomFeatureDependency
    /**
      Deletes all of the current dependencies. This method is for convenience and
      is equivalent to iterating through the collection and deleting them one at a time.
      @returns Returns true if the operation was successful.
    */
    deleteAll(): boolean
  }

  /**
    A custom feature dependency defines a dependency the custom feature has on an entity
    outside the custom feature. For example, a feature might be dependent on a face or a
    point and if those entities are modified the custom feature needs to recompute to be
    up to date.
    @experimental
  */
  abstract class CustomFeatureDependency extends core.Base {
    /**
      Returns the ID of this custom feature dependency.
    */
    readonly id: string
    /**
      Gets and sets the entity associated with this dependency.
    */
    entity: core.Base
    /**
      Deletes this dependency from the custom feature.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Returns the custom feature this dependency is associated with.
    */
    readonly parentCustomFeature: CustomFeature
  }

  /**
    A collection of named values. The values are strings that Fusion stores but can be
    anything you choose. If you have several things you need to save you can choose to
    combine the data into a JSON or XML representation and save it as a single custom value
    or create a new custom value or each unique value you want to store. Fusion doesn't care
    what the value is or what it represents but only saves and provides access to it.
    @experimental
  */
  abstract class CustomNamedValues extends core.Base {
    /**
      Adds or updates a value. If the specified ID does not exist, a new named value is
      added. If the ID does exist, the named value is updated with the specified value.
      @param id The ID of the value to create or change.
      @param value The string to assign to the value.
      @returns Returns true is successful and false if it failed.
    */
    addOrSetValue(id: string, value: string): boolean
    /**
      Function that returns if a value with the specified ID exists or not.
      @param id The ID of the value to check if it exists.
      @returns Returns true if a value with the ID exists.
    */
    isExistingValue(id: string): boolean
    /**
      Function that returns the specified value given its ID.
      @param id The ID of the value, which was assigned when the value was created.
      @returns Returns the value or an empty string if the specified ID was not found.
    */
    value(id: string): string
    /**
      Function that returns the name of a value specified by its index.
      @param index The index of the item within the collection to return the name of. The first item in the collection has an index of 0
      and the last item is the count of this collection minus 1.
      @returns Returns the ID of the specified item or asserts if an out of bounds index is used.
    */
    idByIndex(index: number /*unsigned int*/): string
    /**
      The number of values in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Removes the specified value from the collection.
      @param id The ID of the value to remove.
      @returns Returns true if the value was successfully removed and false if it failed.
      Failure is typically because the specified ID does not exist within the collection.
    */
    remove(id: string): boolean
  }

  /**
    A collection object that supports the ability to merge faces. Merging faces is currently
    limited to a Direct Modeling design or a body in a base feature. The result of merging faces
    is a direct B-Rep modification, and the change is not represented as a feature in the browser.
    As a result, a MergeFacesFeature object does not exist, and this collection only supports the
    merging faces and not accessing any existing features.
  */
  abstract class MergeFacesFeatures extends core.Base {
    /**
      Creates a MergeFacesFeatureInput object for defining a simple merge face feature.
      Use properties and methods on this object to define the merge you want to create and then use the Add method,
      passing in the MergeFacesFeatureInput object.
      @param inputFaces An array of BRepFace objects that define the faces the merge will be performed on.
      The faces need to be connected and from the same body (solid or surface).
      @param isChainSelection A boolean value for setting whether or not faces that are connected and from the same body
      (solid or surface) will be included in the faces to merge. The default value is false.
      @returns Returns the newly created MergeFacesFeatureInput object or null if the creation failed.
    */
    createInput(inputFaces: BRepFace[], isChainSelection?: boolean/* = false*/): MergeFacesFeatureInput | null
    /**
      Creates a new merge face feature.
      @param input A MergeFacesFeatureInput object that defines the desired merge. Use the createInput
      method to create a new MergeFacesFeatureInput object and then use methods on it
      (the MergeFacesFeatureInput object) to define the merge.
      @returns Returns true if successful. Because this is limited to direct modeling only that directly
      modifies the B-Rep body and does not create a MergeFacesFeature object there is nothing to
      return besides if the merge was successful or no.
    */
    add(input: MergeFacesFeatureInput): boolean
  }

  /**
    This class defines the methods and properties that pertain to the definition of a merge
    face feature.
  */
  abstract class MergeFacesFeatureInput extends core.Base {
    /**
      Gets and sets an array of BRepFace objects that define the faces the merge will be performed on.
      The faces need to be connected and from the same body (solid or surface).
    */
    inputFaces: BRepFace[]
    /**
      Get and sets whether or not faces that are tangentially connected and from the same body
      (solid or surface) will be included in the faces to merge
    */
    isChainSelection: boolean
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the Merge is created based on geometry (e.g. faces)
      in another component AND (Merge) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
    */
    creationOccurrence: Occurrence
  }

  /**
    Collection that provides access to all of the existing volumetric custom features in a component
    and supports the ability to create new Volumetric Custom features.
    @experimental
  */
  abstract class VolumetricCustomFeatures extends core.Base {
    /**
      The number of features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified item using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): VolumetricCustomFeature | null
    /**
      Returns the item with the specified internal name.
      @param name The name of the item.
      @returns Returns the specified item or null in the case where there is no item with the specified name.
    */
    itemByName(name: string): VolumetricCustomFeature | null
    /**
      Add a new volumetric custom feature.
      To create a new volumetric custom feature use the createInput method to create a new input
      object and use the methods and properties on that object to define the required input for a
      volumetric custom feature. Once the information is defined on the input object you can pass
      it to the add method to create the feature.
      @param input The input object for creating a volumetric custom feature.
      @returns The newly added volumetric custom feature object or null if one cannot be added.
      Only one volumetric model can be added to each body.
    */
    add(input: VolumetricCustomFeatureInput): VolumetricCustomFeature | null
    /**
      Create a new VolumetricCustomFeatureInput object.
      @param boundaryBody The boundary body for the volumetric model. Must be a BRepBody or MeshBody. Must have the same parent
      component as the VolumetricCustomFeatures.
      @returns Returns the newly created VolumetricCustomFeatureInput object or null if the creation failed.
    */
    createInput(boundaryBody: core.Base): VolumetricCustomFeatureInput | null
  }

  /**
    An input object for creating a volumetric custom feature.
    @experimental
  */
  abstract class VolumetricCustomFeatureInput extends core.Base {
    /**
      The boundary body of the volumetric model.
    */
    boundaryBody: core.Base
  }

  /**
    Object that represents an existing volumetric custom feature in a design.
    @experimental
  */
  abstract class VolumetricCustomFeature extends Feature {
    /**
      Get the volumetric model object.This property is typed as core.Base because the adsk.fusion
      library does not reference the volume library where the VolumetricModel object is defined.
      At runtime, this property will return a VolumetricModel object.
      @returns Returns the volumetric model object.
    */
    readonly volumetricModel: core.Base
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: VolumetricCustomFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: fusion.Occurrence): VolumetricCustomFeature | null
  }

  /**
    Collection that provides access to all of the existing volumetric model to mesh features in a component
    and supports the ability to create new Volumetric Model To Mesh features.
    @experimental
  */
  abstract class VolumetricModelToMeshFeatures extends core.Base {
    /**
      The number of features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified item using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): VolumetricModelToMeshFeature | null
    /**
      Returns the item with the specified name.
      @param name The name of the item.
      @returns Returns the specified item or null in the case where there is no item with the specified name.
    */
    itemByName(name: string): VolumetricModelToMeshFeature | null
    /**
      Add a new volumetric model to mesh feature. To create a new volumetric model to mesh feature use
      the createInput function to create a new input object and use the methods and proprties on that
      object to define the required input for an volumetric model to mesh feature. Once the information
      is defined on the input object you can pass it to the Add method to create the Volumetric Model to
      Mesh.
      @param input The input object for creating a volumetric model to mesh feature.
      @returns The newly added volumetric model to mesh feature.
    */
    add(input: VolumetricModelToMeshFeatureInput): VolumetricModelToMeshFeature
    /**
      Create a new VolumetricModelToMeshFeatureInput object.
      @param volumetricModel The volumetric model to be converted to a mesh. Must have the same parent component as the
      VolumetricModelToMeshFeatures. This property is typed as core.Base because the adsk.fusion
      library does not reference the volume library where the VolumetricModel object is defined.
      At runtime, this property will return a VolumetricModel object.
      @returns Returns the newly created VolumetricModelToMeshFeatureInput object or null if the creation failed.
    */
    createInput(volumetricModel: core.Base): VolumetricModelToMeshFeatureInput | null
  }

  /**
    List of Volumetric Model to Mesh Refinement Types.
    @experimental
  */
  const enum VolumetricMeshRefinementTypes {
    /**
      Creates a high resolution mesh from the volumetric model.
    */
    VolumetricMeshRefinementHighType,
    /**
      Creates a medium resolution mesh from the volumetric model.
    */
    VolumetricMeshRefinementMediumType,
    /**
      Creates a low resolution mesh from the volumetric model.
    */
    VolumetricMeshRefinementLowType,
    /**
      Creates a custom resolution mesh from the volumetric model.
    */
    VolumetricMeshRefinementCustomType,
  }

  /**
    List of Meshing Approaches for converting a volumetric model to a mesh.
    @experimental
  */
  const enum VolumetricMeshingApproachTypes {
    /**
      Mesh the volumetric model using advanced techniques that preserve sharp features on the boundary of the model.
    */
    VolumetricMeshingAdvancedType,
    /**
      Mesh the volumetric model using the original meshing techniques.
    */
    VolumetricMeshingOriginalType,
  }

  /**
    An input object for creating a volumetric model to mesh feature.
    @experimental
  */
  abstract class VolumetricModelToMeshFeatureInput extends core.Base {
    /**
      Gets and sets the volumetric model to be converted to a mesh. The volumetric model must have the
      same parent component as the VolumetricModelToMeshFeature.This property is typed as core.Base
      because the adsk.fusion library does not reference the volume library where the VolumetricModel object
      is defined. At runtime, this property will return a VolumetricModel object.
    */
    volumetricModel: core.Base
    /**
      Gets and sets the refinement type to be used when creating the mesh. The default is Low.
    */
    refinementType: VolumetricMeshRefinementTypes
    /**
      Gets and sets the element size to be used when creating the mesh. This value is only used when the
      RefinementType is set to Custom. The value must be greater than 0. The default is equivalent to the
      Low refinement type and is dependent on the size of the model.
    */
    elementSize: core.ValueInput
    /**
      Gets and sets the meshing approach to be used when creating the mesh.
      The default is VolumetricMeshingAdvancedType.
    */
    meshingApproach: VolumetricMeshingApproachTypes
    /**
      Gets and sets if the volumetric model should be removed after creating the mesh.
      the default is true.
    */
    isVolumetricModelRemoved: boolean
    /**
      Gets and sets if small mesh shells should be removed after creating the mesh.
      The default is false.
    */
    isSmallShellsRemoved: boolean
    /**
      Gets and Sets the small mesh threshold used to determine if a mesh shell is considered small.
      The value is a fraction of the total mesh area and must be between 0 and 1. The default is 0.02.
    */
    smallShellThreshold: core.ValueInput
    /**
      Gets and sets if the feature compute should be suspended if a dependent entity changes. Default is false.
      If true, the feature will need to be recomputed manually if a dependent entity changes.
      The default is false.
    */
    isComputeSuspended: boolean
  }

  /**
    @experimental
  */
  abstract class VolumetricModelToMeshFeature extends Feature {
    /**
      Get the mesh body created from the volumetric model.
      @returns Returns the mesh body object.
    */
    readonly meshBody: MeshBody
    /**
      Gets and sets the volumetric model to be converted to a mesh. The volumetric model must have the
      same parent component as the VolumetricModelToMeshFeature.This property is typed as core.Base
      because the adsk.fusion library does not reference the volume library where the VolumetricModel object
      is defined. At runtime, this property will return a VolumetricModel object.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    volumetricModel: core.Base
    /**
      Gets and sets the refinement type to be used when creating the mesh.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    refinementType: VolumetricMeshRefinementTypes
    /**
      Gets the element size that will be used when creating the mesh. This value is only used when the
      refinement type is set to Custom. The value must be greater than 0.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    readonly elementSize: ModelParameter
    /**
      Gets and sets the meshing approach to be used when creating the mesh.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    meshingApproach: VolumetricMeshingApproachTypes
    /**
      Gets and sets if the volumetric model should be removed after creating the mesh.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isVolumetricModelRemoved: boolean
    /**
      Gets and sets if small mesh shells should be removed after creating the mesh.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isSmallShellsRemoved: boolean
    /**
      Gets the small mesh threshold used to determine if a mesh shell is considered small.
      The value is a fraction of the total mesh area and must be between 0 and 1.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    readonly smallShellThreshold: ModelParameter
    /**
      Gets and sets if the feature compute should be suspended if a dependent entity changes.
      If true, the feature will need to be recomputed manually if a dependent entity changes.
      To set this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    isComputeSuspended: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: VolumetricModelToMeshFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: fusion.Occurrence): VolumetricModelToMeshFeature | null
  }

  /**
    <p>Fusion Default Units for Design Preferences. The following code can be used to access this object.</p>
    <pre class="api-code">unitPrefs = app.preferences.defaultUnitsPreferences.itemByName('Design')</pre>
  */
  abstract class FusionDefaultUnitsPreferences extends core.DefaultUnitsPreferences {
    /**
      Gets and sets the default design units for length when creating a new Fusion file.
      Setting this property will have the side effect of changing the defaultUnitSystem
      property to custom.
    */
    distanceDisplayUnits: DistanceUnits
    /**
      Gets and sets the default design units for mass when creating a new Fusion file.
      Setting this property will have the side effect of changing the defaultUnitSystem
      property to custom.
    */
    massDisplayUnits: MassUnits
    /**
      Gets and sets the default unit system when creating a new Fusion file.
    */
    defaultUnitSystem: UnitSystems
  }

  /**
    Fusion General Design Preferences
  */
  abstract class FusionProductPreferences extends core.ProductPreferences {
    /**
      Gets and sets the Active Component Visibility option
    */
    isActiveComponentVisibilityUsed: boolean
    /**
      Gets and sets the default modeling type setting
    */
    defaultDesignType: DefaultDesignTypeOptions
    /**
      Gets and sets the Default workspace setting. (Model, Sculpt or Patch)
    */
    defaultWorkspace: DefaultWorkspaces
    /**
      Gets and sets the Animate joint preview option
    */
    isJointPreviewAnimated: boolean
    /**
      Gets and sets the Allow 3D sketching of lines and splines option
      which controls if 3D sketching is allowed or if sketching is forced to
      be on the x-y plane of the sketch.
    */
    is3DSketchingAllowed: boolean
    /**
      Gets and sets the Show ghosted result body option
    */
    isGhostedResultBodyShown: boolean
    /**
      Gets and sets if dimension value is edited when the dimension is created.
    */
    isDimensionEditedWhenCreated: boolean
    /**
      This property has been replaced by the isAutoLookAtSketch2 property, which
      provides the full capabilities.
      @remarks
      Gets and sets if the view is re-oriented to view the newly created sketch.
      @deprecated
    */
    isAutoLookAtSketch: boolean
    /**
      Gets and Sets if geometry, not in the active sketch plane, is to be automatically projected.
    */
    isAutoProjectGeometry: boolean
    /**
      Gets and sets if model edges should be automatically projected when creating
      constraints and dimensions in the active sketch when the orientation is normal
      to the active sketch plane.
    */
    isAutoProjectEdgesOnReference: boolean
    /**
      Gets and sets if the sketch should be automatically hidden whenever
      a feature is created from it.
    */
    isAutoHideSketchOnFeatureCreation: boolean
    /**
      Gets and sets if the sketch geometry is automatically scaled when
      the first dimension is added.
    */
    isSketchScaledWithFirstDimension: boolean
    /**
      Gets and sets if you can create associative references while editing
      external components in context.
    */
    isAllowReferencesDuringEditInPlace: boolean
    /**
      Gets and sets if the Arrange, Remove Features, Remove Faces, and
      Replace with Primitives commands should be added to the Modify menu
      in the Design workspace.
    */
    isEnableArrangeAndSimplifyTools: boolean
    isFirstComponentGroundToParent: boolean
  }

  /**
    The different options for the AutoLookAtSketch preference setting.
  */
  const enum AutoLookAtSketchSettings {
    /**
      Turn off the Auto Look at Sketch functionality.
    */
    OffAutoLookAtSketchSetting,
    /**
      Turn on the Auto Look at Sketch functionality and use the current
      camera setting when looking at the sketch.
    */
    UserCameraAutoLookAtSketchSetting,
    /**
      Turn on the Auto Look at Sketch functionality and use an orthographic
      camera when looking at the sketch.
    */
    AlwaysOrthographicAutoLookAtSketchSetting,
  }

  /**
    The valid options for the default modeling type setting.
  */
  const enum DefaultDesignTypeOptions {
    /**
      Prompt the user for the design type.
    */
    PromptForDesignTypeOption,
    /**
      Create a direct edit (non-parametric) design.
    */
    DirectDesignTypeOption,
    /**
      Create a parametric design.
    */
    ParametricDesignTypeOption,
  }

  /**
    The valid options for the Default workspaces setting.
  */
  const enum DefaultWorkspaces {
    /**
      The model workspace.
    */
    ModelWorkspace,
    /**
      The sculpt workspace.
    */
    SculptWorkspace,
    /**
      The patch workspace.
    */
    PatchWorkspace,
  }

  /**
    Object that represents a Fusion specific document.
  */
  abstract class FusionDocument extends core.Document {
    /**
      Returns the design associated with this Fusion document.
    */
    readonly design: Design
  }

  /**
    Object that represents an open Fusion design. This derives from the
    Product base class and adds the Fusion functionality specific to a Design.
  */
  abstract class Design extends core.Product {
    /**
      Gets and sets the current design type (DirectDesignType or ParametricDesignType)
      Changing an existing design from ParametricDesignType to DirectDesignType will result in the timeline and all design
      history being removed and further operations will not be captured in the timeline.
    */
    designType: DesignTypes
    /**
      Returns the root Component.
    */
    readonly rootComponent: Component
    /**
      Returns the Components collection that provides access to existing components
      in a design.
    */
    readonly allComponents: Components
    /**
      Returns the current edit target as seen in the user interface. This edit target
      is defined as the container object that will be added to if something is created.
      For example, a component can be an edit target so that when new bodies are created they
      are added to that component. A sketch can also be an edit target.
    */
    readonly activeEditObject: core.Base
    /**
      Returns the component that is current being edited. This can return the root component
      or another component within the design.
    */
    readonly activeComponent: Component
    /**
      Returns the Snapshots object associated with this design which provides access to the
      existing snapshots and the creation of new snapshots.
    */
    readonly snapshots: Snapshots
    /**
      Returns the timeline associated with this design.
    */
    readonly timeline: Timeline
    /**
      Returns the collection of User Parameters in a design
    */
    readonly userParameters: UserParameters
    /**
      Returns a read only list of all parameters in the design. This includes
      the user parameters and model parameters from all components in this design. The parameters from Externally Referenced components
      are NOT included because they are in actuality, separate designs.
    */
    readonly allParameters: ParameterList
    /**
      Returns a specialized UnitsManager that can set the default length units and work
      with parameters.
    */
    readonly fusionUnitsManager: FusionUnitsManager
    /**
      Returns the ExportManager for this design. You use the ExportManager
      to export the current design in various formats.
    */
    readonly exportManager: ExportManager
    /**
      Gets whether the root component is the active edit target in the user interface.
      This is the same as checking the state of the radio button next to the root component in the browser.
      To activate the root component use the ActivateRootComponent method.
    */
    readonly isRootComponentActive: boolean
    /**
      Makes the root component the active component in the user interface. This is the same
      as enabling the radio button next to the root component in the browser.
      @returns Returns true if the activation was successful.
    */
    activateRootComponent(): boolean
    /**
      Returns the materials contained in this document.
    */
    readonly materials: core.Materials
    /**
      Returns the appearances contained in this document.
    */
    readonly appearances: core.Appearances
    /**
      Creates an InterferenceInput object. This object collects the entities and options that are
      used when calculating interference. To analyze interference you first create an InterferenceInput
      supplying the entities and set any other settings and then provide this object as input to the
      analyzeInterference method.
      @param entities An ObjectCollection containing the BRepBody and/or Occurrence entities that will be used in the
      interference calculation. All entities must be in the context of the root component of the top-level design.
      @returns Returns an InterferenceInput object which you can use to set any other interference settings and then
      use as input to the analyzeInterference method to calculate the interference. Returns null if the
      creation failed.
    */
    createInterferenceInput(entities: core.ObjectCollection): InterferenceInput | null
    /**
      Calculates the interference between the input bodies and/or occurrences.
      @param input An InterferenceInput that defines all of the necessary input needed to calculate the interference.
      An InterferenceInput object is created using the createInterferenceInput method.
      @returns Returns an InterferenceResults object that can be used to examine the interference results.
    */
    analyzeInterference(input: InterferenceInput): InterferenceResults
    /**
      Returns the occurrence that is currently activated, if any. This can return null in the case
      where no occurrence is activated and the root component is active.
    */
    readonly activeOccurrence: Occurrence
    /**
      Returns the AreaProperties object that has properties for getting the area, perimeter, centroid, etc
      for a collection of 2D sketch profiles and/or planar surfaces that all lie on the same plane.
      @param inputs A collection of one or more 2D sketch profile and/or planar surface input objects to perform the calculations on.
      Supported input object types are 2D closed sketch profiles and planar surfaces. Object must all lie on the same plane.
      Calculation results reflect the sums of the input objects (i.e. total area of multiple sketch profiles)
      @param accuracy Specifies the desired level of computational accuracy of the property calculations.
      The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
      @returns Returns an AreaProperties object that can be used to examine the area results.
    */
    areaProperties(inputs: core.ObjectCollection, accuracy?: CalculationAccuracy/* = CalculationAccuracy.LowCalculationAccuracy*/): AreaProperties
    /**
      Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc
      for a collection of 3D solid objects.
      @param inputs A collection of one or more 3D solid input objects to perform the calculations on.
      Supported input object types are Components, Occurrences and BRepBodies.
      Calculation results reflect the sums of the input objects (i.e. total volume of multiple bodies)
      @param accuracy Specifies the desired level of computational accuracy of the property calculations.
      The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
    */
    physicalProperties(inputs: core.ObjectCollection, accuracy?: CalculationAccuracy/* = CalculationAccuracy.LowCalculationAccuracy*/): PhysicalProperties
    /**
      Returns the contact sets associated with this design.
    */
    readonly contactSets: ContactSets
    /**
      Gets and sets whether contact analysis is enabled for all components. This
      is the equivalent of the "Disable Contact / Enable Contact" command. If this
      if True then any contact analysis defined (either all or contact sets) is enabled.
      if False, then no contact analysis is performed.
    */
    isContactAnalysisEnabled: boolean
    /**
      Gets and sets whether contact analysis is done using contact sets
      or between all bodies, independent of any contact sets. If True and
      the isContactAnalysisEnabled property is True then contact analysis
      is performed using contact sets. If False and isContactAnalysisEnabled
      is True, then contact analysis is performed between all bodies. If
      isContactAnalysisEnabled is False then no contact analysis is performed.
    */
    isContactSetAnalysis: boolean
    /**
      Returns the entities associated with the provided token. The return is an
      array of entities. In most cases an array containing a single entity will be returned but
      there are cases where more than one entity can be returned. An example of this
      is where a token is obtained from a face and subsequent modeling operations cause
      the face to be split into two or more pieces. All of the faces that represent
      the original face will be returned with the first face being the most logical
      match to the original face.
      @param entityToken The input entity token you want to find the matching entity for.
      @returns Returns an array of entities associated with the provided token, or an empty array
      in the case where there are no matches.
    */
    findEntityByToken(entityToken: string): core.Base[]
    /**
      Forces a recompute of the entire design. This is the equivalent of the "Compute All"
      command.
      @returns Returns true if the compute completed. This doesn't indicate if all the items in the
      timeline successfully computed or not. You need to check the health state of each item
      in the timeline to determine if everything successfully computed or not.
    */
    computeAll(): boolean
    /**
      Modifies the values of many parameters all at once. Changing them all at once is more efficient
      than modifying them one at a time.
      @param parameters An array of UserParameter and ModelParameter objects that you want to change the value. The parameters
      must all exist within the Design object you're calling this method from. They can be in any component
      but must be local components owned by the Design.
      @param values An array of ValueInput objects that defines the new value for each parameter defined by the "parameters" argument.
      This array must be the same size as the array used for the "parameters" argument, and the items in the arrays are
      used in the order they exist within the arrays. For example, the parameter at index 0 will use the value at index 0.
      If you use the createByString method to create the ValueInput, the expression of the parameter will be edited, and
      the effect is the same as interactively editing the expression.When you set the expression, you can include units,
      references to other parameters, and math operators and functions.For example, "(Length / 3) * cos(Angle)" is a valid
      expression for a distance parameter if the parameters "Length" and "Angle" already exist.
      If you use the createByReal method, the value is assigned directly and is always in the internal units for the unit
      type associated with the parameter.For example, if the parameter is a length, the value will ALWAYS be used as
      centimeters. If the parameter is an angle, the value will ALWAYS be used as radians.This is because the default design
      unit types for length are ignored, and internal units are ALWAYS used.
      @returns Returns true if setting all of the parameters was successful. Setting multiple parameters is either all or none. If it
      fails to set any parameters, none of them are updated, and the method will return false.
    */
    modifyParameters(parameters: Parameter[], values: core.ValueInput[]): boolean
    /**
      Gets the collection of sheet metal rules in the design.
    */
    readonly designSheetMetalRules: SheetMetalRules
    /**
      Gets the collection of sheet metal rules in the sheet metal rule library.
    */
    readonly librarySheetMetalRules: SheetMetalRules
    /**
      Gets the collection of design analyses associated with this design.
    */
    readonly analyses: Analyses
    /**
      Returns the RenderManager object associated with this design. Using the RenderManager you can access the
      same functionality that is available in the Render workspace.
    */
    readonly renderManager: RenderManager
    /**
      Converts this design into a configured design. The returned ConfigurationTable
      has a single row and no columns. You can use it to add columns and rows to define
      the configuration.
      @returns Returns the ConfigurationTable that defines the configurations for this design.
    */
    createConfiguredDesign(): ConfigurationTopTable
    /**
      Gets if this design is a configured design. A configured design contains a
      configuration table. Use the configurationTable property to get the associated table.
    */
    readonly isConfiguredDesign: boolean
    /**
      If this design is a configured design or a configuration, this property returns the associated
      ConfigurationTopTable object. If this is not a configured design or configuration, this property
      returns null.
    */
    readonly configurationTopTable: ConfigurationTopTable
    /**
      Gets if this design is a configuration. If this returns true,
      the configurationRowId can be used to get the row used to define this configuration.
      Also, when this is true, the design is essentially read-only and edits are either
      blocked from taking place or cannot be saved.
    */
    readonly isConfiguration: boolean
    /**
      Returns the ID of the row that defines this configuration. Use the
      isCongiguration property to determine if this Design is a configuration
      or not. If this is not a configuration, this property returns an
      empty string.
    */
    readonly configurationRowId: string
    /**
      Gets the collection of plastic rules in the design.
    */
    readonly designPlasticRules: PlasticRules
    /**
      Gets the collection of plastic rules in the plastic rule library.
    */
    readonly libraryPlasticRules: PlasticRules
    /**
      Get the root DataComponent in this design. This is only available for top level designs.
      @experimental
    */
    readonly rootDataComponent: core.DataComponent
  }

  /**
    A type of product that utilizes the internal "Working Model" functionality within Fusion.
    This is used where a model is referenced into another product. For example, when you create a
    Manufacturing Model, you see a copy of the original design, but you can make isolated edits to
    it within the Manufacturing Model. This is using the internal Working Model functionality to
    create an associative reference to a specific component.
  */
  abstract class WorkingModel extends Design {
    /**
      Returns the component being referenced by this working model.
    */
    readonly sourceComponent: Component
  }

  /**
    Used to gather and define the various inputs and settings needed to calculate interference. This
    object is created using the Design.createInterferenceInput method.
  */
  abstract class InterferenceInput extends core.Base {
    /**
      Gets and set an ObjectCollection containing BRepBody and/or Occurrence entities that
      will be used when checking for interference. All entities must be in the context of
      the root component of the top-level design.
    */
    entities: core.ObjectCollection
    /**
      Gets and sets whether any coincident faces in the input bodies are considered as interference
      or not. This property defaults to False for a newly created InterferenceInput object.
    */
    areCoincidentFacesIncluded: boolean
  }

  /**
    Transient object used to return the result of an interference analysis.
  */
  abstract class InterferenceResults extends core.Base {
    /**
      Function that returns the specified interference result using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): InterferenceResult | null
    /**
      Returns the number of interference results in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates bodies in the model that represent the interference volumes.
      This is not supported in parametric modeling.
      @param allInterferenceBodies Sets if all bodies or only individual bodies will be created as bodies in the model.
      If False, then only interferenceResult objects whose isCreateBody property is true
      will be created as a model body. If true, all interface volumes will be created as
      a body regardless of the value of the isCreateBody property on each InterferenceResult object.
      @returns Returns an ObjectCollection containing the bodies that were created.
    */
    createBodies(allInterferenceBodies: boolean): core.ObjectCollection
  }

  /**
    Represents the interference between bodies and/or occurrences in an interference analysis.
  */
  abstract class InterferenceResult extends core.Base {
    /**
      Returns the first entity involved in the interference
    */
    readonly entityOne: core.Base
    /**
      Returns the second entity involved in the interference
    */
    readonly entityTwo: core.Base
    /**
      Returns a transient BRepBody that represents the volume of interference.
    */
    readonly interferenceBody: BRepBody
    /**
      Gets and sets if this interference volume should be created as a model body. Setting
      this to true doesn't create the body just indicates that a body is desired. Calling
      the createBodies method on the interferenceResults object will result in the creation
      of the model body if this property is true.
    */
    isCreateBody: boolean
  }

  /**
    Fusion design types
  */
  const enum DesignTypes {
    /**
      Direct modeling design.
    */
    DirectDesignType,
    /**
      Parametric modeling design.
    */
    ParametricDesignType,
  }

  /**
    Utility class used to work with Values and control default design units.
    Internal values are held in SI units (e.g. seconds, radians, kg for time, angle, mass)
    with the exception that all lengths are in cm rather than meter and this affects derived
    units (e.g. velocity is cm/s, volume is cm^3). Units are specified flexibly via strings
    (e.g. "cm", "in", "inch", "cm^3", "cm*cm*cm", "mph", "mps" "m/s").
  */
  abstract class FusionUnitsManager extends core.UnitsManager {
    /**
      Returns the parent design
    */
    readonly design: Design
    /**
      Gets and sets the default distance units for this design. Setting this
      property has the side effect of changing the unitSystem
      property to custom.
    */
    distanceDisplayUnits: DistanceUnits
    /**
      Gets and sets the default mass units for this design. Setting this property
      has the side effect of changing the unitSystem property to custom.
    */
    massDisplayUnits: MassUnits
    /**
      Gets and sets the pre-defined combination of length and mass units to use for the
      units in the design. The distanceDisplayUnits and massDisplayUnits properties provide
      a way to get the current setting for distance and mass and to modify them to other values
      besides the predefined combinations. When a custom unit system is specified, any combination
      of distance and mass can be specified.
    */
    unitSystem: UnitSystems
  }

  /**
    Predefined combinations of length and mass units used
    for units in the design.
  */
  const enum UnitSystems {
    /**
      A custom unit system that supports any combination of
      distance and mass units as the default units of the design.
    */
    CustomUnitSystem,
    /**
      Specifies millimeters as the default distance units and grams
      as the default mass units of the design.
    */
    MillimeterGramUnitSystem,
    /**
      Specifies centimeters as the default distance units and grams
      as the default mass units of the design.
    */
    CentimeterGramUnitSystem,
    /**
      Specifies meters as the default distance units and kilograms
      as the default mass units of the design.
    */
    MeterKilogramUnitSystem,
    /**
      Specifies inches as the default distance units and ounces
      as the default mass units of the design.
    */
    InchOunceUnitSystem,
    /**
      Specifies feet as the default distance units and pounds
      as the default mass units of the design.
    */
    FootPoundUnitSystem,
  }

  /**
    Valid unit types for distance.
  */
  const enum DistanceUnits {
    /**
      Millimeter
    */
    MillimeterDistanceUnits,
    /**
      Centimeter
    */
    CentimeterDistanceUnits,
    /**
      Meter
    */
    MeterDistanceUnits,
    /**
      Inch
    */
    InchDistanceUnits,
    /**
      Foot
    */
    FootDistanceUnits,
    /**
      Yard
    */
    YardDistanceUnits,
    /**
      Micron
    */
    MicronDistanceUnits,
    /**
      Hectometer
    */
    HectometerDistanceUnits,
    /**
      Mile
    */
    MileDistanceUnits,
    /**
      Mil (One thousandth of an inch)
    */
    MilDistanceUnits,
    /**
      Nautical Mile
    */
    NauticalMileDistanceUnits,
  }

  /**
    Valid unit types for mass.
  */
  const enum MassUnits {
    /**
      Grams
    */
    GramMassUnits,
    /**
      Kilograms
    */
    KilogramMassUnits,
    /**
      Pounds
    */
    PoundMassUnits,
    /**
      Ounces
    */
    OunceMassUnits,
    /**
      Tons
    */
    TonMassUnits,
    /**
      Slugs
    */
    SlugMassUnits,
  }

  /**
    The various states that a feature can be in. This is used for the
    states of modeling features, construction geometry, and sketches.
  */
  const enum FeatureHealthStates {
    /**
      The feature, construction geometry, or sketch is successfully computed.
    */
    HealthyFeatureHealthState = 0,
    /**
      The feature, construction geometry, or sketch has a warning. Use the errorOrWarningMessage property to get the message.
    */
    WarningFeatureHealthState = 1,
    /**
      The feature, construction geometry, or sketch has an error. Use the errorOrWarningMessage property to get the message.
    */
    ErrorFeatureHealthState = 2,
    /**
      The feature, construction geometry, or sketch is suppressed so it has not computed.
    */
    SuppressedFeatureHealthState = 3,
    /**
      The feature, construction geometry, or sketch is rolled back so it has not computed.
    */
    RolledBackFeatureHealthState = 4,
    /**
      The state of the object is unknown. This can occur in the case where the object being queried
      is a TimelineObject whose associated entity does not have a health state. For example, if it
      is a TimelineGroup or an position snapshot.
    */
    UnknownFeatureHealthState = 5,
  }

  /**
    Provides access to the Snapshots within a design and provides
    methods to create new Snapshots.
  */
  abstract class Snapshots extends core.Base {
    /**
      Creates a new snapshot. Creating a snapshot is only valid when the HasPendingTransforms property returns true.
      @returns Returns the newly created snapshot.
    */
    add(): Snapshot
    /**
      Function that returns the specified snapshot in the collection using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Snapshot | null
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Indicates if there are any changes that have been made than can be snapshot.
    */
    readonly hasPendingSnapshot: boolean
    /**
      Reverts and changes that have been made that can be snapshot. This effectively
      reverts the design back to the last snapshot. This is only valid when the
      HasPendingSnapshot property returns true.
      @returns Returns true if the revert was successful.
    */
    revertPendingSnapshot(): boolean
  }

  /**
    Object that represents a Snapshot in the timeline
  */
  abstract class Snapshot extends core.Base {
    /**
      Gets and sets the name of the snapshot as seen in the timeline.
    */
    name: string
    /**
      Returns the timeline object associated with this snapshot.
    */
    readonly timelineObject: TimelineObject
    /**
      Deletes this snapshot.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
  }

  /**
    A collection of TimelineObjects in a parametric design.
  */
  abstract class Timeline extends core.Base {
    /**
      Moves the marker to the beginning of the timeline.
      @returns Returns true if the move is successful
    */
    moveToBeginning(): boolean
    /**
      Moves the marker to the end of the timeline.
      @returns Returns true if the move is successful
    */
    moveToEnd(): boolean
    /**
      Moves the marker to the next step in the timeline.
      @returns Returns true if the move is successful
    */
    movetoNextStep(): boolean
    /**
      Moves the marker to the previous step in the timeline.
      @returns Returns true if the move is successful
    */
    moveToPreviousStep(): boolean
    /**
      Plays the timeline beginning at the current position of the marker.
      @returns Returns true if playing the timeline was successful
    */
    play(): boolean
    /**
      Gets and sets the current position of the marker where
      0 is at the beginning of the timeline and the value of Timeline.count is the end of the
      timeline.
    */
    markerPosition: number /*int*/
    /**
      Function that returns the specified item in the timeline using an index into the collection.
      The items are returned in the order they appear in the timeline.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified TimeLineObject or null if an invalid index was specified. A TimeLineObject
      represents both a simple timeline object like a feature or sketch, but is also the base class
      for the TimelineGroup object. This means the this method can return a TimelineObject or a
      TimelineGroup.
    */
    item(index: number /*unsigned int*/): TimelineObject | null
    /**
      Returns the number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the collection of groups within the timeline.
    */
    readonly timelineGroups: TimelineGroups
    /**
      Deletes all objects in the timeline that are after the current position of the marker.
      @returns Returns true if successful.
    */
    deleteAllAfterMarker(): boolean
  }

  /**
    Represents an object in the timeline.
  */
  abstract class TimelineObject extends core.Base {
    /**
      Gets and sets if this object is suppressed.
    */
    isSuppressed: boolean
    /**
      Returns the parent group, if this object is part of a group.
      Returns null if this object is not part of a group.
    */
    readonly parentGroup: TimelineGroup
    /**
      Returns the position of this item within the timeline where
      the first item has an index of 0.
      This property can return -1 in the two cases where this object
      is not currently represented in the timeline. The two cases are:
      1. When this is a TimelineGroup object and the group is expanded.
      2. When this object is part of a group and the group is collapsed.
    */
    readonly index: number /*int*/
    /**
      Indicates if this item is currently not being computed
      because it has been rolled back.
      If this is a timelineGroup object and the group is expanded
      the value of this property should be ignored.
    */
    readonly isRolledBack: boolean
    /**
      Rolls the timeline by repositioning the marker to either before or after this object.
      This method will fail if this is a timelineGroup object and the group is expanded.
      @param rollBefore Set rollBefore to true to reposition the marker before this object or to false to
      reposition the marker after this object
      @returns Returns true if the move was successful
    */
    rollTo(rollBefore: boolean): boolean
    /**
      Returns the entity associated with this timeline object.
      Edit operations can be performed by getting the object
      representing the associated entity and using the methods
      and properties on that entity to make changes.
      Returns null if this TimelineObject represents a TimelineGroup object,
      since it does not have an associated entity.
    */
    readonly entity: core.Base
    /**
      Checks to see if this object can be reordered to the specified position.
      The default value of -1 indicates the end of the timeline.
      This method will fail if this is a timelineGroup object and the group is expanded.
      @param beforeIndex The index number of the position in the timeline to check
      @returns Returns true if the object can be reordered to the specified position
    */
    canReorder(beforeIndex?: number /*int*//* = -1*/): boolean
    /**
      Reorders this object to the position specified.
      The default value of -1 indicates the end of the timeline.
      @param beforeIndex The index number of the position in the timeline to place this object before
      @returns Returns true if the reorder operation was successful
      This method will fail and return false if this is a timelineGroup object and the
      group is expanded.
    */
    reorder(beforeIndex?: number /*int*//* = -1*/): boolean
    /**
      Indicates if this TimelineObject represents a group. If True you can
      operate on this object as a TimelineGroup object.
    */
    readonly isGroup: boolean
    /**
      Gets and sets the name of this timeline object. This name is shared by the object
      the timeline object represents. For example, if the TimelineObject represents a Sketch
      and you change the name using the TimelineObject, the name of the sketch in the browser
      is also changed. The reverse is also true. Setting the name of an object sketch, feature
      construction geometry, etc, will also change the name of the associated node in the timeline.
    */
    name: string
    /**
      Returns the current health state of the object associated with this TimelineObject.
    */
    readonly healthState: FeatureHealthStates
    /**
      Returns the error or warning message in the case where the healthState property returns either
      WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
    */
    readonly errorOrWarningMessage: string
  }

  /**
    Provides access to the time line groups within a design and provides
    methods to create new groups.
  */
  abstract class TimelineGroups extends core.Base {
    /**
      Creates a new group within the timeline. The sequential set of items defined
      by the start and end indices will be included in the group. A group cannot contains
      another group so none of the items being grouped can be a group of this will fail.
      @param startIndex The index of the first item in the timeline that will be added to the group.
      @param endIndex The index of the last item in the timeline that will be added to the group.
      @returns Returns the created TimelineGroup object or null in the case of failure.
    */
    add(startIndex: number /*int*/, endIndex: number /*int*/): TimelineGroup | null
    /**
      Function that returns the specified timeline group using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): TimelineGroup | null
    /**
      Returns the number of items in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents a group in the timeline.
  */
  abstract class TimelineGroup extends TimelineObject {
    /**
      Deletes the group with the option of deleting or keeping the contents.
      @param deleteGroupAndContents Indicates if the group and its contents should be deleted or if only the group
      should be deleted and the contents kept and expanded. A value of true will delete
      the group and its contents.
      @returns Returns true if the delete was successful.
    */
    deleteMe(deleteGroupAndContents: boolean): boolean
    /**
      Indicates if the group is collapsed or expanded.
    */
    isCollapsed: boolean
    /**
      Function that returns the specified timeline object within the group using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): TimelineObject | null
    /**
      The number of items in the group.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Transient object used to pass a set of parameters.
  */
  abstract class ParameterList extends core.Base {
    /**
      Function that returns the specified parameter using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Parameter | null
    /**
      Returns the specified parameter using the name of the parameter
      as it is displayed in the parameters dialog
      @param name The name of the parameter as it is displayed in the parameters dialog
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): Parameter | null
    /**
      Returns the number of parameters in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Adds a parameter to the list. This does not create a
      new parameter, it adds an existing parameter to the list.
      Note that duplicates can exist in the list.
      @param parameter The existing parameter to add to the list
      @returns Returns true if successful. This method will fail if the list is read-only
    */
    add(parameter: Parameter): boolean
    /**
      Method that removes a parameter from the list using the index of the item
      in the list
      Will fail if the list is read only.
      @param index The index of the parameter to be removed from the list
      @returns Returns true if successful. This method will fail if the list is read-only
    */
    removeByIndex(index: number /*unsigned int*/): boolean
    /**
      Method that removes a parameter from the list by specifying the parameter (item)
      to remove
      @param item The parameter item to remove from the list
      @returns Returns true if successful. This method will fail if the list is read-only
    */
    removeByItem(item: Parameter): boolean
    /**
      Finds the specified parameter in the list. The search can be started at a specified
      index rather than from the beginning of the list.
      If not found, -1 is returned.
      @param parameter The parameter to find
      @param startIndex the index in the list to start the search from
      @returns Returns the index of the parameter found in the list.
    */
    find(parameter: Parameter, startIndex?: number /*unsigned int*//* = 0*/): number /*int*/
    /**
      Indicates whether or not ParameterList collection contains a specified parameter
      @param parameter The parameter to look for in the list
      @returns Returns true if list contains the specified parameter
    */
    contains(parameter: Parameter): boolean
    /**
      Indicates if the list is read-only
      Some lists returned by API calls (instead of lists created by the
      user) are read only. Items cannot be added or remove from such a list.
    */
    readonly isReadOnly: boolean
    /**
      Creates a parameter list that the client can use for various purposes.
      Use ParameterList.Add to add parameters to the list after creating it.
      @returns Returns a ParameterList
    */
    static create(): ParameterList
  }

  /**
    Provides access to the Model Parameters within a component.
  */
  abstract class ModelParameters extends core.Base {
    /**
      Function that returns the specified Model Parameter using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ModelParameter | null
    /**
      Function that returns the specified Model Parameter using the name of the parameter as it is
      displayed in the parameters dialog.
      @param name The name of the Model Parameter as it is displayed in the parameters dialog
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): ModelParameter | null
    /**
      Returns the number of parameters in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the component that owns the Model Parameters collection
    */
    readonly component: Component
  }

  /**
    Provides access to the User Parameters within a design and provides
    methods to create new user parameters.
  */
  abstract class UserParameters extends core.Base {
    /**
      Function that returns the specified User Parameter using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): UserParameter | null
    /**
      Function that returns the specified User Parameter using the name of the parameter
      as it is displayed in the parameters dialog.
      @param name The name of the User Parameter as it is displayed in the parameters dialog
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): UserParameter | null
    /**
      Returns the number of parameters in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the design that owns the user parameters collection.
    */
    readonly design: Design
    /**
      Adds a new user parameter to the collection.
      @param name The name of the parameter. This is the name shown in the parameters dialog
      @param value ValueInput object that specifies the value of the parameter. If the ValueInput was created using a real,
      the value will be interpreted using the internal unit for the unit type specified by the "units" argument.
      For example, if the ValueInput was created using the real value 5 and the input to the "units" argument is
      any valid length unit, the value will be interpreted as 5 centimeters since centimeters is the internal unit
      for lengths. If the "units" argument is a valid angle unit the value will be interpreted as 5 radians.
      If the ValueInput was created using a string, the string is used as-is for the expression of the parameter.
      For value parameters, this means if there are units as part of the string, it must evaluate to the same unit
      type as that specified by the "units" argument and if no units are specified it will use the current default
      units specified for the current document. For example, if the ValueInput was created with the string "5 in",
      then the "units" argument must define any valid length so they are compatible. If the ValueInput was created
      with the string "5", any unit type can be used and the result will be 5 of that unit.
      If the "units" argument is "Text" then a text parameter will be created using the value provided as the expression.
      When using a ValueInput created using a string, it's the same as creating a parameter in the user-interface.
      You can specify any valid expression, i.e. "5", "5 in", "5 in / 2", "5 + Length", etc. and you can choose
      from many different types of units. The only requirement is that the units must match in type. For example,
      they must both be lengths, or they must both be angles.
      @param units The units to use for the value of the parameter. The use of any of the measurement units will result in the
      creation of a numeric parameter. The units specified must match the units specified (if any) in the ValueInput object.
      To create a parameter with no units, you can specify an empty string as the units, which will also create a
      numeric parameter. To create a text parameter, use "Text" as the unit type.
      @param comment The comment to display in the parameters dialog. Specify an empty string ("") for no comment
      @returns Returns the newly created UserParameter or null if the creation failed.
    */
    add(name: string, value: core.ValueInput, units: string, comment: string): UserParameter | null
    /**
      Returns the user parameters in the design as an array.
      @returns Returns an array of the user parameters in the design.
    */
    asArray(): UserParameter[]
    /**
      Function that exports a list of user parameters to a csv file.
      @param userParameterArray The array of user parameters to export.
      @param filename The full filename (path and file) of the file to write the parameters to.
      @returns Returns whether the export was successful.
    */
    exportUserParameters(userParameterArray: UserParameter[], filename: string): boolean
    /**
      Function that imports a list of user parameters from a csv file.
      The format of the csv file is as follows:
      It must have at least two rows - Header followed by a row of parameter.
      It must be encoded in UTF8 format.
      It must contain at least six columns - name, unit, expression, value, comment, and favorite
      where favorite is either true or false.
      The columns must only have a comma delimiter.
      Any locale will work but no thousands.
      expression column support double quotes.
      comment can either be single line or multi line. If multi line, it must be in double quotes.
      Here is an example of a csv file with two rows
      Name,Unit,Expression,Value,Comments,Favorite
      p1,mm,32 mm,32,the first parameter,FALSE
      The function exportUserParameters could be used to see what a csv file looks like.
      @param filename The full filename (path and file) of the file to read the parameters from.
      @returns Returns whether the import was successful.
    */
    importUserParameters(filename: string): boolean
  }

  /**
    The base class Parameter object that can represent model or user parameters.
  */
  abstract class Parameter extends core.Base {
    /**
      Gets and sets the real value (a double) of the parameter in database units.
      Setting this property will set/reset the expression value for this parameter.
      This property is only valid for numeric parameters and will fail for text parameters.
      You can determine the value type of the parameter by using the valueType property.
      Use the textValue property to get and set the value of text parameters.
    */
    value: number
    /**
      Gets and sets the expression used to calculate the value of the parameter. This is the
      equivalent of the "Expression" column in the Parameters dialog. Numeric parameters can
      be defined by a simple expression like "6.25", which will be interpreted based on whatever the
      default units are for the document. For example, if the units are set to millimeters,
      the value will be 6.25 mm if the units are inches, it will be 6.25 inches. The expression
      can also contain the units so "6.25 in" will always be evaluated as inches regardless
      of the document units.
      An expression can also contain references to other parameters and use equations.
      For example, the expression "Length / 2" is valid for a numeric parameter as long as
      there is a numeric parameter named "Length". Expressions can also be used for text parameters,
      such as concatenating two other text parameters. For example, if there are two existing text
      parameters named text1 and text2, the expression for another text parameter can be "text1 + text2".
      More complex equations can also be used with text parameters like
      "if (Length < 20 mm 'Short' 'Long')" where "Length" is a numeric parameter.
      The resulting string can be obtained using the textValue property.
    */
    expression: string
    /**
      Gets and sets the name of the parameter. Setting the name can fail if the name
      is not unique with respect to all other parameters in the design.
    */
    name: string
    /**
      The unit type associated with this parameter. An empty string is returned for parameters
      that don't have a unit type.
    */
    readonly unit: string
    /**
      The comment associated with this parameter
    */
    comment: string
    /**
      Gets and sets whether this parameter is included in the Favorites list in the
      parameters dialog
    */
    isFavorite: boolean
    /**
      Returns a list of parameters that are dependent on this parameter as a result
      of this parameter being referenced in their equation.
    */
    readonly dependentParameters: ParameterList
    /**
      Gets if this parameter can be deleted. Parameters that have dependents cannot
      be deleted, and model parameters typically cannot be deleted. However,
      there is the possibility in uncommon workflows where a model parameter no longer
      has any dependents, and it was not automatically deleted. In this case, this
      property will return true, and the deleteMe method can delete the parameter.
    */
    readonly isDeletable: boolean
    /**
      Returns the collection of attributes associated with this face.
    */
    readonly attributes: core.Attributes
    /**
      Returns a token for the Parameter object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same parameter.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Returns a list of parameters that this parameter is dependent on.
    */
    readonly dependencyParameters: ParameterList
  }

  /**
    Specifies the different types of values that a parameter can be.
  */
  const enum ParameterValueTypes {
    /**
      Indicates the parameter has a numeric value.
    */
    NumericParameterValueType,
    /**
      Indicates the parameter has a string value.
    */
    TextParameterValueType,
  }

  /**
    The expression of the parameter. Setting this can fail because of an invalid expression or
    because a cyclic reference is created between parameters.
  */
  const enum ExpressionError {
    /**
      A cyclical parametric reference occurred.
    */
    CyclicParameterReferenceError = 200,
  }

  /**
    Represents a User Parameter.
  */
  abstract class UserParameter extends Parameter {
    /**
      Deletes the user parameter
      A parameter can only be deleted if it is a UserParameter and
      it is not referenced by other parameters.
      @returns Returns a bool indicating if the delete was successful or not.
      Bug!!! Currently returning true if the parameter can't be deleted because it is
      being referenced by other parameters.
    */
    deleteMe(): boolean
    /**
      Returns the Collection containing the UserParameter.
    */
    readonly userParameters: UserParameters
    /**
      Returns the Design containing the UserParameter.
    */
    readonly design: Design
  }

  /**
    Specific error types for DeleteMe methods.
  */
  const enum DeleteMeError {
    /**
      The parameter is referenced by another parameter.
    */
    ParameterReferencedByOtherParameterError = 200,
  }

  /**
    Represents a Model Parameter.
  */
  abstract class ModelParameter extends Parameter {
    /**
      Returns the Collection containing the ModelParameter.
    */
    readonly modelParameters: ModelParameters
    /**
      Returns the Component containing the ModelParameter.
    */
    readonly component: Component
    /**
      This property identifies what the parameter is used for. For an extrude, it
      could be "Depth", for a work plane it could be "Offset".
    */
    readonly role: string
    /**
      Returns the object that created this parameter. For example,
      a feature, a sketch dimension, or a construction plane.
    */
    readonly createdBy: core.Base
    /**
      Deletes this ModelParameter. As a general rule, model parameters cannot be deleted
      because features depend on them. However, there are uncommon workflows where a
      parameter no longer has any dependents and is not automatically deleted. You can
      use the isDeletable property to see if the parameter is in this state and can
      successfully be deleted.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
  }

  /**
    Provides support for exporting model data to various formats.
  */
  abstract class ExportManager extends core.Base {
    /**
      Creates an IGESExportOptions object that's used to export a design in IGES format. Creation
      of the IGESExportOptions object does not perform the export. You must pass this object to the
      ExportManager.execute method to perform the export. The IGESExportOptions supports any available
      options when exporting to IGES format.
      @param filename The filename of the IGES file to be created.
      @param geometry The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
      and if not specified, it results in the root component and it entire contents being exported.
      @returns The created IGESExportOptions object or null if the creation failed.
    */
    createIGESExportOptions(filename: string, geometry?: core.Base/* = null*/): IGESExportOptions | null
    /**
      Creates an STEPExportOptions object that's used to export a design in STEP format. Creation
      of the STEPExportOptions object does not perform the export. You must pass this object to the
      ExportManager.execute method to perform the export. The STEPExportOptions supports any available
      options when exporting to STEP format.
      @param filename The filename of the STEP file to be created.
      @param geometry The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
      and if not specified, it results in the root component and it entire contents being exported.
      @returns The created STEPExportOptions object or null if the creation failed.
    */
    createSTEPExportOptions(filename: string, geometry?: core.Base/* = null*/): STEPExportOptions | null
    /**
      Creates an SATExportOptions object that's used to export a design in SAT format. Creation
      of the SATExportOptions object does not perform the export. You must pass this object to the
      ExportManager.execute method to perform the export. The SATExportOptions supports any available
      options when exporting to SAT format.
      @param filename The filename of the SAT file to be created.
      @param geometry The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
      and if not specified, it results in the root component and it entire contents being exported.
      @returns The created SATExportOptions object or null if the creation failed.
    */
    createSATExportOptions(filename: string, geometry?: core.Base/* = null*/): SATExportOptions | null
    /**
      Creates an SMTExportOptions object that's used to export a design in SMT format. Creation
      of the SMTExportOptions object does not perform the export. You must pass this object to the
      ExportManager.execute method to perform the export. The SMTExportOptions supports any available
      options when exporting to SMT format.
      @param filename The filename of the SMT file to be created.
      @param geometry The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
      and if not specified, it results in the root component and it entire contents being exported.
      @returns The created SMTExportOptions object or null if the creation failed.
    */
    createSMTExportOptions(filename: string, geometry?: core.Base/* = null*/): SMTExportOptions | null
    /**
      Creates an FusionArchiveExportOptions object that's used to export a design in Fusion archive format. Creation
      of the FusionArchiveExportOptions object does not perform the export. You must pass this object to the
      ExportManager.execute method to perform the export. The FusionArchiveExportOptions supports any available
      options when exporting to Fusion archive format.
      @param filename The filename of the Fusion archive file to be created.
      @param geometry The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
      and if not specified, it results in the root component and it entire contents being exported.
      @returns The created FusionArchiveExportOptions object or null if the creation failed.
    */
    createFusionArchiveExportOptions(filename: string, geometry?: core.Base/* = null*/): FusionArchiveExportOptions | null
    /**
      Creates an STLExportOptions object that's used to export a design in STL format. Creation
      of the STLExportOptions object does not perform the export. You must pass this object to the
      ExportManager.execute method to perform the export.
      @param geometry The geometry to export. This can be a BRepBody, Occurrence, or Component object.
      @param filename The filename of the STL file to be created. This is optional and can be left out if the mesh will be opened in a mesh editor.
      @returns The created createSTLExportOptions object or null if the creation failed.
    */
    createSTLExportOptions(geometry: core.Base, filename?: string/* = ""*/): STLExportOptions | null
    /**
      Executes the export operation to create the file in the format specified by the provided ExportOptions object.
      @param exportOptions An ExportOptions object that is created using one of the create methods on the ExportManager object. This
      defines the type of file and any available options supported for that file type.
      @returns Returns true if the export was successful.
    */
    execute(exportOptions: ExportOptions): boolean
    /**
      Creates a C3MFExportOptions object that's used to export a design in 3MF format. Creation
      of the C3MFExportOptions object does not perform the export. You must pass this object to the
      ExportManager.execute method to perform the export.
      @param geometry The geometry to export. This can be a BRepBody, Occurrence, or Component object.
      @param filename The filename of the 3MF file to be created. This is optional and can be left out if the mesh will be opened in a mesh editor.
      @returns The created createC3MFExportOptions object or null if the creation failed.
    */
    createC3MFExportOptions(geometry: core.Base, filename?: string/* = ""*/): C3MFExportOptions | null
    /**
      Creates an USDExportOptions object that's used to export a design in USD format. Creation
      of the USDExportOptions object does not perform the export. You must pass this object to the
      ExportManager.execute method to perform the export. The USDExportOptions supports any available
      options when exporting to USD format.
      @param filename The filename of the USD file to be created.
      @param geometry The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
      and if not specified, it results in the root component and it entire contents being exported.
      @returns The created USDExportOptions object or null if the creation failed.
    */
    createUSDExportOptions(filename: string, geometry?: core.Base/* = null*/): USDExportOptions | null
    /**
      Creates an OBJExportOptions object that's used to export a design in OBJ format. Creation
      of the OBJExportOptions object does not perform the export. You must pass this object to the
      ExportManager.execute method to perform the export.
      @param geometry The geometry to export. This can be a BRepBody, Occurrence, or Component object.
      @param filename The filename of the OBJ file to be created. This is optional and can be left out if the mesh will be opened in a mesh editor.
      @returns The created createOBJExportOptions object or null if the creation failed.
    */
    createOBJExportOptions(geometry: core.Base, filename?: string/* = ""*/): OBJExportOptions | null
    /**
      Creates a DXFFlatPatternExport object that's used to export a flat pattern in DXF format. Creation
      of the DXFFlatPatternExport object does not perform the export. You must call the execute method.
      You can change any additional settings by setting properties on the returned object before calling
      the execute method.
      @param filename The filename of the DXF file to be created.
      @param flatPattern The FlatPattern object to export.
      @returns The created DXFFlatPatternExport object or null if the creation failed.
    */
    createDXFFlatPatternExportOptions(filename: string, flatPattern: FlatPattern): DXFFlatPatternExportOptions | null
    /**
      Creates a DXFSketchExportOptions object that's used to export a sketch in DXF format. Creation
      of the DXFSketchExportOptions object does not perform the export. You must call the execute method after changing
      the settings to the desired values.
      @param filename The filename of the DXF file to be created.
      @param sketch The Sketch object to export.
      @returns The created DXFSketchExportOptions object or null if the creation failed.
      @experimental
    */
    createDXFSketchExportOptions(filename: string, sketch: Sketch): DXFSketchExportOptions | null
  }

  /**
    The base class for the different export types. This class is never directly used
    in an export because you need the specific export type to specify the type of
    export to be performed.
  */
  abstract class ExportOptions extends core.Base {
    /**
      Gets and sets the filename that the exported file will be written to. This can
      be empty in the case of STL export and sending the result to the mesh editor.
    */
    filename: string
    /**
      Specifies the geometry to export. This can be an Occurrence, or the root Component.
      For STL, OBJ, and 3MF export, it can be a BRepBody. For DXF export, it can be a sketch of flat pattern.
    */
    geometry: core.Base
  }

  /**
    Defines that an IGES export is to be done and specifies the various options.
  */
  abstract class IGESExportOptions extends ExportOptions {
  }

  /**
    Defines that a STEP export is to be done and specifies the various options.
  */
  abstract class STEPExportOptions extends ExportOptions {
    /**
      Indicates if the STEP file should include the Fusion temporary IDs for faces and edges.
      Outside services can use these IDs with the findByTempId method of the BRepBody,
      which will return the given entity. The default is false.
    */
    wantTempIds: boolean
  }

  /**
    Defines that a SAT export is to be done and specifies the various options.
  */
  abstract class SATExportOptions extends ExportOptions {
  }

  /**
    Defines that an SMT export is to be done and specifies the various options.
  */
  abstract class SMTExportOptions extends ExportOptions {
    /**
      Gets and set the version of the SMT format to write to. The default
      is to use the current version of the Autodesk Shape Manager kernel
      that Fusion is using. Specifying an invalid version will result
      in an assert.
      Valid versions are 218 up to the current version, which is what this
      property returns by default when a new SMTExportOptions object is
      created.
    */
    version: number /*int*/
  }

  /**
    Defines that a Fusion Archive export is to be done and specifies the various options.
  */
  abstract class FusionArchiveExportOptions extends ExportOptions {
  }

  /**
    Defines that a STL export is to be done and specifies the various options.
  */
  abstract class STLExportOptions extends ExportOptions {
    /**
      Indicates if the STL file is to be an ASCII or binary STL format. The default is true.
    */
    isBinaryFormat: boolean
    /**
      If the input is an Occurrence or the root Component, this specifies if a single file should be created containing
      all of the bodies within that occurrence or component or if multiple files should be created one for each body.
      If multiple files are created, the body name is appended to the filename. The default is false.
    */
    isOneFilePerBody: boolean
    /**
      Gets and sets the current simple mesh refinement settings. Setting this property
      will reset the surfaceDeviation, normalDeviation, maximumEdgeLength, and aspectRatio
      to values that correspond to the specified mesh refinement. The default is MeshRefinementMedium.
    */
    meshRefinement: MeshRefinementSettings
    /**
      Gets and sets the current surface deviation, or the distance the mesh can deviate
      from the actual surface. This is defined in centimeter. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    surfaceDeviation: number
    /**
      Gets and sets the current normal deviation, or the angle the mesh normals at the vertices can deviate
      from the actual surface normals. This is defined in radians. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    normalDeviation: number
    /**
      Gets and sets the maximum length of any mesh edge. This is defined in centimeter. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    maximumEdgeLength: number
    /**
      Gets and sets the minimum aspect ratio for that triangles that are generated for the mesh. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    aspectRatio: number
    /**
      Returns a list of the known available print utilities. These strings can be used to set the PrintUtility
      property to specify which print utility to open the STL file in.
    */
    readonly availablePrintUtilities: string[]
    /**
      Specifies which print utility to use when opening the STL file if the sendToPrintUtility property is true.
      The value of this property can be one of the strings returned by the availalbePrintUtilities property, which
      will specify one of the know print utilities. You can also specify a custom print utility by specifying
      the full path to the print utility executable. The default value of this property is the last setting specified
      in the user-interface.
    */
    printUtility: string
    /**
      Gets and sets whether the created STL file will be sent to the print utility specified by the printUtility property. If this
      is false a filename must be defined.
    */
    sendToPrintUtility: boolean
    /**
      Gets and sets the units to use for the created STL file. When the STLExportOptions object is created, this property
      is initialized with the default units specified for the Design.
    */
    unitType: DistanceUnits
  }

  /**
    Defines that an OBJ export is to be done and specifies the various options.
  */
  abstract class OBJExportOptions extends ExportOptions {
    /**
      If the input is an Occurrence or the root Component, this specifies if a single file should be created containing
      all of the bodies within that occurrence or component or if multiple files should be created one for each body.
      If multiple files are created, the body name is appended to the filename. The default is false.
    */
    isOneFilePerBody: boolean
    /**
      Gets and sets the current simple mesh refinement settings. Setting this property
      will reset the surfaceDeviation, normalDeviation, maximumEdgeLength, and aspectRatio
      to values that correspond to the specified mesh refinement. The default is MeshRefinementMedium.
    */
    meshRefinement: MeshRefinementSettings
    /**
      Gets and sets the current surface deviation, or the distance the mesh can deviate
      from the actual surface. This is defined in centimeter. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    surfaceDeviation: number
    /**
      Gets and sets the current normal deviation, or the angle the mesh normals at the vertices can deviate
      from the actual surface normals. This is defined in radians. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    normalDeviation: number
    /**
      Gets and sets the maximum length of any mesh edge. This is defined in centimeter. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    maximumEdgeLength: number
    /**
      Gets and sets the minimum aspect ratio for that triangles that are generated for the mesh. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    aspectRatio: number
    /**
      Returns a list of the known available print utilities. These strings can be used to set the PrintUtility
      property to specify which print utility to open the OBJ file in.
    */
    readonly availablePrintUtilities: string[]
    /**
      Specifies which print utility to use when opening the OBJ file if the sendToPrintUtility property is true.
      The value of this property can be one of the strings returned by the availalbePrintUtilities property, which
      will specify one of the known print utilities. You can also specify a custom print utility by specifying
      the full path to the print utility executable. The default value of this property is the last setting specified
      in the user-interface.
    */
    printUtility: string
    /**
      Gets and sets whether the created OBJ file will be sent to the print utility specified by the printUtility property. If this
      is false a filename must be defined. The default is false.
    */
    sendToPrintUtility: boolean
    /**
      Gets and sets the units to use for the created OBJ file. The default is Centimeters.
    */
    unitType: DistanceUnits
  }

  /**
    Defines that a 3MF export is to be done and specifies the various options.
  */
  abstract class C3MFExportOptions extends ExportOptions {
    /**
      If the input is an Occurrence or the root Component, this specifies if a single file should be created containing
      all of the bodies within that occurrence or component or if multiple files should be created one for each body.
      If multiple files are created, the body name is appended to the filename. The default is false.
    */
    isOneFilePerBody: boolean
    /**
      Gets and sets the current simple mesh refinement settings. Setting this property
      will reset the surfaceDeviation, normalDeviation, maximumEdgeLength, and aspectRatio
      to values that correspond to the specified mesh refinement. The default is MeshRefinementMedium.
    */
    meshRefinement: MeshRefinementSettings
    /**
      Gets and sets the current surface deviation, or the distance the mesh can deviate
      from the actual surface. This is defined in centimeter. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    surfaceDeviation: number
    /**
      Gets and sets the current normal deviation, or the angle the mesh normals at the vertices can deviate
      from the actual surface normals. This is defined in radians. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    normalDeviation: number
    /**
      Gets and sets the maximum length of any mesh edge. This is defined in centimeter. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    maximumEdgeLength: number
    /**
      Gets and sets the minimum aspect ratio for that triangles that are generated for the mesh. Setting this property
      will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
      associated with medium mesh refinement.
    */
    aspectRatio: number
    /**
      Returns a list of the known available print utilities. These strings can be used to set the PrintUtility
      property to specify which print utility to open the 3MF file in.
    */
    readonly availablePrintUtilities: string[]
    /**
      Specifies which print utility to use when opening the 3MF file if the sendToPrintUtility property is true.
      The value of this property can be one of the strings returned by the availalbePrintUtilities property, which
      will specify one of the know print utilities. You can also specify a custom print utility by specifying
      the full path to the print utility executable. The default value of this property is the last setting specified
      in the user-interface.
    */
    printUtility: string
    /**
      Gets and sets whether the created 3MF file will be sent to the print utility specified by the printUtility property. If this
      is false a filename must be defined.
    */
    sendToPrintUtility: boolean
  }

  /**
    Defines that a DXF export of a flat pattern is to be done and specifies the various options.
  */
  abstract class DXFFlatPatternExportOptions extends ExportOptions {
    /**
      Specifies if splines are converted to polylines. If true, the convertToPolylineTolerance
      value is used to specify the accuracy of the conversion. Defaults to false.
    */
    isSplineConvertedToPolyline: boolean
    /**
      Specifies the tolerance when converting a spline to polylines. This value is only used when
      the isSplineConvertedToPolyline property is true and otherwise it is ignored. The units for
      this value are centimeters. Defaults to 0.01 cm.
    */
    convertToPolylineTolerance: number
    /**
      Gets and sets the units that will be used for the DXF file. This defaults to be
      the same as the default units of the design.
    */
    units: DistanceUnits
    /**
      Specifies if the center lines (bend line) of the flat pattern are exported in the DXF.
      Defaults to true.
    */
    isCenterLinesExported: boolean
    /**
      Specifies if the bend extent lines of the flat pattern are exported in the DXF.
      Defaults to true.
    */
    isExtentLinesExported: boolean
  }

  /**
    Defines the various settings associated with exporting a sketch in DXF format.
  */
  abstract class DXFSketchExportOptions extends ExportOptions {
    /**
      Gets and sets the units that will be used for the DXF file. This defaults to be
      the same as the default units of the design.
    */
    units: DistanceUnits
    /**
      Indicates if construction geometry should be exported. Defaults to true,
      which will export all construction geometry. If false it will be ignored
      and not included in the DXF file.
    */
    isConstructionExported: boolean
    /**
      Indicates if the sketch points should be exported. Defaults to true,
      which will export all points. If false it will be ignored
      and not included in the DXF file.
    */
    isPointsExported: boolean
    /**
      Indicates if any projected geometry should be exported. Defaults to true,
      which will export all projected geometry. If false it will be ignored
      and not included in the DXF file.
    */
    isProjectedGeometryExported: boolean
  }

  /**
    The different refinement settings supported when exporting the design as an STL or 3MF file.
  */
  const enum MeshRefinementSettings {
    /**
      Sets the various settings to the values associated with a high quality export.
    */
    MeshRefinementHigh,
    /**
      Sets the various settings to the values associated with a medium quality export.
    */
    MeshRefinementMedium,
    /**
      Sets the various settings to the values associated with a low quality export.
    */
    MeshRefinementLow,
    /**
      Indicates that the settings are not predefined values associated with high, medium, or low quality export.
    */
    MeshRefinementCustom,
  }

  /**
    Defines that an USD export is to be done and specifies the various options.
  */
  abstract class USDExportOptions extends ExportOptions {
  }

  /**
    The physical properties of a Component, Occurrence or BRepBody
  */
  abstract class PhysicalProperties extends core.Base {
    /**
      Gets the area in square centimeters.
    */
    readonly area: number
    /**
      Gets the density in kilograms per cubic centimeter.
    */
    readonly density: number
    /**
      Gets the mass in kilograms.
    */
    readonly mass: number
    /**
      Gets the volume in the cubic centimeters.
    */
    readonly volume: number
    /**
      Returns the accuracy that was used for the calculation.
    */
    readonly accuracy: CalculationAccuracy
    /**
      Returns the center of mass position
    */
    readonly centerOfMass: core.Point3D
    /**
      Method that returns the principal axes.
      @param xAxis The output Vector3D object that indicates the direction of the x axis.
      @param yAxis The output Vector3D object that indicates the direction of the y axis.
      @param zAxis The output Vector3D object that indicates the direction of the z axis.
      @returns Returns true if successful
    */
    getPrincipalAxes(): [xAxis: core.Vector3D, yAxis: core.Vector3D, zAxis: core.Vector3D]
    /**
      Method that returns the moments of inertia about the principal axes. Unit for returned values is kg*cm^2.
      @param i1 Output Double that specifies the first moment of inertia.
      @param i2 Output Double that specifies the second moment of inertia.
      @param i3 Output Double that specifies the third moment of inertia.
      @returns Returns true if successful
    */
    getPrincipalMomentsOfInertia(): [i1: number, i2: number, i3: number]
    /**
      Method that returns the radius of gyration about the principal axes. Unit for returned values is cm.
      @param kx Output Double that returns the X partial radius of gyration.
      @param ky Output Double that returns the Y partial radius of gyration.
      @param kz Output Double that returns the Z partial radius of gyration.
      @returns Returns true if successful
    */
    getRadiusOfGyration(): [kx: number, ky: number, kz: number]
    /**
      Gets the rotation from the world coordinate system of the target to the principal coordinate system.
      @returns Returns true if successful
    */
    getRotationToPrincipal(): [rx: number, ry: number, rz: number]
    /**
      Method that gets the moment of inertia about the world coordinate system.
      Unit for returned values is kg*cm^2.
      @param xx Output Double that returns the XX partial moment.
      @param yy Output Double that returns the YY partial moment.
      @param zz Output Double that returns the ZZ partial moment.
      @param xy Output Double that returns the XY partial moment.
      @param yz Output Double that returns the YZ partial moment.
      @param xz Output Double that returns the XZ partial moment.
      @returns Returns true if successful
    */
    getXYZMomentsOfInertia(): [xx: number, yy: number, zz: number, xy: number, yz: number, xz: number]
  }

  /**
    The Area properties of a sketch profile or planar surface.
  */
  abstract class AreaProperties extends core.Base {
    /**
      Gets the area in the square centimeters.
    */
    readonly area: number
    /**
      Gets the centroid where the units are centimeters.
      The Location is relative to the sketch origin for a profile or relative to the world coordinate system for a planar face.
    */
    readonly centroid: core.Point3D
    /**
      Gets the perimeter in centimeters.
      The perimeter is the sum of the length of all the curves or edges of the profile or planar surface
    */
    readonly perimeter: number
    /**
      Gets the angle of rotation of the principal axes.
    */
    readonly rotationToPrincipal: number
    /**
      Returns the accuracy that was used for the calculation.
    */
    readonly accuracy: CalculationAccuracy
    /**
      Method that returns the principal axes.
      @param xAxis The output Vector3D object that indicates the direction of the x axis.
      @param yAxis The output Vector3D object that indicates the direction of the y axis.
      @returns Returns true if successful
    */
    getPrincipalAxes(): [xAxis: core.Vector3D, yAxis: core.Vector3D]
    /**
      Method that, for a sketch, returns the moments of inertia about the sketch origin.
      For a planar face, this method returns the moments about the world coordinate system origin.
      Unit for returned values is kg*cm^2.
      @param ixx Output Double that returns the XX partial moment.
      @param iyy Output Double that returns the YY partial moment.
      @param izz Output Double that returns the ZZ partial moment.
      @param ixy Output Double that returns the XY partial moment.
      @param iyz Output Double that returns the YZ partial moment.
      @param ixz Output Double that returns the XZ partial moment.
      @returns Returns true if successful
    */
    getMomentsOfInertia(): [ixx: number, iyy: number, izz: number, ixy: number, iyz: number, ixz: number]
    /**
      Method that returns the moments of inertia about the centroid. Unit for returned values is kg*cm^2.
      @param ixx Output Double that returns the XX partial moment.
      @param iyy Output Double that returns the YY partial moment.
      @param izz Output Double that returns the ZZ partial moment.
      @param ixy Output Double that returns the XY partial moment.
      @param iyz Output Double that returns the YZ partial moment.
      @param ixz Output Double that returns the XZ partial moment.
      @returns Returns true if successful
    */
    getCentroidMomentsOfInertia(): [ixx: number, iyy: number, izz: number, ixy: number, iyz: number, ixz: number]
    /**
      Method that returns the moments of inertia about the principal axes. Unit for returned values is kg*cm^2.
      @param i1 Output Double that specifies the first moment of inertia.
      @param i2 Output Double that specifies the second moment of inertia.
      @param i3 Output Double that specifies the third moment of inertia.
      @returns Returns true if successful
    */
    getPrincipalMomentsOfInertia(): [i1: number, i2: number, i3: number]
    /**
      Method that returns the radius of gyration about the principal axes. Unit for returned values is cm.
      @param kxx Output Double that returns the X partial radius of gyration.
      @param kyy Output Double that returns the Y partial radius of gyration.
      @param kzz Output Double that returns the Z partial radius of gyration.
      @returns Returns true if successful
    */
    getRadiusOfGyration(): [kxx: number, kyy: number, kzz: number]
  }

  /**
    The different accuracy settings for calculating area and physical property related values.
    The higher the accuracy setting, the longer it will take to perform the calculations.
  */
  const enum CalculationAccuracy {
    /**
      Sets the calculation accuracy to low, which returns results within a +/- 1% error margin.
    */
    LowCalculationAccuracy,
    /**
      Sets the calculation accuracy to medium, which returns results within a +/- 0.5% error margin.
    */
    MediumCalculationAccuracy,
    /**
      Sets the calculation accuracy to high, which returns results within a +/- 0.1% error margin.
    */
    HighCalculationAccuracy,
    /**
      Sets the calculation accuracy to very high, which returns results within a +/- 0.01% error margin.
    */
    VeryHighCalculationAccuracy,
  }

  /**
    Provides access to the existing analysis results within a design.
  */
  abstract class Analyses extends core.Base {
    /**
      A method that returns the specified Analysis using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Analysis | null
    /**
      A method that returns the specified Analysis using the name of the analysis
      as it is displayed in the browser.
      @param name The name of the Analysis as it is displayed in the browser.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): Analysis | null
    /**
      Returns the number of Analysis objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the AccessibilityAnalyses object, which provides access to any existing AccessibilityAnalysis
      objects in the design.
    */
    readonly accessibilityAnalyses: AccessibilityAnalyses
    /**
      Returns the CurvatureCombAnalyses object, which provides access to any existing CurvatureCombAnalysis
      objects in the design.
    */
    readonly curvatureCombAnalyses: CurvatureCombAnalyses
    /**
      Returns the CurvatureMapAnalyses object, which provides access to any existing CurvatureMapAnalysis
      objects in the design.
    */
    readonly curvatureMapAnalyses: CurvatureMapAnalyses
    /**
      Returns the DraftAnalyses object, which provides access to any existing DraftAnalysis
      objects in the design.
    */
    readonly draftAnalyses: DraftAnalyses
    /**
      Returns the IsoCurveAnalyses object, which provides access to any existing IsoCurveAnalysis
      objects in the design.
    */
    readonly isoCurveAnalyses: IsoCurveAnalyses
    /**
      Returns the MinimumRadiusAnalyses object, which provides access to any existing MinimumRadiusAnalysis
      objects in the design.
    */
    readonly minimumRadiusAnalyses: MinimumRadiusAnalyses
    /**
      Returns the SectionAnalyses object, which provides access to any existing SectionAnalysis
      objects in the design.
    */
    readonly sectionAnalyses: SectionAnalyses
    /**
      Returns the ZebraAnalyses object, which provides access to any existing ZebraAnalysis
      objects in the design.
    */
    readonly zebraAnalyses: ZebraAnalyses
    /**
      A property that gets and sets if the display is enabled for all Analysis objects in the design.
      If this is false, all Analysis results will be hidden. If this is true, the Analysis
      objects whose isLightBulbOn property is also true will be visible.
    */
    isLightBulbOn: boolean
  }

  /**
    The base class Analysis object that represents all the types of analysis results.
  */
  abstract class Analysis extends core.Base {
    /**
      A property that gets and sets the name of the analysis. If you use a name that is not unique,
      Fusion will automatically append a number to the name to make it unique.
    */
    name: string
    /**
      A property that gets and sets if the display is enabled for this Analysis object. If false,
      this analysis will be hidden. If true and the IsLightBulbOn property of the
      Analyses object is True the Analysis will be visible.
    */
    isLightBulbOn: boolean
    /**
      Gets if this Analysis is currently visible in the graphics window. The visibility is
      controlled by a combination of the isLightBulbOn properties of the Analyses collection
      object and the Analysis object. If both are true, the Analysis will be visible.
    */
    readonly isVisible: boolean
    /**
      A method that deletes this Analysis.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      A property that returns the collection of attributes associated with this Analysis.
    */
    readonly attributes: core.Attributes
    /**
      Returns a token for the Analysis object. The token can be saved and used later with
      the Design.findEntityByToken method to get back the same Analysis.
      When using entity tokens, it's crucial to understand that the token string returned
      for a specific entity can be different over time. For example, you can have two different
      token strings obtained from the same entity at different times, and when you use
      findEntityByToken they will both return the same entity. Because of that, you should
      never compare entity tokens as a way to determine what the token represents. Instead,
      you need to use the findEntityByToken method to get the two entities identified by the
      tokens and then compare them.
    */
    readonly entityToken: string
  }

  /**
    Provides access to any accessibility analyses results in the design.
  */
  abstract class AccessibilityAnalyses extends core.Base {
    /**
      A method that returns the specified AccessibilityAnalysis object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): AccessibilityAnalysis | null
    /**
      A method that returns the specified AccessibilityAnalysis object using the name of the analysis
      as displayed in the browser.
      @param name The name of the AccessibilityAnalysis object as displayed in the browser.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): AccessibilityAnalysis | null
    /**
      Returns the number of AccessibilityAnalysis objects in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents any existing Accessibility Analysis that exist in the design.
  */
  abstract class AccessibilityAnalysis extends Analysis {
  }

  /**
    Provides access to any curvature comb analyses results in the design.
  */
  abstract class CurvatureCombAnalyses extends core.Base {
    /**
      A method that returns the specified CurvatureCombAnalysis object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CurvatureCombAnalysis | null
    /**
      A method that returns the specified CurvatureCombAnalysis object using the name of the analysis
      as displayed in the browser.
      @param name The name of the CurvatureCombAnalysis object as displayed in the browser.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): CurvatureCombAnalysis | null
    /**
      Returns the number of CurvatureCombAnalysis objects in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents any existing Curvature Comb Analysis that exist in the design.
  */
  abstract class CurvatureCombAnalysis extends Analysis {
  }

  /**
    Provides access to any curvature map analyses results in the design.
  */
  abstract class CurvatureMapAnalyses extends core.Base {
    /**
      A method that returns the specified CurvatureMapAnalysis object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CurvatureMapAnalysis | null
    /**
      A method that returns the specified CurvatureMapAnalysis object using the name of the analysis
      as displayed in the browser.
      @param name The name of the CurvatureMapAnalysis object as displayed in the browser.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): CurvatureMapAnalysis | null
    /**
      Returns the number of CurvatureMapAnalysis objects in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents any existing Curvature Map Analysis that exist in the design.
  */
  abstract class CurvatureMapAnalysis extends Analysis {
  }

  /**
    Provides access to any draft analyses results in the design.
  */
  abstract class DraftAnalyses extends core.Base {
    /**
      A method that returns the specified DraftAnalysis object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): DraftAnalysis | null
    /**
      A method that returns the specified DraftAnalysis object using the name of the analysis
      as displayed in the browser.
      @param name The name of the DraftAnalysis object as displayed in the browser.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): DraftAnalysis | null
    /**
      Returns the number of DraftAnalysis objects in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents any existing Draft Analysis that exist in the design.
  */
  abstract class DraftAnalysis extends Analysis {
  }

  /**
    Provides access to any Iso Curve analyses results in the design.
  */
  abstract class IsoCurveAnalyses extends core.Base {
    /**
      A method that returns the specified IsoCurveAnalysis object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): IsoCurveAnalysis | null
    /**
      A method that returns the specified IsoCurveAnalysis object using the name of the analysis
      as displayed in the browser.
      @param name The name of the IsoCurveAnalysis object as displayed in the browser.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): IsoCurveAnalysis | null
    /**
      Returns the number of CurvatureCombAnalysis objects in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents any existing Iso Curve Analysis that exist in the design.
  */
  abstract class IsoCurveAnalysis extends Analysis {
  }

  /**
    Provides access to any minimum radius analyses results in the design.
  */
  abstract class MinimumRadiusAnalyses extends core.Base {
    /**
      A method that returns the specified MinimumRadiusAnalysis object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MinimumRadiusAnalysis | null
    /**
      A method that returns the specified MinimumRadiusAnalysis object using the name of the analysis
      as displayed in the browser.
      @param name The name of the MinimumRadiusAnalysis object as displayed in the browser.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): MinimumRadiusAnalysis | null
    /**
      Returns the number of MinimumRadiusAnalysis objects in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents any existing Minimum Radius Analysis that exist in the design.
  */
  abstract class MinimumRadiusAnalysis extends Analysis {
  }

  /**
    Provides access to any section analyses results in the design and supports
    the ability to create new sections.
  */
  abstract class SectionAnalyses extends core.Base {
    /**
      A method that returns the specified SectionAnalysis object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SectionAnalysis | null
    /**
      A method that returns the specified SectionAnalysis object using the name of the analysis
      as displayed in the browser.
      @param name The name of the SectionAnalysis object as displayed in the browser.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): SectionAnalysis | null
    /**
      Returns the number of SectionAnalysis objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new SectionAnalysisInput object to use when creating a new Section Analysis.
      A SectionAnalysisInput object is the API equivalent of the command dialog that
      contains the inputs to create a section analysis. Use this object to define the
      settings you need and then pass this into the add method to create the section analysis.
      @param cutPlaneEntity The planar entity used to define the cut plane and can be either a
      planar BRepFace or a ConstructionPlane object.
      @param distance The offset distance of the section from the cut plane. A positive value will offset
      in the positive normal direction of the cut plane entity. The value is in centimeters.
      This value is used to create a transformation matrix that defines the specified offset.
      @returns Returns a SectionAnalysisInput object if successful.
    */
    createInput(cutPlaneEntity: core.Base, distance: number): SectionAnalysisInput
    /**
      Creates a new Section Analysis.
      @param input A SectionAnalysisInput object that defines how the section analysis should be created.
      Use the createInput method to create a new SectionAnalysisInput object.
      @returns Returns the new SectionAnalysis object if successful.
    */
    add(input: SectionAnalysisInput): SectionAnalysis
  }

  /**
    Provides access the all of the settings available when creating a section analysis.
    This object is the API equivalent of the command dialog that contains the inputs
    to create a section analysis. Use this object to define the settings you need and
    then pass this into the add method to create the section analysis.
  */
  abstract class SectionAnalysisInput extends core.Base {
    /**
      A property that gets and sets the planar entity used to define the cut plane and can be either
      a planar BRepFace or a ConstructionPlane object.
    */
    cutPlaneEntity: core.Base
    /**
      Returns the matrix that describes the initial position and orientation of the
      specified cut plane entity. Any additional offsets or rotations are defined
      by a transformation matrix that is applied to this initial position matrix.
      That matrix is obtained and set using the transform property.
    */
    readonly initialPosition: core.Matrix3D
    /**
      The initial position of the section plane is defined by the specified cut plane
      entity. Any offsets or rotations are defined by a transformation matrix that is
      applied to the initial position. This property allows you to get and set the
      transformation matrix.
    */
    transform: core.Matrix3D
    /**
      A property that flips which side of the part is cut away by the section. This is a
      convenience method that results in flipping the Z axis of the transform while maintaining
      a valid rectangular coordinate system. You can directly manipulate the transform matrix
      to have the same effect.
    */
    flip(): boolean
    /**
      A property that gets and sets the color of the section. This property defaults to null,
      indicating that the component color should be used. The opacity value of the color is ignored.
    */
    sectionColor: core.Color
    /**
      A property that gets and sets if a hatch pattern should be shown on the section. This
      property defaults to true when the input is created.
    */
    isHatchShown: boolean
  }

  /**
    Represents any existing Section Analysis that exist in the design.
  */
  abstract class SectionAnalysis extends Analysis {
    /**
      A property that gets and sets the planar entity used to define the cut plane and can be either
      a planar BRepFace or a ConstructionPlane object.
    */
    cutPlane: core.Base
    /**
      Returns the matrix that describes the initial position and orientation of the
      specified cut plane entity. Any additional offsets or rotations are defined
      by a transformation matrix that is applied to this initial position. That
      matrix can be obtained and set using the transform property.
    */
    readonly initialPosition: core.Matrix3D
    /**
      The initial position of the section plane is defined by the specified cut plane
      entity. Any offsets or rotations are defined by a transformation matrix that is
      applied to the initial position. This property allows you to get and set the
      transformation matrix.
    */
    transform: core.Matrix3D
    /**
      A property that flips which side of the part is cut away by the section. This is a
      convenience method that results in flipping the Z axis of the transform while maintaining
      a valid rectangular coordinate system. You can directly manipulate the transform matrix
      to have the same effect.
    */
    flip(): boolean
    /**
      A property that gets and sets the color of the section. A value of null indicates
      the component color should be used. The opacity value of the color is ignored.
    */
    sectionColor: core.Color
    /**
      A property that gets and sets if a hatch pattern should be shown on the section.
    */
    isHatchShown: boolean
  }

  /**
    Provides access to any zebra analyses results in the design.
  */
  abstract class ZebraAnalyses extends core.Base {
    /**
      A method that returns the specified ZebraAnalysis object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ZebraAnalysis | null
    /**
      A method that returns the specified ZebraAnalysis object using the name of the analysis
      as it is displayed in the browser.
      @param name The name of the ZebraAnalysis object as it is displayed in the browser.
      @returns Returns the specified item or null if an invalid name was specified.
    */
    itemByName(name: string): ZebraAnalysis | null
    /**
      Returns the number of ZebraAnalysis objects in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represent any existing Zebra Analysis that exist in the design.
  */
  abstract class ZebraAnalysis extends Analysis {
  }

  /**
    The base class for all visible and selectable custom graphics objects.
  */
  abstract class CustomGraphicsEntity extends core.Base {
    /**
      Deletes the entity from the custom graphics group.
      @returns Returns true if the deletion was successful.
    */
    deleteMe(): boolean
    /**
      Gets and sets if the graphics entity is visible in the graphics window. By
      default, when a new entity is created it is visible.
    */
    isVisible: boolean
    /**
      Gets and sets if the graphics entity is selectable within the graphics window. By
      default, when a new entity is created it is selectable.
    */
    isSelectable: boolean
    /**
      Sets the opacity of the graphics entity. By default, when a new entity is it is
      completely opaque and does not override the opacity defined by the material.
      @param opacity The opacity value where 1.0 is completely opaque and 0.0 is completely transparent.
      @param isOverride Indicates if this entities opacity will override the opacity defined by the material.
      If true, it will override the material opacity and if false the opacity values will
      accumulate.
      @returns Returns true if setting the opacity information was successful.
    */
    setOpacity(opacity: number, isOverride: boolean): boolean
    /**
      Gets the opacity of the graphics entity.
      @param opacity The opacity value where 1.0 is completely opaque and 0.0 is completely transparent.
      @param isOverride Indicates if this entities opacity will override the opacity defined by the material.
      If true, it will override the material opacity and if false the opacity values will
      accumulate.
      @returns Returns true if getting the opacity information was successful.
    */
    getOpacity(): [opacity: number, isOverride: boolean]
    /**
      Gets and sets the transform associated with the graphics entity. When a new graphics
      entity is created its default transform is an identity matrix which results in the graphics entity
      being displayed in model space using the original coordinate data used to define the entity.
    */
    transform: core.Matrix3D
    /**
      Gets and sets the depth priority associated with the graphics entity. The depth priority defines
      how one graphics entity will be drawn with respect to another entity. This is useful when there
      are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
      example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
      set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
      and will remain visible.
      When a new graphics entity is created it's default depth priority is 0.
    */
    depthPriority: number /*int*/
    /**
      Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
      a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
      for a watertight mesh or solid B-Rep so that the "inside" of the faces is not rendered since it's never
      visible to the user.
      When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
      the rendering of "solid" meshes so the inside is not rendered.
    */
    cullMode: CustomGraphicsCullModes
    /**
      Gets and sets the current color definition for this entity. The color of custom graphics can
      be defined in many ways solid color, simple material, and appearance.
    */
    color: CustomGraphicsColorEffect
    /**
      Returns the parent Component for a top-level group or the CustomGraphicsGroup object for
      graphics entities and child groups.
    */
    readonly parent: core.Base
    /**
      An id you can specify for the entity. By default, all new graphics entities do not have an id and
      this property will return an empty string. But in cases where entities will be selected, assigning
      an id can make understanding what was selected much easier.
    */
    id: string
    /**
      Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
      Depending on whether the graphics are drawn in model space or screen space this will return
      the bounding box in either centimeters (model) or pixels (screen). In the case where it
      returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
      you can set this property using a CustomGraphicsBillBoard objects that you statically create using
      the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
      you can set this property to null.
      Billboarding is used to specify that the orientation of custom graphics is defined relative to the
      screen instead of model space. This is commonly used for legends and symbols that you want to
      always face the user, even as the camera is rotated.
    */
    billBoarding: CustomGraphicsBillBoard
    /**
      Gets and sets the graphics view placement being applied to this graphics entity. A
      CustomGraphicsViewPlacement object can be created using the static create method of the
      class. When assigned to a graphics entity the position of the graphics is defined
      relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
    */
    viewPlacement: CustomGraphicsViewPlacement
    /**
      Gets and sets the graphics view scale being applied to this graphics entity. A
      CustomGraphicsViewScale object can be created using the static create method of the
      class. When assigned to a graphics entity the size of the graphics entity is defined
      in view space (pixels) instead of model space (centimeters).
    */
    viewScale: CustomGraphicsViewScale
    /**
      Gets and sets the name displayed when this entity is selected. If no name has been set,
      "Custom Graphics" will be displayed.
    */
    name: string
  }

  /**
    Specifies the different styles that can be used to control billboarding.
  */
  const enum CustomGraphicsBillBoardStyles {
    /**
      Billboards relative to the screen, so the x-y plane of the graphics will always remain parallel to the view plane.
      and the graphics X axis will align with the view's x axis.
    */
    ScreenBillBoardStyle = 1,
    /**
      Sets the billboarding so that the graphics X axis will align with a defined axis.
    */
    AxialBillBoardStyle = 2,
    /**
      Sets the billboarding so that graphics can never be viewed from the back. As the view is rotated, the
      graphics will be automatically flipped so they are always viewed from the front.
    */
    RightReadingBillBoardStyle = 3,
  }

  /**
    Used to specify if the orientation of custom graphics are defined relative to the screen instead of model space.
    This is commonly used for legends and symbols that you want to always face the user, even as the
    camera is rotated.
  */
  abstract class CustomGraphicsBillBoard extends core.Base {
    /**
      Creates a new CustomGraphicsBillBoard object that can be used when calling the billBoarding property
      of the CustomGraphicsEntity object to specify the billboarding behavior of some custom graphics. Once
      created you can assign it to a custom graphics entity using its billBoarding property.
      @param anchorPoint The parameter must be input and can be null but the value is ignored. Use of the anchor point has been retired and it is no longer used.
      @returns Returns the newly created CustomGraphicsBillBoard object or null in the case of failure. This can be assigned
      to a custom graphics entity using its billBoarding property.
    */
    static create(anchorPoint: core.Point3D): CustomGraphicsBillBoard | null
    /**
      <mark>RETIRED - This property has been retired. It is not needed since the matrix defined for the CustomGraphicsText
      object defines the position and anchor for the billboarded text. Getting the value of this property will return a
      point at the origin. Setting this property will be ignored.
      </mark>
      Specifies the coordinate in model or view space that the graphics will anchor to. For graphics that
      represent a label, this will typically be the point where the label attaches to the model. A
      CustomGraphicsAnchorPoint can be created using the static create method on the CustomGraphicsAnchorPoint
      object.
    */
    anchorPoint: core.Point3D
    /**
      Specifies the type of billboarding to use. When a new CustomGraphicsBillBoard object is created
      this defaults to ScreenBillBoardStyle so the graphics will all be facing the view plane. It can also
      be set to an arbitrary plane by setting this to AxialBillBoardStyle and can be defined so that it never
      appear backwards by setting it to RightReadingBillBoardStyle.
    */
    billBoardStyle: CustomGraphicsBillBoardStyles
    /**
      When the billBoardStyle property is set to AxialBillBoardStyle, this is used to control the direction
      of the graphics. Otherwise it uses the x axis of the view.
    */
    axis: core.Vector3D
  }

  /**
    Positions custom graphics relative to one of the four corners of the view. Graphics positioned
    this way will always appear on top of the model graphics. This is typically used to display
    legends are small interactive tools.
  */
  abstract class CustomGraphicsViewPlacement extends core.Base {
    /**
      Creates a new CustomGraphicsViewPlacement object that can be used when setting the viewPlacement property
      of a custom graphics entity to specify the billboarding behavior.
      @param anchorPoint The position within the defined graphics that will serve as the anchor. This is the location
      on the graphics that will be positioned at the specified view point.
      @param viewCorner Defines which of the four corners of the view the graphics are drawn relative to.
      @param viewPoint A 2D point in the view that defines the position of the graphics. This is relative to the corner
      and is in pixels. The x and y directions vary for each of the corners. These directions are only
      used to position the 2D point and do not affect the standard coordinate system the graphics were
      drawn in.
      upperLeftViewCorner - The x direction is to the right and y is down.
      upperRightViewCorner - The x direction is to the left and y is down.
      lowerLeftViewCorner - The x direction is to the right and y is up.
      lowerRightViewCorner - The x direction is to the left and y is up.
      @returns Returns the newly created CustomGraphicsViewPlacement object or null in the case of failure. This can then
      be assigned to any custom graphics entity using its viewPlacement property.
    */
    static create(anchorPoint: core.Point3D, viewCorner: ViewCorners, viewPoint: core.Point2D): CustomGraphicsViewPlacement | null
    /**
      Gets and sets the position within the defined graphics that serves as the anchor. This is the location
      on the graphics that is positioned at the specified view point.
    */
    anchorPoint: core.Point3D
    /**
      A 2D point in the view that defines the position of the graphics. This is relative to the corner
      and is in pixels. The x and y directions vary for each of the corners. These directions are only
      used to position the 2D point and do not affect the standard coordinate system the graphics were
      drawn in.
      upperLeftViewCorner - The x direction is to the right and y is down.
      upperRightViewCorner - The x direction is to the left and y is down.
      lowerLeftViewCorner - The x direction is to the right and y is up.
      lowerRightViewCorner - The x direction is to the left and y is up.
    */
    viewPoint: core.Point2D
    /**
      Gets and sets which corner the graphics are positioned relative to.
    */
    viewCorner: ViewCorners
  }

  /**
    Specifies which of the four view corners custom graphics will be drawn in relation to. The
    notUsedViewCorner setting indicates the graphics are not positioned with respect to the view.
  */
  const enum ViewCorners {
    /**
      Indicates that custom graphics are positioned with respect to the upper-left corner of the view.
    */
    upperLeftViewCorner,
    /**
      Indicates that custom graphics are positioned with respect to the upper-right corner of the view.
    */
    upperRightViewCorner,
    /**
      Indicates that custom graphics are positioned with respect to the lower-left corner of the view.
    */
    lowerLeftViewCorner,
    /**
      Indicates that custom graphics are positioned with respect to the lower-right corner of the view.
    */
    lowerRightViewCorner,
  }

  /**
    Specifies that custom graphics are to be scaled relative to the view (pixels) and not model space.
    If this is applied to some custom graphics then they will stat the same size on the screen regardless
    of the user zooming in or out. This is commonly used for glyphs and other interactive widgets so they don't
    don't get too large or too small.
  */
  abstract class CustomGraphicsViewScale extends core.Base {
    /**
      Creates a new CustomGraphicsViewScale object that can be used when setting the viewScale property
      of a custom graphics entity to specify the scaling behavior.
      @param pixelScale Defines the scale of the custom graphics relative to the view. If a custom graphics line is defined
      to be 100 units long it would usually display as 100 cm long. When it is view scaled with a pixel scale of
      1 it will display as 100 pixels long.
      @param anchorPoint Defines the point in the graphics that defines the origin of the scaling. The graphics will be scaled
      up or down relative to that point.
      @returns Returns the newly created CustomGraphicsViewScale object or null in the case of failure. This can then
      be assigned to any custom graphics entity using its viewScale property.
    */
    static create(pixelScale: number, anchorPoint: core.Point3D): CustomGraphicsViewScale | null
    /**
      Gets and sets the scale of the custom graphics relative to the view. If a custom graphics line is defined
      to be 100 units long it would usually display as 100 cm long. When it is view scaled with a pixel scale of
      1 it will display as 100 pixels long.
    */
    pixelScale: number
    /**
      Gets and sets the point in the graphics that defines the origin of the scaling. The graphics will be scaled
      up or down relative to that point.
    */
    anchorPoint: core.Point3D
  }

  /**
    The various culling modes supported by custom graphics.
  */
  const enum CustomGraphicsCullModes {
    /**
      Cull the graphics that are front facing.
    */
    CustomGraphicsCullFront,
    /**
      Cull the graphics that are back facing.
    */
    CustomGraphicsCullBack,
    /**
      Do not perform any culling.
    */
    CustomGraphicsCullNone,
  }

  /**
    Provides access to a set of graphics groups that are either associated with a component or owned by another
    CustomGraphicsGroup object. This object also supports the creation of new custom graphics groups.
  */
  abstract class CustomGraphicsGroups extends core.Base {
    /**
      Function that returns the specified graphics group using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CustomGraphicsGroup | null
    /**
      Returns the number of graphics groups in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new, empty CustomGraphicsGroup.
      @returns Returns the new CustomGraphicsGroup object or null in the case of a failure.
    */
    add(): CustomGraphicsGroup | null
  }

  /**
    Represents of group of custom graphics entities. A group can also own other graphics groups.
  */
  abstract class CustomGraphicsGroup extends CustomGraphicsEntity {
    /**
      Function that returns the specified custom graphics entity within this group. This also includes
      any child graphics groups.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CustomGraphicsEntity | null
    /**
      Returns the number of graphics entities within the group.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new, empty CustomGraphicsGroup that is owned by this CustomGraphicsGroup.
      @returns Returns the new CustomGraphicsGroup object or null in the case of a failure.
    */
    addGroup(): CustomGraphicsGroup | null
    /**
      Adds a new CustomGraphicsMesh entity to this group.
      @param coordinates The CustomGraphicsCoordinates object that defines the coordinates of the vertices of the mesh.
      A CustomGrahpicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class.
      @param coordinateIndexList An array of integers that represent indices into the coordinates to define the vertices of the triangles. If an empty
      array is provided, then it's assumed that the first three coordinates defines the first triangle, the next three define
      the second triangle, and so on.
      @param normalVectors An array of doubles that represent the x, y, z components of the normals at each coordinate. There should be a normal defined
      for each coordinate. If an empty array is provided for the normal vectors, Fusion will automatically calculate normal vectors
      that are 90 degrees to the face of the triangle, making it appear flat.
      @param normalIndexList An array of integers that represent indices into the normal vectors to define the which vector corresponds to which vertex. This
      should be the same size as the vertex index list. If an empty array is input and normal vectors are provided, it is assumed that
      the normals match up one-to-one to each coordinate.
      @returns Returns the new CustomGraphicsMesh object or null in the case of a failure.
    */
    addMesh(coordinates: CustomGraphicsCoordinates, coordinateIndexList: number[] /*int[]*/, normalVectors: number[], normalIndexList: number[] /*int[]*/): CustomGraphicsMesh | null
    /**
      Adds a new CustomGraphicsLines entity to this group.
      @param coordinates The CustomGraphicsCoordinates object that defines the coordinates of the vertices of the lines.
      A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class.
      @param indexList An array of integers that represent indices into the coordinates to define the order the coordinates are used to draw the lines.
      If an empty array is provided, the coordinates are used in the order they're provided in the provided CustomGraphicsCoordinates object.
      @param isLineStrip A boolean indicating if a series of individual lines or a connected set of lines (a line strip) is to be drawn. If individual lines
      are drawn, (this argument is false), each pair of coordinates defines a single line. If a line strip is drawn, (this argument is true),
      the first pair of coordinates define the first line and the third coordinate defines a line that connects to the second coordinate.
      The fourth coordinate creates a line connecting to the third coordinate, and so on.
      @param lineStripLengths If isLineStrip is true, this argument is used to define the number of coordinates to use in each line strip. It is an array of integers
      that defines the number of coordinates for each line strip. For example, if the array [4,10] is input, 4 coordinates are connected for
      the first line strip and 10 are used to create a second line strip. If an empty array is provided, a single line strip is created. If
      isLineStrip is False, this argument is ignored.
      @returns Returns the new CustomGraphicsLines object or null in the case of a failure.
    */
    addLines(coordinates: CustomGraphicsCoordinates, indexList: number[] /*int[]*/, isLineStrip: boolean, lineStripLengths?: number[] /*int[]*//* = null*/): CustomGraphicsLines | null
    /**
      Adds a new CustomGraphicsCurve entity to this group. A CustomGraphicsCurve is a wireframe graphic
      that is based on any object derived from Curve3D (except InfiniteLine3D). This is useful when
      drawing curved geometry where the alternative is to stroke the smooth curve and draw it as a series
      of lines. Using this you can directly use the curve and Fusion will automatically take care of creating
      the correct display for the current level of detail.
      @param curve The curve that defines the shape of the graphics entity. Any of the curve types derived from Curve3D
      are valid except for InfiniteLine3D.
      @returns Returns the newly created CustomGraphicsCurve object or null in the case of failure.
    */
    addCurve(curve: core.Curve3D): CustomGraphicsCurve | null
    /**
      Adds a new CustomGraphicsPointSet entity to this group. This will be displayed as one or more points where
      all of the points will display using the same image.
      @param coordinates The CustomGraphicsCoordinates object that defines the coordinates where the points will be displayed.
      A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class.
      @param indexList An array of integers that represent indices into the coordinates to define which coordinates to use when drawing points.
      If an empty array is provided, a point is drawn for every coordinate.
      @param pointType Specifies the type of point to display. Currently there are two choices UserDefinedCustomGraphicsPointType and
      PointCloudCustomGraphicsPointType. When set to PointCloudCustomGraphicsPointType, each point displays as a single pixel and is
      the most efficient point display type for displaying sets that contain very large quantities of points. When
      set to UserDefinedCustomGraphicsPointType, you specify the image to display as the point. This can be any PNG image and is
      centered on the point.
      @param pointImage If the pointType is PointCloudCustomGraphicsPointType this argument is ignored and can be an empty string. This argument
      must be specified if the pointType is UserDefinedCustomGraphicsPointType. This is the path to the PNG image file that will be
      displayed as the point. It can be either a full path to the file or a relative path that is respect to the .py, dll, or dylib
      file being run. There is no restriction on the size of the image, but generally very small images would be used for points.
      @returns Returns the newly created CustomGraphicsPointSet object or null in the case of failure.
    */
    addPointSet(coordinates: CustomGraphicsCoordinates, indexList: number[] /*int[]*/, pointType: CustomGraphicsPointTypes, pointImage: string): CustomGraphicsPointSet | null
    /**
      Adds a new CustomGraphicsText entity to this group. This will be displayed as a single line of text.
      It is placed so that the upper-left corner is at the point defined and the text will be parallel
      to the X-Y plane of the world coordinate system and in the X direction. To change it's position relative
      to the input point you can change the horizontal and vertical justification on the returned CustomGrahicsText
      object. You can also reorient the text by changing the transform of the returned CustomGraphicsText object.
      @param formattedText The text string to be displayed. Overall formatting can be defined using properties on the returned
      CustomGraphicsText object. Formatting overrides can be defined within the string using formatting codes.
      @param font The name of the font to use when displaying the text.
      @param size The size of the text in centimeters.
      @param transform Transformation matrix that specifies the position and orientation of the text in model space. The origin of the text
      is the upper-left corner.
      @returns Returns the newly created CustomGraphicsText object or null in the case of failure.
    */
    addText(formattedText: string, font: string, size: number, transform: core.Matrix3D): CustomGraphicsText | null
    /**
      Adds a new CustomGraphicsBRepBody object to this group. This displays a real or transient BRepBody
      object as custom graphics. No relationship exists back to the original input body so if it is
      changed, the custom graphics will not change.
      The body associated with the CustomGraphicsBRep body is a copy of the original input body. Equivalent
      Faces, Edges, and vertices can be found by using the indexes in the collection. For example if you have
      a face of the original body and find that it is at index 24 in the BRepFaces collection of that body,
      the equivalent face in the custom graphics body will also be at index 24. This works as long as the original
      body is not modified in any way.
      @param body The real or transient BRepBody object to draw using custom graphics.
      @returns Returns the newly created CustomGraphicsBRepBody object or null in the case of failure.
    */
    addBRepBody(body: BRepBody): CustomGraphicsBRepBody | null
    /**
      Defines if the child custom graphic entities are selectable or if the entire group is selected in the UI. By default this is true.
      If false, the isSelectable property defines if this group is selectable. If true, the isSelectable property of each child entity defines if it is selectable.
    */
    isChildrenSelectable: boolean
  }

  /**
    Represents coordinates that are used to define vertices in custom graphics.
  */
  abstract class CustomGraphicsCoordinates extends core.Base {
    /**
      Static method that creates a CustomGraphicsCoordinates object which can be used as input to
      various custom graphics methods.
      @param coordinates An array of doubles where the values are the x, y, z components of each coordinate where
      the unit of measure is centimeters.
      @returns Returns the created CustomGraphicsCoordinates object or null in the case of failure.
    */
    static create(coordinates: number[]): CustomGraphicsCoordinates | null
    /**
      Gets and sets the coordinate data associated with this CustomGraphicsCoordinates object.
      This data represents the x, y, z components of the coordinates where the unit of measure is centimeters.
    */
    coordinates: number[]
    /**
      Returns the number of coordinates defined in the CustomGraphicsCoordinates object.
    */
    readonly coordinateCount: number /*int*/
    /**
      Gets the coordinate at the specified index.
      @param index The index of the coordinate to return. The first coordinate has an index of 0.
      @returns Returns the coordinate as a Point3D object.
    */
    getCoordinate(index: number /*int*/): core.Point3D
    /**
      Sets the coordinate at the specified index.
      @param index The index of the coordinate to set. The first coordinate has an index of 0.
      @param coordinate The coordinate value as a Point3D object.
      @returns Returns true if setting the coordinate was successful.
    */
    setCoordinate(index: number /*int*/, coordinate: core.Point3D): boolean
    /**
      Gets and sets the colors associated with the coordinate data. This is used when a mesh is
      displayed using per-vertex coloring.
      The color at each vertex is represented by four values where they are the red, green, blue,
      and alpha values. This should contain the same number of colors as vertices.
    */
    colors: number[] /*short[]*/
    /**
      Gets the color assigned to the coordinate at the specified index.
      @param index The index of the color to return. The first color has an index of 0.
      @returns Returns the color associated with the index. Can also return null in the case
      where there is no color assigned.
    */
    getColor(index: number /*int*/): core.Color | null
    /**
      Sets the color of the coordinate at the specified index.
      @param index The index of the coordinate to set. The first coordinate has an index of 0.
      @param color The color value as a Color object.
      @returns Returns true if setting the color was successful.
    */
    setColor(index: number /*int*/, color: core.Color): boolean
  }

  /**
    Represents a custom triangle mesh drawn in the graphics window.
  */
  abstract class CustomGraphicsMesh extends CustomGraphicsEntity {
    /**
      Gets and sets the coordinates associated with this CustomGraphicsMesh.
    */
    coordinates: CustomGraphicsCoordinates
    /**
      Gets and sets the normal vectors of the mesh where there is a normal
      vector at each node. The normals are defined as an array
      of floats where they are the x, y, z components of each vector.
    */
    normalVectors: number[]
    /**
      Gets and sets an array of indices that define which coordinate in the
      coordinate list is used for each vertex in the mesh. Each set of three
      indices defines a triangle. For example:
      Indices 0, 1, and 2 define the coordinates to use for the first triangle and
      indices 3, 4, and 5 define the coordinates for the second triangle, and so on.
    */
    vertexIndexList: number[] /*int[]*/
    /**
      Gets and sets an array of indices that define which normal is associated
      with each vertex in the mesh. This is used to look-up the normal in the
      normalVectors array.
    */
    normalIndexList: number[] /*int[]*/
    /**
      Gets and sets the texture coordinates as an array of floats where
      they are the u,v components at each node. They are defined as an
      array of doubles where they are the u, v coordinates of each node.
      Defining texture coordinates for a mesh is optional.
    */
    textureCoordinates: number[]
  }

  /**
    Represents lines drawn in the graphics window.
  */
  abstract class CustomGraphicsLines extends CustomGraphicsEntity {
    /**
      Gets and sets the CustomGraphicsCoordinates object that defines the coordinates of the vertices of the lines.
      A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class.
    */
    coordinates: CustomGraphicsCoordinates
    /**
      Gets and sets an array of integers that represent indices into the coordinates to define the order the coordinates are used to draw the lines.
      An empty array indicates that no index list is used and coordinates are used in the order they're provided in the provided CustomGraphicsCoordinates object.
    */
    indexList: number[] /*int[]*/
    /**
      Defines if the coordinates are used to define a series of individual lines or a connected set of lines (line strip). If individual lines
      are drawn (this property is false), each pair of coordinates define a single line. If a line strip is drawn (this property is true),
      the first pair of coordinates define the first line and the third coordinate defines a line that connects to the second coordinate.
      The fourth coordinate creates a line connecting to the third coordinate, and so on.
    */
    isLineStrip: boolean
    /**
      If isLineStrip is true, this property defines the number of coordinates to use in the line strips. It is an array of integers
      that defines the number of coordinates for each line strip. An empty array indicates that a single line strip is to be drawn.
    */
    lineStripLengths: number[] /*int[]*/
    /**
      Defines the thickness of the line in pixels.
    */
    weight: number
    /**
      Defines the scale as it relates to how the line style is applied. The effect is to
      shrink or expand the line style as it is applied to the line. This does not affect the line width.
    */
    lineStyleScale: number
    /**
      Specifies if the line style is computed based on the screen or model space. The default is
      based on the screen which means the style is drawn the same regardless of how you zoom in
      or out of the view. That is the length of lines and spaces are based on pixels. If it
      is drawn relative to model space then the lines and spaces are defined in centimeters and
      will zooming in and out will change the apparent spacing.
    */
    isScreenSpaceLineStyle: boolean
    /**
      The line style to apply to the line. The default is to draw a continuous line.
    */
    lineStylePattern: LineStylePatterns
  }

  /**
    Specifies the line styles that can be applied to custom graphics lines and curves.
  */
  const enum LineStylePatterns {
    /**
      A solid line with no breaks.
    */
    continuousLineStylePattern,
    /**
      A center line type of pattern which is a series of long and short lines.
    */
    centerLineStylePattern,
    /**
      A center line type of pattern made of a series of short lines.
    */
    dashedLineStylePattern,
    /**
      A center line type of pattern made of a series of dots.
    */
    dotLineStylePattern,
    /**
      A center line type of pattern made of a series of short lines.
    */
    hiddenLineStylePattern,
    /**
      A center line type of pattern made of a series of a long line and two short lines.
    */
    phantomLineStylePattern,
    /**
      A center line type of pattern made of a single continuous line and many short perpendicular lines.
    */
    tracksLineStylePattern,
    /**
      A center line type of pattern made of a series of 45 degree lines to create a zig-zag pattern.
    */
    zigzagLineStylePattern,
  }

  /**
    Represents text drawn in the graphics window. The default position of the text is at (0,0,0) and
    orientation is the text lying on the x-y plane. To reposition and reorient the text you can use
    the transformation property.
  */
  abstract class CustomGraphicsText extends CustomGraphicsEntity {
    /**
      Gets and sets the formatted text definition. This is the full string, including the
      formatting information, that's used to define the displayed text.
    */
    formattedText: string
    /**
      Gets and sets the font used to display the text. This is the default font and applies to
      all of text unless there is a font override defined within the text.
    */
    font: string
    /**
      Specifies that the text displays using an italic style. This is the default italic style and applies to
      all of text unless there is a style override defined within the text.
    */
    isItalic: boolean
    /**
      Specifies that the text displays using a bold style. This is the default bold style and applies to
      all of text unless there is a style override defined within the text.
    */
    isBold: boolean
    /**
      Specifies that the text displays using an underline style. This is the default underline style and applies to
      all of text unless there is a style override defined within the text.
    */
    isUnderline: boolean
    /**
      Specifies that the text displays using a strike through style. This is the default strike through style and applies to
      all of text unless there is a style override defined within the text.
    */
    isStrikeThrough: boolean
    /**
      Gets and sets the size of the text in centimeters. This is the default size and applies to
      all of text unless there is a size override defined within the text.
    */
    size: number
    /**
      The actual width of the text in centimeters. This is useful when you want to position several
      GraphicsText objects together.
    */
    readonly width: number
    /**
      The actual height of the text in centimeters. This is useful when you want to position several
      GraphicsText objects together.
    */
    readonly height: number
  }

  /**
    This represents custom graphics that are based on any object derived from Curve3D (except InfiniteLine3D).
    This is useful when drawing curved geometry where the alternative is to stroke the smooth curve and draw
    it as a series of lines. Using this you can directly use the curve and Fusion will automatically take care
    of creating the correct display for the current level of detail.
  */
  abstract class CustomGraphicsCurve extends CustomGraphicsEntity {
    /**
      Gets and sets the curve associated with this graphics entity. Any of the curve types derived from Curve3D
      is valid except for InfiniteLine3D.
    */
    curve: core.Curve3D
    /**
      Defines the thickness of the curve in pixels.
    */
    weight: number
    /**
      The line style to apply to the curve. The default is to draw the curve using continuous line style.
    */
    lineStylePattern: LineStylePatterns
    /**
      Defines the scale as it relates to how the line style is applied. The effect is to
      shrink or expand the line style as it is applied to the line. This does not affect the line width.
    */
    lineStyleScale: number
  }

  /**
    This represents custom graphics that are based on a BRepBody.
  */
  abstract class CustomGraphicsBRepBody extends CustomGraphicsEntity {
    /**
      Returns a transient BRepBody that is being displayed as custom graphics.
    */
    readonly bRepBody: BRepBody
  }

  /**
    Represents a set of one or more custom graphics points all of the same style.
  */
  abstract class CustomGraphicsPointSet extends CustomGraphicsEntity {
    /**
      Gets and sets the coordinates used to define the position of the custom graphics points.
      If no indexList is specified, every coordinate will be drawn using a custom graphics point,
    */
    coordinates: CustomGraphicsCoordinates
    /**
      An list of indices that specify which coordinates from the coordinate list to draw points for.
      If this is an empty array, then all of the coordinates are used.
    */
    indexList: number[] /*int[]*/
    /**
      Gets and sets the image that will be used to display the point if the point type
      is a custom image. The image will always be billboarded. The file should be
      a PNG image and can use transparency. The filename can be a full path or a
      relative path that is relative to your runtime file. Setting this will automatically
      set the pointType to UserDefinedCustomGraphicsPointType. This property can also
      return an empty string in the case where a user defined image point is not being used.
    */
    pointImage: string
    /**
      Specifies which of the predefined point images to use. Attempting to set this property
      to UserDefinedCustomGraphicsPointType will fail. To change to a user defined point type
      you must set use the pointImage property to specify the image to use and this will have
      the side-effect of changing the value of this property to UserDefinedCustomGraphicsPointType.
    */
    pointType: CustomGraphicsPointTypes
  }

  /**
    A list of predefined point images that you can use for a CustomGraphicsPointSet.
  */
  const enum CustomGraphicsPointTypes {
    /**
      Specifies that the type of point is user defined, which means you supply the image.
    */
    UserDefinedCustomGraphicsPointType,
    /**
      Displays the point using a single pixel. This is the most efficient point display type
      and can be used to display very large quantities of points.
    */
    PointCloudCustomGraphicsPointType,
  }

  /**
    The base class for all custom graphics color effects.
  */
  abstract class CustomGraphicsColorEffect extends core.Base {
  }

  /**
    One of the types of color effects that can be applied to a custom graphics entity. With this
    type of effect, the graphics entity will display using the colors associated with the vertices
    of the mesh in the CustomGraphicsCoordinates object.
  */
  abstract class CustomGraphicsVertexColorEffect extends CustomGraphicsColorEffect {
    /**
      Statically creates a new CustomGraphicsVertexColorEffect object.
      @returns Returns the created CustomGraphicsVertexColorEffect or null in case of a failure.
    */
    static create(): CustomGraphicsVertexColorEffect | null
  }

  /**
    One of the types of color effects that can be applied to a custom graphics entity. With this
    type of effect, the graphics entity will display as the single color without any lighting
    effects. For example, a sphere will display as a solid filled circle without any shading
    indicating it is actually spherical.
  */
  abstract class CustomGraphicsSolidColorEffect extends CustomGraphicsColorEffect {
    /**
      Statically creates a new CustomGraphicsSolidColorEffect object. This can be used as input
      when creating various color related custom graphics attributes. A solid color effect,
      colors the entity with a single color without any lighting effects. With this coloring
      effect, a sphere will display as a solid filled circle.
      @param color The color to use for the solid color display. The opacity component of the color is ignored
      because the opacity of custom graphics is controlled separately using an opacity attribute.
      @returns Returns the created CustomGraphicsSolidColorEffect or null in case of a failure.
    */
    static create(color: core.Color): CustomGraphicsSolidColorEffect | null
    /**
      The color to use for the solid color display. The opacity component of the color is ignored
      because the opacity of custom graphics is controlled separately using an opacity attribute.
    */
    color: core.Color
  }

  /**
    One of the types of color effects that can be applied to a custom graphics entity. With this type
    of effect, basic Phong shading and lighting techniques are used so give the entity a 3-dimensional
    appearance.
  */
  abstract class CustomGraphicsBasicMaterialColorEffect extends CustomGraphicsColorEffect {
    /**
      Statically creates a new basic CustomGraphicsBasicMaterialColorEffect object. This can be used to
      color custom graphics entities. With this type of effect you define the basic Phong shading
      properties so that the entity can be rendered with basic shading and lighting effects applied
      so that it appears 3-dimensional.
      If only the emissive color is provided, the API will automatically create values for the
      other colors to render the object as a single color.
      @param diffuseColor The diffuse color is the color of reflected light as it scatters off of a rough surface and is
      the primary color of the entity. This color is always required.
      @param ambientColor The ambient color is the color of the light anywhere there's not a specific light source. If
      not specified the same color as the diffuse color is used.
      @param specularColor The specular color is the color of reflected light (highlights) as it is reflected off of a shiny surface. This is
      commonly white or a lighter shade of the diffuse color. If not specified, white is used.
      @param emissiveColor The emissive color is the color of light that entity emits, such as in a light bulb. If not specified,
      black for no emissive light is used.
      @param glossiness This specifies how glossy the entity is. The glossiness determines the size of highlights, and thus
      the apparent shininess of the material. A value of 0.0 will result in very large highlights like you
      would see with a rough surface. A maximum value of 128.0 will result in very small highlight as
      from a smooth surface.
      @param opacity Specifies the opacity of the entity where a value of 1.0 is completely opaque and 0.0 is completely transparent.
      @returns Returns the created CustomGraphicsBasicMaterialColorEffect or null in case of a failure.
    */
    static create(diffuseColor: core.Color, ambientColor?: core.Color, specularColor?: core.Color, emissiveColor?: core.Color, glossiness?: number/* = 5.0*/, opacity?: number/* = 1.0*/): CustomGraphicsBasicMaterialColorEffect | null
    /**
      Gets and sets the emissiveColor associated with this CustomGraphicsBasicMaterialColorEffect object.
      The emissive color is the primary color of the entity
    */
    emissiveColor: core.Color
    /**
      Gets and sets the ambientColor associated with this CustomGraphicsBasicMaterialColorEffect object.
      The ambient color is the color of the light anywhere there's not a specific light source.
    */
    ambientColor: core.Color
    /**
      Gets and sets the diffuseColor associated with this CustomGraphicsBasicMaterialColorEffect object.
      The diffuse color is the color of reflected light as it scatters off of a rough surface.
    */
    diffuseColor: core.Color
    /**
      Gets and sets the specularColor associated with this CustomGraphicsBasicMaterialColorEffect object.
      The specular color is the color of reflected light (highlights) as it is reflected off of a shiny surface. This is
      commonly white or a lighter shade of the emissive color.
    */
    specularColor: core.Color
    /**
      Gets and sets the glossiness associated with this CustomGraphicsBasicMaterialColorEffect object.
      The glossiness determines the size of highlights, and thus the apparent shininess of the material.
      A value of 0.0 will result in very large highlights like you would see with a rough surface.
      A maximum value of 128.0 will result in very small highlight as from a smooth surface.
    */
    glossiness: number
    /**
      Gets and sets the opacity associated with this CustomGraphicsBasicMaterialColorEffect object.
      A value of 1.0 is completely opaque and 0.0 is completely transparent.
    */
    opacity: number
  }

  /**
    One of the types of color effects that can be applied to a custom graphics entity. With this
    type of effect, the graphics entity will display using a Fusion appearance.
  */
  abstract class CustomGraphicsAppearanceColorEffect extends CustomGraphicsColorEffect {
    /**
      Statically creates a new CustomGraphicsAppearanceColorEffect object. This can be used when
      setting the color property of the various custom graphics objects. With this coloring
      effect, an existing appearance is used. The appearance must be available in the
      design where the graphics will be drawn.
      @param appearance The appearance to use. The appearance must be available in the design where the
      graphics will be drawn.
      @returns Returns the created CustomGraphicsAppearanceColorEffect or null in case of a failure.
    */
    static create(appearance: core.Appearance): CustomGraphicsAppearanceColorEffect | null
    /**
      Gets and sets the appearance to use. The appearance assigned must be available in the
      design where the graphics will be drawn.
    */
    appearance: core.Appearance
  }

  /**
    One of the types of color effects that can be applied to a custom graphics entity. With this
    type of effect, the graphics entity will display using the specified color and will show through
    other graphics that are in front of it.
  */
  abstract class CustomGraphicsShowThroughColorEffect extends CustomGraphicsColorEffect {
    /**
      Creates a new CustomGraphicsShowThroughColorEffect object that can be assigned to a custom graphics entity
      using its showThrough property.
      @param color The color that will be used to render the custom graphics object.
      @param opacity The level of opacity that will be applied when rendering the custom graphics object. A value of 0 is fully translucent
      and will have the effect of the object being completely covered by objects in front of it. A value of 1 is fully opaque
      which will have the effect of the object completely covering all objects. Values in between will make objects in front of
      the graphics object appear translucent to varying degrees so you can see the custom graphics object through it.
      @returns Returns the newly created CustomGraphicsShowThroughColorEffect object or null in the case of failure. This can be assigned
      to a custom graphics entity using its showThrough property.
    */
    static create(color: core.Color, opacity: number): CustomGraphicsShowThroughColorEffect | null
    /**
      Gets and sets the color associated with this CustomGraphicsShowThroughColorEffect object. The color that will be used to render
      the portion of the entity that is covered by other objects in the scene.
    */
    color: core.Color
    /**
      Gets and sets the opacity value associated with this CustomGraphicsShowThroughColorEffect object. The opacity is used when rendering
      the portion of the entity that is covered by other objects in the scene. This can be a value between 0 and 1, where 1 is
      fully opaque and will completely cover any other entities.
    */
    opacity: number
  }

  /**
    Provides access to the Canvases in a component and provides the functionality
    to add new Canvases.
  */
  abstract class Canvases extends core.Base {
    /**
      Returns the specified canvas using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Canvas | null
    /**
      Returns the specified canvas using the name of the canvas.
      @param name The name of the canvas as seen in the browser and timeline.
      @returns Returns the specified Canvas, if it exists. Otherwise it returns null.
    */
    itemByName(name: string): Canvas
    /**
      Returns the number of canvases in the component.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new canvas. Use the createInput method to first create an input object and
      set the available options. Then, pass that input object to the add method to create the canvas.
      @param input The CanvasInput object that defines the required information needed to create a new canvas.
      A CanvasInput object is the logical equivalent to the command dialog when creating
      a canvas. It provides access to the various options when creating a canvas. Calling the add method and passing
      in the CanvasInput is the equivalent to clicking the OK button on the dialog to create the canvas.
      @returns Returns the newly created Canvas object.
    */
    add(input: CanvasInput): Canvas
    /**
      Creates a new CanvasInput object. A CanvasInput object is the logical equivalent to the command dialog when creating
      a canvas. It provides access to the various options when creating a canvas. Calling the add method and passing
      in the CanvasInput is the equivalent to clicking the OK button on the dialog to create the canvas.
      @param imageFilename The full filename to the image to use for the canvas. PNG, JPEG, and TIFF files are supported.
      @param planarEntity A planar BRepFace or a Construction plane to create the canvas on. If the canvas is being created in a base
      feature or in a direct modeling design, this can be a Plane object.
      @returns Returns a CanvasInput object or null in the case of failure.
    */
    createInput(imageFilename: string, planarEntity: core.Base): CanvasInput | null
  }

  /**
    The CanvasInput object is used to define the various options when creating a new canvas. It's created
    using the Canvases.createInput method and is used by the Canvases.add method to create a Canvas.
  */
  abstract class CanvasInput extends core.Base {
    /**
      Gets and sets the plane the canvas is associated with. This can be either a planar Face
      or a construction plane. In a direct modeling design or the canvas is being created in a
      base feature, this can be a Plane object.
    */
    planarEntity: core.Base
    /**
      Gets and sets the opacity of the canvas where 0 is completely
      transparent and 100 is completely opaque. Setting this property
      to a value outside the range of 0-100 will result in the value
      being set to the closest valid value.
      Defaults to 50 when the input is created.
    */
    opacity: number /*int*/
    /**
      Controls if the image is visible through the model or not.
      Defaults to true when the input is created.
    */
    isDisplayedThrough: boolean
    /**
      Controls if the canvas is selectable or not within the graphics window.
      Defaults to false when the input is created.
    */
    isSelectable: boolean
    /**
      Controls if the canvas will be rendered when ray tracing within the Render workspace.
      Defaults to false when the input is created.
    */
    isRenderable: boolean
    /**
      Gets and sets the filename of the image used for the canvas.
      When setting this property, it is the full filename to the image to use for the canvas.
      PNG, JPEG, and TIFF files are supported.
    */
    imageFilename: string
    /**
      Returns a Plane object that is obtained from the planar face or construction plane
      and defines the parameter space the canvas is positioned relative to.
    */
    readonly plane: core.Plane
    /**
      Gets and sets the transform of the canvas. This allows you to control the position, rotation,
      scaling, and flipping. The X and Y axes defined by the matrix, must be perpendicular to one another.
      The directions of the X and Y axes defines the orientation of the image.
      This is a 3x3 matrix where the third column controls the position of the canvas and is relative to
      the parameter space of the plane defined by the specified planar face or construction plane.
    */
    transform: core.Matrix2D
    /**
      Flips the image along the horizontal axis. This is a convenience method that
      flips the direction of the X axis of the transform.
      @returns Returns true if the flip was successful.
    */
    flipHorizontal(): boolean
    /**
      Flips the image along the vertical axis. This is a convenience method that
      flips the direction of the Y axis of the transform.
      @returns Returns true if the flip was successful.
    */
    flipVertical(): boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Represents a Canvas within a component.
  */
  abstract class Canvas extends core.Base {
    /**
      Gets and sets the name of the canvas. This is the name seen in the browser and timeline.
    */
    name: string
    /**
      Deletes the canvas from the component.
    */
    deleteMe(): boolean
    /**
      Gets and sets the plane the canvas is associated with. This can be either a planar Face
      or a construction plane. In a direct modeling design or the canvas is being created in
      a base feature, this can be a Plane object.
    */
    planarEntity: core.Base
    /**
      Gets and sets the opacity of the canvas where 0 is completely
      transparent and 100 is completely opaque. Setting this property
      to a value outside the range of 0-100 will result in the value
      being set to the closest valid value.
    */
    opacity: number /*int*/
    /**
      Controls if the image is visible through the model or not.
    */
    isDisplayedThrough: boolean
    /**
      Controls if the canvas is selectable or not within the graphics window.
    */
    isSelectable: boolean
    /**
      Controls if the canvas will be rendered when ray tracing within the Render workspace.
    */
    isRenderable: boolean
    /**
      Returns if the canvas is currently visible in the graphics window. The isLightBulbOn
      property of the canvas controls if the canvas should be displayed or not, but even
      when true, the canvas may not be visible because the occurrence that references the
      component may not be visible. It's also possible to turn off the visibility of all
      canvases for a component. This property takes all of that into account when reporting
      if the canvas is visible or not.
    */
    readonly isVisible: boolean
    /**
      Gets and sets the filename of the image used for the canvas. When getting this property,
      the filename returned is the file that was used when the canvas was initially created.
      it's possible the file may no longer exist.
      When setting this property, it is the full filename to the image to use for the canvas.
      PNG, JPEG, and TIFF files are supported.
    */
    imageFilename: string
    /**
      Saves the image associated with the canvas to the specified file. This is useful in
      cases where the original image file is no longer available but you need the image
      for some other purpose.
      @param filename The full filename of the image to save, including the file extension, which controls
      the format of the image file. If a file extension other than png, jpg, or tiff is
      specified, a png extension will be added to the filename by default.
      This method will fail if a file with the specified filename already exists.
      If you want to overwrite the file, you'll need to delete it first before
      calling this method.
      @returns Returns true if writing the file was successful.
    */
    saveImage(filename: string): boolean
    /**
      Returns a Plane object that represents the position and orientation of the canvas in model space.
    */
    readonly plane: core.Plane
    /**
      Gets and sets the transform of the canvas. This allows you to control the position, rotation,
      scaling, and flipping. The X and Y axes defined by the matrix and must be perpendicular to one another.
      This is a 3x3 matrix where the third column controls the position of the canvas and
      defines the position using 2D coordinates in the model space.
    */
    transform: core.Matrix2D
    /**
      Flips the image along the horizontal axis. This is a convenience method that
      flips the direction of the X axis of the transform.
      @returns Returns true if the flip was successful.
    */
    flipHorizontal(): boolean
    /**
      Flips the image along the vertical axis. This is a convenience method that
      flips the direction of the Y axis of the transform.
      @returns Returns true if the flip was successful.
    */
    flipVertical(): boolean
    /**
      Gets and sets if the light bulb of this canvas as displayed in the browser is on or off.
      A canvas will only be visible if the light bulb is switched on. However, the light bulb
      can be on and the canvas still invisible if the visibility of a higher level occurrence
      has its light bulb off or if the light bulb for Canvases folder is off to turn off all
      canvases in a component.
    */
    isLightBulbOn: boolean
    /**
      Returns a token for the Canvas object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same canvas.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: Canvas
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): Canvas | null
    /**
      Returns the timeline object associated with the creation of this canvas.
    */
    readonly timelineObject: TimelineObject
  }

  /**
    Provides access to the Decals in a component and provides the functionality
    to add new Decals.
  */
  abstract class Decals extends core.Base {
    /**
      Returns the specified Decal object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Decal | null
    /**
      Returns the specified decal using the name of the decal.
      @param name The name of the decal as seen in the browser and timeline.
      @returns Returns the specified Decal object, if it exists. Otherwise it returns null.
    */
    itemByName(name: string): Decal
    /**
      Returns the number of decals in the component.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new decal. Use the createInput method to first create an input object and
      set the available options. Then, pass that input object to the add method to create the decal.
      @param input The DecalInput object that defines the required information needed to create a new decal.
      A DecalInput object is the logical equivalent to the Decal command dialog by providing access to
      all the decal options. Passing in the DecalInput object to the add method is the equivalent of
      clicking the OK button on the dialog to create the decal.
      @returns Returns the newly created Decal object.
    */
    add(input: DecalInput): Decal
    /**
      Creates a new DecalInput object. A DecalInput object is the logical equivalent to the Decal
      command dialog by providing access to all the decal options. Passing in the DecalInput object
      to the add method is the equivalent of clicking the OK button on the dialog to create the decal.
      @param imageFilename The full filename to the image to use for the decal. PNG, JPEG, and TIFF files are supported.
      @param faces Specifies the faces the decal will be associated with. Typically, this will be an array containing
      a single face. If the isChainFaces property on the input is true, only a single face is needed,
      and the rest of the faces in the body will automatically be used. If the isChainFaces property is
      false, this defines a subset of faces in the body to which the decal will be applied.
      If multiple faces are provided, the first face in the array is used to position and orient the
      decal. The position and orientation are relative to the first face. Any additional faces should
      connect directly or indirectly through other connected faces to the first face.
      @param point Specifies a point on the first face that defines the center position of the decal.
      @returns Returns a DecalInput object or null in the case of failure.
    */
    createInput(imageFilename: string, faces: BRepFace[], point: core.Point3D): DecalInput | null
  }

  /**
    The DecalInput object is used to define the various options when creating a new decal. It's created
    using the Decals.createInput method and is used by the Decals.add method to create a Decal.
  */
  abstract class DecalInput extends core.Base {
    /**
      Gets and sets the faces the decal will be associated with. Typically, this will be an array containing
      a single face and the isChainFaces property on the input will be true. The position and orientation of
      the decal is based on this face and the decal can wrap onto other faces in the body.
      If the isChainFace property is false, the decal will only be applied to the provided faces where the
      first face is used to calculate the position and orientation of the decal.
    */
    faces: BRepFace[]
    /**
      Gets and sets the opacity of the decal where 0 is completely transparent and 1.0 is completely
      opaque. Setting this property to a value outside the range of 0-1 will result in the value
      being set to the closest valid value.
      Defaults to 1.0 when the input is created.
    */
    opacity: number
    /**
      Controls if the decal will wrap onto the faces that connect to the face the decal is placed on. When this
      is true, the list of faces should contain only one face.
      Defaults to true when the input is created.
    */
    isChainFaces: boolean
    /**
      Gets and sets the filename of the image used for the decal.
      When setting this property, it is the full filename to the image to use for the decal.
      PNG, JPG, and TIFF files are supported.
    */
    imageFilename: string
    /**
      Gets and sets the transform of the decal. This controls the position, rotation,
      scaling, and flipping. This is done by providing a 3D matrix that defines a 3D coordinate system
      in model space. The origin of the matrix defines the center of the decal and must lie somewhere
      on the first face. The Z-axis of the matrix should be the same as the normal of the face at the
      origin. The X and Y axes define the orientation of the decal and must be both perpendicular to
      the Z and each other. Reversing the direction of the X or Y axis will flip the decal in that
      direction. The magnitude of the X and Y axes controls the scale, and the scale can be non-uniform,
      meaning the length of the X and Y vectors do not need to be the same.
    */
    transform: core.Matrix3D
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Represents a Decal within a component.
  */
  abstract class Decal extends core.Base {
    /**
      Gets and sets the name of the decal. This is the name seen in the browser and timeline.
    */
    name: string
    /**
      Deletes the decal from the component.
    */
    deleteMe(): boolean
    /**
      Gets the faces the decal is associated with. Typically, this is an array containing a single
      face. If the isChainFaces property is true, this will return the primary
      face. If the isChainFaces property is false, the decal is limited to the faces in this
      list.
      If multiple faces have been provided, the first face in the list is the
      primary face, which is used to position and orient the decal.
      To set the faces, use the redefine method.
    */
    readonly faces: BRepFace[]
    /**
      Gets and sets the opacity of the decal where 0 is completely transparent and 1.0 is completely
      opaque. Setting this property to a value outside the range of 0-1 will result in the value
      being set to the closest valid value.
      Defaults to 1.0 when the input is created.
    */
    opacity: number
    /**
      Returns if the decal is limited to a specified set of faces or wraps onto all faces in the body. If this
      property is True, a single face has been specified and the decal can wrap onto other faces of the body.
      If False, the decal is limited to the set of specified faces.
      To change this setting, use the redefine method.
    */
    readonly isChainFaces: boolean
    /**
      Returns if the decal is currently visible in the graphics window. The isLightBulbOn
      property of the decal controls if the decal should be displayed or not, but even
      when true, the decal may not be visible because the occurrence that references the
      component may not be visible. It's also possible to turn off the visibility of all the
      decals in a component. This property takes all of that into account when reporting
      if the decal is visible or not.
    */
    readonly isVisible: boolean
    /**
      Gets and sets the filename of the image used for the decal. When getting this property,
      the filename returned is the file that was used when the decal was initially created.
      it's possible the file may no longer exist.
      When setting this property, it is the full filename to the image to use for the decal.
      PNG, JPEG, and TIFF files are supported.
    */
    imageFilename: string
    /**
      Saves the image associated with the decal to the specified file. This is useful in
      cases where the original image file is no longer available but you need the image
      for some other purpose.
      @param filename The full filename of the image to save, including the extension of the file, which
      controls what format the image file will be. If file extension is other than png, jpg
      or tiff, then by default png extension will be added to the filename.
      This method will fail if a file with the specified filename already exists.
      If you want to overwrite the file, you'll need to delete it first before
      calling this method.
      @returns Returns true if writing the file was successful.
    */
    saveImage(filename: string): boolean
    /**
      Gets the transform of the decal. The returned matrix defines the position, rotation,
      scaling, and flipping. This is done by providing a 3D matrix which defines a 3D coordinate system
      in model space. The origin of the matrix defines the center of the decal and must lie somewhere on
      the first face. The normal of the face defines the Z axis of the matrix and the X and Y axes
      define the orientation of the decal and must be both perpendicular to the Z axis and to each other.
      Reversing the direction of the X or Y axis will flip the decal in that direction. The magnitude
      of the X and Y axes controls the scale and the scale can be non-uniform, meaning the length of
      the X and Y vectors do not need to be the same.
      To set the transform, use the redefine method.
    */
    readonly transform: core.Matrix3D
    /**
      Redefines the position, orientation, and how the decal is applied to the body.
      To call this method, you need to position the timeline marker to immediately before this decal.
      This can be accomplished using the following code: thisDecal.timelineObject.rollTo(True)
      @param position Defines the position, rotation, scaling, and flipping of the decal. The input 3D matrix defines a
      3D coordinate system in model space. The origin of the matrix defines the center of the decal and must
      lie somewhere on the first face. The Z-axis of the matrix should be the same as the normal of the face at the
      origin. The X and Y axes define the orientation of the decal and must be both perpendicular to
      the Z axis and each other. Reversing the direction of the X or Y axis will flip the decal in that
      direction. The magnitude of the X and Y axes controls the scale, and the scale can be non-uniform,
      meaning the length of the X and Y vectors do not need to be the same.
      @param faces Defines the face where the decal will be placed. The first face in the array is the primary face, which
      is where the position point must be on. If the isChainFaces argument is true, only the primary face is needed
      and it will be used to define the position and orientation of the decal and the decal can wrap onto all the
      faces of the body. If the isChainFaces argument is false, the decal can only be applied to the specified
      faces with the first face in the array being used as the primary face.
      @param isChainFaces If true, only one face is needed and the decal wraps onto all the faces of the body.
      If false, the decal can only be applied to the specified faces with the first face being used to calculate
      the position and orientation.
    */
    redefine(position: core.Matrix3D, faces: BRepFace[], isChainFaces: boolean): boolean
    /**
      Gets and sets if the light bulb of this decal as displayed in the browser is on or off.
      A decal will only be visible if the light bulb is switched on. However, the light bulb
      can be on and the decal still invisible if the visibility of a higher level occurrence
      has its light bulb off or if the light bulb for the Decals folder is off to turn off all
      decals in a component.
    */
    isLightBulbOn: boolean
    /**
      Returns a token for the Decal object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same Decal.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: Decal
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): Decal | null
    /**
      Returns the timeline object associated with the creation of this decal.
    */
    readonly timelineObject: TimelineObject
  }

  /**
    Provides access to the MeshBodies in the parent Component and
    supports the creation of new mesh bodies.
  */
  abstract class MeshBodies extends core.Base {
    /**
      Creates a new mesh body by importing an STL, OBJ or 3MF file.
      Because of a current limitation, if you want to create a mesh body in a parametric model,
      you must first call the edit method of the base or form feature, use this method to create
      the mesh body, and then call the finishEdit method of the base or form feature. The base
      or form feature must be in an "edit" state to be able to add any additional items to it.
      @param fullFilename The full filename (path and file) of a STL, OBJ or 3MF file.
      @param units The units to use when importing the file.
      @param baseOrFormFeature The BaseFeature or FormFeature object that this mesh body will be associated with. This is an optional
      requirement. It is required in a parametric modeling design but is ignored in a direct modeling design.
      @returns Returns a list of the newly created mesh bodies or null if the creation failed. Multiple
      bodies can be created in the case where a .obj file that contains multiple bodies was imported.
      STL files always contain a single body.
    */
    add(fullFilename: string, units: MeshUnits, baseOrFormFeature?: core.Base/* = null*/): MeshBodyList | null
    /**
      Provides access to a mesh body within the collection.
      @param index The index of the mesh body to return, where an index of 0 is the first mesh body in the collection.
      @returns Returns the specified mesh body or null in the case of a invalid index.
    */
    item(index: number /*unsigned int*/): MeshBody | null
    /**
      Returns the number of mesh bodies in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new mesh body using the mesh description provided.
      @param coordinates Input array of doubles that defines the X, Y, Z coordinates of each node in the mesh. Each set of three numbers define
      the coordinates of a node.
      @param coordinateIndexList An array of integers that represent indices into the coordinates to define the vertices of the triangles. If an empty
      array is provided, then it's assumed that the first three coordinates defines the first triangle, the next three define
      the second triangle, and so on.
      @param normalVectors An array of doubles that represent the x, y, z components of the normals at each coordinate. There should be a normal defined
      for each coordinate. If an empty array is provided for the normal vectors, Fusion will automatically calculate normal vectors
      that are 90 degrees to the face of the triangle, making it appear flat.
      @param normalIndexList An array of integers that represent indices into the normal vectors to define the which vector corresponds to which vertex. This
      should be the same size as the vertex index list. If an empty array is input and normal vectors are provided, it is assumed that
      the normals match up one-to-one to each coordinate.
      @returns Returns the newly created MeshBody object or null in the case of a failure.
    */
    addByTriangleMeshData(coordinates: number[], coordinateIndexList: number[] /*int[]*/, normalVectors: number[], normalIndexList: number[] /*int[]*/): MeshBody | null
  }

  /**
    The unit types that can be specified when importing a .stl or .obj file as a mesh.
  */
  const enum MeshUnits {
    /**
      Interpret the coordinate data using centimeters.
    */
    CentimeterMeshUnit,
    /**
      Interpret the coordinate data using millimeters.
    */
    MillimeterMeshUnit,
    /**
      Interpret the coordinate data using meters.
    */
    MeterMeshUnit,
    /**
      Interpret the coordinate data using inches.
    */
    InchMeshUnit,
    /**
      Interpret the coordinate data using feet.
    */
    FootMeshUnit,
  }

  /**
    Provides access to a list of MeshBody objects.
  */
  abstract class MeshBodyList extends core.Base {
    /**
      Provides access to a mesh body within the collection.
      @param index The index of the mesh body to return, where an index of 0 is the first mesh body in the collection.
      @returns Returns the specified mesh body or null in the case of a invalid index.
    */
    item(index: number /*unsigned int*/): MeshBody | null
    /**
      Returns the number of mesh bodies in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Container for overrides that control how the mesh is displayed in the interactive 3D view.
  */
  abstract class MeshBodyDisplayOverrides extends core.Base {
    /**
      Controls whether the mesh body face group colors are shown. If set to true, the face
      groups will be shown with the assigned appearance, ignoring the current display settings.
    */
    isSuppressFaceGroupColors: boolean
    /**
      Controls whether the edges of the triangles of the mesh body are shown. If set to true,
      individual triangles will not be visible, edges of face groups (if any) will be shown instead.
    */
    isSuppressTriangleEdges: boolean
  }

  /**
    Provides access to a mesh body.
  */
  abstract class MeshBody extends core.Base {
    /**
      Gets and sets the name of the mesh body as displayed in the browser.
    */
    name: string
    /**
      Gets and sets if the mesh body is selectable in the graphics window.
    */
    isSelectable: boolean
    /**
      Is the light bulb (as displayed in the browser) on.
      A mesh body will only be visible if the light bulb is switched on. However,
      the light bulb can be on and the mesh body is still invisible if the light bulb
      for all bodies or the owning component is off.
    */
    isLightBulbOn: boolean
    /**
      Gets if the mesh body point is visible.
    */
    readonly isVisible: boolean
    /**
      Deletes the mesh body.
      @returns Returns true in the case where the selection was successful.
    */
    deleteMe(): boolean
    /**
      Returns the original mesh data that was imported. This can include triangles, quads, and polygons.
    */
    readonly mesh: PolygonMesh
    /**
      Returns the associated mesh that is used for the display. This will always be triangles and includes any textures.
    */
    readonly displayMesh: TriangleMesh
    /**
      Returns the parent Component.
    */
    readonly parentComponent: Component
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshBody
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      Fails if this object is not the NativeObject.
      @param occurrence The occurrence that represents the context you want to create this proxy in.
      @returns Returns the proxy for the occurrence in the context of the specified occurrence. Returns null if it failed.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshBody | null
    /**
      This property returns the base or form feature that this mesh body is associated with. It
      returns null in a direct modeling design.
    */
    readonly baseOrFormFeature: core.Base
    /**
      Returns the collection of attributes associated with this mesh body.
    */
    readonly attributes: core.Attributes
    /**
      Gets and sets the physical material assigned to this mesh body.
    */
    material: core.Material
    /**
      Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying
      an override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
      this property to null will remove any override.
    */
    appearance: core.Appearance
    /**
      Read-write property that gets the source of the appearance for the body. If this returns OverrideAppearanceSource, an override exists
      on this body. The override can be removed by setting the Appearance property to null.
    */
    readonly appearanceSourceType: core.AppearanceSourceTypes
    /**
      Gets and sets the opacity override assigned to this body. A value of 1.0 specifies
      that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
      This value is not necessarily related to what the user sees because the opacity is inherited.
      For example, if you this body is in a component and that component's opacity is set to something
      other than 1.0, the body will also be shown as slightly transparent even though the opacity
      property for the body will return 1.0. Because the component that contains the body can be
      referenced as an occurrence in other components and they can have different opacity settings,
      it's possible that different instances of the same body can display using different opacity levels.
      To get the opacity that it is being displayed with use the MeshBody.visibleOpacity property.
      This is the API equivalent of the "Opacity Control" command available for the body in the browser.
    */
    opacity: number
    /**
      The user can set an override opacity for components and bodies these opacity overrides combine if
      children and parent components have overrides. This property returns the actual opacity that is
      being used to render the body. To set the opacity use the opacity property of the MeshBody object.
    */
    readonly visibleOpacity: number
    /**
      Returns a token for the MeshBody object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same mesh body.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Returns the TextureMapControl object associated with this body when there is an
      appearance assigned to the body that has a texture associated with it. If there
      isn't a texture, this property will return null. If there is a texture, you can
      use the returned object to query and modify how the texture is applied to the body.
    */
    readonly textureMapControl: core.TextureMapControl
    /**
      Returns the area in cm ^ 2.
      @experimental
    */
    readonly area: number
    /**
      Returns the volume in cm ^ 3. Returns 0 in the case the mesh body is not closed.
      @experimental
    */
    readonly volume: number
    /**
      Returns the bounding box of this mesh body.
      @experimental
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Check to see if the mesh is closed - i.e. contains no edges with only
      one triangle. Returns true if the mesh is closed, false if not.
      @experimental
    */
    readonly isClosed: boolean
    /**
      Check to see if the mesh is oriented - i.e. every edge has at most two
      triangles, and those triangles have consistent orientations.
      Returns true if the mesh is oriented, false if not.
      @experimental
    */
    readonly isOriented: boolean
    /**
      Creates a new component and occurrence within the component that currently owns this body.
      This body is moved into the new component and returned. The newly created component can be
      obtained by using the parentComponent property of the MeshBody object.
      @returns Returns the MeshBody in the new component or null in the case the creation failed.
      @experimental
    */
    createComponent(): MeshBody | null
    /**
      Returns a collection of all of the face groups in the body.
      @experimental
    */
    readonly faceGroups: FaceGroups
    /**
      Returns the face group with the temporary id.
      @param tempId The ID of the face group to find.
      @returns Returns the face group with the given tempId.
      @experimental
    */
    findByTempId(tempId: number /*int*/): core.Base
    /**
      Returns an oriented bounding box of the body that is best oriented to tightly fit the body.
      @experimental
    */
    readonly orientedMinimumBoundingBox: core.OrientedBoundingBox3D
    /**
      Gets the object that allows manipulation of overrides that control how the mesh is displayed in the interactive 3D view.
      @experimental
    */
    readonly displayOverrides: MeshBodyDisplayOverrides
    /**
      Copies the mesh body to the clipboard.
      @returns Returns true if the copy was successful.
      @experimental
    */
    copy(): boolean
    /**
      Cuts the mesh body to the clipboard.
      @returns Returns true if the cut was successful.
      @experimental
    */
    cut(): boolean
    /**
      Moves this mesh body from it's current component into the root component or the component owned by the
      specified occurrence.
      @param target The target can be either the root component or an occurrence.
      In the case where an occurrence is specified, the mesh body will be moved into the parent component of the target
      occurrence and the target occurrence defines the transform of how the mesh body will be copied so that the body
      maintains it's same position with respect to the assembly.
      @returns Returns the moved mesh body or null in the case the move failed.
      @experimental
    */
    moveToComponent(target: core.Base): MeshBody | null
    /**
      Creates a copy of this mesh body into the specified target.
      @param target The target can be either the root component or an occurrence.
      In the case where an occurrence is specified, the mesh body will be copied into the parent component of the target
      occurrence and the target occurrence defines the transform of how the mesh body will be copied so that the body
      maintains it's same position with respect to the assembly.
      @returns Returns the moved mesh body or null in the case the move failed.
      @experimental
    */
    copyToComponent(target: core.Base): MeshBody | null
  }

  /**
    FaceGroup collection.
    @experimental
  */
  abstract class FaceGroups extends core.Base {
    /**
      Function that returns the specified faceGroup using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): FaceGroup | null
    /**
      The number of FaceGroup objects in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represent a connected region on a single geometric surface.
    @experimental
  */
  abstract class FaceGroup extends core.Base {
    /**
      Returns the parent body of the face.
    */
    readonly parentBody: MeshBody
    /**
      Returns the area in cm ^ 2.
    */
    readonly area: number
    /**
      Returns the bounding box of this face
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Returns a point at the centroid (aka, geometric center) of the face.
    */
    readonly centroid: core.Point3D
    /**
      Returns the temporary ID of this face group. This ID is only good while the document
      remains open and as long as the owning mesh body is not modified in any way.
    */
    readonly tempId: number /*int*/
    /**
      Returns a token for the face group object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same face.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
      This is only valid for faces that exist in the design, (the isTemporary
      property is false).
    */
    readonly entityToken: string
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      face group object is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: FaceGroup
    /**
      Returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context for the created proxy.
      @returns Returns the new face group proxy or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): FaceGroup | null
    /**
      Returns if the face group is planar or not.
    */
    readonly isPlanar: boolean
  }

  /**
    Base class object representing all mesh features. Mesh features works on MeshBody objects and provide all functionality of the base
    feature except the functions bodies and faces, which will always return null.
    @experimental
  */
  abstract class MeshFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing mesh repair features in a component
    and supports the ability to create new mesh repair features.
    @experimental
  */
  abstract class MeshRepairFeatures extends core.Base {
    /**
      Function that returns the specified mesh repair feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshRepairFeature | null
    /**
      The number of mesh repair features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshRepairFeatureInput object. Use properties and methods on this object
      to define the mesh repair you want to create and then use the add method, passing in
      the MeshRepairFeatureInput object.
      @param mesh A MeshBody in either a parametric or direct modeling design.
      @returns Returns the newly created MeshRepairFeatureInput object or null if the creation failed.
    */
    createInput(mesh: core.Base): MeshRepairFeatureInput | null
    /**
      Creates a mesh repair feature.
      @param input A MeshRepairFeatureInput object that defines the desired repair feature. Use the createInput
      method to create a new MeshRepairFeatureInput object and then use methods on it
      (the MeshRepairFeatureInput object) to define the repair.
      @returns Returns the newly created MeshRepairFeature object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MeshRepairFeatureInput): MeshRepairFeature | null
    /**
      Function that returns the specified MeshRepair feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshRepairFeature | null
  }

  /**
    Specify the main repair type for the mesh. If RebuildMeshRepairType is chosen, other parameters can be set.
    @experimental
  */
  const enum MeshRepairTypes {
    /**
      Simplest and fastest type of repair, only close holes and fix flipped triangles are used to fix the part.
    */
    CloseHolesMeshRepairType,
    /**
      Makes the same changes as CloseHolesMeshRepairType, and also stitches triangles, removes double
      triangles, removes degenerated faces, and removes tiny shells.
    */
    StitchAndRemoveMeshRepairType,
    /**
      Uses in addition to the methods in StitchAndRemoveMeshRepairType also the wrapped method.
      This methods takes time and removes internal structure.
    */
    WrapMeshRepairType,
    /**
      Reconstructs the mesh body using one of 4 MeshRepairRebuildTypes. All inner structures are destroyed.
    */
    RebuildMeshRepairType,
  }

  /**
    Specify the method for the rebuild type of mesh repair. If AccurateMeshRepairRebuildType is chosen,
    an offset can be set.
    @experimental
  */
  const enum MeshRepairRebuildTypes {
    /**
      Rebuilds mesh body quickly, but not accurately.
    */
    FastMeshRepairRebuildType,
    /**
      Rebuilding the mesh, while preserving sharp edges.
    */
    PreserveSharpEdgesMeshRepairRebuildType,
    /**
      Rebuilds mesh body as accurately as possible.
    */
    AccurateMeshRepairRebuildType,
    /**
      The mesh will be rebuild in a blocky style.
    */
    BlockyMeshRepairRebuildType,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a mesh repair
    feature.
    @experimental
  */
  abstract class MeshRepairFeatureInput extends core.Base {
    /**
      Gets and sets the input mesh body.
    */
    mesh: core.Base
    /**
      Gets and sets the type of mesh repair, default value is StitchAndRemoveMeshRepairType.
    */
    meshRepairType: MeshRepairTypes
    /**
      Gets and sets the type of mesh repair rebuild mode, default value is FastMeshRepairRebuildType.
      Only valid if meshRepairType is RebuildMeshRepairType.
    */
    meshRepairRebuildType: MeshRepairRebuildTypes
    /**
      Controls the density of the newly created triangles in RebuildMeshRepairType, default value is 128.
      The values can range between 8 and 256.
      Only valid if meshRepairType is RebuildMeshRepairType.
    */
    density: core.ValueInput
    /**
      Gets and sets the offset from the original mesh to the newly created mesh, default value is zero.
      Only valid if meshRepairType is RebuildMeshRepairType and meshRepairRebuildType is AccurateMeshRepairRebuildType.
    */
    offset: core.ValueInput
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing mesh repair feature in a design.
    To change the properties of this feature, you need to position the timeline marker to immediately before this feature.
    This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    @experimental
  */
  abstract class MeshRepairFeature extends MeshFeature {
    /**
      Gets and sets the input mesh body.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    mesh: core.Base
    /**
      Gets and sets the type of mesh repair.
    */
    meshRepairType: MeshRepairTypes
    /**
      Gets and sets the type of mesh repair rebuild mode.
      Only valid if meshRepairType is RebuildMeshRepairType.
    */
    meshRepairRebuildType: MeshRepairRebuildTypes
    /**
      Controls the density of the newly created triangles in RebuildMeshRepairType.
      The values can range between 8 and 256.
      Only valid if meshRepairType is RebuildMeshRepairType.
    */
    readonly density: ModelParameter
    /**
      Gets and sets the offset from the original mesh to newly created mesh.
      Only valid if meshRepairType is RebuildMeshRepairType and meshRepairRebuildType
      is AccurateMeshRepairRebuildType.
    */
    readonly offset: ModelParameter
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshRepairFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshRepairFeature | null
  }

  /**
    Collection that provides access to all of the existing MeshSmooth features in a component
    and supports the ability to create new MeshSmooth features.
    @experimental
  */
  abstract class MeshSmoothFeatures extends core.Base {
    /**
      Function that returns the specified mesh smooth feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshSmoothFeature | null
    /**
      The number of mesh smooth features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshSmoothFeatureInput object. Use properties and methods on this object
      to define the mesh smooth you want to create and then use the add method, passing in
      the MeshSmoothFeatureInput object.
      @param mesh A MeshBody in either a parametric or direct modeling design.
      @returns Returns the newly created MeshSmoothFeatureInput object or null if the creation failed.
    */
    createInput(mesh: core.Base): MeshSmoothFeatureInput | null
    /**
      Creates a mesh smooth feature.
      @param input A MeshSmoothFeatureInput object that defines the desired MeshSmooth feature. Use the createInput
      method to create a new MeshSmoothFeatureInput object and then use methods on it
      (the MeshSmoothFeatureInput object) to define the smoothing.
      @returns Returns the newly created MeshSmoothFeature object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MeshSmoothFeatureInput): MeshSmoothFeature | null
    /**
      Function that returns the specified MeshSmooth feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshSmoothFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a MeshSmooth
    feature.
    @experimental
  */
  abstract class MeshSmoothFeatureInput extends core.Base {
    /**
      Gets and sets the input mesh body.
    */
    mesh: core.Base
    /**
      Gets and sets the smoothness value. The range is between 0 and 1.
      The default value is 0.02.
      The higher the value the stronger the smoothing.
    */
    smoothness: core.ValueInput
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing MeshSmooth feature in a design.
    To change the properties of this feature, you need to position the timeline marker to immediately before this feature.
    This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    @experimental
  */
  abstract class MeshSmoothFeature extends MeshFeature {
    /**
      Gets and sets the input mesh body.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    mesh: core.Base
    /**
      Gets and sets the smoothness parameter. The range is between 0 and 1.
      The higher the value the stronger the smoothing.
    */
    readonly smoothness: ModelParameter
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshSmoothFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshSmoothFeature | null
  }

  /**
    Collection that provides access to all of the existing mesh reduce features in a component
    and supports the ability to create new mesh reduce features.
    @experimental
  */
  abstract class MeshReduceFeatures extends core.Base {
    /**
      Function that returns the specified mesh reduce feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshReduceFeature | null
    /**
      The number of mesh reduce features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshReduceFeatureInput object. Use properties and methods on this object
      to define the mesh reduce you want to create and then use the add method, passing in
      the MeshReduceFeatureInput object.
      @param mesh A MeshBody in either a parametric or direct modeling design.
      @returns Returns the newly created MeshReduceFeatureInput object or null if the creation failed.
    */
    createInput(mesh: core.Base): MeshReduceFeatureInput | null
    /**
      Creates a mesh reduce feature.
      @param input A MeshReduceFeatureInput object that defines the desired reduce feature. Use the createInput
      method to create a new MeshReduceFeatureInput object and then use methods on it
      (the MeshReduceFeatureInput object) to define the reduce.
      @returns Returns the newly created MeshReduceFeatureInput object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MeshReduceFeatureInput): MeshReduceFeature | null
    /**
      Function that returns the specified MeshReduce feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshReduceFeature | null
  }

  /**
    Specify the reduce method for the mesh.
    @experimental
  */
  const enum MeshReduceMethodTypes {
    /**
      Creates smaller(larger) faces in areas of high (low) detail.
    */
    AdaptiveReduceType,
    /**
      Creates faces of similar size in all areas.
    */
    UniformReduceType,
  }

  /**
    Specify what the target criteria for the reduction should be.
    @experimental
  */
  const enum MeshReduceTargetTypes {
    /**
      Reduces mesh by merging faces within a maximum deviation from the original mesh shape. If this
      criteria type is used, the reduce method type is ignored and the adaptive method is always
      applied.
    */
    MaximumDeviationMeshReduceTargetType,
    /**
      Reduces mesh to a given proportion of the number of faces on the original mesh.
    */
    ProportionMeshReduceTargetType,
    /**
      Reduces mesh to a given specific number of faces.
    */
    FaceCountMeshReduceTargetType,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a mesh reduce
    feature.
    @experimental
  */
  abstract class MeshReduceFeatureInput extends core.Base {
    /**
      Gets and sets the input mesh body.
    */
    mesh: core.Base
    /**
      Gets and sets the type of mesh reduce, default value is AdaptiveReduceType.
    */
    meshReduceMethodType: MeshReduceMethodTypes
    /**
      Gets and sets the target criteria for the reduction, default value is MaximumDeviationMeshReduceTargetType.
    */
    meshReduceTargetType: MeshReduceTargetTypes
    /**
      Controls the maximum deviation of the reduced mesh to the original mesh.
      The default value is 0.
      Only valid if meshReduceTargetType is MaximumDeviationMeshReduceTargetType.
    */
    maximumDeviation: core.ValueInput
    /**
      Gets and sets the proportion of number of faces of the reduced mesh to the number of
      faces of original mesh as a target for the reduction. The value can range between 0 and 100 percent.
      Only valid if meshReduceTargetType is ProportionMeshReduceTargetType.
    */
    proportion: core.ValueInput
    /**
      Gets and sets the target face count for the reduced mesh as a target for the reduction.
      Only valid if meshReduceTargetType is FaceCountMeshReduceTargetType.
    */
    facecount: core.ValueInput
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing mesh reduce feature in a design.
    To change the properties of this feature, you need to position the timeline marker to immediately before this feature.
    This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    @experimental
  */
  abstract class MeshReduceFeature extends MeshFeature {
    /**
      Gets and sets the input mesh body.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    mesh: core.Base
    /**
      Gets and sets the type of mesh reduce.
    */
    meshReduceMethodType: MeshReduceMethodTypes
    /**
      Gets and sets the target criteria for the reduction.
    */
    meshReduceTargetType: MeshReduceTargetTypes
    /**
      Controls the maximum deviation of the reduced mesh to the original mesh.
      Only valid if meshReduceTargetType is MaximumDeviationMeshReduceTargetType.
    */
    readonly maximumDeviation: ModelParameter
    /**
      Gets and sets the proportion of number of faces of the reduced mesh to the number of
      faces of original mesh as a target for the reduction. The value can range between 0 and 100 percent.
      Only valid if meshReduceTargetType is ProportionMeshReduceTargetType.
    */
    readonly proportion: ModelParameter
    /**
      Gets and sets the target face count for the reduced mesh as a target for the reduction.
      Only valid if meshReduceTargetType is FaceCountMeshReduceTargetType.
    */
    readonly facecount: ModelParameter
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshReduceFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshReduceFeature | null
  }

  /**
    Collection that provides access to all of the existing mesh re-mesh features in a component
    and supports the ability to create new mesh re-mesh features.
    @experimental
  */
  abstract class MeshRemeshFeatures extends core.Base {
    /**
      Function that returns the specified mesh re-mesh feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshRemeshFeature | null
    /**
      The number of mesh re-mesh features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshRemeshFeatureInput object. Use properties and methods on this object
      to define the mesh re-mesh you want to create and then use the add method, passing in
      the MeshRemeshFeatureInput object.
      @param mesh A MeshBody in either a parametric or direct modeling design.
      @returns Returns the newly created MeshRemeshFeatureInput object or null if the creation failed.
    */
    createInput(mesh: core.Base): MeshRemeshFeatureInput | null
    /**
      Creates a mesh re-mesh feature.
      @param input A MeshRemeshFeatureInput object that defines the desired re-mesh feature. Use the createInput
      method to create a new MeshRemeshFeatureInput object and then use methods on it
      (the MeshRemeshFeatureInput object) to define the re-mesh.
      @returns Returns the newly created MeshRemeshFeatureInput object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MeshRemeshFeatureInput): MeshRemeshFeature | null
    /**
      Function that returns the specified MeshRemesh feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshRemeshFeature | null
  }

  /**
    Specify the re-mesh method for the mesh.
    @experimental
  */
  const enum MeshRemeshMethodTypes {
    /**
      Creates smaller(larger) faces in areas of high (low) detail.
    */
    AdaptiveRemeshType,
    /**
      Creates faces of similar size in all areas.
    */
    UniformRemeshType,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a mesh re-mesh
    feature.
    @experimental
  */
  abstract class MeshRemeshFeatureInput extends core.Base {
    /**
      Gets and sets the input mesh body.
    */
    mesh: core.Base
    /**
      Gets and sets the type of mesh re-mesh, default value is AdaptiveType.
    */
    meshRemeshMethodType: MeshRemeshMethodTypes
    /**
      Controls the density of the newly created faces of the re-meshed mesh.
      The values can range between 0 and 1. The default value is 0.25
    */
    density: core.ValueInput
    /**
      Gets and sets how much of the original shape needs to preserved.
      The value can range between 0 and 1. The default value is 0.5.
      Only valid if meshRemeshMethodType is AdaptiveType.
    */
    shapePreservation: core.ValueInput
    /**
      Gets and sets if sharp edges are preserved during the re-mesh process.
      Default value is false.
    */
    isPreserveSharpEdgesEnabled: boolean
    /**
      Gets and sets if open boundary edges are preserved during the re-mesh process.
      Default value is false.
    */
    isPreserveBoundariesEnabled: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing mesh re-mesh feature in a design.
    To change the properties of this feature, you need to position the timeline marker to immediately before this feature.
    This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    @experimental
  */
  abstract class MeshRemeshFeature extends MeshFeature {
    /**
      Gets and sets the input mesh body.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    mesh: core.Base
    /**
      Gets and sets the type of mesh re-mesh.
    */
    meshRemeshMethodType: MeshRemeshMethodTypes
    /**
      Controls the density of the newly created faces of the re-meshed mesh.
      The values can range between 0 and 1.
    */
    readonly density: ModelParameter
    /**
      Gets and sets how much of the original shape needs to preserved.
      The value can range between 0 and 1.
      Only valid if meshRemeshMethodType is AdaptiveType.
    */
    readonly shapePreservation: ModelParameter
    /**
      Gets and sets if sharp edges are preserved during the re-mesh process.
    */
    isPreserveSharpEdgesEnabled: boolean
    /**
      Gets and sets if open boundary edges are preserved during the re-mesh process.
    */
    isPreserveBoundariesEnabled: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshRemeshFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshRemeshFeature | null
  }

  /**
    Collection that provides access to all of the existing mesh generate face groups features in a component
    and supports the ability to create new mesh generate face groups features.
    @experimental
  */
  abstract class MeshGenerateFaceGroupsFeatures extends core.Base {
    /**
      Function that returns the specified mesh generate face groups feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshGenerateFaceGroupsFeature | null
    /**
      The number of mesh generate face groups features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshGenerateFaceGroupsFeatureInput object. Use properties and methods on this object
      to define the mesh generate face groups feature you want to create and then use the add method, passing in
      the MeshGenerateFaceGroupsFeatureInput object.
      @param mesh A MeshBody in either a parametric or direct modeling design.
      @returns Returns the newly created MeshGenerateFaceGroupsFeatureInput object or null if the creation failed.
    */
    createInput(mesh: core.Base): MeshGenerateFaceGroupsFeatureInput | null
    /**
      Creates a mesh generate face groups feature.
      @param input A MeshGenerateFaceGroupsFeatureInput object that defines the desired generate face groups feature. Use the createInput
      method to create a new MeshGenerateFaceGroupsFeatureInput object and then use methods on it
      (the MeshGenerateFaceGroupsFeatureInput object) to define the generate face groups feature.
      @returns Returns the newly created MeshGenerateFaceGroupsFeatureInput object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MeshGenerateFaceGroupsFeatureInput): MeshGenerateFaceGroupsFeature | null
    /**
      Function that returns the specified MeshGenerateFaceGroups feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshGenerateFaceGroupsFeature | null
  }

  /**
    Specify the generate face group method for the mesh.
    @experimental
  */
  const enum MeshGenerateFaceGroupsMethodTypes {
    /**
      Generates face groups based on an angle threshold between faces.
      Prioritizes speed over accuracy.
    */
    FastGenerateFaceGroupsType,
    /**
      Generates face groups by matching mesh faces to simple geometric primitives.
      Prioritizes accuracy over speed.
    */
    AccurateGenerateFaceGroupsType,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a mesh generate face groups
    feature.
    @experimental
  */
  abstract class MeshGenerateFaceGroupsFeatureInput extends core.Base {
    /**
      Gets and sets the input mesh body.
    */
    mesh: core.Base
    /**
      Gets and sets the type of mesh generate face groups, default value is FastGenerateFaceGroupsType.
    */
    meshGenerateFaceGroupsMethodType: MeshGenerateFaceGroupsMethodTypes
    /**
      Controls the angle threshold during the face group generation.
      The values can range between 0 and pi/2. The default value is 0.436.
      Only valid if meshGenerateFaceGroupsMethodType is FastGenerateFaceGroupsType.
    */
    angleThreshold: core.ValueInput
    /**
      Gets and sets the fraction of the overall mesh area
      which determines the smallest face group.
      The value can range between 0 and 1. The default value is 0.02.
      Only valid if meshGenerateFaceGroupsMethodType is FastGenerateFaceGroupsType.
    */
    minimumFaceGroupSize: core.ValueInput
    /**
      Gets and sets tolerance to define face group. This value is used
      during the fitting of the primitives. The values can range between
      0 and 0.01. The default value is 0.001.
      Only valid if meshGenerateFaceGroupsMethodType is AccurateGenerateFaceGroupsType.
    */
    boundaryTolerance: core.ValueInput
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing mesh generate face groups feature in a design.
    @experimental
  */
  abstract class MeshGenerateFaceGroupsFeature extends MeshFeature {
    /**
      Gets and sets the input mesh body.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    mesh: core.Base
    /**
      Gets and sets the type of mesh generate face groups.
    */
    meshGenerateFaceGroupsMethodType: MeshGenerateFaceGroupsMethodTypes
    /**
      Controls the angle threshold during the face group generation.
      The values can range between 0 and pi/2.
      Only valid if meshGenerateFaceGroupsMethodType is FastGenerateFaceGroupsType.
    */
    readonly angleThreshold: ModelParameter
    /**
      Gets and sets the fraction of the overall mesh area
      which determines the smallest face group.
      The value can range between 0 and 1.
      Only valid if meshGenerateFaceGroupsMethodType is FastGenerateFaceGroupsType.
    */
    readonly minimumFaceGroupSize: ModelParameter
    /**
      Gets and sets tolerance to define face group. This value is used
      during the fitting of the primitives. The values can range between
      0 and 0.01.
      Only valid if meshGenerateFaceGroupsMethodType is AccurateGenerateFaceGroupsType.
    */
    readonly boundaryTolerance: ModelParameter
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshGenerateFaceGroupsFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshGenerateFaceGroupsFeature | null
  }

  /**
    Collection that provides access to all of the existing mesh shell features in a component
    and supports the ability to create new mesh shell features.
    @experimental
  */
  abstract class MeshShellFeatures extends core.Base {
    /**
      Function that returns the specified mesh shell feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshShellFeature | null
    /**
      The number of mesh shell features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshShellFeatureInput object. Use properties and methods on this object
      to define the mesh shell you want to create and then use the add method, passing in
      the MeshShellFeatureInput object.
      @param mesh A MeshBody in either a parametric or direct modeling design.
      @returns Returns the newly created MeshShellFeatureInput object or null if the creation failed.
    */
    createInput(mesh: core.Base): MeshShellFeatureInput | null
    /**
      Creates a mesh shell feature.
      @param input A MeshShellFeatureInput object that defines the desired shell feature. Use the createInput
      method to create a new MeshShellFeatureInput object and then use methods on it
      (the MeshShellFeatureInput object) to define the shell.
      @returns Returns the newly created MeshShellFeatureInput object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MeshShellFeatureInput): MeshShellFeature | null
    /**
      Function that returns the specified MeshShell feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshShellFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a mesh shell
    feature.
    @experimental
  */
  abstract class MeshShellFeatureInput extends core.Base {
    /**
      Gets and sets the input mesh body.
    */
    mesh: core.Base
    /**
      Controls the thickness of the created shell.
      The default value is 0.2.
    */
    thickness: core.ValueInput
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing mesh shell feature in a design.
    To change the properties of this feature, you need to position the timeline marker to immediately before this feature.
    This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    @experimental
  */
  abstract class MeshShellFeature extends MeshFeature {
    /**
      Gets and sets the input mesh body.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    mesh: core.Base
    /**
      Controls the thickness of the shell.
    */
    readonly thickness: ModelParameter
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshShellFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshShellFeature | null
  }

  /**
    Collection that provides access to all of the existing tessellate features in a component
    and supports the ability to create new tessellate features.
    @experimental
  */
  abstract class TessellateFeatures extends core.Base {
    /**
      Function that returns the specified tessellate feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): TessellateFeature | null
    /**
      The number of tessellate features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a TessellateFeatureInput object. Use properties and methods on this object
      to define the tessellation you want to create and then use the add method, passing in
      the TessellateFeatureInput object.
      @param bodies A array with BReb bodies in either a parametric or direct modeling design.
      @returns Returns the newly created TessellateFeatureInput object or null if the creation failed.
    */
    createInput(bodies: BRepBody[]): TessellateFeatureInput | null
    /**
      Creates a tessellate feature.
      @param input A TessellateFeatureInput object that defines the desired tessellate feature. Use the createInput
      method to create a new TessellateFeatureInput object and then use methods on it
      (the TessellateFeatureInput object) to define the tessellate.
      @returns Returns the newly created TessellateFeatureInput object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: TessellateFeatureInput): TessellateFeature | null
    /**
      Function that returns the specified Tessellate feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): TessellateFeature | null
  }

  /**
    Specify the refinement setting type for the tessellation process.
    @experimental
  */
  const enum TessellateRefinementTypes {
    /**
      Applies a preset with high refinement settings to tessellate the body.
    */
    HighTessellateRefinementType,
    /**
      Applies a preset with medium refinement settings to tessellate the body.
    */
    MediumTessellateRefinementType,
    /**
      Applies a preset with low refinement settings to tessellate the body.
    */
    LowTessellateRefinementType,
    /**
      Applies custom refinement settings to tessellate the body.
    */
    CustomTessellateRefinementType,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a tessellate
    feature.
    @experimental
  */
  abstract class TessellateFeatureInput extends core.Base {
    /**
      Gets and sets the input list of BReb bodies.
    */
    inputBodies: BRepBody[]
    /**
      Gets and sets the type of refinement, default value is MediumTessellateRefinementType.
    */
    tessellateRefinementType: TessellateRefinementTypes
    /**
      Specify maximum distance between the surface of the original
      body and the surface of the mesh body.
      Only valid if tessellateRefinementType is CustomTessellateRefinementType.
    */
    surfaceDeviation: core.ValueInput
    /**
      Specify maximum angle between the normal vectors of each face on the mesh body.
      Only valid if tessellateRefinementType is CustomTessellateRefinementType.
    */
    normalDeviation: core.ValueInput
    /**
      Specify maximum length of any face edge on the mesh body.
      Only valid if tessellateRefinementType is CustomTessellateRefinementType.
    */
    maximumEdgeLength: core.ValueInput
    /**
      Specify ratio between the height and width of each face on the mesh body.
      Only valid if tessellateRefinementType is CustomTessellateRefinementType.
    */
    aspectRatio: core.ValueInput
    /**
      Creates quad faces on the mesh body where possible.
    */
    createQuads: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing tessellate feature in a design.
    @experimental
  */
  abstract class TessellateFeature extends MeshFeature {
    /**
      Gets and sets the input B-Rep bodies.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    inputBodies: BRepBody[]
    /**
      Gets and sets the type of refinement.
    */
    tessellateRefinementType: TessellateRefinementTypes
    /**
      Specify maximum distance between the surface of the original
      body and the surface of the mesh body.
      Only valid if tessellateRefinementType is CustomTessellateRefinementType.
    */
    readonly surfaceDeviation: ModelParameter
    /**
      Specify maximum angle between the normal vectors of each face on the mesh body.
      Only valid if tessellateRefinementType is CustomTessellateRefinementType.
    */
    readonly normalDeviation: ModelParameter
    /**
      Specify maximum length of any face edge on the mesh body.
      Only valid if tessellateRefinementType is CustomTessellateRefinementType.
    */
    readonly maximumEdgeLength: ModelParameter
    /**
      Specify ratio between the height and width of each face on the mesh body.
      Only valid if tessellateRefinementType is CustomTessellateRefinementType.
    */
    readonly aspectRatio: ModelParameter
    /**
      Creates quad faces on the mesh body where possible.
    */
    createQuads: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: TessellateFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): TessellateFeature | null
  }

  /**
    Collection that provides access to all of the existing mesh combine features in a component
    and supports the ability to create new mesh Combine features.
    @experimental
  */
  abstract class MeshCombineFeatures extends core.Base {
    /**
      Function that returns the specified mesh combine feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshCombineFeature | null
    /**
      The number of mesh combine features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshCombineFeatureInput object. Use properties and methods on this object
      to define the mesh combine you want to create and then use the add method, passing in
      the MeshCombineFeatureInput object.
      @param targetBody The MeshBody in either a parametric or direct modeling design, which represent the target body.
      @param toolBodies The MeshBodies in either a parametric or direct modeling design, which represent the tool bodies.
      @returns Returns the newly created MeshCombineFeatureInput object or null if the creation failed.
    */
    createInput(targetBody: MeshBody, toolBodies: MeshBody[]): MeshCombineFeatureInput | null
    /**
      Creates a mesh combine feature.
      @param input A MeshCombineFeatureInput object that defines the desired combine feature. Use the createInput
      method to create a new MeshCombineFeatureInput object and then use methods on it
      (the MeshCombineFeatureInput object) to define the combine.
      @returns Returns the newly created MeshCombineFeatureInput object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MeshCombineFeatureInput): MeshCombineFeature | null
    /**
      Function that returns the specified MeshCombine feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshCombineFeature | null
  }

  /**
    Specify the combine method for the mesh.
    @experimental
  */
  const enum MeshCombineOperationTypes {
    /**
      Combines multiple mesh bodies into a single mesh body by enclosing their volumes.
    */
    JoinMeshCombineType,
    /**
      Removes overlapping areas from target body.
    */
    CutMeshCombineType,
    /**
      Combines overlapping areas into a mesh body.
    */
    IntersectMeshCombineType,
    /**
      Combines multiple mesh bodies into a single mesh body without altering the faces of the original mesh.
    */
    MergeMeshCombineType,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a mesh combine
    feature.
    @experimental
  */
  abstract class MeshCombineFeatureInput extends core.Base {
    /**
      Gets and sets the input targetBody.
    */
    targetBody: MeshBody
    toolBodies: MeshBody[]
    /**
      Gets and sets the operation type of mesh combine, default value is JoinMeshCombineType.
    */
    meshCombineOperationType: MeshCombineOperationTypes
    /**
      Creates a new component to contain combined mesh bodies.
      Default value is false.
    */
    isNewComponent: boolean
    /**
      Preserves a copy of each tool body.
      Default value is false.
    */
    isKeepToolBodies: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing mesh combine feature in a design.
    @experimental
  */
  abstract class MeshCombineFeature extends MeshFeature {
    /**
      Gets and sets the input targetBody.
    */
    targetBody: MeshBody
    toolBodies: MeshBody[]
    /**
      Gets and sets the operation type of mesh combine.
    */
    meshCombineOperationType: MeshCombineOperationTypes
    /**
      Creates a new component to contain combined mesh bodies.
      Default value is false.
    */
    readonly isNewComponent: boolean
    /**
      Preserves a copy of each tool body.
    */
    isKeepToolBodies: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshCombineFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshCombineFeature | null
  }

  /**
    Specify the plane cut method for the mesh.
    @hidden
  */
  const enum MeshPlaneCutTypes {
    /**
      Splits mesh faces along the cut plane, then removes one side of the mesh body.
    */
    TrimMeshPlaneCutType,
    /**
      Splits mesh faces along the cut plane, then separates the mesh body into two mesh bodies.
    */
    SplitBodyMeshPlaneCutType,
    /**
      Splits mesh faces along the cut plane and maintains a single mesh body.
    */
    SplitFacesMeshPlaneCutType,
  }

  /**
    Specify the method of filling the plane.
    @hidden
  */
  const enum MeshPlaneCutFillTypes {
    /**
      Does not add mesh faces to close mesh body.
    */
    NoFillMeshPlaneCutFillType,
    /**
      Adds a minimal number of mesh faces to close mesh body.
    */
    MinimalMeshPlaneCutFillType,
    /**
      Adds a uniform set of mesh faces to close mesh body.
    */
    UniformMeshPlaneCutFillType,
  }

  /**
    Collection that provides access to all of the existing mesh convert features in a component
    and supports the ability to create new mesh Convert features.
    @experimental
  */
  abstract class MeshConvertFeatures extends core.Base {
    /**
      Function that returns the specified mesh convert feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshConvertFeature | null
    /**
      The number of mesh convert features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshConvertFeatureInput object. Use properties and methods on this object
      to define the mesh convert you want to create and then use the add method, passing in
      the MeshConvertFeatureInput object.
      @param inputBodies A array with mesh bodies in either a parametric or direct modeling design.
      @returns Returns the newly created MeshConvertFeatureInput object or null if the creation failed.
    */
    createInput(inputBodies: MeshBody[]): MeshConvertFeatureInput | null
    /**
      Creates a mesh convert feature.
      @param input A MeshConvertFeatureInput object that defines the desired convert feature. Use the createInput
      method to create a new MeshConvertFeatureInput object and then use methods on it
      (the MeshConvertFeatureInput object) to define the convert.
      @returns Returns the newly created MeshConvertFeatureInput object or null if the creation failed.
      Returns null in the case where the feature is non-parametric.
    */
    add(input: MeshConvertFeatureInput): MeshConvertFeature | null
    /**
      Function that returns the specified MeshConvert feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshConvertFeature | null
  }

  /**
    Specify the convert method for the mesh.
    @experimental
  */
  const enum MeshConvertMethodTypes {
    /**
      Converts individual faces on the mesh body to individual faces on the new solid or surface body.
    */
    FacetedMeshConvertMethodType,
    /**
      Merges groups of faces in prismatic features into singular faces on the new solid or surface body. Face
      groups are used to infer prismatic features.
    */
    PrismaticMeshConvertMethodType,
    /**
      This converts the mesh body to an organically shaped solid or surface body. Only accessible if the product design extension is active.
    */
    OrganicMeshConvertMethodType,
  }

  /**
    Specify the operation method for the mesh conversion.
    @experimental
  */
  const enum MeshConvertOperationTypes {
    /**
      A parametric MeshConvert feature is created after the operation.
    */
    ParametricFeatureMeshConvertOperationType,
    /**
      A base feature is created after the operation.
    */
    BaseFeatureMeshConvertOperationType,
  }

  /**
    Specify the resolution method for the organic mesh conversion.
    @experimental
  */
  const enum MeshConvertResolutionTypes {
    /**
      Creates a solid or surface body that matches the shape of the original mesh body more or less accurately,
      based on the resolution you select.
    */
    ByAccuracyMeshConvertResolutionType,
    /**
      Creates solid or surface body with a specific number of faces.
    */
    ByFacetNumberMeshConvertResolutionType,
  }

  /**
    Specify the resolution for the organic mesh conversion if ByAccuracyMeshConvertResolutionType is selected
    @experimental
  */
  const enum MeshConvertAccuracyTypes {
    /**
      Converts the body with low accuracy compared to the original mesh body. (Fastest)
    */
    LowMeshConvertAccuracyType,
    /**
      Converts the body with medium accuracy compared to the original mesh body. (Fast)
    */
    MediumMeshConvertAccuracyType,
    /**
      Converts the body with high accuracy compared to the original mesh body. (Average)
    */
    HighMeshConvertAccuracyType,
    /**
      Converts the body with the highest possible accuracy compared to the original mesh body. (Slowest)
    */
    PreciseMeshConvertAccuracyType,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a mesh convert
    feature.
    @experimental
  */
  abstract class MeshConvertFeatureInput extends core.Base {
    /**
      Gets and sets the input meshes.
    */
    inputBodies: MeshBody[]
    /**
      Gets and sets the convert type of mesh convert, default value is FacetedMeshConvertMethodType.
    */
    meshConvertMethodType: MeshConvertMethodTypes
    /**
      Gets and sets the resolution method of mesh convert, default value is ByAccuracyMeshConvertResolutionType.
      Only valid if meshConvertMethodType is OrganicMeshConvertMethodType.
    */
    meshConvertResolutionType: MeshConvertResolutionTypes
    /**
      Gets and sets the accuracy of organic mesh convert, default value is MediumMeshConvertResolutionType.
      Only valid if meshConvertResolutionType is ByAccuracyMeshConvertResolutionType.
    */
    meshConvertAccuracyType: MeshConvertAccuracyTypes
    /**
      Specify the number of faces to generate for the converted body.
      Only valid if meshConvertResolutionType is ByFacetNumberMeshConvertResolutionType.
    */
    numberOfFaces: core.ValueInput
    /**
      Smooths the boundaries of open holes in the mesh body. Improves the chance of successful conversion by
      refining the shape of holes that will remain open. Default value is false. Only valid if meshConvertMethodType is
      OrganicMeshConvertType.
    */
    isPreprocessHoles: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      Gets and sets the operation type of mesh convert, default value is ParametricFeatureMeshConvertOperationType.
    */
    meshConvertOperationType: MeshConvertOperationTypes
  }

  /**
    Object that represents an existing mesh convert feature in a design.
    To change the properties of this feature, you need to position the timeline marker to immediately before this feature.
    This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    @experimental
  */
  abstract class MeshConvertFeature extends Feature {
    /**
      Gets and sets the input meshes.
    */
    inputBodies: MeshBody[]
    /**
      Gets and sets the convert type of mesh convert.
    */
    meshConvertMethodType: MeshConvertMethodTypes
    /**
      Gets and sets the resolution method of mesh convert.
      Only valid if meshConvertMethodType is OrganicMeshConvertMethodType.
    */
    meshConvertResolutionType: MeshConvertResolutionTypes
    /**
      Gets and sets the accuracy of organic mesh convert.
      Only valid if meshConvertResolutionType is ByAccuracyMeshConvertResolutionType.
    */
    meshConvertAccuracyType: MeshConvertAccuracyTypes
    /**
      Specify the number of faces to generate for the converted body.
      Only valid if meshConvertResolutionTypes is ByFacetNumberMeshConvertResolutionType.
    */
    readonly numberOfFaces: ModelParameter
    /**
      Smooths the boundaries of open holes in the mesh body. Improves the chance of successful conversion by
      refining the shape of holes that will remain open. Only valid if meshConvertMethodType is OrganicMeshConvertMethodType.
    */
    isPreprocessHoles: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshConvertFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshConvertFeature | null
  }

  /**
    Collection that provides access to all of the existing mesh combine face groups features in a component
    and supports the ability to create new mesh face group combine features.
    @experimental
  */
  abstract class MeshCombineFaceGroupsFeatures extends core.Base {
    /**
      Function that returns the specified mesh combine face groups feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshCombineFaceGroupsFeature | null
    /**
      The number of mesh combine face groups features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshCombineFaceGroupsFeatureInput object. Use properties and methods on this object
      to define the mesh combine face groups feature you want to create and then use the add method, passing in
      the MeshCombineFaceGroupsFeatureInput object.
      @param inputFaceGroups A array with face groups belonging to the same mesh. The mesh can be in either a parametric or direct modeling design.
      @returns Returns the newly created MeshCombineFaceGroupsFeatureInput object or null if the creation failed.
    */
    createInput(inputFaceGroups: FaceGroup[]): MeshCombineFaceGroupsFeatureInput | null
    /**
      Creates a mesh combine face groups feature.
      @param input A MeshCombineFaceGroupsFeatureInput object that defines the desired mesh combine face groups feature. Use the createInput
      method to create a new MeshCombineFaceGroupsFeatureInput object and then use methods on it
      (the MeshCombineFaceGroupsFeatureInput object) to define the mesh combine face groups feature.
      @returns Returns the newly created MeshCombineFaceGroupsFeatureInput object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MeshCombineFaceGroupsFeatureInput): MeshCombineFaceGroupsFeature | null
    /**
      Function that returns the specified MeshCombineFaceGroups feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshCombineFaceGroupsFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a mesh combine face groups
    feature.
    @experimental
  */
  abstract class MeshCombineFaceGroupsFeatureInput extends core.Base {
    /**
      Gets and sets the input face groups, which should be combined. They need to belong to the same mesh body.
    */
    inputFaceGroups: FaceGroup[]
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing mesh combine face groups feature in a design.
    @experimental
  */
  abstract class MeshCombineFaceGroupsFeature extends MeshFeature {
    /**
      Gets the input mesh body. The actual mesh body is set implicitly by the input face groups.
    */
    readonly mesh: core.Base
    /**
      Gets and sets the input face groups, which should be combined. They need to belong to the same mesh body.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    inputFaceGroups: FaceGroup[]
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshCombineFaceGroupsFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshCombineFaceGroupsFeature | null
  }

  /**
    Collection that provides access to all of the existing MeshSeparate features in a component
    and supports the ability to create new MeshSeparate features.
    @experimental
  */
  abstract class MeshSeparateFeatures extends core.Base {
    /**
      Function that returns the specified mesh separate feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshSeparateFeature | null
    /**
      The number of mesh separate features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshSeparateFeatureInput object. Use properties and methods on this object
      to define the mesh separate you want to create and then use the add method, passing in
      the MeshSeparateFeatureInput object.
      @param mesh A mesh body or an object collection with face groups in either a parametric or direct modeling design.
      @returns Returns the newly created MeshSeparateFeatureInput object or null if the creation failed.
    */
    createInput(mesh: core.Base): MeshSeparateFeatureInput | null
    /**
      Creates a mesh separate feature.
      @param input A MeshSeparateFeatureInput object that defines the desired MeshSeparate feature. Use the createInput
      method to create a new MeshSeparateFeatureInput object and then use methods on it
      (the MeshSeparateFeatureInput object) to define the separation.
      @returns Returns the newly created MeshSeparateFeature object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MeshSeparateFeatureInput): MeshSeparateFeature | null
    /**
      Function that returns the specified MeshSeparate feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshSeparateFeature | null
  }

  /**
    Specifies the output options for separating a mesh body. Only valid if the input is a mesh body.
    @experimental
  */
  const enum MeshSeparateTypes {
    /**
      Separates all mesh shells into independent mesh bodies.
    */
    ShellMeshSeparateType,
    /**
      Separates all face groups into independent mesh bodies.
    */
    FaceGroupMeshSeparateType,
  }

  /**
    This class defines the methods and properties that pertain to the definition of a MeshSeparate
    feature.
    @experimental
  */
  abstract class MeshSeparateFeatureInput extends core.Base {
    /**
      Gets and sets the input mesh body. This can either be a mesh body or an object collection with face groups.
    */
    mesh: core.Base
    /**
      Gets and sets the output type of mesh separation, default value is ShellMeshSeparateType. Only valid if the input is a mesh body.
    */
    meshSeparateType: MeshSeparateTypes
    /**
      Preserves a copy of the original mesh body. Default value is false.
    */
    isKeepBody: boolean
    isMultipleBodies: boolean
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing MeshSeparate feature in a design.
    To change the properties of this feature, you need to position the timeline marker to immediately before this feature.
    This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    @experimental
  */
  abstract class MeshSeparateFeature extends MeshFeature {
    /**
      Gets and sets the input mesh body. This can either be a mesh body or an object collection with face groups.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    mesh: core.Base
    /**
      Gets and sets the output type of mesh separation.
    */
    meshSeparateType: MeshSeparateTypes
    /**
      Preserves a copy of the original mesh body.
    */
    isKeepBody: boolean
    /**
      Separates each face group into an independent mesh body. Only valid if face groups are used as inputs.
    */
    isMultipleBodies: boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshSeparateFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshSeparateFeature | null
  }

  /**
    Collection that provides access to all of the existing MeshReverseNormal features in a component
    and supports the ability to create new MeshReverseNormal features.
    @experimental
  */
  abstract class MeshReverseNormalFeatures extends core.Base {
    /**
      Function that returns the specified mesh reverse normal feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MeshReverseNormalFeature | null
    /**
      The number of mesh reverse normal features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a MeshReverseNormalFeatureInput object. Use properties and methods on this object
      to define the mesh reverse normal you want to create and then use the add method, passing in
      the MeshReverseNormalFeatureInput object.
      @param mesh A mesh body or an object collection with face groups in either a parametric or direct modeling design.
      @returns Returns the newly created MeshReverseNormalFeatureInput object or null if the creation failed.
    */
    createInput(mesh: core.Base): MeshReverseNormalFeatureInput | null
    /**
      Creates a mesh reverse normal feature.
      @param input A MeshReverseNormalFeatureInput object that defines the desired MeshReverseNormal feature. Use the createInput
      method to create a new MeshReverseNormalFeatureInput object and then use methods on it
      (the MeshReverseNormalFeatureInput object) to define the normal reversion.
      @returns Returns the newly created MeshReverseNormalFeature object or null if the creation failed.
      Returns nothing in the case where the feature is non-parametric.
    */
    add(input: MeshReverseNormalFeatureInput): MeshReverseNormalFeature | null
    /**
      Function that returns the specified MeshReverseNormal feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): MeshReverseNormalFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a MeshReverseNormal
    feature.
    @experimental
  */
  abstract class MeshReverseNormalFeatureInput extends core.Base {
    /**
      Gets and sets the input mesh body. This can either be a mesh body or an object collection with face groups.
    */
    mesh: core.Base
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
  }

  /**
    Object that represents an existing MeshReverseNormal feature in a design.
    To change the properties of this feature, you need to position the timeline marker to immediately before this feature.
    This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    @experimental
  */
  abstract class MeshReverseNormalFeature extends MeshFeature {
    /**
      Gets and sets the input mesh body. This can either be a mesh body or an object collection with face groups.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True)
    */
    mesh: core.Base
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MeshReverseNormalFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MeshReverseNormalFeature | null
  }

  /**
    Provides access to meshes that approximate a B-Rep and T-Spline.
  */
  abstract class MeshManager extends core.Base {
    /**
      Creates a new MeshCalculator which is used to calculate
      new triangular meshes based on various parameters that control the calculation.
      @returns Returns the new MeshCalculator object or null if the creation failed.
    */
    createMeshCalculator(): TriangleMeshCalculator | null
    /**
      Returns a collection that provides access to all of the
      existing display meshes.
    */
    readonly displayMeshes: TriangleMeshList
    /**
      Returns the parent BRepBody, BRepFace, BRepLump, BRepShell, SculptBody, or SculptFace object.
    */
    readonly parent: core.Base
  }

  /**
    Provides access to a set of triangle meshes.
  */
  abstract class TriangleMeshList extends core.Base {
    /**
      Returns the specified triangle meshes.
      @param index The index of the mesh to return where the first item has an index of 0.
      @returns Returns the specified mesh or null in the case of invalid index.
    */
    item(index: number /*unsigned int*/): TriangleMesh | null
    /**
      Returns the mesh with the tightest surface tolerance. This can return null
      in the case the list is empty, i.e. Count is 0.
    */
    readonly bestMesh: TriangleMesh
    /**
      Returns the number of meshes in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Used to calculate new meshes for a B-Rep or T-Spline using defined criteria.
  */
  abstract class TriangleMeshCalculator extends core.Base {
    /**
      This is a simplified way to set the various settings that control the resulting mesh. When used it automatically
      adjusts all of the property values appropriately. It does this for the given geometry by computing its bounding
      box diameter. Then the surface tolerance is calculated as shown below where the meshLOD is the "Level of Detail" and
      is described in more detail below. The diameter is the bounding box diameter.
        double nodeApproximateSize = std::pow(2.0, meshLOD)
        double fracTol = 1.0 / nodeApproximateSize
        surfaceTolerance = fracTol * diameter
      @param triangleMeshQuality The mesh quality is specified by using an item from the enum list where the following items result
      in a corresponding mesh LOD that's used in the equation above.
      LowQualityTriangleMesh: 8
      NormalQualityTriangleMesh: 11
      HighQualityTriangleMesh: 13
      VeryHighQualityTriangleMesh: 15
      @returns Returns true if setting the quality was successful.
    */
    setQuality(triangleMeshQuality: TriangleMeshQualityOptions): boolean
    /**
      Specifies the maximum distance that the mesh can deviate from the smooth surface.
      The value is in centimeters. Smaller values can result in a much greater number
      of facets being returned and will require more processing time to calculate.
    */
    surfaceTolerance: number
    /**
      Specifies the maximum side of any triangle in the mesh. A value of 0 (the default)
      indicates that no maximum length is specified. The value is specified in centimeters.
    */
    maxSideLength: number
    /**
      Specifies the maximum length to height ratio that a triangle can have.
      This helps to avoid long skinny triangles. A value of 0 (the default)
      indicates that no maximum aspect ratio is specified.
    */
    maxAspectRatio: number
    /**
      Specifies the maximum deviation between adjacent vertex normals.
      This value is the maximum angle allowed between normals and is
      specified in radians. A value of 0 (the default) indicates that no normal deviation is specified.
    */
    maxNormalDeviation: number
    /**
      Calculates a new triangle mesh based on the current settings.
      @returns Returns the new TriangleMesh object or null in the case where the calculation failed.
    */
    calculate(): TriangleMesh | null
    /**
      Returns the parent MeshManager object.
    */
    readonly parentMeshManager: MeshManager
  }

  /**
    Types that indicate the level of quality of a triangle mesh.
  */
  const enum TriangleMeshQualityOptions {
    /**
      Low quality
    */
    LowQualityTriangleMesh = 8,
    /**
      Normal quality
    */
    NormalQualityTriangleMesh = 11,
    /**
      High quality
    */
    HighQualityTriangleMesh = 13,
    /**
      Very high quality
    */
    VeryHighQualityTriangleMesh = 15,
  }

  /**
    The TriangleMesh object represents all of the data defining
    a triangular mesh.
  */
  abstract class TriangleMesh extends core.Base {
    /**
      Returns the total number of nodes in the mesh.
    */
    readonly nodeCount: number /*int*/
    /**
      Returns the node coordinates as an array of doubles where
      they are the x, y, z components of each coordinate.
    */
    readonly nodeCoordinatesAsDouble: number[]
    /**
      Returns the node coordinates as an array of floats where
      they are the x, y, z components of each coordinate.
    */
    readonly nodeCoordinatesAsFloat: number[]
    /**
      Returns the node coordinates as an array of Point3D objects.
    */
    readonly nodeCoordinates: core.Point3D[]
    /**
      Returns the number of triangles in the mesh.
    */
    readonly triangleCount: number /*int*/
    /**
      Returns the normal vectors of the mesh where there is a normal
      vector at each node. The normals are returned as an array
      of doubles where they are the x, y, z components of each vector.
    */
    readonly normalVectorsAsDouble: number[]
    /**
      Returns the normal vectors of the mesh where there is a normal
      vector at each node. The normals are returned as an array
      of floats where they are the x, y, z components of each vector.
    */
    readonly normalVectorsAsFloat: number[]
    /**
      Returns the normal vectors of the mesh where there is a normal
      vector at each node. The normals are returned as an array
      of Vector3D objects.
    */
    readonly normalVectors: core.Vector3D[]
    /**
      Returns an array of indices that define which nodes are used
      for each triangle. This is used to look-up the coordinates in the
      NodeCoordinates array to get the three coordinates of each triangle.
    */
    readonly nodeIndices: number[] /*int[]*/
    /**
      Returns the texture coordinates used when mapping a texture to
      this face. The coordinates are returned as an array of
      doubles where they are the u and v components of each
      coordinate as defined in parametric space. There is a texture
      coordinate for each vertex in the face mesh.
    */
    readonly textureCoordinatesAsDouble: number[]
    /**
      Returns the texture coordinates used when mapping a texture to
      this face. The coordinates are returned as an array of
      floats where they are the u and v components of each
      coordinate as defined in parametric space. There is a texture
      coordinate for each vertex in the face mesh.
    */
    readonly textureCoordinatesAsFloat: number[]
    /**
      Returns the texture coordinates used when mapping a texture to
      this face. The coordinates are returned as an array of
      Point2D objects where the x and y properties of the point are
      u and v coordinates as defined in parametric space. There is
      a texture coordinate for each vertex in the face mesh.
    */
    readonly textureCoordinates: core.Point2D[]
    /**
      Returns the surface tolerance that was used to generate this mesh.
      This is most useful when using display meshes that have already
      been calculated.
    */
    readonly surfaceTolerance: number
  }

  /**
    The PolygonMesh represents a mesh that can contain any
    combination of polygons, quads, and triangles.
  */
  abstract class PolygonMesh extends core.Base {
    /**
      Returns the number of nodes in the mesh.
    */
    readonly nodeCount: number /*int*/
    /**
      Returns the node coordinates as an array of doubles where
      they are the x, y, z components of each coordinate.
    */
    readonly nodeCoordinatesAsDouble: number[]
    /**
      Returns the node coordinates as an array of floats where
      they are the x, y, z components of each coordinate.
    */
    readonly nodeCoordinatesAsFloat: number[]
    /**
      Returns the node coordinates as an array of Point3D objects.
    */
    readonly nodeCoordinates: core.Point3D[]
    /**
      Returns the number of triangles in the mesh.
    */
    readonly triangleCount: number /*int*/
    /**
      Returns the number of quads in the mesh.
    */
    readonly quadCount: number /*int*/
    /**
      Returns the number of polygons (more than 4 sides) in the mesh.
    */
    readonly polygonCount: number /*int*/
    /**
      Returns the normal vectors as an array of doubles where
      they are the x, y, z components of each vector. There is one normal vector for each index.
    */
    readonly normalVectorsAsDouble: number[]
    /**
      Returns the normal vectors as an array of floats. There is one normal vector for each index.
    */
    readonly normalVectorsAsFloat: number[]
    /**
      Returns the normal vectors as an array of Vector 3D objects. There is one normal vector for each index.
    */
    readonly normalVectors: core.Vector3D[]
    /**
      Returns the index values that index into the NodeCoordinates and NormalVectors arrays to
      define the three coordinates of each triangle and the corresponding normal.
    */
    readonly triangleNodeIndices: number[] /*int[]*/
    /**
      Returns the index values that index into the NodeCoordinates and NormalVectors arrays to
      define the four coordinates of each quad and the corresponding normal.
    */
    readonly quadNodeIndices: number[] /*int[]*/
    /**
      Returns the index values that index into the NodeCoordinates and NormalVectors arrays to
      define the coordinates of each polygon and the corresponding normal.
    */
    readonly polygonNodeIndices: number[] /*int[]*/
    /**
      Returns the number of nodes that define each polygon. For example,
      if NodeCountPerPolygon[0] returns 6 it indicates the first polygon
      is defined using 6 nodes. The first six indices returned by the
      PolygonNodeIndices properties provide the look-up into the NodeCoordinates
      array.
    */
    readonly nodeCountPerPolygon: number[] /*int[]*/
    /**
      Returns the face groups tempId values for every triangle of the mesh. The tempId corresponds
      to the triangles, which are defined in triangleNodeIndices.
      @experimental
    */
    readonly triangleFaceGroupTempIds: number[] /*int[]*/
    /**
      Returns the wall thickness per node in cm. This property calculates the wall thickness of the mesh,
      i.e. the distance of a surface of the mesh to the opposing surface.
      @experimental
    */
    readonly wallThickness: number[]
  }

  /**
    Collection that provides access to all of the existing boss features in a design.
  */
  abstract class BossFeatures extends core.Base {
    /**
      Function that returns the specified boss feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): BossFeature | null
    /**
      The number of boss features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified boss feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): BossFeature | null
    /**
      Creates a new boss feature (or more boss features) based on the information provided
      by a BossFeatureInput object.
      To create a new boss or boss connection, use createInput function to define a new input object for
      the type of boss feature you want to create. Use the methods and properties on the input object
      to define any additional inputs. Once the information is defined on the input object, you
      can pass it to the Add method to create the boss feature or boss connection.
      @param input The BossFeatureInput object that defines the boss or boss connection you want to create.
      @returns Returns the newly created BossFeature objects or empty vector/list if the creation failed.
    */
    add(input: BossFeatureInput): BossFeature[]
    /**
      Creates a new BossFeatureInput object that is used to specify the input needed to create a new boss feature(s).
      @returns Returns the newly created BossFeatureInput object or null if the creation failed.
    */
    createInput(): BossFeatureInput | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a boss feature or a boss connection
  */
  abstract class BossFeatureInput extends core.Base {
    /**
      When creating a feature that is owned by a base feature, set this property to the
      base feature you want to associate the new feature with. By default, this is null,
      meaning it will not be associated with a base feature.
      Because of a current limitation, if you want to create a feature associated with a base
      feature, you must set this property AND call the startEdit method of the base feature,
      create the feature, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
    */
    targetBaseFeature: BaseFeature
    /**
      In order for geometry to be transformed correctly, an Occurrence for creation needs to be
      specified when the boss feature is created based on geometry (e.g. point) in another
      component AND (the boss) is not in the root component.
      The CreationOccurrence is analogous to the active occurrence in the UI
      A value of null indicates that everything is in the context of a single component.
      The occurrence provided sets scope for detection of target participant bodies.
    */
    creationOccurrence: Occurrence
    /**
      Defines the position and orientation of the boss feature using a sketch point(s).
      @param pointOrPoints The sketch point or ObjectCollection of sketch points that defines the position(s) for boss mating location.
      The orientation of the boss feature is inferred from the normal (Z-axis) of the point's parent sketch.
      The natural direction (or direction of the screw) will be opposite the normal of the sketch.
      If multiple sketch points are provided all must belong to the same sketch.
      Participant bodies will be inferred from closest visible bodies unless specified explicitly.
      @returns Returns true if successful.
    */
    setPositionBySketchPoints(pointOrPoints: core.Base): boolean
    /**
      Gets and sets the list of bodies that will participate in the boss feature. If body provided does
      not intersect with direction vector at proposed position points it will be ignored. If more bodies intersect
      at given position point only the closest body will be accepted. Boss feature works with solid bodies only.
      If this property has not been set (or is empty) closest visible bodies will be detected automatically
      based on proposed positions and orientation.
    */
    participantBodies: BRepBody[]
    /**
      Creates a new BossFeatureSideInput object that is used to specify the input for boss feature side.
      This object can be set to side1 or side2. Side1 is meant to be side where screw head engages with the boss
      and Side2 is meant to be a side where screw thread engages with the part or metal inserts.
      @returns Returns BossFeatureSideInput if successful.
    */
    createSideInput(): BossFeatureSideInput
    /**
      Gets or sets inputs for top side of the boss feature connection. It is the side where screw head engages with the boss.
      Default Side1 direction is considered direction of Z-axis of the parent sketch for selected position point.
    */
    side1: BossFeatureSideInput
    /**
      Gets or sets inputs for bottom side of the boss feature connection. It is the side where screw thread engages with the part or metal insert.
      Default Side2 direction is considered opposite to the direction Z-axis of the parent sketch for selected position point.
    */
    side2: BossFeatureSideInput
    /**
      Get or set if the boss feature (or boss connection) goes in the default direction or is reversed.
    */
    isDefaultDirection: boolean
    /**
      Get or set offset of the parting face from the selected position point.
    */
    offset: core.ValueInput
  }

  /**
    This class defines the methods and properties that pertain to the definition of a single side of boss feature
  */
  abstract class BossFeatureSideInput extends core.Base {
    /**
      Set boss shape into blank constant diameter shank with no hole.
      @param diameter The outside diameter for the boss feature shank.
      @returns 
    */
    setBlank(diameter: core.ValueInput): void
    /**
      Set boss shape into constant diameter shank with simple hole.
      @param diameter The outside diameter for the boss feature shank.
      @param holeDiameter The hole diameter.
      @returns 
    */
    setSimple(diameter: core.ValueInput, holeDiameter: core.ValueInput): void
    /**
      Set boss shape into constant diameter shank with counterbore hole.
      @param diameter The outside diameter for the boss feature shank.
      @param holeDiameter The hole diameter.
      @param holeMajorDiameter The hole major (or counterbore) diameter.
      @param depth With respect to hole orientation in the boss feature the parameter is either the counterbore depth or thickness of the material
      under the screw head.
      @returns 
    */
    setCounterbore(diameter: core.ValueInput, holeDiameter: core.ValueInput, holeMajorDiameter: core.ValueInput, depth: core.ValueInput): void
    /**
      Set boss shape into constant diameter shank with countersink hole.
      @param diameter The outside diameter for the boss feature shank.
      @param holeDiameter The hole diameter.
      @param holeMajorDiameter The hole major (or countersink) diameter.
      @param depth With respect to hole orientation in the boss feature the parameter is either the counterbore depth or thickness of the material
      under the screw head.
      @param countersinkAngle Optional parameter for hole countersink angle. If not specified it is set to 90 deg.
      @returns 
    */
    setCountersink(diameter: core.ValueInput, holeDiameter: core.ValueInput, holeMajorDiameter: core.ValueInput, depth: core.ValueInput, countersinkAngle?: core.ValueInput/* = null*/): void
    /**
      Get or set boss alignment shape. This usually corresponds to the alignment shape of the boss counterpart.
    */
    alignmentType: BossAlignmentTypes
    /**
      Get or set hole extent this feature represents. For top side only through hole extent is accepted.
    */
    holeExtentType: BossHoleExtentTypes
    /**
      Type of boss ribs this feature represents.
    */
    ribType: BossRibShapeTypes
    /**
      Set rib extent type for particular rib for position point provided.
      @param position Position point object for the rib extent types provided
      @param ribExtentTypes Vector of BossRibExtentTypes for individual rib based on rib count input.
      @returns 
    */
    setRibExtent(position: core.Base, ribExtentTypes: number[] /*int[]*/): void
    /**
      Clears rib extent types for all position points.
      @returns 
    */
    clearRibExtent(): void
    /**
      Get or set offset clearance as additional small offset from the selected parting plane and position point.
    */
    offsetClearance: core.ValueInput
    /**
      Get or set boss shank diameter.
    */
    diameter: core.ValueInput
    /**
      Get or set shank draft angle.
    */
    draftAngle: core.ValueInput
    /**
      Get or set alignment diameter.
    */
    alignmentDiameter: core.ValueInput
    /**
      Get or set alignment depth.
    */
    alignmentDepth: core.ValueInput
    /**
      Get or set alignment draft angle.
    */
    alignmentDraftAngle: core.ValueInput
    /**
      Get or set hole diameter.
    */
    holeDiameter: core.ValueInput
    /**
      Get or set hole draft angle.
    */
    holeDraftAngle: core.ValueInput
    /**
      Get or set hole depth with respect to hole extent type.
      If hole extent type is set to BossHoleThrough parameter is ignored. If hole extent type is BossBlindFull
      the parameter is a distance from farthest face. If hole extent type is set to BossBlindDepth the parameter
      is a distance from start face of the hole.
    */
    holeDepth: core.ValueInput
    /**
      Get or set major hole diameter for counterbore or countersink hole.
      This input is ignored for blank boss or boss with simple hole.
    */
    holeMajorDiameter: core.ValueInput
    /**
      Get or set major hole depth for counterbore and countersink hole or material thickness under screw head
      based on hole orientation in a boss feature. This input is ignored for blank boss or boss with simple hole.
    */
    holeMajorDepth: core.ValueInput
    /**
      Get or set major hole draft angle for counterbore and countersink hole.
      This input is ignored for blank boss or boss with simple hole.
    */
    holeMajorDraftAngle: core.ValueInput
    /**
      Get or set countersink angle for countersink hole. This input is used only for countersink hole.
    */
    holeCountersinkAngle: core.ValueInput
    /**
      Get or set blend radius of the boss shank and participant body.
    */
    rootRadius: core.ValueInput
    /**
      Get or set blend radius of the boss shank top parting face.
    */
    tipRadius: core.ValueInput
    /**
      Get or set blend radius of the boss alignment tip.
    */
    alignmentTipRadius: core.ValueInput
    /**
      Get or set blend radius of the boss alignment root.
    */
    alignmentRootRadius: core.ValueInput
    /**
      Get or set blend radius of the hole start.
    */
    holeStartRadius: core.ValueInput
    /**
      Get or set blend radius of the hole end.
    */
    holeEndRadius: core.ValueInput
    /**
      Get or set blend radius of major hole counterbore.
    */
    holeMajorTipRadius: core.ValueInput
    /**
      Get or set blend radius of major hole counterbore root.
    */
    holeMajorRootRadius: core.ValueInput
    /**
      Get or set ribs length measured from the shank axis.
    */
    ribLength: core.ValueInput
    /**
      Get or set ribs offset from the top face or alignment face.
    */
    ribOffset: core.ValueInput
    /**
      Get or set ribs thickness.
    */
    ribThickness: core.ValueInput
    /**
      Get or set ribs draft angle.
    */
    ribDraftAngle: core.ValueInput
    /**
      Get or set rib outer draft angle.
    */
    ribOuterDraftAngle: core.ValueInput
    /**
      Get or set size of rib chamfer or fillet.
    */
    ribCutSize: core.ValueInput
    /**
      Get or set rib chamfer angle. This input is used only for rib with chamfer.
    */
    ribChamferAngle: core.ValueInput
    /**
      Get or set rib outer tip blend radius.
    */
    ribTipRadius: core.ValueInput
    /**
      Get or set rib base root blend radius.
    */
    ribRootRadius: core.ValueInput
    /**
      Get or set rotation angle of the first rib from the reference vector.
      Reference vector is X-axis of the parent sketch from selected sketch point(s).
    */
    ribRotation: core.ValueInput
    /**
      Get or set total angle for ribs distribution. Default is 360 deg.
    */
    ribTotalAngle: core.ValueInput
    /**
      Get or set number of ribs.
    */
    ribCount: core.ValueInput
  }

  /**
    List of different boss shank shape types.
  */
  const enum BossShapeTypes {
    /**
      Blank boss with no hole and constant diameter.
    */
    BossBlank,
    /**
      Boss with constant outer shank diameter.
    */
    BossConstDiameter,
    /**
      Boss with constant shank thickness. Not supported yet.
    */
    BossConstThickness,
  }

  /**
    List of different types of boss alignment shape types.
  */
  const enum BossAlignmentTypes {
    /**
      Boss flat alignment.
    */
    BossAlignFlat,
    /**
      Boss with step out.
    */
    BossAlignStepOut,
    /**
      Boss with step in.
    */
    BossAlignStepIn,
  }

  /**
    List of the different types of boss hole extent types.
  */
  const enum BossHoleExtentTypes {
    /**
      Hole through all body.
    */
    BossHoleThrough,
    /**
      Blind hole of max depth with offset from bottom.
    */
    BossBlindFull,
    /**
      Blind hole set by hole depth.
    */
    BossBlindDepth,
  }

  /**
    List of different types of boss rib shape.
  */
  const enum BossRibShapeTypes {
    /**
      Boss with no ribs.
    */
    BossRibShapeNone,
    /**
      Boss with chamfered ribs.
    */
    BossRibShapeChamfer,
    /**
      Boss with filleted ribs
    */
    BossRibShapeFillet,
  }

  /**
    List of different types of boss rib extent type.
  */
  const enum BossRibExtentTypes {
    /**
      Boss rib has given shape and length as specified.
    */
    RibSizeByLength,
    /**
      Boss rib has shape of web and extents to next face.
    */
    RibSizeToNext,
    /**
      Boss rib is suppressed.
    */
    RibSuppressed,
  }

  /**
    Object that represents an existing boss feature in a design.
    For history free model this interface has limited functionality.
  */
  abstract class BossFeature extends Feature {
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: BossFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): BossFeature | null
    /**
      Creates object with inputs this feature represents.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True).
      @returns Returns BossFeatureInput this feature represent if successful.
    */
    createInput(): BossFeatureInput
    /**
      Changes the boss feature (or boss connection) to the input provided.
      To use this property, you need to position the timeline marker to immediately before this feature.
      This can be accomplished using the following code: thisFeature.timelineObject.rollTo(True).
      @param input The object defines inputs the feature will be set to.
      @returns Returns true if successful.
    */
    update(input: BossFeatureInput): boolean
    /**
      Returns the direction of the boss feature with respect to selected position point.
      For selected sketch point this direction represents a Z-axis of the sketch.
    */
    readonly direction: core.Vector3D
    /**
      Gets and sets if the direction of the boss (or boss connection) is flipped.
    */
    isDirectionFlipped: boolean
    /**
      Gets if this boss feature instance represents a bottom side where screw thread engages with the part.
      If this feature instance represents a geometry where screw head engages it returns false.
    */
    readonly isGeometryOpposite: boolean
    /**
      Returns the current boss shape this feature represents.
    */
    readonly shapeType: BossShapeTypes
    /**
      Returns the current boss alignment shape this feature represents.
    */
    readonly alignmentType: BossAlignmentTypes
    /**
      Returns the current type of hole this feature represents.
    */
    readonly holeType: HoleTypes
    /**
      Returns the current type of hole extent this feature represents.
    */
    readonly holeExtentType: BossHoleExtentTypes
    /**
      Returns the current type of ribs shape this feature represents.
    */
    readonly ribType: BossRibShapeTypes
    /**
      Returns a BossPositionDefinition object that provides access to the information used
      to define the position of the boss feature.
    */
    readonly positionDefinition: BossPositionDefinition
    /**
      Returns the model parameter for thickness - plastic part rule reference.
    */
    readonly thickness: ModelParameter
    /**
      Returns the model parameter for taper angle - plastic part rule reference.
    */
    readonly taperAngle: ModelParameter
    /**
      Returns the model parameter for inner radius - reference for parametric expressions.
    */
    readonly innerRadius: ModelParameter
    /**
      Returns the model parameter for screw diameter - reference for parametric expressions.
    */
    readonly screwDiameter: ModelParameter
    /**
      Returns the model parameter for screw head diameter - reference for parametric expressions.
    */
    readonly screwHeadDiameter: ModelParameter
    /**
      Returns the model parameter for countersink head angle - reference for parametric expressions.
    */
    readonly screwHeadAngle: ModelParameter
    /**
      Returns the model parameter controlling the offset from the selected parting plane.
    */
    readonly offset: ModelParameter
    /**
      Returns the model parameter controlling the offset clearance from the selected parting plane and offset.
    */
    readonly offsetClearance: ModelParameter
    /**
      Returns the model parameter controlling the shank diameter.
    */
    readonly diameter: ModelParameter
    /**
      Returns the model parameter controlling the shank draft angle.
    */
    readonly draftAngle: ModelParameter
    /**
      Returns the model parameter controlling the step diameter used for alignment of its counterparts.
    */
    readonly alignmentDiameter: ModelParameter
    /**
      Returns the model parameter controlling the step depth used for alignment of its counterparts.
    */
    readonly alignmentDepth: ModelParameter
    /**
      Returns the model parameter controlling the step draft angle.
    */
    readonly alignmentDraftAngle: ModelParameter
    /**
      Returns the model parameter controlling the hole diameter.
    */
    readonly holeDiameter: ModelParameter
    /**
      Returns the model parameter controlling hole draft angle.
    */
    readonly holeDraftAngle: ModelParameter
    /**
      Returns the model parameter controlling the hole depth with respect to hole extent type.
      If hole extent type is set to BossHoleThrough parameter not used. If hole extent type is BossBlindFull
      the parameter is a distance from farthest face. If hole extent type is set to BossBlindDepth the parameter
      is a distance from start face of the hole.
    */
    readonly holeDepth: ModelParameter
    /**
      Returns the model parameter controlling major hole diameter for counterbore and countersink hole.
      If hole type is set to simple hole or boss shape is to BossBlank this parameter is unused.
    */
    readonly holeMajorDiameter: ModelParameter
    /**
      Returns the model parameter controlling major hole depth for counterbore and countersink hole.
      If hole type is set to simple hole or boss shape is to BossBlank this parameter is unused.
    */
    readonly holeMajorDepth: ModelParameter
    /**
      Returns the model parameter controlling major hole draft angle for counterbore and countersink hole.
      If hole type is set to simple hole or boss shape is to BossBlank this parameter is unused.
    */
    readonly holeMajorDraftAngle: ModelParameter
    /**
      Returns the model parameter controlling countersink angle for countersink hole.
      If hole type is not set to countersink hole or boss shape is to BossBlank this parameter is unused.
    */
    readonly holeCountersinkAngle: ModelParameter
    /**
      Returns the model parameter controlling blend radius of the boss shank.
    */
    readonly rootRadius: ModelParameter
    /**
      Returns the model parameter controlling blend radius of the boss shank top face.
    */
    readonly tipRadius: ModelParameter
    /**
      Returns the model parameter controlling blend radius of the boss alignment top face.
    */
    readonly alignmentTipRadius: ModelParameter
    /**
      Returns the model parameter controlling blend radius of the boss alignment root.
    */
    readonly alignmentRootRadius: ModelParameter
    /**
      Returns the model parameter controlling blend radius of the hole start.
    */
    readonly holeStartRadius: ModelParameter
    /**
      Returns the model parameter controlling blend radius of the hole end.
    */
    readonly holeEndRadius: ModelParameter
    /**
      Returns the model parameter controlling blend radius of major hole counterbore.
    */
    readonly holeMajorTipRadius: ModelParameter
    /**
      Returns the model parameter controlling blend radius of major hole counterbore root.
    */
    readonly holeMajorRootRadius: ModelParameter
    /**
      Returns the model parameter controlling ribs length measured from the shank axis.
    */
    readonly ribLength: ModelParameter
    /**
      Returns the model parameter controlling ribs offset from the top face or alignment face.
    */
    readonly ribOffset: ModelParameter
    /**
      Returns the model parameter controlling ribs thickness.
    */
    readonly ribThickness: ModelParameter
    /**
      Returns the model parameter controlling ribs draft angle.
    */
    readonly ribDraftAngle: ModelParameter
    /**
      Returns the model parameter controlling size of rib outer draft angle.
    */
    readonly ribOuterDraftAngle: ModelParameter
    /**
      Returns the model parameter controlling size of rib chamfer or fillet.
    */
    readonly ribCutSize: ModelParameter
    /**
      Returns the model parameter controlling size of rib chamfer angle.
    */
    readonly ribChamferAngle: ModelParameter
    /**
      Returns the model parameter controlling size of rib tip blend radius.
    */
    readonly ribTipRadius: ModelParameter
    /**
      Returns the model parameter controlling size of rib root blend radius.
    */
    readonly ribBlendRadius: ModelParameter
    /**
      Returns the model parameter controlling rotation angle of the first rib from the reference vector.
      For selected sketch point(s) the direction of reference vector is X-axis of the parent sketch.
    */
    readonly ribRotation: ModelParameter
    /**
      Returns the model parameter controlling total angle for ribs distribution.
    */
    readonly ribTotalAngle: ModelParameter
    /**
      Returns the model parameter controlling number of ribs.
    */
    readonly ribCount: ModelParameter
  }

  /**
    The base class for the classes that define how a boss feature can be positioned.
  */
  abstract class BossPositionDefinition extends core.Base {
  }

  /**
    Provides positioning information for a boss feature that is positioned by a sketch point(s).
  */
  abstract class SketchPointsBossPositionDefinition extends BossPositionDefinition {
    /**
      Returns the sketch points that defines the position of the boss feature.
    */
    readonly sketchPoints: core.ObjectCollection
  }

  /**
    A collection of plastic rules.
  */
  abstract class PlasticRules extends core.Base {
    /**
      Function that returns the specified plastic rule using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): PlasticRule | null
    /**
      The number of plastic rules in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified plastic rule using the name of the rule.
      @param name The name of the rule within the collection to return. This is the name seen in the Plastic Rules dialog.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): PlasticRule | null
    /**
      Creates a new plastic rule by copying an existing rule. The new rule
      can then be edited to define the rule characteristics you want.
      @param existingPlasticRule The existing PlasticRule object you want to copy. This can be a rule from the
      library or the design.
      @param name The name to assign to the new plastic rule. This name must be unique with respect to other
      plastic rules in the design or library it's created in.
      @returns Returns the new PlasticRule object or will assert in the case where it fails.
    */
    addByCopy(existingPlasticRule: PlasticRule, name: string): PlasticRule
  }

  /**
    Used to get and set the current value associated with a plastic rule. A value can be gotten
    or set using a string or a double. A string can contain equations and unit specifiers, whereas
    a double defines the size in centimeters. In the user interface, the user is always setting
    the string expression. However, when programming, it is typically more convenient to set it
    using an explicit value. When the value is set using a double, Fusion creates an equivalent expression.
  */
  abstract class PlasticRuleValue extends core.Base {
    /**
      Gets and sets the expression of the plastic rule value. This can be an
      equation that includes the name "Thickness" and can also include length unit
      specifiers. For example, a valid expression is "Thickness / 2 + 1 mm". If no
      units are specified, the unit is implied and uses the units associated with the rule
      which can be mm or inch. For example an expression of "3" will be 3 inches if the
      rule units are inches or 3 mm if the rule units are millimeters. You can find out
      what units are used for a rule using the PlasticRule.units property.
    */
    expression: string
    /**
      Gets and sets the value of the plastic rule value in centimeters. Setting
      this value will create a new expression that is equivalent to the new value.
    */
    value: number
  }

  /**
    A plastic rule.
  */
  abstract class PlasticRule extends core.Base {
    /**
      The name of the plastic rule. When setting the name, it must be
      unique with respect to other plastic rules in the design or library.
    */
    name: string
    /**
      Gets and sets the material assigned to this plastic rule
    */
    material: core.Material
    /**
      The minimum thickness of the part in centimeters.  This is used by
      the Design Advice command when analyzing the part for manufacturability.
    */
    minimumThickness: number
    /**
      The maximum thickness of the part in centimeters.  This is used by
      the Design Advice command when analyzing the part for manufacturability.
    */
    maximumThickness: number
    /**
      The thickness used for plastic features. This value must be within the range specified
      by the minimumThickness and maximumThickness properties. This is used by the plastic
      commands when a wall thickness is needed.
      When using a float to set the value, it is defined in centimeters. When using a string to
      set the expression, the units can be defined as part of the expression or it defaults to
      the units associated with the rule if no units are specified.
    */
    readonly thickness: PlasticRuleValue
    /**
      The maximum thickness of the part. This is used by the Design Advice command
      when analyzing the part for manufacturability.
      When using a float to set the value, it is defined in centimeters. When using a string to
      set the expression, the units can be defined as part of the expression or it defaults to
      the units associated with the rule if no units are specified.
    */
    readonly thicknessVariation: PlasticRuleValue
    /**
      The draft angle used for plastic features. When using a float to set the value, it
      is defined in radians. When using a string to set the expression it uses degrees.
    */
    readonly draftAngle: PlasticRuleValue
    /**
      The minimum draft angle allowed in radians. This is used by the Design Advice command
      when analyzing the part for manufacturability.
    */
    minimumDraftAngle: number
    /**
      The nominal radius used for plastic features. When using a float to set the value, it
      is defined in centimeters. When using a string to set the expression, the
      units can be defined as part of the expression or it defaults to the units associated
      with the rule if no units are specified.
    */
    readonly nominalRadius: PlasticRuleValue
    /**
      The minimal thickness where an edge is considered a knife edge. This is used by the Design Advice
      command when analyzing the part for manufacturability.
      When using a float to set the value, it is defined in centimeters. When using a string to
      set the expression, the units can be defined as part of the expression or it defaults to
      the units associated with the rule if no units are specified.
    */
    readonly knifeEdgeThreshold: PlasticRuleValue
    /**
      The reveal height used for plastic features. When using a float to set the value, it
      is defined in centimeters. When using a string to set the expression, the
      units can be defined as part of the expression or it defaults to
      the units associated with the rule if no units are specified.
    */
    readonly revealHeight: PlasticRuleValue
    /**
      The clearance used for plastic features. When using a float to set the value, it
      is defined in centimeters. When using a string to set the expression, the
      units can be defined as part of the expression or it defaults to
      the units associated with the rule if no units are specified.
    */
    readonly clearance: PlasticRuleValue
    /**
      Returns the parent design for a plastic rule in a design or it
      returns null if the plastic rule is in the library.
    */
    readonly parentDesign: Design
    /**
      This gets and sets which rule in a library is the default rule. This is only
      valid for rules in a library and will fail for rules in a design.
    */
    isDefault: boolean
    /**
      Indicates if this rule is currently being used by a component. This is only
      valid for rules in a design.
    */
    readonly isUsed: boolean
    /**
      Deletes the rule from the design or library. If the rule is in the
      library and set as the default rule, you cannot delete it. If the
      rule is in a design and is used by a component you cannot delete it.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Gets the units this rule uses to display values in the dialog.
      Rules currently only use mm or inch and the units are permanently
      associated with a rule and cannot be modified.
    */
    readonly units: string
  }

  /**
    Provides access to the Rendering functionality in Fusion and is accessed from the Design object.
  */
  abstract class RenderManager extends core.Base {
    /**
      Returns the parent Design this RenderManager was obtained from.
    */
    readonly parentDesign: core.Product
    /**
      Returns the SceneSettings object that provides access to all of the
      settings that control how the scene is rendered. This provides equivalent
      functionality as the "Settings" tab in the "SCENE SETTINGS" dialog.
    */
    readonly sceneSettings: SceneSettings
    /**
      Provides access to the provided environments and supports specifying
      a custom environment. This provides access to the same list of environments
      that you see in the "Environment Library" tab of the "SCENE SETTINGS" dialog.
    */
    readonly renderEnvironments: RenderEnvironments
    /**
      Provides access to the local and cloud rendering capabilities of Fusion. In both
      cases, the rendering is done in a process external to Fusion, either a local or
      cloud rendering process.
    */
    readonly rendering: Rendering
    /**
      Returns if the Render workspace for this Design is active or not. Returns
      true if the workspace is active.
    */
    readonly isRenderWorkspaceActive: boolean
    /**
      Activates the Render workspace for this design. If the workspace is already
      active, nothing happens and it remains active.
      @returns Returns true if the activation was successful or if the Render workspace was already active.
    */
    activateRenderWorkspace(): boolean
    /**
      Provides access to the in-canvas rendering capabilities of Fusion. This
      uses the active viewport and the user will see the rendering as it takes place.
    */
    readonly inCanvasRendering: InCanvasRendering
  }

  /**
    Provides access to the ability to render in a background process on the local machine.
  */
  abstract class Rendering extends core.Base {
    /**
      Gets and sets the aspect ratio of the rendered image. This is not the resolution, but
      only the aspect ratio. To define a custom aspect ratio set this property to CustomAspectRatio
      and use the resolutionHeight and resolutionWidth properties to define the resolution and aspect ratio.
      The default value is the aspect ratio defined in the scene settings.
      The width and height must be between 108 and 4000 pixels.
    */
    aspectRatio: RenderAspectRatios
    /**
      Gets and sets the desired quality of the rendering. The quality is specified using a
      value between 25 and 100, where 75 is the equivalent of "Final" and 100 is
      the same as "Excellent" in the user interface. The default value is 75
    */
    renderQuality: number /*int*/
    /**
      Specifies if the background of the rendering should be transparent. The default
      is false, which means it will not be transparent.
    */
    isBackgroundTransparent: boolean
    /**
      Gets and sets the resolution of the rendered image. This is the final width and height of the
      image in pixels. To define a custom aspect ratio, use the resolutionHeight and resolutionWidth
      properties to define any resolution. Using those has the side effect of setting this property
      to CustomRenderResolution. Setting this to anything except CustomRenderResolution, will also have
      the side effect of setting the aspect ratio.
    */
    resolution: RenderResolutions
    /**
      Gets and sets the height of the image in pixels. If anything but CustomRenderAspectRatio is defined as the
      aspect ratio, the resolution width will be modified to maintain the specified aspect ratio.
      The height must be between 108 and 4000 pixels.
    */
    resolutionHeight: number /*int*/
    /**
      Gets and sets the width of the image in pixels. If anything but CustomRenderAspectRatio is defined as the
      aspect ratio, the resolution height will be modified to maintain the specified aspect ratio.
      The width must be between 108 and 4000 pixels.
    */
    resolutionWidth: number /*int*/
    /**
      Starts a local rendering process using either the active viewport or a specified camera to define
      the camera information. This starts a background process on the local machine to generate the rendering.
      Even though this is a background process, it is tied to the running Fusion process and will be terminated
      if Fusion is shut down. If multiple local renders are started, they are queued and only one runs at a time.
      @param filename Optional argument that is the full path and filename of the file to write the resulting rendering
      to. The file extension can be .png, .jpg, .jpeg, or .tiff and the file will be saved as that type.
      If not provided or is an empty string, the rendering will be saved to the cloud as a PNG file.
      @param camera Optional argument that specifies the camera to use for the rendering. The default value is null, which
      will use the camera associated with the active viewport.
      @returns Returns a RenderFuture that allows you to check the current state of this rendering job.
    */
    startLocalRender(filename?: string/* = ""*/, camera?: core.Camera/* = null*/): RenderFuture
  }

  /**
    Used to check the state of a local or in canvas rendering.
  */
  abstract class RenderFuture extends core.Base {
    /**
      Returns the progress of this rendering expressed as a percentage
      where 0.0 is no progress and 1.0 is complete.
    */
    readonly progress: number
    /**
      Returns the current state of the rendering.
    */
    readonly renderState: LocalRenderStates
    /**
      Returns the width of the image. The width was specified when the
      rendering was started.
    */
    readonly imageWidth: number /*int*/
    /**
      Returns the height of the image. The height was specified when the
      rendering was started.
    */
    readonly imageHeight: number /*int*/
    /**
      The filename that the finished rendering will be saved to. If being
      saved to the cloud, this is the name Fusion will use for the completed
      rendering.
    */
    readonly filename: string
  }

  /**
    The different states of a local rendering.
  */
  const enum LocalRenderStates {
    /**
      Indicates the rendering is queued, waiting to start.
    */
    QueuedLocalRenderState,
    /**
      Indicates the rendering is processing.
    */
    ProcessingLocalRenderState,
    /**
      Indicates the rendering has finished.
    */
    FinishedLocalRenderState,
    /**
      Indicates the rendering has failed and is no longer processing.
    */
    FailedLocalRenderState,
  }

  /**
    Provides access to the in-canvas rendering capabilities of Fusion. This
    uses the active viewport and the user will see the rendering as it takes place.
  */
  abstract class InCanvasRendering extends core.Base {
    /**
      Gets and sets if the view should be locked during the in-canvas render. This prohibits
      the user from interacting with the view, which will cause the rendering to restart.
    */
    lockView: boolean
    /**
      Sets the percentage of the full resolution to render the image. Valid
      values are between 20 and 100 inclusive. 100 is full resolution (100%).
    */
    limitResolution: number
    /**
      Starts the process of in-canvas rendering. There are two modes
      when doing in-canvas rendering advanced and fast. This is specified in the
      API using the isAdvanced property. When using advanced rendering, you can
      specify the desired quality and the rendering will stop once that quality has
      been reached. When using fast rendering, the rendering never stops but continues
      until you stop it.
      When using the API, it's generally best to use advanced rendering so you
      can easily control the final quality and get notified by the renderComplete
      event when it has finished. When using fast rendering, the renderComplete event
      is not fired and you have to use some other criteria like the number of iterations
      complete or the time taken to determine when to stop the rendering process.
      @param renderQuality Specifies the desired quality of the rendering. The quality is specified using a
      value between 0 and 1, where 0.75 is the equivalent of "Excellent" and 1.0 is
      the same as "Final" in the user interface.
      This is ignored when using fast rendering (the isAdvanced property is False).
      @returns Returns true if the rendering was successfully started.
    */
    start(renderQuality: number): boolean
    /**
      Stops the current rendering process.
      @returns Returns true if successful.
    */
    stop(): boolean
    /**
      Returns the seconds spent on the current render.
    */
    readonly elapsedTime: number /*int*/
    /**
      Returns the current number of iterations the renderer has completed.
    */
    readonly iterations: number /*int*/
    /**
      Gets and sets if "Fast" or "Advanced" rendering should be used.
      If false, "Fast" rendering is used, which uses simplified lighting
      and materials.
      There are two modes when doing in-canvas rendering advanced and fast. When
      using advanced rendering, you can specify the desired quality and the rendering
      will stop once that quality has been reached. When using fast rendering, the
      rendering never stops but continues until you stop it.
      When using the API, it's generally best to use advanced rendering so you
      can easily control the final quality and get notified by the renderComplete
      event when it has finished. When using fast rendering, the renderComplete event
      is not fired, and you have to use some other criteria like the number of iterations
      complete, or the time taken to determine when to stop the rendering process.
    */
    isAdvanced: boolean
    /**
      The RenderEvent event fires when the rendering has reached the
      quality that was specified when the rendering started. This event is only fired
      when using advanced rendering (the isAdvanced property is True). To save the
      finished rendering, use the saveImage method.
      You can add or remove event handlers from the RenderEvent.
    */
    readonly renderComplete: RenderEvent
    /**
      Saves the image as it currently exists in the active viewport. To get the
      best quality, this should be called after the renderComplete event has fired.
      @param filename The filename to save the image to. This must be the full path.
      The file extension can be .png, .jpg, .jpeg, or .tiff and the
      file will be saved as that type.
      The size of the image is dependent on the size of the viewport and
      the current specified aspect ratio.
      @returns Returns true if the save was successful.
    */
    saveImage(filename: string): boolean
  }

  /**
    A RenderEvent represents an event that occurs in reaction to the
    rendering process in the Render workspace.
  */
  abstract class RenderEvent extends core.Event {
    /**
      Add a handler to be notified when the event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: RenderEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: RenderEventHandler): boolean
  }

  /**
    The RenderEventHandler is a client implemented class that can be added as a handler to a
    RenderEvent.
  */
  abstract class RenderEventHandler extends core.EventHandler {
    /**
      The function called by Fusion when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: RenderEventArgs): void
  }

  /**
    The RenderEventArgs provides information associated with the render process.
    Render events happen when there's a change in state of the rendering process.
    The most typical is when the rendering process has reached a predefined quality.
  */
  abstract class RenderEventArgs extends core.EventArgs {
    /**
      Returns the viewport that the rendering was performed in when the render is an in-canvas rendering.
    */
    readonly viewport: core.Viewport
  }

  /**
    Provides access to all the settings that control how the scene is rendered.
  */
  abstract class SceneSettings extends core.Base {
    /**
      Gets and sets the brightness or luminance of the scene. This must be a value between
      0 and 100,000 and is in lux units.
    */
    brightness: number
    /**
      Gets and sets the origin of the projection of the environment onto the textured
      ground plane. This lets you position the environment relative to the model. This
      is only used when the isGroundFlattened property is true.
      If the isGroundFlattened property is true, and a texture is being applied to
      the ground, the groundPosition property can be used to change both
      the offset and location of the texture on the ground. The lightAngle
      property controls the orientation of the texture.
    */
    groundPosition: core.Point3D
    /**
      Gets and sets the distance of the ground from the bottom of the model.
      A value of 0 is at the bottom of the model and a positive value moves
      the plane up and negative down. The value is in centimeters.
      If the isGroundFlattened property is true, and a texture is being applied to
      the ground, the groundPosition property can be used to change both
      the offset and location of the texture on the ground. The lightAngle
      property controls the orientation of the texture.
    */
    groundOffset: number
    /**
      Specifies the rotation of the lighting. The angle is specified in Radians.
      When the isGroundFlattened property is true, this also controls the angle
      of the texture that is applied to the ground. When the background is an
      environment, this controls the rotation of the environment relative to
      the model.
    */
    lightAngle: number
    /**
      Gets and sets the background color. When this property is set, it defines
      the background to be a solid color. The opacity component of the color is ignored.
      Getting this property is only valid when the backgroundType property returns
      SolidColorRenderSceneBackgroundType. Setting this property will automatically
      set the background type to SolidColorRenderSceneBackgroundType.
    */
    backgroundSolidColor: core.Color
    /**
      Gets and sets the environment to use for the background. The available environments
      can be accessed through the RenderManager.renderEnvironments property.
      Getting this property is only valid when the backgroundType property returns
      EnvironmentRenderSceneBackgroundType. Setting this property will automatically
      set the background type to EnvironmentRenderSceneBackgroundType.
    */
    backgroundEnvironment: RenderEnvironment
    /**
      Specifies the current type of background being used to render the scene.
      To change the background type use either the backgroundEnvironment
      or the backgroundSolidColor to set the environment or color.
    */
    readonly backgroundType: RenderSceneBackgroundTypes
    /**
      Gets and sets if the ground plane is displayed. The plane allows shadows
      on the ground and reflections if the isGroundReflections property is true.
    */
    isGroundDisplayed: boolean
    /**
      Gets and sets if the ground plane is "textured" where the environment
      image is mapped as a texture.
    */
    isGroundFlattened: boolean
    /**
      Gets and sets if objects are reflected on the ground plane.
    */
    isGroundReflections: boolean
    /**
      Gets and sets the roughness of the ground which controls the sharpness
      of the reflection. This is only used when the isGroundReflections property
      is true. This is a value between 0 and 1, where 0 is smooth and 1 is rough.
    */
    groundRoughness: number
    /**
      Gets and sets the type of camera to use when rendering the scene.
    */
    cameraType: core.CameraTypes
    /**
      Gets and sets the focal length of the camera, specified in millimeters.
      Changing the perspective angle of the camera associated with the active
      viewport will also change the focal length. Focal length and perspective
      angle are two different ways to control the same setting.
    */
    cameraFocalLength: number
    /**
      Gets and sets if the exposure of the camera as specified using the "Exposure Value" (EV). Valid
      values are between -15.0 and 25.0, inclusive.
    */
    cameraExposure: number
    /**
      Gets and sets if the depth of field option is enabled. When setting this to true, use the
      centerOfFocus and depthOfFieldBlur properties to specify how the depth of field is defined.
    */
    isDepthOfFieldEnabled: boolean
    /**
      When the isDepthofFieldEnabled property is true, this point is used as the center of focus.
      All objects that are the same distance from the camera as this point will be in focus.
      Any geometry that is closer or further away from the camera than this point will appear more out of focus.
      Setting this property has the side effect of setting the isDepthOfField property to true. If the
      isDepthOfFieldEnabled property is false, the value of this property is ignored.
    */
    centerOfFocus: core.Point3D
    /**
      Specify the amount of blur to apply to objects outside the center of focus. This must be a value
      between 0.001 and 2.000 inclusive. The depth of field is defined by using the centerOfFocus
      property to set the depth where the model is in focus.
      Setting this property has the side effect of setting the isDepthOfField property to true. If the
      isDepthOfFieldEnabled property is false, the value of this property is ignored.
    */
    depthOfFieldBlur: number
    /**
      Gets and sets the aspect ratio of the rendered image. This is not the resolution, but
      only the aspect ratio. To define a custom aspect ratio set this property to CustomRenderAspectRatio
      and use the aspectRatioHeight and aspectRatioWidth properties to define any aspect ratio.
      This is used for in-canvas render to allow you to use a different aspect ratio than what
      is implicitly defined by the size of the active viewport.
      If this is set to CustomRenderAspectRatio, use the aspectRatioHeight and aspectRatioWidth to
      define the aspect ratio.
    */
    aspectRatio: RenderAspectRatios
    /**
      Gets and sets the height of the aspect ratio of the rendered image. This is not the resolution, but
      only the aspect ratio. For example specifying the width and height of 4:3 is equivalent to setting
      20:15. It's only the ratio of the numbers that matters.
      The resolution is determined by the screen resolution when rendering in-canvas or is specified when
      rendering locally or using the cloud. When setting this property the aspectRatio property is
      automatically set to CustomRenderAspectRatio.
    */
    aspectRatioHeight: number /*int*/
    /**
      Gets and sets the width of the aspect ratio of the rendered image. This is not the resolution, but
      only the aspect ratio. For example specifying the width and height of 4:3 is equivalent to setting
      20:15. It's only the ratio of the numbers that matters.
      The resolution is determined by the screen resolution when rendering in-canvas or is specified when
      rendering locally or using the cloud. When setting this property the aspectRatio property is
      automatically set to CustomRenderAspectRatio.
    */
    aspectRatioWidth: number /*int*/
    /**
      Saves all of the scene settings as the default settings for this Design.
      @returns Returns true if saving the defaults was successful.
    */
    saveAsDefaults(): boolean
    /**
      Changes all of the scene settings to the default values.
      @returns Returns true if setting to the default settings was successful.
    */
    restoreDefaults(): boolean
  }

  /**
    Types that indicate the type of background being used to render the scene.
  */
  const enum RenderSceneBackgroundTypes {
    /**
      Specifies that an environment is being used as the background
      of the scene.
    */
    EnvironmentRenderSceneBackgroundType,
    /**
      Specifies that a solid color is being used as the background
      of the scene.
    */
    SolidColorRenderSceneBackgroundType,
  }

  /**
    Types that indicate the output aspect ratio when rendering a scene. This is
    used with in-canvas rendering, to allow you to define a different aspect
    ratio than the current active viewport.
  */
  const enum RenderAspectRatios {
    /**
      Specifies that the Current Viewport aspect ratio is used.
    */
    CurrentViewportRenderAspectRatio,
    /**
      Specifies a 1:1 square aspect ratio.
    */
    Square1to1RenderAspectRatio,
    /**
      Specifies a 4:3 presentation aspect ratio.
    */
    Presentation4to3RenderAspectRatio,
    /**
      Specifies a 16:9 wide screen aspect ratio.
    */
    Widescreen16to9RenderAspectRatio,
    /**
      Specifies a 5:4 landscape aspect ratio.
    */
    Landscape5to4RenderAspectRatio,
    /**
      Specifies a 4:5 portrait aspect ratio.
    */
    Portrait4to5RenderAspectRatio,
    /**
      Specifies that a custom aspect ratio is used.
    */
    CustomRenderAspectRatio,
  }

  /**
    The different standard resolutions supported when rendering.
  */
  const enum RenderResolutions {
    /**
      800x600 resolution. Commonly used for low-res images shown in a browser.
    */
    Web800x600RenderResolution,
    /**
      1024x768 resolution. Commonly used for images shown in a browser.
    */
    Web1024x768RenderResolution,
    /**
      1152x864 resolution. Commonly used for images shown in a browser.
    */
    Web1152x864RenderResolution,
    /**
      1280x1024 resolution. Commonly used for images shown in a browser.
    */
    Web1280x1024RenderResolution,
    /**
      1600x1200 resolution. Commonly used for images shown in a browser.
    */
    Web1600x1200RenderResolution,
    /**
      960x640 resolution. Commonly used for images shown on a mobile device.
    */
    Mobile960x640RenderResolution,
    /**
      1136x640 resolution. Commonly used for images shown on a mobile device.
    */
    Mobile1136x640RenderResolution,
    /**
      1334x750 resolution. Commonly used for images shown on a mobile device.
    */
    Mobile1334x750RenderResolution,
    /**
      1920x1080 resolution. Commonly used for images shown on a mobile device.
    */
    Mobile1920x1080RenderResolution,
    /**
      2048x1536 resolution. Commonly used for images shown on a mobile device.
    */
    Mobile2048x1536RenderResolution,
    /**
      1800x1200 resolution. Commonly used for images that will be printed.
    */
    Print1800x1200RenderResolution,
    /**
      2100x1500 resolution. Commonly used for images that will be printed.
    */
    Print2100x1500RenderResolution,
    /**
      3000x2400 resolution. Commonly used for images that will be printed.
    */
    Print3000x2400RenderResolution,
    /**
      3300x2550 resolution. Commonly used for images that will be printed.
    */
    Print3300x2550RenderResolution,
    /**
      854x480 resolution. Commonly used for images that will be used for video.
    */
    Video854x480RenderResolution,
    /**
      1280x720 resolution. Commonly used for images that will be used for video.
    */
    Video1280x720RenderResolution,
    /**
      1920x1080 resolution. Commonly used for images that will be used for video.
    */
    Video1920x1080RenderResolution,
    /**
      Custom resolution.
    */
    CustomRenderResolution,
  }

  /**
    The list of available render environments. This represents the list of environments
    shown in the "Scene Settings" dialog as being in the "Fusion Library". It does not
    include a custom environment, if one has been loaded.
  */
  abstract class RenderEnvironments extends core.Base {
    /**
      Method that returns the specified render environment using an index into the collection.
      @param index The index of the item within the collection. The first item has an index of 0.
      @returns Returns the specified render environment or null if an invalid index was specified.
    */
    item(index: number /*int*/): RenderEnvironment | null
    /**
      The number of render environments in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the specified render environment using the name as seen in the user interface.
      @param name The name of the render environment to return.
      @returns Returns the specified render environment or null if there's no match on the name.
    */
    itemByName(name: string): RenderEnvironment | null
    /**
      Returns the render environment with the specified ID.
      @param id The ID of the render environment to return.
      @returns Returns the specified render environment or null if the ID does not match a render environment.
    */
    itemById(id: string): RenderEnvironment | null
  }

  /**
    A render environment that is used when defining the scene for rendering. You see these
    in the user interface in the "Environment Library" tab of the "Scene Settings" dialog.
    Use this with the backgroundEnvironment property of the SceneSettings object to set
    a render environment. For a custom render environment, use the loadCustomEnvironment
    method to statically create a custom environment and assign it to the backgroundEnvironment
    property.
  */
  abstract class RenderEnvironment extends core.Base {
    /**
      Statically creates a RenderEnvironment which can be used to set the environment for
      a scene using the SceneSettings.backgroundEnvironment property.
    */
    static loadCustomEnvironment(fullFilename: string): RenderEnvironment
    /**
      Returns true if this environment is a custom environment.
    */
    readonly isCustomEnvironment: boolean
    /**
      The name of the environment.
    */
    readonly name: string
    /**
      The internal ID of the environment.
    */
    readonly id: string
  }

  /**
    Collection that provides access to all of the existing flange features in a design.
  */
  abstract class FlangeFeatures extends core.Base {
    /**
      Function that returns the specified flange feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): FlangeFeature | null
    /**
      The number of flange features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified flange feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): FlangeFeature | null
  }

  /**
    Object that represents an existing flange feature in a design.
  */
  abstract class FlangeFeature extends Feature {
  }

  /**
    The different types of hems that can be created.
    @experimental
  */
  const enum HemFeatureDefinitionTypes {
    /**
      The hem type is undefined. This occurs when a new HemFeatureInput is created
      and before a specific type has been defined.
    */
    UndefinedHemFeatureDefinitionType,
    /**
      A flat hem is like an open hem but the gap is closed and the edge is flattened against the main sheet.
    */
    FlatHemFeatureDefinitionType,
    /**
      An open hem is simple bend along an edge that leaves a gap between the hem and the main sheet.
    */
    OpenHemFeatureDefinitionType,
    /**
      A rolled hem is where the edge is rolled over to form a tube-like profile.
    */
    RolledHemFeatureDefinitionType,
    /**
      A teardrop hem is where the edge is bent around a diameter to form a teardrop like profile.
    */
    TeardropHemFeatureDefinitionType,
    /**
      A rope hem is where the edge is rolled over (like a rolled hem) with an added length after the roll parallel to the main sheet.
    */
    RopeHemFeatureDefinitionType,
    /**
      A double hem is where the edge is bent over twice to form a hem that doubles back on itself.
    */
    DoubleHemFeatureDefinitionType,
  }

  /**
    Collection that provides access to all of the existing unfold features in a design.
  */
  abstract class UnfoldFeatures extends core.Base {
    /**
      Function that returns the specified unfold feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): UnfoldFeature | null
    /**
      The number of unfold features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified unfold feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): UnfoldFeature | null
  }

  /**
    Object that represents an existing unfold feature in a design.
  */
  abstract class UnfoldFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing refold features in a design.
  */
  abstract class RefoldFeatures extends core.Base {
    /**
      Function that returns the specified refold feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): RefoldFeature | null
    /**
      The number of refold features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified refold feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): RefoldFeature | null
  }

  /**
    Object that represents an existing refold feature in a design.
  */
  abstract class RefoldFeature extends Feature {
  }

  /**
    Collection that provides access to all of the existing Rip features in a design.
  */
  abstract class RipFeatures extends core.Base {
    /**
      Function that returns the specified Rip feature using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): RipFeature | null
    /**
      The number of Rip features in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified Rip feature using the name of the feature.
      @param name The name of the feature within the collection to return. This is the name seen in the timeline.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): RipFeature | null
    /**
      Creates a RipFeatureInput object. Use methods on this object to define the rip you want
      to create and then use the add method, passing in the RipFeatureInput object.
      @returns Returns the newly created RipFeatureInput object or null if the creation failed.
    */
    createRipFeatureInput(): RipFeatureInput | null
    /**
      Creates a new Rip feature.
      @param input A RipFeatureInput object that defines the desired rip. Use the createInput
      method to create a new RipFeatureInput object and then use methods on it
      (the RipFeatureInput object) to define the rip.
      @returns Returns the newly created RipFeature object or null if the creation failed.
    */
    add(input: RipFeatureInput): RipFeature | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a Rip feature.
  */
  abstract class RipFeatureInput extends core.Base {
    /**
      Specifies the rip feature will be defined by a face..
      @param face The sheet metal face that defines the rip.
      @returns Returns true if the defining the rip is successful.
    */
    setByFace(face: BRepFace): boolean
    /**
      Specifies the rip feature will be along an edge.
      @param edge The BRepEdge that defines the location of the rip.
      @param gapDistance The gap distance of the rip.
      @returns Returns true if the defining the rip is successful.
    */
    setAlongEdge(edge: BRepEdge, gapDistance: core.ValueInput): boolean
    /**
      This input method is for creating a rip between two points. Each point can be either a BRepVertex
      or a BRepEdge and an associated offset along the edge.
      @param pointOneEntity The first point of the rip. This can be defined using a BrepVertex or a BRepEdge and offset to define
      where the point is along the edge. If an edge is specified, the pointOneOffset parameter must be specified.
      @param pointTwoEntity The second point of the rip and must lie on the same face as point 1. This can be defined using a
      BrepVertex or a BRepEdge and an offset to define where the point is along the edge.
      If an edge is specified, the pointTwoOffset parameter must be specified.
      @param gapDistance The gap distance of the rip.
      @param pointOneOffset If the first point lies on an edge, then this is the offset along the edge which defines the point.
      This is the physical distance from the topological start of the edge.
      If the offset is negative or exceeds the edge length, the corresponding vertex of the edge will be used.
      @param pointTwoOffset If the second point lies on an edge, then this is the offset along the edge which defines the point.
      This is the physical distance from the topological start of the edge.
      If the offset is negative or exceeds the edge length, the corresponding vertex of the edge will be used.
      @returns Returns true if the rip definition is successful.
    */
    setBetweenPoints(pointOneEntity: core.Base, pointTwoEntity: core.Base, gapDistance: core.ValueInput, pointOneOffset?: core.ValueInput/* = null*/, pointTwoOffset?: core.ValueInput/* = null*/): boolean
  }

  /**
    A Base class to return the information used to define the RipFeature.
  */
  abstract class RipFeatureDefinition extends core.Base {
  }

  /**
    The definition for a face rip.
  */
  abstract class FaceRipFeatureDefinition extends RipFeatureDefinition {
    /**
      Gets and sets the input face for a face rip.
    */
    ripFace: BRepFace
  }

  /**
    The definition for an along edge rip.
  */
  abstract class AlongEdgeRipFeatureDefinition extends RipFeatureDefinition {
    /**
      Gets and sets the input edge for an along edge rip.
    */
    ripEdge: BRepEdge
    /**
      Gets the ModelParameter that defines the gap distance of the rip.
      The value can be edited by using the properties of the returned ModelParameter object.
    */
    readonly gapDistance: ModelParameter
  }

  /**
    The definition for an along edge rip.
  */
  abstract class BetweenPointsRipFeatureDefinition extends RipFeatureDefinition {
    /**
      Gets and sets the BRepEdge or BRepVertex that defines the first point for a between points rip.
      If a BRepEdge is returned the pointOneOffset property will control the position of the point along the edge.
    */
    pointOneEntity: core.Base
    /**
      Gets and sets the BRepEdge or BRepVertex that defines the second point for a between points rip.
      If a BRepEdge is returned the pointTwoOffset property will control the position of the point along the edge.
    */
    pointTwoEntity: core.Base
    /**
      Gets the ModelParameter that defines the offset for the first point of a between points rip.
      This is the physical distance from the topological start of the edge.
      If the offset is either negative, or exceeds the edge length,
      then the point will be taken as the corresponding vertex of the edge.
      Returns null if the first point is defined by a vertex.
      The value can be edited by using the properties of the returned ModelParameter object.
    */
    readonly pointOneOffset: ModelParameter
    /**
      Gets the ModelParameter that defines the offset for the second point of a between points rip.
      This is the physical distance from the topological start of the edge.
      If the offset is either negative, or exceeds the edge length,
      then the point will be taken as the corresponding vertex of the edge.
      Returns null if the first point is defined by a vertex.
      The value can be edited by using the properties of the returned ModelParameter object.
    */
    readonly pointTwoOffset: ModelParameter
    /**
      Gets the ModelParameter that defines the gap distance of the rip.
      The value can be edited by using the properties of the returned ModelParameter object.
    */
    readonly gapDistance: ModelParameter
  }

  /**
    Object that represents an existing Rip feature in a design.
  */
  abstract class RipFeature extends Feature {
    /**
      Gets the type of rip defined.
    */
    readonly definitionType: RipFeatureDefinitionTypes
    /**
      Returns the RipFeatureDefinition object which provides access to the information
      defining this RipFeature and the ability to edit it.
    */
    readonly definition: RipFeatureDefinition
    /**
      This input method is for creating a rip from a face.
      @param face The sheet metal face that defines the rip.
      @returns Returns true if the rip definition is successful.
    */
    setByFace(face: BRepFace): boolean
    /**
      Redefines the feature to be a rip along an edge.
      @param edge The BRepEdge that defines the rip.
      @param gapDistance The gap distance of the rip.
      @returns Returns true if the rip definition is successful.
    */
    redefineToAlongEdge(edge: BRepEdge, gapDistance: core.ValueInput): boolean
    /**
      Redefines the feature to be a rip between two points.
      @param pointOneEntity The first point of the rip. This can be defined using a BrepVertex or a BRepEdge and offset to define
      where the point is along the edge. If an edge is specified, the pointOneOffset parameter must be specified.
      @param pointTwoEntity The second point of the rip and must lie on the same face as point 1. This can be defined using a
      BrepVertex or a BRepEdge and an offset to define where the point is along the edge.
      If an edge is specified, the pointTwoOffset parameter must be specified.
      @param gapDistance The gap distance of the rip.
      @param pointOneOffset If the first point lies on an edge, then this is the offset along the edge which defines the point.
      This is the physical distance from the topological start of the edge.
      If the offset is negative or exceeds the edge length, the corresponding vertex of the edge will be used.
      @param pointTwoOffset If the second point lies on an edge, then this is the offset along the edge which defines the point.
      This is the physical distance from the topological start of the edge.
      If the offset is negative or exceeds the edge length, the corresponding vertex of the edge will be used.
      @returns Returns true if the rip definition is successful.
    */
    redefineToBetweenPoints(pointOneEntity: core.Base, pointTwoEntity: core.Base, gapDistance: core.ValueInput, pointOneOffset?: core.ValueInput/* = null*/, pointTwoOffset?: core.ValueInput/* = null*/): boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of its parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: RipFeature
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this is not the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): RipFeature | null
  }

  /**
    Specifies the different ways a Rip feature can be defined.
  */
  const enum RipFeatureDefinitionTypes {
    /**
      The rip type is undefined. This occurs when a new RipFeatureInput is created
      and before a specific type has been defined.
    */
    UndefinedRipFeatureDefinitionType,
    /**
      Rips an entire face.
    */
    FaceRipFeatureDefinitionType,
    /**
      Rips along an edge.
    */
    AlongEdgeRipFeatureDefinitionType,
    /**
      Rips between two points on a face.
      The points may be defined either by vertices,
      or by an edge and an offset along that edge.
    */
    BetweenPointsRipFeatureDefinitionType,
  }

  /**
    Product that contains all of the information associated with a flat pattern.
    A FlatPatternProduct object exists for each flat pattern created.
  */
  abstract class FlatPatternProduct extends Design {
    /**
      Gets the flat pattern associated with this FlatPatternProduct.
    */
    readonly flatPattern: FlatPattern
    /**
      Deletes this FlatPatternProduct and the flat pattern it contains.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
  }

  /**
    This object represent the root component of a FlatPatternProduct. The flatPattern
    property will return a FlatPattern object that provides access to the resulting
    flat pattern geometry.
  */
  abstract class FlatPatternComponent extends Component {
  }

  /**
    The FlatPattern object provides access to the flattened representation of a folded part.
    This supports most of the functionality of a regular component like creating sketches,
    construction geometry, and most features. Functionality that is not supported in a
    flat pattern will fail if you attempt to use it. For example, the creation of occurrences
    and new components is not supported. Also the creation of sheet metal features is
    not supported.
  */
  abstract class FlatPattern extends Feature {
    /**
      Returns the B-Rep body that represents the flattened sheet metal part.
    */
    readonly flatBody: BRepBody
    /**
      Returns the wire B-Rep body that represents the bend lines of the flattened sheet metal part.
    */
    readonly bendLinesBody: BRepBody
    /**
      Returns the wire B-Rep body that represents the extent lines of the flattened sheet metal part.
    */
    readonly extentLinesBody: BRepBody
    /**
      Returns the "top" face of the flat pattern B-Rep body.
    */
    readonly topFace: BRepFace
    /**
      Returns the "bottom" face of the flat pattern B-Rep body.
    */
    readonly bottomFace: BRepFace
    /**
      Returns the "side" faces of the flat pattern B-Rep body. These are the faces around
      the edge of the flat pattern that connect the top and bottom faces.
    */
    readonly sideFaces: BRepFaces
    /**
      Returns the folded B-Rep body in the design that this flat pattern was created from.
    */
    readonly foldedBody: BRepBody
    /**
      Returns bend information for the specified bend.
      @param bendEdge The wire BrepEdge that represents a bend line in the model. The edges are obtained from the wire
      body returned by the bendLinesBody property.
      @param isBendUp Indicates if the bend is in the natural direction of the bend line or in the opposite direction. Returns true
      if the bend is in the same direction as the input bend line.
      @param bendAngle Returns the bend angle of the bend in radians.
      @returns Returns true if the bend information was successfully returned.
    */
    getBendInfo(bendEdge: BRepEdge): [isBendUp: boolean, bendAngle: number]
  }

  /**
    A collection of sheet metal rules.
  */
  abstract class SheetMetalRules extends core.Base {
    /**
      Function that returns the specified sheet metal rule using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SheetMetalRule | null
    /**
      The number of sheet metal rules in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified sheet metal rule using the name of the rule.
      @param name The name of the rule within the collection to return. This is the name seen in the Sheet Metal Rules dialog.
      @returns Returns the specified item or null if the specified name was not found.
    */
    itemByName(name: string): SheetMetalRule | null
    /**
      Creates a new sheet metal rule by copying an existing rule. The new rule
      can then be edited to define the rule characteristics you want.
      @param existingSheetMetalRule The existing SheetMetalRule object you want to copy. This can be a rule from the
      library or the design.
      @param name The name to assign to the new sheet metal rule. This name must be unique with respect to other
      sheet metal rules in the design or library it's created in.
      @returns Returns the new SheetMetalRule object or will assert in the case where it fails.
    */
    addByCopy(existingSheetMetalRule: SheetMetalRule, name: string): SheetMetalRule
  }

  /**
    Used to get and set the current value of a value associated with a sheet metal rule. A value
    can be gotten or set using a string or a double. A string can contain equations and unit specifiers
    whereas a double defines the size in centimeters. In the user-interface, the user is always
    setting the string expression. However, when programming it is typically more convenient to set
    it using an explicit value. When the value is set using a double, Fusion creates an equivalent
    expression.
  */
  abstract class SheetMetalRuleValue extends core.Base {
    /**
      Gets and sets the expression of the sheet metal rule value. This can be an
      equation that includes the name "Thickness" and can also include length unit
      specifiers. For example, a valid expression is "Thickness / 2 + 1 mm". If no
      units are specified, the unit is implied and uses the units associated with the rule
      which can be mm or inch. For example an expression of "3" will be 3 inches if the
      rule units are inches or 3 mm if the rule units are millimeters.
    */
    expression: string
    /**
      Gets and sets the value of the sheet metal rule value in centimeters. Setting
      this value will create a new expression that is equivalent to the new value.
    */
    value: number
  }

  /**
    A sheet metal rule.
  */
  abstract class SheetMetalRule extends core.Base {
    /**
      The name of the sheet metal rule. When setting the name, it should be
      unique with respect to other sheet metal rules in the design or library.
    */
    name: string
    /**
      The thickness of the part. Use the returned SheetMetalRuleValue
      object to get and set the current value of the thickness.
    */
    readonly thickness: SheetMetalRuleValue
    /**
      The K Factor value that is used when calculating the flat pattern. It must be
      a value between 0 and 1.
    */
    kFactor: number
    /**
      The value used for miter, rip, and seam, gaps. Use the returned SheetMetalRuleValue
      object to get and set the current value of the gap.
    */
    readonly gap: SheetMetalRuleValue
    /**
      The interior radius of the bends. Use the returned SheetMetalRuleValue
      object to get and set the current value of the radius.
    */
    readonly bendRadius: SheetMetalRuleValue
    /**
      The relief width used in the flat pattern. Use the returned SheetMetalRuleValue
      object to get and set the current value of the relief width.
    */
    readonly reliefWidth: SheetMetalRuleValue
    /**
      The relief depth used in the flat pattern. Use the returned SheetMetalRuleValue
      object to get and set the current value of the relief depth.
    */
    readonly reliefDepth: SheetMetalRuleValue
    /**
      The relief remnant used in the flat pattern. Use the returned SheetMetalRuleValue
      object to get and set the current value of the relief remnant.
    */
    readonly reliefRemnant: SheetMetalRuleValue
    /**
      Gets and sets the bend relief shape to use.
    */
    reliefShape: BendReliefShapes
    /**
      Gets and sets the relief shape to use when two bends intersect.
      When set to square or round relief shape, the value of the twoBendReliefPlacement
      property will be set to IntersectionTwoBendReliefPlacement. For a round relief
      shape you can change the twoBendReliefPlacment property to TangentTwoBendReliefPlacement.
    */
    twoBendReliefShape: TwoBendReliefShapes
    /**
      The relief size used when two bends meet in the flat pattern and the relief
      shape is round or square. Use the returned SheetMetalRuleValue object to
      get and set the current value of the relief size.
    */
    readonly twoBendReliefSize: SheetMetalRuleValue
    /**
      Gets and sets the relief placement for a two bend relief shape. When the relief shape
      is round, both intersection and tangent are valid placements. For square shape, only
      intersection is valid. For all other shapes, this property will return NoTwoBendReliefPlacement
      because the placement option is not used.
    */
    twoBendReliefPlacement: TwoBendReliefPlacements
    /**
      Gets and sets the relief shape to use when three bends intersect.
    */
    threeBendReliefShape: ThreeBendReliefShapes
    /**
      The relief size used when three bends meet in the flat pattern and the relief shape
      is "round with radius". Use the returned SheetMetalRuleValue object to get and set
      the current value of the relief size.
    */
    readonly threeBendReliefRadius: SheetMetalRuleValue
    /**
      Returns the parent design for a sheet metal rule in a design or it
      returns null if the sheet metal rule is in the library.
    */
    readonly parentDesign: Design
    /**
      This gets and sets which rule in a library is the default rule. This is only
      valid for rules in a library and will fail for rules in a design.
    */
    isDefault: boolean
    /**
      Indicates if this rule is currently being used by a component. This is only
      valid for rules in a design.
    */
    readonly isUsed: boolean
    /**
      Deletes the rule from the design or library. If the rule is in the
      library and set as the default rule, you cannot delete it. If the
      rule is in a design and is used by a component you cannot use it.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Gets the units this rule uses to display values in the dialog.
      Rules currently only use mm or inch and the units are permanently
      associated with a rule and cannot be modified.
    */
    readonly units: string
  }

  /**
    The bend relief shapes used for a single bend.
  */
  const enum BendReliefShapes {
    /**
      Straight shape for the bend relief.
    */
    StraightBendReliefShape,
    /**
      Tear shape for the bend relief.
    */
    TearBendReliefShape,
    /**
      Round shape for the bend relief.
    */
    RoundBendReliefShape,
  }

  /**
    The bend relief shapes used when two bends intersect.
  */
  const enum TwoBendReliefShapes {
    /**
      Round shape for the bend relief.
    */
    RoundTwoBendReliefShape,
    /**
      Square shape for the bend relief.
    */
    SquareTwoBendReliefShape,
    /**
      Tear shape for the bend relief.
    */
    TearTwoBendReliefShape,
    /**
      Trim to the bends for the bend relief.
    */
    TrimToBendTwoBendReliefShape,
    /**
      Linear weld for the bend relief.
    */
    LinearWeldTwoBendReliefShape,
    /**
      Arc weld for the bend relief.
    */
    ArcWeldTwoBendReliefShape,
  }

  /**
    The placement options for a two bend relief.
  */
  const enum TwoBendReliefPlacements {
    /**
      Specifies that no two bend relief placement is defined. This is returned for all two bend relief shapes except
      for round and square shapes.
    */
    NoTwoBendReliefPlacement,
    /**
      Specifies that the center point of the two bend relief shape is located at the intersection of the bend center lines.
      This is the only valid placement option for square two bend relief shapes. For round shapes, this and tangent placement
      is valid.
    */
    IntersectionTwoBendReliefPlacement,
    /**
      Specifies that the shape of the two bend relief is tangential to the flange sides. This is only used for round to bend
      relief shapes where this or intersection placement is valid.
    */
    TangentTwoBendReliefPlacement,
  }

  /**
    The bend relief shapes used when three bends intersect.
  */
  const enum ThreeBendReliefShapes {
    /**
      No replacement for the bend relief.
    */
    NoReplacementThreeBendReliefShape,
    /**
      Intersection bend relief.
    */
    IntersectionThreeBendReliefShape,
    /**
      Full round bend relief.
    */
    FullRoundThreeBendReliefShape,
    /**
      Round radius bend relief.
    */
    RoundWithRadiusThreeBendReliefShape,
  }

  /**
    Bend location types used for creating flanges and hems.
  */
  const enum BendPositionTypes {
    /**
      Legacy bend location type no longer used. Not tangent to side, same reference plane as eBendInnerVS, but material can flip.
    */
    LegacyBendPositionType,
    /**
      Reference Plane through selected Edge, Material outside
    */
    OutsideBendPositionType,
    /**
      Reference Plane through other Edge, Material inside
    */
    InsideBendPositionType,
    /**
      Reference Plane is the Side Face, Bend starts at selected edge
    */
    StartEdgeBendPositionType,
    /**
      Reference Plane is the Side Face, Bend Tangent to Ref Plane if angle >= 90
    */
    TangentToSideBendPositionType,
  }

  /**
    Provides access to the sketches within a design and provides
    methods to create new sketches.
  */
  abstract class Sketches extends core.Base {
    /**
      Function that returns the specified sketch using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the
      collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Sketch | null
    /**
      Returns the sketch with the specified name.
      @param name The name of the sketch as seen in the browser and the timeline.
      @returns Returns the sketch or null if there isn't a sketch with that name.
    */
    itemByName(name: string): Sketch | null
    /**
      Returns the number of sketches in a component
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new sketch on the specified planar entity.
      @param planarEntity A construction plane or planar face that defines the sketch plane
      @param occurrenceForCreation A creation occurrence is needed if the planarEntity is in another component AND the
      sketch is not in the root component. The occurrenceForCreation is analogous
      to the active occurrence in the UI.
      @returns Returns the newly created Sketch or null if the creation failed.
    */
    add(planarEntity: core.Base, occurrenceForCreation?: Occurrence/* = null*/): Sketch | null
    /**
      Creates a parametric sketch that is associated with a base feature.
      Because of a current limitation, if you want to create a sketch associated with a base
      feature, you must first call the edit method of the base feature, use this method to
      create the sketch, and then call the finishEdit method of the base feature. The base
      feature must be in an "edit" state to be able to add any additional items to it.
      @param planarEntity A construction plane or planar face that defines the sketch plane.
      @param targetBaseOrFormFeature The existing base feature that you want to associate this sketch with.
      @param includeFaceEdges When a BrepFace is used as the planarEntity argument, this defines if the edges of the face
      should be included in the sketch.
      @returns Returns the newly created Sketch or null if the creation failed.
    */
    addToBaseOrFormFeature(planarEntity: core.Base, targetBaseOrFormFeature: core.Base, includeFaceEdges: boolean): Sketch | null
    /**
      Creates a new sketch on the specified planar entity. If a BRepFace is provided, the edges of the face
      are not projected into the sketch so the result of creating a new sketch with this method will
      always be a new empty sketch.
      @param planarEntity A construction plane or planar face that defines the sketch plane.
      @param occurrenceForCreation A creation occurrence is needed if the planarEntity is in another component AND the
      sketch is not in the root component. The occurrenceForCreation is analogous
      to the active occurrence in the UI.
      @returns Returns the newly created Sketch or null if the creation failed.
    */
    addWithoutEdges(planarEntity: core.Base, occurrenceForCreation?: Occurrence/* = null*/): Sketch | null
  }

  /**
    Represents a sketch within a component.
  */
  abstract class Sketch extends core.Base {
    /**
      Gets and sets the name of this sketch as seen in the browser and timeline.
    */
    name: string
    /**
      Returns the sketch points collection associated with this sketch.
      This provides access to the existing sketch points and supports
      the creation of new sketch points.
    */
    readonly sketchPoints: SketchPoints
    /**
      Returns the sketch curves collection associated with this sketch.
      This provides access to the existing sketch curves which is all
      geometry in the sketch except for sketch points. It is through this
      collection that new sketch geometry gets created.
    */
    readonly sketchCurves: SketchCurves
    /**
      Returns the sketch dimensions collection associated with this sketch.
      This provides access to the existing sketch dimensions and supports
      the creation of new sketch dimensions.
    */
    readonly sketchDimensions: SketchDimensions
    /**
      Returns the sketch constraints collection associated with this sketch.
      This provides access to the existing sketch constraints and supports
      the creation of new sketch constraints.
    */
    readonly geometricConstraints: GeometricConstraints
    /**
      This method has been replaced by the project2 method, which supports specifying if
      the result will be linked or not.
      @remarks
      Projects the specified entity or entities onto the x-y plane of the sketch
      and returns the created sketch entity(s). You can provide either a single
      entity or an ObjectCollection of multiple entities, which will be projected simultaneously.
      @param entity The entity to project. This can be a single entity of the following types:
      sketch entity, an edge, a face (which will get all of its edges), a vertex,
      a construction axis, a construction point, or a construction plane that is
      perpendicular to the sketch to create a line.
      This can also be an ObjectCollection that contains multiple entities and will be
      projected simultaneously. The entities that can be projected must be the types
      and have the same restrictions as described above.
      @returns Returns a collection of the sketch entities that were created as a result of the
      projection.
      @deprecated
    */
    project(entity: core.Base): core.ObjectCollection
    /**
      Intersects the specified body with the sketch plane and creates new
      curves representing the intersection.
      @param body The body to be intersected by the sketch.
      @returns Returns a collection of the sketch entities that were created a a result of the
      cut.
    */
    projectCutEdges(body: BRepBody): core.ObjectCollection
    /**
      Creates new sketch curves and points that represent the specified entity
      as sketch geometry. The sketch geometry is not projected but is created
      in the same location in space as the input geometry.
      @param entity The entity to include into the sketch. This can be a sketch entity from
      another sketch, edge, face (which results in getting all of its edges, a
      vertex, construction axis, or construction point.
      @returns Returns a collection of the sketch entities that were created as a result of the include.
      When including this curves it will be a single sketch curve, but for faces, multiple
      sketch curves will be created one for each edge.
    */
    include(entity: core.Base): core.ObjectCollection
    /**
      Finds the sketch curves that are end connected to the input curve. This can be useful
      for many cases but is especially useful in gathering the input when creating an offset.
      @param curve The initial sketch curve that will be used to find the connected curves.
      @returns A collection of the connected curves. They are returned in their connected order with
      the original input curve being one of the curves.
    */
    findConnectedCurves(curve: SketchCurve): core.ObjectCollection
    /**
      Creates offset curves for the set of input curves. If the offset distance is not
      provided, the offset distance is defined by the direction point.
      @remarks
      To access the full capabilities supported by offset, you should use the createOffsetInput and
      addOffset2 methods.
      @param curves A set of end connected curves. The Sketch.FindConnectedCurves method is a convenient way to get
      this set of curves.
      @param directionPoint Defines which side of the input curves to create the offset on
      @param offset The distance to offset the curves in centimeters.
      @returns A collection of the new offset sketch curves created
      @deprecated
    */
    offset(curves: core.ObjectCollection, directionPoint: core.Point3D, offset?: number/* = 0*/): core.ObjectCollection
    /**
      Gets and sets the transform of the sketch with respect to model space.
      This defines the transform from the parent component space
      to the sketch space. For example, if you have point coordinates in the space
      of the parent component and apply this transform it will result in the
      coordinates of the equivalent position in sketch space.
      The transform is sensitive to the assembly context.
      The position of a parametric sketch cannot be modified since its position is defined by
      its parametric association to other geometry. As a result this property will fail when called on
      a parametric sketch. Setting this property is only valid for sketches in a non-parametric
      design or sketches owned by a base feature.
    */
    transform: core.Matrix3D
    /**
      A specified point in model space returns the equivalent point in sketch space.
      This is sensitive to the assembly context.
      @param modelCoordinate A coordinate in model space.
      @returns Returns the equivalent point in sketch space.
    */
    modelToSketchSpace(modelCoordinate: core.Point3D): core.Point3D
    /**
      A specified point in sketch space returns the equivalent point in model space.
      This is sensitive to the assembly context.
      @param sketchCoordinate A coordinate in sketch space.
      @returns Returns the equivalent point in model space.
    */
    sketchToModelSpace(sketchCoordinate: core.Point3D): core.Point3D
    /**
      Indicates if this sketch is parametric or not. For parametric sketches, you can also
      get the construction plane or face it is associative to using the ReferencePlane property.
    */
    readonly isParametric: boolean
    /**
      Gets if this sketch is currently visible in the graphics window. Use the
      isLightBulbOn to change if the light bulb beside the sketch node in the
      browser is on or not. Parent nodes in the browser can have their light
      bulb off which affects all of their children. This property indicates
      the final result and whether this body is actually visible or not.
    */
    isVisible: boolean
    /**
      Indicates if the dimensions of the sketch are displayed when the sketch is not active
      (in sketch edit mode)
    */
    areDimensionsShown: boolean
    /**
      Indicates if the profiles of the sketch are displayed
    */
    areProfilesShown: boolean
    /**
      Returns the origin point of the sketch in model space.
    */
    readonly origin: core.Point3D
    /**
      Returns the X direction of the sketch as defined in model space.
    */
    readonly xDirection: core.Vector3D
    /**
      Returns the Y direction of the sketch as defined in model space.
    */
    readonly yDirection: core.Vector3D
    /**
      Gets and sets the construction plane or planar face the sketch is associated
      to. This is only valid when the IsParametric property is True otherwise this
      returns null and setting the property will fail.
      Setting this property is the equivalent of the Redefine command.
    */
    referencePlane: core.Base
    /**
      This property temporarily turns off sketch computing. It is used to increase the
      performance as sketch geometry is created and modified. Once the sketch is drawn,
      this property should be set to false to allow the sketch to recompute. The file
      does not save this setting and is always false when a file is opened.
      There is a side-effect when using this property that can result in the creation of a
      bad model. This is only a problem when editing an existing sketch used by one or more
      features. When the sketch is edited with the isComputeDeferred property set to true,
      the compute of the profiles can sometimes create weird results in the dependent
      features. There are two easy ways to solve this problem. The first is not to defer
      the sketch compute. The second is to roll the timeline back to just after the sketch,
      make whatever changes you want to the sketch with the compute deferred, and then roll the
      timeline back to its original location. This process mimics the behavior you see in
      the user interface when you manually edit a sketch where Fusion automatically rolls the
      timeline back while you're editing the sketch.
    */
    isComputeDeferred: boolean
    /**
      Moves the specified sketch entities using the specified transform.
      Transform respects any constraints that would normally prohibit the move.
      @param sketchEntities A collection of sketch entities to transform.
      @param transform The transform that defines the move, rotate or scale.
      @returns Returns true if the move was successful.
    */
    move(sketchEntities: core.ObjectCollection, transform: core.Matrix3D): boolean
    /**
      Copies the specified sketch entities, applying the specified transform.
      Any geometric or dimension constraints associated with the entities will
      automatically be copied, if possible. For example, if there is a horizontal
      dimension and the transform defines a rotation then it will not be included in the
      result. This same behavior can be seen when performing a copy/paste operation
      in the user interface.
      @param sketchEntities The collection of sketch entities to copy. They must all exist in this sketch.
      @param transform The transform to apply to the copied entities.
      @param targetSketch Optionally specifies the sketch to copy the entities to. If not provided the entities are copied to this sketch.
      @returns Returns a collection of the new sketch entities that were created as a result of the copy.
    */
    copy(sketchEntities: core.ObjectCollection, transform: core.Matrix3D, targetSketch?: Sketch/* = null*/): core.ObjectCollection
    /**
      Returns the profiles currently computed for the sketch.
    */
    readonly profiles: Profiles
    /**
      Deletes the sketch.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Saves the contents of the sketch to a specified DXF file.
      @remarks
      This method has been replaced by using the ExportManager.createDXFSketchExportOptions
      method, which provides additional capabilities.
      @param fullFilename The full filename, including the path, of the DXF file.
      @returns Returns true if the operation was successful.
      @deprecated
    */
    saveAsDXF(fullFilename: string): boolean
    /**
      Imports the contents of an SVG file into the active sketch.
      @param fullFilename The full filename, including the path, of the SVG file.
      @param xPosition The X offset in centimeters in the sketch for the origin of the SVG data
      relative to the sketch origin.
      @param yPosition The Y offset in centimeters in the sketch for the origin of the SVG data
      relative to the sketch origin.
      @param scale The scale value to apply to the imported SVG data.
      @returns Returns true if the import was successful.
    */
    importSVG(fullFilename: string, xPosition: number, yPosition: number, scale: number): boolean
    /**
      Returns the timeline object associated with this sketch.
    */
    readonly timelineObject: TimelineObject
    /**
      Returns the parent Component.
    */
    readonly parentComponent: Component
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: Sketch
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): Sketch | null
    /**
      Returns the 3D bounding box of the sketch
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Returns the sketch text collection associated with this sketch.
      This provides access to existing text and supports the creation
      of new text.
    */
    readonly sketchTexts: SketchTexts
    /**
      Returns the sketch point that was automatically created by projecting the
      origin construction point into the sketch.
    */
    readonly originPoint: SketchPoint
    /**
      Indicates if this sketch is fully constrained.
    */
    readonly isFullyConstrained: boolean
    /**
      Changes which plane the sketch is based on.
      @param planarEntity A construction plane or planar face that defines the sketch plane
      @returns Returns true if the operation was successful.
    */
    redefine(planarEntity: core.Base): boolean
    /**
      Returns the collection of attributes associated with this face.
    */
    readonly attributes: core.Attributes
    /**
      This property returns the base or form feature that this sketch is associated with. It returns
      null in the case where the sketch is parametrically defined and is not related to a base or form
      feature. It also returns null in a direct modeling design.
    */
    readonly baseOrFormFeature: core.Base
    /**
      Returns the current health state of this sketch.
    */
    readonly healthState: FeatureHealthStates
    /**
      Returns the error or warning message in the case where the healthState property returns either
      WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
    */
    readonly errorOrWarningMessage: string
    /**
      Intersects the specified entities (BRepBody, BRepFace, BRepEdge, BRepVertex, SketchCurve, ConstructionPoint,
      ConstructionAxis, and ConstructionPlane) with the sketch plane and creates sketch geometry that represents
      the intersection.
      @param entities An array containing the entities to intersect with the sketch plane.
      @returns An array returning the sketch entities that were created as a result of the
      intersections. It's possible that this can come back empty in the case where the input
      entities don't intersect the sketch plane.
    */
    intersectWithSketchPlane(entities: core.Base[]): fusion.SketchEntity[]
    /**
      Projects the specified set of curves onto the specified set of faces using the specified method of projection.
      if the projection type is along a vector, then the directionEntity argument must be supplied. if the projectionType
      is the closest point method, the directionEntity argument is ignored.
      @param faces An array of BRepFace objects that the curves will be projected onto.
      @param curves An array of various curve objects that will be projected onto the faces. The curves can be sketch curves and points,
      BRepEdge objects, ConstructionAxis objects, and ConstructionPoint objects.
      @param projectType Specifies which projection type to use which defines the direction of projection. If this is set to AlongVectorSurfaceProjectType
      the directionEntity argument must be provided.
      @param directionEntity if the projectType argument is AlongVectorSurfaceProjectType, this argument must be specified and defines the
      direction of projection. It can be a linear BRepEdge, a BRepFace where the normal will be used, a SketchLine, or
      a ConstructionLine.
      @returns Returns an array of the sketch entities that were created as a result of projection the specified curves onto
      the faces.
    */
    projectToSurface(faces: fusion.BRepFace[], curves: core.Base[], projectType: SurfaceProjectTypes, directionEntity?: core.Base): fusion.SketchEntity[]
    /**
      Returns the current revision ID of the sketch. This ID changes any time the sketch is modified in any way. By getting
      and saving the ID when you create any data that is dependent on the sketch, you can then compare the saved
      ID with the current ID to determine if the sketch has changed to know if you should update your data.
    */
    readonly revisionId: string
    /**
      Indicates if the constraints of the sketch are displayed when the sketch is active.
    */
    areConstraintsShown: boolean
    /**
      Indicates if the sketch points in the sketch are displayed. Points that are not connected to any other
      geometry will continue to be shown.
    */
    arePointsShown: boolean
    /**
      Gets and set if the light bulb beside the sketch node in the
      browser is on or not. Parent nodes in the browser can have their light
      bulb off which affects all of their children so this property does not
      indicate if the body is actually visible, just that it should be visible
      if all of it's parent nodes are also visible. Use the isVisible property
      to determine if it's actually visible.
    */
    isLightBulbOn: boolean
    /**
      Returns a token for the Sketch object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same token.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Method that sets the Construction state for an array of sketch curves.
      @param sketchCurves An array of sketch curves to set the construction status.
      @param constructionState Input enum value that specifies if the construction state of the input curves should be toggled,
      set to construction, or set to normal.
      @returns Returns true if successful.
    */
    setConstructionState(sketchCurves: fusion.SketchCurve[], constructionState: SketchCurveConstructionStates): boolean
    /**
      Method that sets the Centerline state for an array of sketch lines.
      @param sketchLines An array of sketch lines to set the centerline status
      @param centerlineState Input enum value that specifies if the centerline state of the input lines should be toggled,
      set to centerline, or set to normal
      @returns Returns true if successful.
    */
    setCenterlineState(sketchLines: fusion.SketchLine[], centerlineState: SketchLineCenterlineStates): boolean
    /**
      Gets and sets whether the model is sliced along the sketch plane when this sketch is active.
      This provides access to the "Slice" setting in the "SKETCH PALETTE".
    */
    isModelSliced: boolean
    /**
      Gets and sets whether projected geometry in the sketch is displayed.
      This provides access to the "Projected Geometries" setting in the "SKETCH PALETTE".
    */
    isProjectedGeometryShown: boolean
    /**
      Gets and sets whether construction geometry in the sketch is displayed.
      This provides access to the "Construction Geometries" setting in the "SKETCH PALETTE".
    */
    isConstructionGeometryShown: boolean
    /**
      Creates sketch geometry that represents the spun profile. The spun profile is the silhouette of the
      entities as if they were spinning around an axis. The created spun profile is based on the
      information provided by the SpunProfileInput object.
      @param input The SpunProfileInput object that specifies the input needed to create the spun profile.
      @returns An array of sketch entities that were created as a result of the spun profile.
    */
    createSpunProfile(input: SpunProfileInput): fusion.SketchEntity[]
    /**
      Creates a new SpunProfileInput object that is used to specify the input needed to create
      a spun profile.
      @param entities An array containing the entities (BRepBody or BRepFace) to
      create a spun profile.
      @param axis The axis can be a sketch line, construction axis, or linear edge. The axis must
      not be perpendicular to the sketch plane.
      @returns Returns the newly created SpunProfileInput object or null if the creation failed.
    */
    createSpunProfileInput(entities: core.Base[], axis: core.Base): SpunProfileInput | null
    /**
      Creates the geometry that represents a slot. Geometric constraints are automatically
      added to the geometry to maintain the slot shape and optionally, dimensions to control
      the size can be added. The created geometry and constraints are returned.
      @param startPoint The start point of the slot. It can be a SketchPoint or Point3D object. If a SketchPoint
      is provided a coincident constraint will be created between the start point of the slot
      and the provided sketch point.
      @param endPoint The end point of the slot. It can be a SketchPoint or Point3D object. This point defines
      the length of the slot. If a SketchPoint is provided a coincident constraint is created
      between the end point of the slot and the provided sketch point.
      If the length or angle arguments are provided, the point is not the actual end point
      but is used to determine the direction of the slot.
      @param width A ValueInput object that defines the width of the slot. The ValueInput can define either
      a real value or an expression string. If it is a real value, it defines the width of the
      slot in centimeters.
      When using a ValueInput created using a string, it's the same as creating a parameter in the user-interface.
      You can specify any valid expression, i.e. "5", "5 in", "5 in / 2", "5 + Length" that defines a length.
      @param createWidthDimension Specifies if a dimension constraint and its associated parameter is created to control the width
      of the slot.
      @param length Optional argument that defines the length of the slot using a ValueInput. If this is provided, it
      overrides the endPoint and explicitly defines the length of the slot. If the length is specified,
      a dimension constraint and its associated parameter is created to control the length.
      The ValueInput can define either a real value or an expression string. If it is a real value,
      it defines the length of the slot in centimeters. When it is an expression string, it's the same as
      creating a parameter in the user-interface. You can specify any valid expression, i.e. "5", "5 in",
      "5 in / 2", "5 + Length" that defines a length.
      @param angle Optional argument that defines the angle of the slot using a ValueInput. If this is provided, it
      overrides the endPoint and explicitly defines the angle of the slot. If the angle is specified,
      a horizontal construction line, a dimension constraint, and its associated parameter is created to control the angle.
      The angle is measured from a horizontal line that starts at that start point and goes in the positive
      X direction. The angle is always less than 180 deg. and depending on the location of the end point, the angle
      will be clockwise or counterclockwise from the horizontal line.
      The ValueInput can define either a real value or an expression string. If it is a real value,
      it defines the angle of the slot in radians. When it is an expression string, it's the same as
      creating a parameter in the user-interface. You can specify any valid expression, i.e. "45", "45 deg",
      "180 / 3", "Sweep * 2" that defines an angle.
      @returns Returns an array containing the start point arc, the end arc, the two lines that define the slot, the construction
      line between the two points, and optionally, the construction line the angle is measured from if an angle is specified, and
      the dimension constraints that were created in the order of width, length, and angle.
    */
    addCenterToCenterSlot(startPoint: core.Base, endPoint: core.Base, width: core.ValueInput, createWidthDimension?: boolean/* = false*/, length?: core.ValueInput/* = null*/, angle?: core.ValueInput/* = null*/): core.Base[]
    /**
      Projects the specified entity or entities onto the X-Y plane of the sketch and returns
      the created sketch entity(s).
      @param entities An array containing the entities to project. It can be an array of one for the case where a single
      entity is being projected. The following types of entities are valid for projection: sketch curves
      and points, B-Rep bodies (which results in projecting the silhouette of the body), B-Rep edges,
      B-Rep faces (which results in projecting all of its edges), B-Rep vertices, construction axes,
      construction points, and construction planes that are perpendicular to the sketch which results
      in the creation of a line.
      @param isLinked A Boolean that indicates if the resulting sketch curves will be parametrically linked to the
      source geometry that was projected. If true, they will be linked. If false, the resulting curves
      are independent.
      @returns Returns an array of the sketch entities that were created as a result of the projection.
    */
    project2(entities: core.Base[], isLinked: boolean): SketchEntity[]
  }

  /**
    Used by the Sketch.setConstructionState method setting the construction state on sketch curves.
  */
  const enum SketchCurveConstructionStates {
    /**
      Specifies that the construction state should be toggled from its current state.
    */
    ToggleSketchCurveConstructionState,
    /**
      Specifies that the construction state should be set to construction.
    */
    ConstructionSketchCurveConstructionState,
    /**
      Specifies that the construction state should be set to normal.
    */
    NormalSketchCurveConstructionState,
  }

  /**
    Used by the Sketch.setCenterlineState method setting the centerline state on sketch lines.
  */
  const enum SketchLineCenterlineStates {
    /**
      Specifies that the centerline state should be toggled from its current state.
    */
    ToggleSketchLineCenterlineState,
    /**
      Specifies that the centerline state should be set to centerline.
    */
    CenterlineSketchLineCenterlineState,
    /**
      Specifies that the centerline state should be set to normal.
    */
    NormalSketchLineCenterlineState,
  }

  /**
    Used by the Sketch.projectToSurface method when defined how to project a curve onto a surface.
  */
  const enum SurfaceProjectTypes {
    /**
      Projects the curve using the closest point on the surface to the curve.
    */
    ClosestPointSurfaceProjectType,
    /**
      Projects the curve along a defined vector.
    */
    AlongVectorSurfaceProjectType,
  }

  /**
    A collection of all of the closed profiles currently calculated for this sketch. Closed profiles are
    automatically computed by Fusion and represent closed areas within the sketch.
    This class also provides some additional utility functions to create open profiles and text based profiles
    that can be used as input for various features.
  */
  abstract class Profiles extends core.Base {
    /**
      Function that returns the specified closed profile using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the
      collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Profile | null
    /**
      Returns the number of closed profiles in the sketch. Open and text based profiles are not included.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Represents a profile in a sketch. Profiles are automatically computed by Fusion and
    represent closed areas within the sketch.
  */
  abstract class Profile extends core.Base {
    /**
      Returns the 3D bounding box of the profile in sketch space.
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Returns the plane the profile is defined in. Profiles are always planar and exist within
      a single plane.
    */
    readonly plane: core.Plane
    /**
      The loops or closed areas within this profile. There is always a single outer loop
      but there can be zero to many inner loops defining voids in the profile.
    */
    readonly profileLoops: ProfileLoops
    /**
      Returns the parent sketch of the profile.
    */
    readonly parentSketch: Sketch
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this
      object in an assembly. This is only valid in the case where this
      is acting as a proxy in an assembly. Returns null
      in the case where the object is not in the context of an assembly.
      but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: Profile
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      Returns null if this isn't the NativeObject.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): Profile | null
    /**
      Calculates the area properties for the profile.
      @param accuracy Specifies the desired level of computational accuracy of the property calculations.
      The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
      @returns Returns the AreaProperties object that has properties for getting the area, perimeter, centroid, etc
      of this profile.
    */
    areaProperties(accuracy?: CalculationAccuracy/* = CalculationAccuracy.LowCalculationAccuracy*/): AreaProperties
    /**
      Returns a token for the Profile object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same profile.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Returns a temporary BRepFace object that is the same shape as the profile. The geometry
      of the returned face is defined in the 3D space of the parent sketch of the profile.
      This can be useful when wanting to use a profile in conjunction with the
      TemporaryBRepManager object to create B-Rep objects.
    */
    readonly face: BRepFace
  }

  /**
    A collection of loops within a Profile.
  */
  abstract class ProfileLoops extends core.Base {
    /**
      Function that returns the specified profile loop using an index into the collection.
      @param index The index of the item within the collection to return.
      The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ProfileLoop | null
    /**
      Returns the number of loops within this profile.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A loop within a profile.
  */
  abstract class ProfileLoop extends core.Base {
    /**
      Indicates if this is an outer or inner loop. Profiles always have
      one outer loop and have an zero to many inner loops defining voids.
    */
    readonly isOuter: boolean
    /**
      Returns a collection of the curves making up this loop.
    */
    readonly profileCurves: ProfileCurves
    /**
      Returns the parent Profile object.
    */
    readonly parentProfile: Profile
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ProfileLoop
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      Returns null if this isn't the NativeObject.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ProfileLoop | null
  }

  /**
    A collection of profile curves within a profile loop.
  */
  abstract class ProfileCurves extends core.Base {
    /**
      Function that returns the specified profile curve using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ProfileCurve | null
    /**
      Returns the number of curves in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A single curve in a profile.
  */
  abstract class ProfileCurve extends core.Base {
    /**
      Returns the geometric entity of this portion of the profile.
    */
    readonly geometry: core.Curve3D
    /**
      Return the geometry type that the Geometry property will return.
    */
    readonly geometryType: core.Curve3DTypes
    /**
      Returns the associated sketch entity that defines this curve.
    */
    readonly sketchEntity: SketchEntity
    /**
      Returns the parent ProfileLoop object.
    */
    readonly parentProfileLoop: ProfileLoop
    /**
      Returns the parent Profile object.
    */
    readonly parentProfile: Profile
    /**
      Returns the parent Profile object.
    */
    readonly parentSketch: Sketch
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ProfileCurve
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      Returns null if this isn't the NativeObject.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ProfileCurve | null
    /**
      Returns the bounding box of the profile curve in sketch space.
    */
    readonly boundingBox: core.BoundingBox3D
  }

  /**
    This object represents all geometry in a sketch, including all
    the various curves, points, and text.
  */
  abstract class SketchEntity extends core.Base {
    /**
      Returns the parent sketch.
    */
    readonly parentSketch: Sketch
    /**
      Returns the sketch dimensions that are attached to this curve.
    */
    readonly sketchDimensions: SketchDimensionList
    /**
      Returns the sketch constraints that are attached to this curve.
    */
    readonly geometricConstraints: GeometricConstraintList
    /**
      Indicates if this curve lies entirely on the sketch x-y plane.
    */
    readonly is2D: boolean
    /**
      Indicates if this geometry is a reference.
      Changing this property from true to false removes the reference.
      This property can not be set to true if it is already false.
    */
    isReference: boolean
    /**
      Indicates if this geometry is "fixed".
    */
    isFixed: boolean
    /**
      When a sketch is created, geometry is sometimes automatically added to the sketch.
      For example a sketch point that references the origin point is always included and
      if a face was selected to create the sketch on, geometry from the face is also included.
      This automatically created geometry behaves in a special way in that it is invisible
      but is available for selection and it also participates in profile calculations. It's
      not possible to make them visible but they can be deleted and they can be used for any
      other standard sketch operation.
    */
    readonly isVisible: boolean
    /**
      Returns the bounding box of the entity in sketch space.
    */
    readonly boundingBox: core.BoundingBox3D
    /**
      Deletes the entity from the sketch.
      @returns Returns true is the delete was successful.
    */
    deleteMe(): boolean
    /**
      Returns the referenced entity in the case where IsReference
      is true. However, this property can also return null when
      IsReference is true in the case where the reference is not
      parametric.
    */
    readonly referencedEntity: core.Base
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      Indicates if this sketch entity can be deleted. There are cases, especially with sketch
      points where another entity is dependent on an entity so deleting it is not allowed.
      For example, you can't delete the center point of circle by itself but deleting the circle
      will delete the point. The same is true for the end points of a line.
    */
    readonly isDeletable: boolean
    /**
      Indicates if this sketch entity is fully constrained.
    */
    readonly isFullyConstrained: boolean
    /**
      Returns the collection of attributes associated with this face.
    */
    readonly attributes: core.Attributes
    /**
      Returns a token for the SketchEntity object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same sketch entity.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Indicates if this sketch entity was created by a projection, inclusion, or driven by an API script.
      If this returns true, then the entity is presented to the user as not editable and with a 'break link'
      command available.
    */
    readonly isLinked: boolean
  }

  /**
    A list of sketch entities.
  */
  abstract class SketchEntityList extends core.Base {
    /**
      Function that returns the specified sketch entity using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchEntity | null
    /**
      Returns the number of sketch entities in the list.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A collection of sketch points.
  */
  abstract class SketchPoints extends core.Base {
    /**
      Function that returns the specified sketch using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchPoint | null
    /**
      Returns the number of sketch points in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a point at the specified location. This is the equivalent
      of creating a sketch point using the Point command in the user
      interface and will create a visible point in the graphics window.
      @param point The coordinate location to create the sketch point.
      @returns Returns the new sketch point or null if the creation fails.
    */
    add(point: core.Point3D): SketchPoint | null
  }

  /**
    A point within a sketch.
  */
  abstract class SketchPoint extends SketchEntity {
    /**
      Returns a Point3D object which provides the position of the sketch point.
      The returned geometry is always in sketch space.
    */
    readonly geometry: core.Point3D
    /**
      Returns a Point3D object which provides the position of the sketch point in world space.
      The returned coordinate takes into account the assembly context and the position of the
      sketch in it's parent component, which means the coordinate will be returned in the root
      component space.
    */
    readonly worldGeometry: core.Point3D
    /**
      Moves the sketch geometry using the specified transform.
      Move respects any constraints that would normally prohibit the move.
      This will fail in the case where the IsReference property is true.
      @param translation The vector that defines the distance and direction to move.
      @returns Returns true if moving the sketch point was successful.
    */
    move(translation: core.Vector3D): boolean
    /**
      Merges the input sketch point into this sketch point. This effectively
      deletes the other sketch point and changes all entities that referenced
      that sketch point to reference this sketch point.
      This is the equivalent of dragging a sketch point on top of another
      sketch point in the user interface.
      @param point The point to merge with this point.
      @returns Returns true if the merge was successful.
    */
    merge(point: SketchPoint): boolean
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchPoint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchPoint | null
    /**
      Returns the set of sketch entities that are directly connected to this point. For
      example any entities that use this point as their start point or end point will be returned
      and any circle, arc or ellipse who have this point as a center point will be returned. This
      does not include entities that are related to the point through a constraint.
    */
    readonly connectedEntities: SketchEntityList
    /**
      This method disconnects the specified curve from the sketch point. The specified curve must
      use this point as one of its endpoints, and at least one other sketch curve must also use
      the point as its endpoint. Detaching the curve creates a new sketch point, which becomes
      the curve's end point. All other curves using the original sketch point will remain unaffected.
      @param curve The sketch curve to detach from the sketch point. One of its end points must be the
      sketch point.
      @returns If successful, the newly created sketch point that the curve was moved to is returned.
      Null is returned in the case of failure. Typical failure cases are if the specified curve
      is the only curve connected to the point or if the curve is not connected to the point.
    */
    detach(curve: SketchCurve): SketchPoint
  }

  /**
    A list of sketch points.
  */
  abstract class SketchPointList extends core.Base {
    /**
      Function that returns the specified sketch point using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchPoint | null
    /**
      Returns the number of sketch points in the list.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A collection of sketch curves in a sketch. This also provides access to collections
    for the specific types of curves where you can get the curves based on type and
    create new curves.
  */
  abstract class SketchCurves extends core.Base {
    /**
      Function that returns the specified sketch curve using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchCurve | null
    /**
      Returns the number of sketch curves in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the sketch arcs collection associated with this sketch.
      This provides access to the existing sketch arcs and supports
      the creation of new sketch arcs.
    */
    readonly sketchArcs: SketchArcs
    /**
      Returns the sketch circles collection associated with this sketch.
      This provides access to the existing sketch circles and supports
      the creation of new sketch circles.
    */
    readonly sketchCircles: SketchCircles
    /**
      Returns the sketch ellipses collection associated with this sketch.
      This provides access to the existing sketch ellipses and supports
      the creation of new sketch ellipses.
    */
    readonly sketchEllipses: SketchEllipses
    /**
      Returns the sketch elliptical arcs collection associated with this sketch.
      This provides access to the existing sketch elliptical arcs and supports
      the creation of new sketch elliptical arcs.
    */
    readonly sketchEllipticalArcs: SketchEllipticalArcs
    /**
      Returns the sketch lines collection associated with this sketch.
      This provides access to the existing sketch lines and supports
      the creation of new sketch lines.
    */
    readonly sketchLines: SketchLines
    /**
      Returns the sketch splines collection associated with this sketch.
      This provides access to the existing sketch splines and supports
      the creation of new sketch splines.
    */
    readonly sketchFittedSplines: SketchFittedSplines
    /**
      Returns the fixed sketch splines collection associated with this sketch.
      This provides access to the existing fixed sketch splines and supports
      the creation of new fixed sketch splines.
    */
    readonly sketchFixedSplines: SketchFixedSplines
    /**
      Returns the conic curves collection associated with this sketch.
      This provides access to the existing conic curves and supports the
      creation of new conic curves.
    */
    readonly sketchConicCurves: SketchConicCurves
    /**
      Returns the control point splines collection associated with this sketch.
      This provides access to the existing control point splines and supports the
      creation of new control point splines.
    */
    readonly sketchControlPointSplines: SketchControlPointSplines
  }

  /**
    A single sketch curve. This is the base class for the specific curve types.
  */
  abstract class SketchCurve extends SketchEntity {
    /**
      Returns the length of the curve in centimeters.
    */
    readonly length: number
    /**
      Gets and sets whether this curve is construction geometry.
    */
    isConstruction: boolean
    /**
      Split a curve at a position specified along the curve
      @param splitPoint A position (transient Point3D) on the curve that defines the point at which to split the curve
      @param createConstraints Constraints are created by default. Specify false to create no constraints.
      @returns Returns the resulting 2 curves the original curve + the newly created curve
      When split spline the original is deleted and two new curves returned.
      Empty collection returned if curve is closed.
    */
    split(splitPoint: adsk.core.Point3D, createConstraints?: boolean/* = true*/): core.ObjectCollection
    /**
      Trim a curve by specifying a point that determines the segment of the curve to trim away
      @param segmentPoint A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
      The segment of the curve closest to the segmentPoint gets removed
      @param createConstraints Constraints are created by default. Specify false to not create constraints.
      @returns When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
      When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
      When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
      Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
      Trimming a curve having no intersections deletes the original and returns an empty collection
    */
    trim(segmentPoint: adsk.core.Point3D, createConstraints?: boolean/* = true*/): core.ObjectCollection
    /**
      Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
      sketch and splitting this curve at the nearest intersections to a specified point on the curve.
      @param segmentPoint A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
      intersection(s) to this point define the break location(s).
      @param createConstraints Optional argument that specifies if constraints should be created between the new curve segments. A value of
      true indicates constraints will be created.
      @returns All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
      are found and as a result the curve is not broken, an empty ObjectCollection is returned.
    */
    breakCurve(segmentPoint: adsk.core.Point3D, createConstraints?: boolean/* = true*/): core.ObjectCollection
    /**
      Extend a curve by specifying a point that determines the end of the curve to extend
      @param endPoint A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
      The end of the curve closest to the endPoint gets extended
      @param createConstraints Constraints are created by default. Specify false to not create constraints.
      @returns Returns the modified original curve if the start or end of the curve is extended
      If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
      If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
    */
    extend(endPoint: adsk.core.Point3D, createConstraints?: boolean/* = true*/): core.ObjectCollection
    /**
      Get the curves that intersect this curve along with the intersection points (Point3D)
      @param sketchCurves A collection of curves to attempt to find intersections with.
      Set the value of this parameter to null to use all curves in the sketch for the calculation.
      @param intersectingCurves A collection of the actual intersecting curves
      @param intersectionPoints A collection of intersection points (Point3D)
      Item numbers in this collection correspond to the item numbers in the intersectingCurves collection.
      @returns Returns true if the method was successful. It can be successful regardless of whether intersections were found or not.
    */
    intersections(sketchCurves: core.ObjectCollection): [intersectingCurves: core.ObjectCollection, intersectionPoints: core.ObjectCollection]
  }

  /**
    The collection of circles in a sketch. This provides access to the existing
    circles and supports the methods to create new circles.
  */
  abstract class SketchCircles extends core.Base {
    /**
      Function that returns the specified sketch circle using an index into the collection.
      @param index The index of the item within the collection to return.
      The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchCircle | null
    /**
      Returns the number of circles in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a sketch circle that is always parallel to the x-y plane of the sketch
      and is centered at the specified point.
      @param centerPoint The center point of the circle. It can be an existing SketchPoint or a Point3D object.
      @param radius The radius of the circle in centimeters.
      @returns Returns the newly created SketchCircle object or null if the creation failed.
    */
    addByCenterRadius(centerPoint: core.Base, radius: number): SketchCircle | null
    /**
      Creates a sketch circle where the circle passes through the two points and the
      distance between the two points is the diameter of the circle.
      @param pointOne A Point3D object that defines a point is sketch space and lies on the x-y plane of the sketch.
      @param pointTwo A Point3D object that defines a point is sketch space and lies on the x-y plane of the sketch.
      @returns Returns the newly created SketchCircle object or null if the creation failed.
    */
    addByTwoPoints(pointOne: core.Point3D, pointTwo: core.Point3D): SketchCircle | null
    /**
      Creates a sketch circle that passes through the three points. The three points must
      lie on the x-y plane of the sketch.
      @param pointOne The first point that the circle will pass through. The z component must be zero.
      @param pointTwo The second point that the circle will pass through. The z component must be zero.
      @param pointThree The third point that the circle will pass through. The z component must be zero.
      @returns Returns the newly created SketchCircle object or null if the creation failed.
    */
    addByThreePoints(pointOne: core.Point3D, pointTwo: core.Point3D, pointThree: core.Point3D): SketchCircle | null
    /**
      Creates a sketch circle that is tangent to the two input lines.
      The two lines must lie on the x-y plane of the sketch.
      @param tangentOne The first line that the circle will be tangent to.
      The line must lie on the x-y plane of the sketch.
      @param tangentTwo The second line that the circle will be tangent to.
      The line must lie on the x-y plane of the sketch and cannot
      be parallel to the first line.
      @param radius The radius of the circle in centimeters.
      @param hintPoint A point that specifies which of the possible four solutions to use
      when creating the circle. If you consider the two input lines to be infinite
      they create four quadrants which results in four possible solutions for the
      creation of the circle. The hint point is a point anywhere within the quadrant
      where you want the circle created.
      @returns Returns the newly created SketchCircle object or null if the creation failed.
    */
    addByTwoTangents(tangentOne: SketchLine, tangentTwo: SketchLine, radius: number, hintPoint: core.Point3D): SketchCircle | null
    /**
      Creates a sketch circle that is tangent to the three input lines.
      The three lines must lie on the x-y plane of the sketch.
      @param tangentOne The first line that the circle will be tangent to.
      The line must lie on the x-y plane of the sketch and cannot be parallel
      to the second or third line.
      @param tangentTwo The second line that the circle will be tangent to.
      The line must lie on the x-y plane of the sketch and cannot be parallel
      to the first or third line.
      @param tangentThree The third line that the circle will be tangent to.
      The line must lie on the x-y plane of the sketch and cannot be parallel
      to the first or second line.
      @param hintPoint A point that specifies which of the possible multiple solutions to use
      when creating the circle. If you consider the three input lines to be infinite
      there are many possible solutions when creating a circle that is tangent to all
      three lines. The hint point is a point anywhere within the area defined by the
      three lines where the circle is to be created.
      @returns Returns the newly created SketchCircle object or null if the creation failed.
    */
    addByThreeTangents(tangentOne: SketchLine, tangentTwo: SketchLine, tangentThree: SketchLine, hintPoint: core.Point3D): SketchCircle | null
  }

  /**
    A circle in a sketch.
  */
  abstract class SketchCircle extends SketchCurve {
    /**
      Returns the sketch point at the center of the circle.
    */
    readonly centerSketchPoint: SketchPoint
    /**
      Returns the transient geometry of the circle which provides geometric
      information about the circle. The returned geometry is always in sketch space.
    */
    readonly geometry: core.Circle3D
    /**
      Returns a Point3D object which provides the position of the sketch point in world space.
      The returned coordinate takes into account the assembly context and the position of the
      sketch in it's parent component, which means the coordinate will be returned in the root
      component space.
    */
    readonly worldGeometry: core.Circle3D
    /**
      Returns the area of the circle in square centimeters.
    */
    readonly area: number
    /**
      Gets and sets the radius of the circle. Changing the radius is limited
      by any constraints that might exist on the circle.
    */
    radius: number
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchCircle
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchCircle | null
  }

  /**
    The collection of lines in a sketch. This provides access to the existing
    lines and supports the methods to create new lines.
  */
  abstract class SketchLines extends core.Base {
    /**
      Function that returns the specified sketch line using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchLine | null
    /**
      Returns the number of lines in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a sketch line between the two input points. The input points
      can be either existing SketchPoints or Point3D objects. If a SketchPoint
      is used the new line will be based on that sketch point and update if the
      sketch point is modified.
      @param startPoint The start point of the line. It can be a SketchPoint or Point3D object.
      @param endPoint The end point of the line. It can be a SketchPoint or Point3D object.
      @returns Returns the newly created SketchLine object or null if the creation failed.
    */
    addByTwoPoints(startPoint: core.Base, endPoint: core.Base): SketchLine | null
    /**
      Creates four sketch lines representing a rectangle where the two points are the opposing corners
      of the rectangle. The input points can be either existing SketchPoints or Point3D objects.
      If a SketchPoint is used the new lines will be based on that sketch point and update if the
      sketch point is modified.
      @param pointOne The first corner of the rectangle. It can be a SketchPoint or Point3D object.
      @param pointTwo The second corner of the rectangle. It can be a SketchPoint or Point3D object.
      @returns Returns the four new sketch lines or null if the creation failed.
    */
    addTwoPointRectangle(pointOne: core.Base, pointTwo: core.Base): SketchLineList | null
    /**
      Creates four sketch lines representing a rectangle where the first two points are the base corners
      of the rectangle and the third point defines the height.
      @param pointOne The first corner of the rectangle. It can be a SketchPoint or Point3D object.
      @param pointTwo The first corner of the rectangle. It can be a SketchPoint or Point3D object.
      @param pointThree The first corner of the rectangle. a Point3D object defining the height of the rectangle.
      @returns Returns the four new sketch lines or null if the creation failed.
    */
    addThreePointRectangle(pointOne: core.Base, pointTwo: core.Base, pointThree: core.Point3D): SketchLineList | null
    /**
      Creates four sketch lines representing a rectangle where the first point represents the center of
      the rectangle. The second point is the corner of the rectangle and can be either an existing
      SketchPoint or Point3D object. The four sketch lines are returned.
      @param centerPoint The center point of the rectangle
      @param cornerPoint The corner of the rectangle. It can be a SketchPoint or Point3D object.
      @returns Returns the four new sketch lines or null if the creation failed.
    */
    addCenterPointRectangle(centerPoint: core.Point3D, cornerPoint: core.Base): SketchLineList | null
    /**
      Creates a chamfer between two sketch lines. In the case where the two input lines cross each other creating
      an "X" shape, this results in four quadrants where the chamfer can be placed. The point arguments are used
      to define which of the four quadrants the chamfer should be created in. The two points define which side of
      the two lines should be kept and the other end will be trimmed by the chamfer. The easiest way to use this is
      to use the end points of the lines on the side you want to keep.
      In the case where the lines don't intersect or connect at the end points, there is only one valid quadrant
      for the chamfer so the points are ignored.
      @param firstLine The first line you want to chamfer.
      @param firstLinePoint A point on the first line that is on the side of the intersection with the second line that you want to keep.
      @param secondLine The second line you want to chamfer.
      @param secondLinePoint A point on the second line that is on the side of the intersection with the first line that you want to keep.
      @param distanceOne Defines the distance of the start point of the chamfer line from the intersection point of the two lines along the first line.
      The distance is defined in centimeters.
      @param distanceTwo Defines the distance of the start point of the chamfer line from the intersection point of the two lines along the second line.
      The distance is defined in centimeters.
      @returns Returns the newly created SketchLine object that represents the chamfer or null if the creation failed.
    */
    addDistanceChamfer(firstLine: SketchLine, firstLinePoint: core.Point3D, secondLine: SketchLine, secondLinePoint: core.Point3D, distanceOne: number, distanceTwo: number): SketchLine | null
    /**
      Creates a chamfer between two sketch lines. In the case where the two input lines cross each other creating
      an "X" shape, this results in four quadrants where the chamfer can be placed. The point arguments are used
      to define which of the four quadrants the chamfer should be created in. The two points define which side of
      the two lines should be kept and the other end will be trimmed by the chamfer. The easiest way to use this is
      to use the end points of the lines on the side you want to keep.
      In the case where the lines don't intersect or connect at the end points, there is only one valid quadrant
      for the chamfer so the points are ignored.
      @param firstLine The first line you want to chamfer.
      @param firstLinePoint A point on the first line that is on the side of the intersection with the second line that you want to keep.
      @param secondLine The second line you want to chamfer.
      @param secondLinePoint A point on the second line that is on the side of the intersection with the first line that you want to keep.
      @param distance Defines the distance of the start point of the chamfer from the intersection point of the two lines along the first line.
      The distance is defined in centimeters.
      @param angle Defines the angle of the chamfer as measured from the first line.
      The angle is defined in radians.
      @returns Returns the newly created SketchLine object that represents the chamfer or null if the creation failed.
    */
    addAngleChamfer(firstLine: SketchLine, firstLinePoint: core.Point3D, secondLine: SketchLine, secondLinePoint: core.Point3D, distance: number, angle: number): SketchLine | null
    /**
      Creates either an inscribed or circumscribed n-sided polygon.
      @param centerPoint Either an existing SketchPoint or a Point3D object that defines the center point of the polygon. If a SketchPoint object
      is provided the point will continue to control the center of the polygon.
      @param edgeCount The number of edges in the resulting polygon.
      @param angle Controls the rotation of the polygon around the center point. For a circumscribed polygon, this defines where the center
      of one of the edges will be positioned. For an inscribed polygon, this defines where one of the corners of the polygon
      will be positioned.
      @param radius The radius of the circle in centimeters that the polygon goes to, either outside (circumscribed) or inside (inscribed) the circle.
      @param isInscribed Specifies if a circumscribed or inscribed polygon should be created.
      @returns Returns a list of the sketch lines that were created to represent the polygon or null in the case of bad input.
    */
    addScribedPolygon(centerPoint: core.Base, edgeCount: number /*int*/, angle: number, radius: number, isInscribed: boolean): SketchLineList | null
    /**
      Creates a polygon where two points specify an edge of the polygon. By specifying an edge, the size and position of
      the polygon is also defined.
      @param pointOne The first point of the edge.
      @param pointTwo The second point of the edge.
      @param isRight After defining points one and two, a polygon can be created on either side of the line defined by the two points.
      This argument specifies which side of the line the polygon will be created on. If this is true, the polygon will
      be created to the right of the line from the perspective of looking from point one to point two. If false,
      it will be to the left of the line.
      @param edgeCount The number of edges in the resulting polygon.
      @returns Returns a list of the sketch lines that were created to represent the polygon or null in the case of bad input.
    */
    addEdgePolygon(pointOne: core.Base, pointTwo: core.Base, isRight: boolean, edgeCount: number /*int*/): SketchLineList | null
  }

  /**
    A line in a sketch.
  */
  abstract class SketchLine extends SketchCurve {
    /**
      The sketch point at the start of the line. The line is dependent on this point and moving the
      point will cause the line to adjust.
    */
    readonly startSketchPoint: SketchPoint
    /**
      The sketch point at the end of the line. The line is dependent on this point and moving the
      point will cause the line to adjust.
    */
    readonly endSketchPoint: SketchPoint
    /**
      Returns the transient geometry of the line which provides geometry
      information about the line. The returned geometry is always in sketch space.
    */
    readonly geometry: core.Line3D
    /**
      Returns a Line3D object which provides geometric information in world space.
      The returned geometry takes into account the assembly context and the position of the
      sketch in it's parent component, which means the geometry will be returned in the root
      component space.
    */
    readonly worldGeometry: core.Line3D
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchLine
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchLine | null
    /**
      Gets and sets whether this line is defined as a centerline.
    */
    isCenterLine: boolean
  }

  /**
    A list of sketch lines.
  */
  abstract class SketchLineList extends core.Base {
    /**
      Function that returns the specified sketch line using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchLine | null
    /**
      Returns the number of sketch lines in the list.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The collection of arcs in a sketch. This provides access to the existing
    arcs and supports the methods to create new arcs.
  */
  abstract class SketchArcs extends core.Base {
    /**
      Function that returns the specified sketch arc using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchArc | null
    /**
      Returns the number of arcs in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a sketch arc that is always parallel to the x-y plane of the sketch
      and is centered at the specified point.
      @remarks
      Sketch arcs always exist in a counterclockwise direction. Even though you can specify a
      negative sweep to define an arc in a clockwise direction, the result will still be a
      counterclockwise arc. This means if you query the created sketch arc, the start and end
      points may be opposite of what you expect.
      @param centerPoint The center point of the arc. This can be either an existing SketchPoint or a Point3D object.
      @param startPoint The start point of the arc. The distance between this point and the center defines the radius
      of the arc. This can be either an existing SketchPoint or a Point3D object.
      @param sweepAngle The sweep of the arc. This is defined in radians and a positive value defines a counter-clockwise sweep.
      @returns Returns the newly created SketchArc object or null if the creation failed.
    */
    addByCenterStartSweep(centerPoint: core.Base, startPoint: core.Base, sweepAngle: number): SketchArc | null
    /**
      Creates a sketch arc that passes through the three points.
      @remarks
      Sketch arcs always exist in a counterclockwise direction. Even though you can provide three
      that define an arc that will have a clockwise direction, the result will still be a
      counterclockwise arc. This means if you query the created sketch arc, the start and end
      points may be opposite of what you expect.
      @param startPoint The start point of the arc. This can be either an existing SketchPoint or a Point3D object.
      @param point A point along the arc. This is a Point3D object.
      @param endPoint The end point of the arc. This can be either an existing SketchPoint or a Point3D object.
      @returns Returns the newly created SketchArc or null in the case of a failure.
    */
    addByThreePoints(startPoint: core.Base, point: core.Point3D, endPoint: core.Base): SketchArc | null
    /**
      Creates a fillet between two sketch entities
      The side (quadrant) the fillet is created on is determined by the points specified.
      The point for each entity can be its startSketchPoint or endSketchPoint
      @param firstEntity The first curve for the fillet definition. The curve must be open.
      @param firstEntityPoint A point on or closer to one end of the first curve that indicates the side to create the fillet on
      @param secondEnitity The second curve for the fillet definition. The curve must be open.
      @param secondEntityPoint A point on or closer to one end of the second curve that indicates the side to create the fillet on
      @param radius radius of the arc in centimeters
      @returns Returns the newly created SketchArc object (fillet) if the operation was successful or null if it failed.
    */
    addFillet(firstEntity: SketchCurve, firstEntityPoint: core.Point3D, secondEnitity: SketchCurve, secondEntityPoint: core.Point3D, radius: number): SketchArc | null
    /**
      Creates a sketch arc that is centered at the specified point and between the two input points.
      @remarks
      Sketch arcs always exist in a counterclockwise direction. Even though you can provide the start and
      end points that define an arc that will have a clockwise direction, the result will still be a
      counterclockwise arc. This means if you query the created sketch arc, the start and end
      points may be opposite of what you expect.
      @param centerPoint The center point of the arc. This can be either an existing SketchPoint or a Point3D object.
      @param startPoint The start point of the arc. This can be either an existing SketchPoint or a Point3D object.
      @param endPoint The end point of the arc. This can be either an existing SketchPoint or a Point3D object.
      If the end point does not lie on the arc, a new point would be created such that it lies on the arc.
      @param normal An optional argument that specifies the normal of the plane the arc will be created on. If not supplied, a vector
      in the positive Z direction will be used, which results in the creation of an arc that is parallel to the X-Y plane of the sketch.
      However, you can specify a normal vector to orient the arc in any orientation. The normal also helps to control the sweep direction of the arc,
      where the sweep direction is always counterclockwise from the start to the end point, where counterclockwise is defined using
      the right-hand rule around the normal vector.
      @returns Returns the newly created SketchArc or null in the case of a failure.
    */
    addByCenterStartEnd(centerPoint: core.Base, startPoint: core.Base, endPoint: core.Base, normal?: core.Vector3D/* = null*/): SketchArc | null
  }

  /**
    An arc in a sketch.
  */
  abstract class SketchArc extends SketchCurve {
    /**
      The sketch point at the center of the arc. The arc is dependent on this point and moving the
      point will cause the arc to adjust.
    */
    readonly centerSketchPoint: SketchPoint
    /**
      The sketch point at the start of the arc. The arc is dependent on this point and moving the
      point will cause the arc to adjust.
      @remarks
      Sketch arcs always exist in a counterclockwise direction. If you created the sketch arc that
      would define a clockwise arc, the created sketch arc will be counterclockwise which means
      the start and end points may be opposite of what you expect.
    */
    readonly startSketchPoint: SketchPoint
    /**
      The sketch point at the end of the arc. The arc is dependent on this point and moving the
      point will cause the arc to adjust.
      @remarks
      Sketch arcs always exist in a counterclockwise direction. If you created the sketch arc that
      would define a clockwise arc, the created sketch arc will be counterclockwise which means
      the start and end points may be opposite of what you expect.
    */
    readonly endSketchPoint: SketchPoint
    /**
      Gets and sets the radius of the arc. Changing the radius is limited
      by any constraints that might exist on the circle. Setting the radius
      can fail in cases where the radius is fully defined through constraints.
    */
    radius: number
    /**
      Returns the transient geometry of the arc which provides geometric
      information about the arc. The returned geometry is always in sketch space.
    */
    readonly geometry: core.Arc3D
    /**
      Returns an Arc3D object which provides geometric information in world space.
      The returned geometry takes into account the assembly context and the position of the
      sketch in it's parent component, which means the geometry will be returned in the root
      component space.
    */
    readonly worldGeometry: core.Arc3D
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchArc
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchArc | null
  }

  /**
    The collection of ellipses in a sketch. This provides access to the existing
    ellipses and supports the methods to create new ellipses.
  */
  abstract class SketchEllipses extends core.Base {
    /**
      Function that returns the specified sketch ellipse using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchEllipse | null
    /**
      Returns the number of ellipses in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a sketch ellipse using the center point, a point defining the major axis
      and a third point anywhere along the ellipse. The created ellipse is parallel to the
      x-y plane of the sketch.
      @param centerPoint The center point of the ellipse. This can be either an existing SketchPoint or a Point3D object.
      @param majorAxisPoint A point3D object that defines both the major axis direction and major axis radius.
      @param point A point3D object that the ellipse will pass through.
      @returns Returns the newly created SketchEllipse object if the creation was successful or null if it failed.
    */
    add(centerPoint: core.Base, majorAxisPoint: core.Point3D, point: core.Point3D): SketchEllipse | null
  }

  /**
    An ellipse in a sketch.
  */
  abstract class SketchEllipse extends SketchCurve {
    /**
      Returns the sketch point that defines the center of the ellipse. You can
      reposition the ellipse by moving the sketch point, assuming any existing
      constraints allow the desired change.
    */
    readonly centerSketchPoint: SketchPoint
    /**
      Gets and sets the major axis direction of the ellipse. Changing the axis is
      limited by any constraints that might exist on the ellipse. Setting the axis
      can fail in cases where the direction is fully defined through constraints.
    */
    majorAxis: core.Vector3D
    /**
      Gets and sets the major axis radius of the ellipse. Changing the radius is
      limited by any constraints that might exist on the ellipse. Setting the radius
      can fail in cases where the radius is fully defined through constraints.
    */
    majorAxisRadius: number
    /**
      Gets and sets the minor axis radius of the ellipse. Changing the radius is
      limited by any constraints that might exist on the ellipse. Setting the radius
      can fail in cases where the radius is fully defined through constraints.
    */
    minorAxisRadius: number
    /**
      Returns the transient geometry of the ellipse which provides geometric
      information about the ellipse. The returned geometry is always in sketch space.
    */
    readonly geometry: core.Ellipse3D
    /**
      Returns an Ellipse3D object which provides geometric information in world space.
      The returned geometry takes into account the assembly context and the position of the
      sketch in it's parent component, which means the geometry will be returned in the root
      component space.
    */
    readonly worldGeometry: core.Ellipse3D
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchEllipse
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchEllipse | null
    /**
      Returns the sketch line associated with the ellipse that lies along the major axis.
      This can return null in the case where the line has been deleted.
    */
    readonly majorAxisLine: SketchLine
    /**
      Returns the sketch line associated with the ellipse that lies along the minor axis.
      This can return null in the case where the line has been deleted.
    */
    readonly minorAxisLine: SketchLine
  }

  /**
    The collection of elliptical arcs in a sketch. This provides access to the existing
    elliptical arcs and supports the methods to create new elliptical arcs.
  */
  abstract class SketchEllipticalArcs extends core.Base {
    /**
      Function that returns the specified sketch elliptical arc using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchEllipticalArc | null
    /**
      Returns the number of elliptical arcs in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates an elliptical sketch arc where the sweep of the arc is defined by the start and sweep angles.
      @param centerPoint The center point of the ellipse. This can be either an existing SketchPoint or a Point3D object.
      @param majorAxis The direction of the major axis. The magnitude of this vector defines the major radius.
      @param minorAxis The direction of the minor axis. The magnitude of this vector defines the minor radius.
      This vector should be perpendicular to the major axis.
      @param startAngle The start angle of the elliptical arc in radians, where 0 is along the major axis.
      @param sweepAngle The sweep angle of the elliptical arc in radians, where a positive value is counterclockwise.
      @returns Returns the newly created SketchEllipticalArc or null if the creation failed.
    */
    addByAngle(centerPoint: core.Base, majorAxis: core.Vector3D, minorAxis: core.Vector3D, startAngle: number, sweepAngle: number): SketchEllipticalArc | null
    /**
      Creates an elliptical sketch arc where the sweep of the arc is defined by two points.
      @param centerPoint The center point of the ellipse. This can be either an existing SketchPoint or a Point3D object.
      @param majorAxis The direction of the major axis. The magnitude of this vector defines the major radius.
      @param minorAxis The direction of the minor axis. The magnitude of this vector defines the minor radius.
      This vector should be perpendicular to the major axis.
      @param startPoint The start point of the elliptical arc. This can be either an existing SketchPoint or a Point3D object.
      The point should lie on the defined ellipse.
      @param endPoint The end point of the elliptical arc. This can be either an existing SketchPoint or a Point3D object.
      The point should lie on the defined ellipse and the elliptical arc is defined by a counterclockwise
      sweep from the start point to the end point.
      @returns Returns the newly created SketchEllipticalArc or null if the creation failed.
    */
    addByEndPoints(centerPoint: core.Base, majorAxis: core.Vector3D, minorAxis: core.Vector3D, startPoint: core.Base, endPoint: core.Base): SketchEllipticalArc | null
  }

  /**
    An elliptical arc in a sketch.
  */
  abstract class SketchEllipticalArc extends SketchCurve {
    /**
      Gets the sketch point that defines the center of the elliptical arc. You can
      reposition the elliptical arc by moving the sketch point, assuming any existing
      constraints allow the desired change.
    */
    readonly centerSketchPoint: SketchPoint
    /**
      Gets the sketch point that defines the start of the elliptical arc. You can
      reposition the sketch point, assuming any existing constraints allow the
      desired change.
    */
    readonly startSketchPoint: SketchPoint
    /**
      Gets the sketch point that defines the end of the elliptical arc. You can
      reposition the sketch point, assuming any existing constraints allow the
      desired change.
    */
    readonly endSketchPoint: SketchPoint
    /**
      Gets and sets the major axis direction of the elliptical arc. Changing the axis is
      limited by any constraints that might exist on the elliptical arc. Setting the axis
      can fail in cases where the direction is fully defined through constraints.
    */
    majorAxis: core.Vector3D
    /**
      Gets and sets the major axis radius of the elliptical arc. Changing the radius is
      limited by any constraints that might exist on the elliptical arc. Setting the radius
      can fail in cases where the radius is fully defined through constraints.
    */
    majorAxisRadius: number
    /**
      Gets and sets the minor axis radius of the elliptical arc. Changing the radius is
      limited by any constraints that might exist on the elliptical arc. Setting the radius
      can fail in cases where the radius is fully defined through constraints.
    */
    minorAxisRadius: number
    /**
      Returns the transient geometry of the elliptical arc which provides geometric
      information about the elliptical arc. The returned geometry is always in sketch space.
    */
    readonly geometry: core.EllipticalArc3D
    /**
      Returns an EllipticalArc3D object which provides geometric information in world space.
      The returned geometry takes into account the assembly context and the position of the
      sketch in it's parent component, which means the geometry will be returned in the root
      component space.
    */
    readonly worldGeometry: core.EllipticalArc3D
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchEllipticalArc
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchEllipticalArc | null
  }

  /**
    The collection of fitted splines in a sketch. This provides access to the existing
    fitted splines and supports the methods to create new fitted splines.
  */
  abstract class SketchFittedSplines extends core.Base {
    /**
      Function that returns the specified sketch fitted spline using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchFittedSpline | null
    /**
      Returns the number of fitted splines in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new fitted spline through the specified points.
      @param fitPoints A collection of points that the curve will fit through. They
      can be any combination of existing SketchPoint or Point3D objects.
      @returns Returns the newly created SketchFittedSpline object if the creation was successful or null if it failed.
    */
    add(fitPoints: core.ObjectCollection): SketchFittedSpline | null
    /**
      Creates a new fitted spline using the input NurbsCurve3D to define the shape. Fit points are created
      to create a curve that exactly matches the input curve.
      @remarks
      This method has been retired and replaced by the addByNurbsCurve method on the SketchFixedSplines collection.
      Using this method creates a curve that can have unreliable behavior if it is edited in any way. The new method
      will create a stable curve and also supports the ability to modify it by providing a new NURBS curve definition.
      @param nurbsCurve A NurbsCurve3D object that defines a valid NURBS curve.
      @returns Returns the newly created SketchFittedSpline object if the creation was successful or null if it failed.
      @deprecated
    */
    addByNurbsCurve(nurbsCurve: core.NurbsCurve3D): SketchFittedSpline | null
  }

  /**
    A fitted spline in a sketch.
  */
  abstract class SketchFittedSpline extends SketchCurve {
    /**
      Returns the sketch point that defines the starting position
      of the spline. Editing the position of this sketch point
      will result in editing the spline.
    */
    readonly startSketchPoint: SketchPoint
    /**
      Returns the sketch point that defines the ending position
      of the spline. Editing the position of this sketch point
      will result in editing the spline.
    */
    readonly endSketchPoint: SketchPoint
    /**
      Returns the set of sketch points that the spline fits through.
      The points include the start and end points and are returned in
      the same order as the spline fits through them where the first point
      in the list is the start point and the last point is the end point.
      Editing the position of these sketch points will result in
      editing the spline.
    */
    readonly fitPoints: SketchPointList
    /**
      Gets and sets if this spline is closed. A closed spline
      is also periodic. This property can return false even in
      the case where the spline is physically closed. It's possible
      that the start and end points of a spline can be the same point
      but the curve is still not considered closed. This can happen
      when the start and end points of an open curve are merged. The
      curve is physically closed but is not periodic and can have a
      discontinuity at the joint. Setting it to closed will cause it
      to be periodic and to always remain closed even as fit points
      are deleted.
    */
    isClosed: boolean
    /**
      Returns the transient geometry of the curve which provides geometric
      information about the curve. The returned geometry is always in sketch space.
    */
    readonly geometry: core.NurbsCurve3D
    /**
      Returns an NurbsCurve3D object which provides geometric information in world space.
      The returned geometry takes into account the assembly context and the position of the
      sketch in it's parent component, which means the geometry will be returned in the root
      component space.
    */
    readonly worldGeometry: core.NurbsCurve3D
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchFittedSpline
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchFittedSpline | null
    /**
      Activates the tangent handle for the specified fit point and returns the sketch line
      that acts as the handle to control the tangency. You can use the getTangentHandle
      property to determine if the tangent handle has already been activated. If this method
      is called for a handle that already exists, nothing changes and the existing sketch line
      that acts as the tangent handle is returned.
      The getTangentHandle method can be used to determine if the handle has already been
      activated.
      To deactivate a sketch handle you can delete the sketch line.
      @param fitPoint The fit point on the curve where you want to activate the tangent handle.
      The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object.
      @returns Returns the sketch line that acts as the tangent handle at the specified fit point.
    */
    activateTangentHandle(fitPoint: SketchPoint): SketchLine
    /**
      Returns the sketch line that acts as the handle to control the tangency at the specified fit
      point. Returns null in the case where the tangent handle has not been activated at that sketch point.
      Deleting the returned line will deactivate the tangent handle. Use the activateTangentHandle method
      to activate the tangent handle.
      @param fitPoint The fit point on the curve where you want to get the tangent handle.
      The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object.
      @returns Returns the sketch line that acts as the handle to control the tangency at the specified point or
      returns null in the case where the tangency handle has not been activated at the specified sketch point.
    */
    getTangentHandle(fitPoint: SketchPoint): SketchLine | null
    /**
      Activates the curvature handle for the specified fit point and returns the sketch arc
      that acts as the handle to control the curvature. You can use the getCurvatureHandle
      property to determine if the curvature handle has already been activated. If this method
      is called for a handle that already exists, nothing changes and the existing sketch arc
      that acts as the curvature handle is returned.
      The getCurvatureHandle method can be used to determine if the handle has already been
      activated.
      To deactivate a sketch handle you can delete the sketch arc.
      @param fitPoint The fit point on the curve where you want to activate the curvature handle.
      The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object.
      @returns Returns the sketch arc that acts as the curvature handle at the specified fit point.
    */
    activateCurvatureHandle(fitPoint: SketchPoint): SketchArc
    /**
      Returns the sketch arc that acts as the handle to control the curvature at the specified fit
      point. Returns null in the case where the curvature handle has not been activated at that sketch point.
      Deleting the returned arc will deactivate the curvature handle. Use the activateCurvatureHandle method
      to activate the curvature handle.
      @param fitPoint The fit point on the curve where you want to get the curvature handle.
      The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object.
      @returns Returns the sketch arc that acts as the handle to control the curvature at the specified point or
      returns null in the case where the curvature handle has not been activated at the specified sketch point.
    */
    getCurvatureHandle(fitPoint: SketchPoint): SketchArc | null
    /**
      Creates a new fit point at the specified parameter value.
      @param parameter The parameter value at the position along the curve where you want to add the new fit point. The
      CurveEvaluator3D object provides utilities that support going from a 3D coordinate to a parameter
      value on the curve.
      @returns Returns the newly created SketchPoint that acts as the fit point. Fails in the case where an invalid
      parameter is specified.
    */
    addFitPoint(parameter: number): SketchPoint
  }

  /**
    The collection of fixed splines in a sketch. Fixed splines are splines that were created
    as the result of some operation (i.e. intersection) and is not directly editable.
  */
  abstract class SketchFixedSplines extends core.Base {
    /**
      Function that returns the specified sketch fixed spline using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchFixedSpline | null
    /**
      Returns the number of fitted splines in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new fixed spline using the input NurbsCurve3D to define the shape. The resulting curve
      is not editable by the user but can be updated via the API using the replaceGeometry method on the
      SketchFixedSpline object.
      @param nurbsCurve A NurbsCurve3D object that defines a valid NURBS curve.
      @returns Returns the newly created SketchFixedSpline object if the creation was successful or null if it failed.
    */
    addByNurbsCurve(nurbsCurve: core.NurbsCurve3D): SketchFixedSpline | null
  }

  /**
    The SketchFixedSpline class represents splines in a sketch that are
    not editable. These can result from including splines from other sketches
    or the spline edges. They can also be created by intersections and
    projecting splines onto a sketch.
  */
  abstract class SketchFixedSpline extends SketchCurve {
    /**
      The sketch point at the start of the spline.
    */
    readonly startSketchPoint: SketchPoint
    /**
      The sketch point at the end of the spline.
    */
    readonly endSketchPoint: SketchPoint
    /**
      Returns the transient geometry of the curve which provides geometric
      information about the curve. The returned geometry is always in sketch space.
      Because the fixed spline can be analytically defined, for example it
      can be the precise intersection of a surface and the sketch plane,
      returning a NURBS curve that represents the spline may be an
      approximation of the actual curve. You can use the Evaluator
      property of the SketchFixedSpline object to perform evaluations
      on the precise curve.
    */
    readonly geometry: core.NurbsCurve3D
    /**
      Returns a NurbsCurve3D object that is the equivalent of this sketch curve
      but is in the space of the parent component rather than in sketch space.
    */
    readonly worldGeometry: core.NurbsCurve3D
    /**
      Returns an evaluator object that lets you perform evaluations
      on the precise geometry of the curve.
    */
    readonly evaluator: core.CurveEvaluator3D
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchFixedSpline
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchFixedSpline | null
    /**
      Replaces the underlying NURBS curve that defines the shape of the fixed curve. This
      can only be used if the isNative property of the SketchFixedSpline returns false.
      @param nurbsCurve A NurbsCurve3D object that defines a valid NURBS curve and will be used to replace
      the existing geometry definition.
      @returns Returns true if the replacement was successful.
    */
    replaceGeometry(nurbsCurve: core.NurbsCurve3D): boolean
  }

  /**
    The collection of control point splines in a sketch.
  */
  abstract class SketchControlPointSplines extends core.Base {
    /**
      Function that returns the specified sketch control point spline using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchControlPointSpline | null
    /**
      Returns the number of control point splines in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new control point spline.
      @param controlPoints An array of points that define the control points of the curve's polygon. They
      can be any combination of existing SketchPoint or Point3D objects.
      @param degree Specifies the degree of the spline. Only degree 3 and degree 5 can be specified while creating the spline.
      @returns Returns the newly created SketchControlPointSpline object if the creation was successful or null if it failed.
    */
    add(controlPoints: core.Base[], degree: SplineDegrees): SketchControlPointSpline | null
  }

  /**
    Defines the options used when specifying the degree of a spline.
  */
  const enum SplineDegrees {
    /**
      Defines a degree 1 spline.
    */
    SplineDegreeOne = 1,
    /**
      Defines a degree 2 spline.
    */
    SplineDegreeTwo = 2,
    /**
      Defines a degree 3 spline.
    */
    SplineDegreeThree = 3,
    /**
      Defines a degree 4 spline.
    */
    SplineDegreeFour = 4,
    /**
      Defines a degree 5 spline.
    */
    SplineDegreeFive = 5,
    /**
      Defines a degree 6 spline.
    */
    SplineDegreeSix = 6,
    /**
      Defines a degree 7 spline.
    */
    SplineDegreeSeven = 7,
    /**
      Defines a degree 8 spline.
    */
    SplineDegreeEight = 8,
    /**
      Defines a degree 9 spline.
    */
    SplineDegreeNine = 9,
  }

  /**
    A control point spline in a sketch.
  */
  abstract class SketchControlPointSpline extends SketchCurve {
    /**
      The sketch point at the start of the spline. If the curve is closed the start and end
      sketch points will be the same.
    */
    readonly startSketchPoint: SketchPoint
    /**
      The sketch point at the end of the spline. If the curve is closed the start and end
      sketch points will be the same.
    */
    readonly endSketchPoint: SketchPoint
    /**
      Returns the set of sketch points that the control frame of the spline fits through.
      The points include the start and end points and are returned in
      the same order as the spline fits through them where the first point
      in the list is the start point and the last point is the end point.
      Editing the position of these sketch points will result in editing the spline.
      Deleting one of the sketch points will remove that point from the control frame and
      the curve will be recomputed.
      @remarks
      There are cases, like when a curve is offset, where a control point spline is created
      but the control frame is not displayed and the curve is not editable. You can check
      for this case by checking the value of the isControlFrameDisplayed property. If it is
      true, this property will return an empty array of control points since they do not
      currently exist.
    */
    readonly controlPoints: SketchPoint[]
    /**
      Adds an additional control point to the control point spline. Inserting a new control
      point does not change the shape of the curve, but the control frame will be re-computed
      and the control points will be adjusted to maintain the current shape.
      This method will fail in the case where the control frame is not displayed. You can
      check for this by using the is isControlFrameDisplayed.
      @param parameter The parameter position that defines where to insert the new control point. The parameter
      value must be within the parametric range of the curve. This can be determined by using the
      getParameterExtents method of the CurveEvaluator3D returned by the evaluator property.
      @returns Returns true if adding the control point was successful.
    */
    addControlPoint(parameter: number): boolean
    /**
      Returns the transient geometry of the curve which provides geometric
      information about the curve. The returned geometry is always in sketch space.
      Use the worldGeometry property to get it in the model's design space.
    */
    readonly geometry: core.NurbsCurve3D
    /**
      Returns a NurbsCurve3D object that is the equivalent of this sketch curve
      but is in the space of the parent component rather than in sketch space.
    */
    readonly worldGeometry: core.NurbsCurve3D
    /**
      Returns an evaluator object that lets you perform evaluations
      on the precise geometry of the curve.
    */
    readonly evaluator: core.CurveEvaluator3D
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchControlPointSpline
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchControlPointSpline | null
    /**
      Gets and sets the degree of the spline.
    */
    degree: SplineDegrees
    /**
      Gets and sets if the control frame of the curve is currently displayed. Using this property
      is useful to be able to determine if the controlPoints and controlFrameLines properties will return
      useful information or not and if the addControlPoint method will succeed or not.
      @remarks
      There are cases where Fusion creates a control point spline but does not display the control
      frame. An example is when you create an offset of a spline.
      If the value of the property is false, you can set it to true to cause the control frame
      to be displayed. If the curve is being controlled by any existing constraints, setting this
      property to true will fail. For example, if the curve is the result of an offset and the offset
      constraint still exists, you cannot turn on the control frame. However, if you first delete
      the constrains so the curve is now independent you can set this property to true and display
      the control frame.
      Setting this property to false will always fail. Turning off the display of the control frame
      is not supported by Fusion.
    */
    isControlFrameDisplayed: boolean
    /**
      Returns the sketch lines that represent the control frame of the spline.
      The lines are in sequential order starting with the line that connects to the
      starting control point to the end.
      @remarks
      There are cases, like when a curve is offset, where a control point spline is created
      but the control frame is not displayed and the curve is not editable. You can check
      for this case by checking the value of the isControlFrameDisplayed property. If it is
      true, this property will return an empty array of sketch lines since they do not
      currently exist.
    */
    readonly controlFrameLines: SketchLine[]
  }

  /**
    The collection of conic curves in a sketch. This provides access to the existing
    conic curves and supports the method to create new conic curves.
  */
  abstract class SketchConicCurves extends core.Base {
    /**
      Function that returns the specified conic curve using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchConicCurve | null
    /**
      Returns the number of conic curves in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new conic curve.
      @param startPoint The start point of the conic curve. This can be either an existing SketchPoint or a Point3D object.
      @param endPoint The end point of the conic curve. This can be either an existing SketchPoint or a Point3D object.
      @param apexPoint The apex point of the conic curve. This can be either an existing SketchPoint or a Point3D object.
      @param rhoValue Double that specifies the rho value for the conic. This value must be greater than zero and less
      than one.
      @returns Returns the new conic curve or null if the creation failed.
    */
    add(startPoint: core.Base, endPoint: core.Base, apexPoint: core.Base, rhoValue: number): SketchConicCurve | null
  }

  /**
    The SketchConicCurve class represents conic curves in a sketch.
  */
  abstract class SketchConicCurve extends SketchCurve {
    /**
      The sketch point at the start of the curve.
    */
    readonly startSketchPoint: SketchPoint
    /**
      The sketch point at the end of the curve.
    */
    readonly endSketchPoint: SketchPoint
    /**
      The sketch point at the apex of the conic curve.
    */
    readonly apexSketchPoint: SketchPoint
    /**
      Returns the transient geometry of the curve which provides geometric
      information about the curve. The returned geometry is always in sketch space.
      Because the fixed spline can be analytically defined, for example it
      can be the precise intersection of a surface and the sketch plane,
      returning a NURBS curve that represents the spline may be an
      approximation of the actual curve. You can use the Evaluator
      property of the SketchFixedSpline object to perform evaluations
      on the precise curve.
    */
    readonly geometry: core.NurbsCurve3D
    /**
      Returns a NurbsCurve3D object that is the equivalent of this sketch curve
      but is in the space of the parent component rather than in sketch space.
    */
    readonly worldGeometry: core.NurbsCurve3D
    /**
      Returns an evaluator object that lets you perform evaluations
      on the precise geometry of the curve.
    */
    readonly evaluator: core.CurveEvaluator3D
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchConicCurve
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchConicCurve | null
    /**
      Get and sets the rho value for the curve. The value must be greater than
      zero and less than one.
    */
    rhoValue: number
  }

  /**
    The collection of text blocks in a sketch. This provides access to the existing
    text blocks and supports creating new text blocks.
  */
  abstract class SketchTexts extends core.Base {
    /**
      Function that returns the specified sketch text using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchText | null
    /**
      Returns the number of texts in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a SketchTextInput object that can be used to define additional settings when creating sketch text. The
      SketchTextInput object is equivalent to the Sketch Text dialog in that it collects all of the input required
      to create sketch text. Once the properties of the SketchTextInput object have been defined, use the add method
      to create the sketch text.
      @remarks
      This method has been retired and is replaced by the createInput2 method, which supports defining
      multi-line text and text along a curve.
      @param formattedText The text used for the sketch text. This is a simple string as no additional formatting is currently supported.
      @param height The height of the text in centimeters.
      @param position The position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
      of the point is ignored and always treated as zero.
      @returns Returns a SketchTextInput object that can be used to set additional formatting and is used as input to the add method.
      @deprecated
    */
    createInput(formattedText: string, height: number, position: core.Point3D): SketchTextInput
    /**
      Creates a sketch text.
      @param input A SketchTextInput object created using the SketchTexts.createInput method.
      @returns Returns the newly created SketchText object or null in the case of failure.
    */
    add(input: SketchTextInput): SketchText | null
    /**
      Creates a SketchTextInput object that is used to define the additional input to create text. The SketchTextInput
      object is equivalent to the Sketch Text dialog in that it collects all of the input required to create sketch text.
      You must call setAsFitOnPath, setAsAlongPath, or setAsMultiLine methods to define one of the three types of text and
      can use other and define any
      setAs Once the properties of the SketchTextInput object have been defined, use the add method
      to create the sketch text.
      @param formattedText The text used for the sketch text. This is a simple string as no additional formatting is currently supported.
      @param height The height of the text in centimeters.
      @returns Returns a SketchTextInput object that can be used to set additional formatting and is used as input to the add method.
    */
    createInput2(formattedText: string, height: number): SketchTextInput
  }

  /**
    The SketchTextInput object is equivalent to the Sketch Text dialog in that it collects all of the input required
    to create sketch text. Once the properties of the SketchTextInput object have been defined, use the add method
    to create the sketch text. A SketchTextInput object is created by using the createInput of the SketchTexts object.
  */
  abstract class SketchTextInput extends core.Base {
    /**
      Gets and sets the height of the text in centimeters.
    */
    height: number
    /**
      Gets and sets the text.
    */
    text: string
    /**
      Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
      of the point is ignored and always treated as zero.
      @remarks
      This method has been retired. The closest equivalent is when creating multi-line text. The setAsMultiLine has a cornerPoint
      argument that lets you define the position of the text. For text along a curve, the curve defines its positions.
      @deprecated
    */
    position: core.Point3D
    /**
      Gets and sets the name of the font to use.
    */
    fontName: string
    /**
      Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch.
      @remarks
      This property was retired when Fusion added support for sketch along a curve, where defining a
      rotation angle doesn't make sense. When creating multi-line text you can use the Sketch.move command
      to rotate and/or move the four lines defining the bounding rectangle of the text.
      @deprecated
    */
    angle: number
    /**
      Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles
      can be combined to apply multiple styles. For example you can apply bold and italic.
    */
    textStyle: TextStyles
    /**
      Gets and sets if the text is flipped horizontally.
    */
    isHorizontalFlip: boolean
    /**
      Gets and sets if the text is flipped vertically.
    */
    isVerticalFlip: boolean
    /**
      Sets this SketchTextInput to define text that fits along a specified path. Fitting on a path will
      space the characters so the text fits along the entire length of the path entity.
      @param path The entity that defines the path for the text. This can be a SketchCurve or BRepEdge object.
      @param isAbovePath Indicates if the text should be positioned above or below the path entity.
      @returns Returns true if the setting the definition was successful.
    */
    setAsFitOnPath(path: adsk.core.Base, isAbovePath: boolean): boolean
    /**
      Sets this SketchTextInput to define text that follows along a specified path.
      @param path The entity that defines the path for the text. This can be a SketchCurve or BRepEdge object.
      @param isAbovePath Indicates if the text should be positioned above or below the path entity.
      @param horizontalAlignment Specifies the horizontal alignment of the text with respect to the path curve.
      @param characterSpacing The percentage change in default spacing between characters.
      @returns Returns true if the setting the definition was successful.
    */
    setAsAlongPath(path: adsk.core.Base, isAbovePath: boolean, horizontalAlignment: adsk.core.HorizontalAlignments, characterSpacing: number): boolean
    /**
      Defines the first corner point of the rectangle that will contain the text.
      @param cornerPoint Specifies the location of one of the corner points of the rectangle that will contain the text.
      This can be a Point3D object, with a Z component of zero, to define any arbitrary location on the X-Y
      plane of the sketch or it can be an existing SketchPoint that lies on the sketch X-Y plane.
      @param diagonalPoint Specifies the location of the diagonal point of the rectangle that will contain the text. This point
      cannot be aligned vertically or horizontally to the corner point but be a diagonal point to define
      a rectangle. This can be a Point3D object, with a Z component of zero, to define any arbitrary location on the X-Y
      plane of the sketch or it can be an existing SketchPoint that lies on the sketch X-Y plane and the sketch point
      will become the opposing corner point.
      @param horizontalAlignment Specifies the horizontal alignment of the text with respect to the text rectangle.
      @param verticalAlignment Specifies the vertical alignment of the text with respect to the text rectangle.
      @param characterSpacing The spacing between the characters. This is an additional spacing to apply that is defined
      as a percentage of the default spacing. A spacing of 0 indicates no additional spacing.
      A spacing of 50 indicates to use the default plus 50% of the default.
      @returns Returns true if the setting the definition was successful.
    */
    setAsMultiLine(cornerPoint: adsk.core.Base, diagonalPoint: adsk.core.Base, horizontalAlignment: adsk.core.HorizontalAlignments, verticalAlignment: adsk.core.VerticalAlignments, characterSpacing: number): boolean
    /**
      Returns the SketchTextDefinition object associated with this input. When the SketchTextInput is first created this
      property will return null. Once one of the "set" methods have been called, this will return the SketchTextDefinition
      of the appropriate type and can be used to make any additional changes to the text.
    */
    readonly definition: SketchTextDefinition
  }

  /**
    Defines the various text style formatting options that can be applied to text. These are
    bitwise values to they can be combined.
  */
  const enum TextStyles {
    /**
      Specifies that the text has bold text style.
    */
    TextStyleBold = 1,
    /**
      Specifies that the text has italic text style.
    */
    TextStyleItalic = 2,
    /**
      Specifies that the text has underline text style.
      Not currently supported.
    */
    TextStyleUnderline = 4,
  }

  /**
    Text in a sketch.
  */
  abstract class SketchText extends SketchEntity {
    /**
      Gets and sets the height of the text in centimeters.
    */
    height: number
    /**
      Gets and sets the text. This is a simple string and ignores any formatting defined within the text.
    */
    text: string
    /**
      Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
      of the point is ignored and always treated as zero.
      @remarks
      This property has been retired as a result of Fusion adding support for text along a curve. To move text, you
      can use the Sketch.move method.
      @deprecated
    */
    position: core.Point3D
    /**
      Gets and sets the name of the font to use.
    */
    fontName: string
    /**
      Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch.
      @remarks
      This was retired when Fusion added support for sketch along a curve and multi-line text, which
      neither supports getting and setting an angle. For multi-line text you can get the rectangle
      sketch lines that define the boundary of the text and manipulate those to move and rotate the text.
      @deprecated
    */
    angle: number
    /**
      Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles
      can be combined to apply multiple styles. For example you can apply bold and underline.
    */
    textStyle: TextStyles
    /**
      Returns the four sketch lines that define the boundary of the sketch text. By adding constraints to these lines
      you can associatively control the size, position and angle of the sketch text.
      @remarks
      This was retired when Fusion added support for sketch along a curve, which doesn't have the boundary lines.
      This functionality is replaced by the MultiLineTextDefinition.rectangleLines property.
      @deprecated
    */
    readonly boundaryLines: fusion.SketchLineList
    /**
      Explodes the SketchText into a set of curves. The original SketchText is deleted as a result of calling this.
      @returns Returns an array of the sketch curves that were created that represent the text.
    */
    explode(): SketchCurve[]
    /**
      Returns the underlying curves that define the outline of the text. Calling this does not affect the
      SketchText and does not create any new sketch geometry but returns the geometrical definition of the
      sketch outline.
      @returns Returns an array of transient curves that represent the outline of the text.
    */
    asCurves(): core.Curve3D[]
    /**
      Gets and sets if the text is flipped horizontally.
    */
    isHorizontalFlip: boolean
    /**
      Gets and sets if the text is flipped vertically.
    */
    isVerticalFlip: boolean
    /**
      Sets this SketchTextInput to define text that fits along a specified path. Fitting on a path will
      space the characters so the text fits along the entire length of the path entity.
      @param path The entity that defines the path for the text. This can be a SketchCurve or BRepEdge object.
      @param isAbovePath Indicates if the text should be positioned above or below the path entity.
      @returns Returns true if the setting the definition was successful.
    */
    redefineAsFitOnPath(path: adsk.core.Base, isAbovePath: boolean): boolean
    /**
      Sets this SketchTextInput to define text that follows along a specified path.
      @param path The entity that defines the path for the text. This can be a SketchCurve or BRepEdge object.
      @param isAbovePath Indicates if the text should be positioned above or below the path entity.
      @param horizontalAlignment Specifies the horizontal alignment of the text with respect to the path curve.
      @param characterSpacing The spacing between the characters. This is an additional spacing to apply that is defined
      as a percentage of the default spacing. A spacing of 0 indicates no additional spacing.
      A spacing of 50 indicates to use the default plus 50% of the default.
      @returns Returns true if the setting the definition was successful.
    */
    redefineAsAlongPath(path: adsk.core.Base, isAbovePath: boolean, horizontalAlignment: adsk.core.HorizontalAlignments, characterSpacing: number): boolean
    /**
      Gets the definition that is currently used to specify how the sketch text is defined.
    */
    readonly definition: SketchTextDefinition
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchText
    /**
      Creates a proxy object for the SketchText object that represents the SketchText
      object in the context of an assembly. The context is defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchText | null
  }

  /**
    The base class for the classes that define how text can be defined.
  */
  abstract class SketchTextDefinition extends core.Base {
    /**
      Returns the SketchText object this definition is associated with. This property will
      return null in the case the definition object was obtained from a SketchTextInput object
      because the SketchText object does not yet exist.
    */
    readonly parentSketchText: SketchText
  }

  /**
    Defines the information for text that fits along a path.
  */
  abstract class FitOnPathTextDefintion extends SketchTextDefinition {
    /**
      Get and sets the entity that defines the path for the text. This can be a SketchCurve or BRepEdge object.
    */
    path: adsk.core.Base
    /**
      Gets and sets if the text should be positioned above or below the path entity.
    */
    isAbovePath: boolean
  }

  /**
    Defines the information for text that follows along a path.
  */
  abstract class AlongPathTextDefinition extends SketchTextDefinition {
    /**
      Get and sets the entity that defines the path for the text. This can be a SketchCurve or BRepEdge object.
    */
    path: adsk.core.Base
    /**
      Gets and sets if the text should be positioned above or below the path entity.
    */
    isAbovePath: boolean
    /**
      Gets and sets the horizontal alignment of the text with respect to the path curve.
    */
    horizontalAlignment: core.HorizontalAlignments
    /**
      Gets and sets the spacing between the characters. This is an additional spacing to apply
      that is defined as a percentage of the default spacing. A spacing of 0 indicates no
      additional spacing. A spacing of 50 indicates to use the default plus 50% of the default.
    */
    characterSpacing: number
  }

  /**
    Defines the information for multi-line text.
  */
  abstract class MultiLineTextDefinition extends SketchTextDefinition {
    /**
      Returns the four sketch lines that define the boundary of the sketch text. By adding constraints to these lines
      you can associatively control the size, position and angle of the sketch text. If the MultiLineTextDefinition
      object is obtained from a SketchTextInput object, this property will return null because the text and it's
      associated lines have not been created yet.
    */
    readonly rectangleLines: SketchLine[]
    /**
      Gets and sets the horizontal alignment of the text with respect to the text rectangle.
    */
    horizontalAlignment: core.HorizontalAlignments
    /**
      Gets and sets the vertical alignment of the text with respect to the text rectangle.
    */
    verticalAlignment: core.VerticalAlignments
    /**
      Rotates the text box.
      @param angle The angle to rotate the text, specified in radians.
      @param keyPoint The key point the rotation is defined around. This is optional and defaults the center of the text box.
      @returns Returns true if successful.
    */
    rotate(angle: number, keyPoint?: TextBoxKeyPoints/* = TextBoxKeyPoints.MiddleTextBoxKeyPoint*/): boolean
    /**
      Gets and sets the spacing between the characters. This is an additional spacing to apply
      that is defined as a percentage of the default spacing. A spacing of 0 indicates no
      additional spacing. A spacing of 50 indicates to use the default plus 50% of the default.
    */
    characterSpacing: number
  }

  /**
    Defines the nine key points that exist for a sketch text box and
    can be used as the origin when rotating the text. The named positions
    are with respect to the text box. For example when the text box has
    not been rotated the top-left key point will be the point in the upper-left
    corner of the text box. If the text box has been rotated 180 degrees,
    the top-left key point will be the point in the lower-right corner of
    the text box.
  */
  const enum TextBoxKeyPoints {
    /**
      The key point in the upper-left corner of the text box.
    */
    TopLeftTextBoxKeyPoint,
    /**
      The key point at the midpoint of the upper line of the text box.
    */
    TopMiddleTextBoxKeyPoint,
    /**
      The key point in the upper-right corner of the text box.
    */
    TopRightTextBoxKeyPoint,
    /**
      The key point at the midpoint of the left line of the text box.
    */
    MiddleLeftTextBoxKeyPoint,
    /**
      The key point in the center of the text box.
    */
    MiddleTextBoxKeyPoint,
    /**
      The key point at the midpoint of the right line of the text box.
    */
    MiddleRightTextBoxKeyPoint,
    /**
      The key point at the bottom-left corner of the text box.
    */
    BottomLeftTextBoxKeyPoint,
    /**
      The key point at the midpoint of the bottom line of the text box.
    */
    BottomMiddleTextBoxKeyPoint,
    /**
      The key point at the bottom-right corner of the text box.
    */
    BottomRightTextBoxKeyPoint,
  }

  /**
    A collection of all of the geometric constraints in a sketch. This object
    also supports the methods to create new geometric constraints.
  */
  abstract class GeometricConstraints extends core.Base {
    /**
      Function that returns the specified sketch constraint using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): GeometricConstraint | null
    /**
      Returns the number of constraints in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new coincident constraint between two entities. The first argument
      is a sketch point. The second argument is a sketch curve or point.
      @param point The SketchPoint that will be made coincident.
      @param entity The SketchPoint or sketch curve that the point will be made coincident to.
      @returns Returns the newly created CoincidentConstraint object or null if the creation failed.
    */
    addCoincident(point: SketchPoint, entity: SketchEntity): CoincidentConstraint | null
    /**
      Creates a new collinear constraint between two lines.
      @param lineOne The first line to create the constraint on.
      @param lineTwo The second line to create the constraint on.
      @returns Returns the newly created CollinearConstraint object or null if the creation failed.
    */
    addCollinear(lineOne: SketchLine, lineTwo: SketchLine): CollinearConstraint | null
    /**
      Creates a new concentric constraint between two circles, arcs, ellipses, or elliptical arcs.
      @param entityOne The first circle, arc, ellipse or elliptical arc.
      @param entityTwo The second circle, arc, ellipse or elliptical arc.
      @returns Returns the newly created ConcentricConstraint object or null if the creation failed.
    */
    addConcentric(entityOne: SketchCurve, entityTwo: SketchCurve): ConcentricConstraint | null
    /**
      Creates a new midpoint constraint between a point and a curve.
      @param point The point to constrain to the midpoint of a curve.
      @param midPointCurve The curve that defines the midpoint to constraint to.
      @returns Returns the newly created MidPointConstraint object or null if the creation failed.
    */
    addMidPoint(point: SketchPoint, midPointCurve: SketchCurve): MidPointConstraint | null
    /**
      Creates a new parallel constraint between two lines.
      @param lineOne The first SketchLine.
      @param lineTwo The second SketchLine.
      @returns Returns the newly created ParallelConstraint object or null if the creation failed.
    */
    addParallel(lineOne: SketchLine, lineTwo: SketchLine): ParallelConstraint | null
    /**
      Creates a new perpendicular constraint between two lines.
      @param lineOne The first SketchLine.
      @param lineTwo The second SketchLine.
      @returns Returns the newly created PerpendicularConstraint object or null if the creation failed.
    */
    addPerpendicular(lineOne: SketchLine, lineTwo: SketchLine): PerpendicularConstraint | null
    /**
      Creates a new horizontal constraint on a line.
      @param line The line to constrain horizontally.
      @returns Returns the newly created HorizontalConstraint object or null if the creation failed.
    */
    addHorizontal(line: SketchLine): HorizontalConstraint | null
    /**
      Creates a new horizontal constraint between two points.
      @param pointOne The first SketchPoint to constrain horizontally.
      @param pointTwo The second SketchPoint to constrain horizontally.
      @returns Returns the newly created HorizontalPointsConstraint object or null if the creation failed.
    */
    addHorizontalPoints(pointOne: SketchPoint, pointTwo: SketchPoint): HorizontalPointsConstraint | null
    /**
      Creates a new vertical constraint on a line.
      @param line The line to constrain vertically.
      @returns Returns the newly created VerticalConstraint object or null if the creation failed.
    */
    addVertical(line: SketchLine): VerticalConstraint | null
    /**
      Creates a new vertical constraint between two points.
      @param pointOne The first SketchPoint to constrain vertically.
      @param pointTwo The second SketchPoint to constrain vertically.
      @returns Returns the newly created VerticalPointsConstraint object or null if the creation failed.
    */
    addVerticalPoints(pointOne: SketchPoint, pointTwo: SketchPoint): VerticalPointsConstraint | null
    /**
      Creates a new tangent constraint between two curves.
      @param curveOne The first curve to be tangent.
      @param curveTwo The second curve to be tangent.
      @returns Returns the newly created TangentConstraint object or null if the creation failed.
    */
    addTangent(curveOne: SketchCurve, curveTwo: SketchCurve): TangentConstraint | null
    /**
      Creates a new smooth constraint between two curves. One of the curves
      must be a spline. The other curve can be a spline or any other type of curve.
      @param curveOne The first curve to be constrained to be smooth to the second curve.
      @param curveTwo The second curve to be constrained to be smooth to the first curve.
      @returns Returns the newly created SmoothConstraint object or null if the creation failed.
    */
    addSmooth(curveOne: SketchCurve, curveTwo: SketchCurve): SmoothConstraint | null
    /**
      Creates a new equal constraint between two lines, or between arcs and circles.
      @param curveOne The first line, arc, or circle.
      @param curveTwo The second line, arc, or circle.
      @returns Returns the newly created EqualConstraint object or null if the creation failed.
    */
    addEqual(curveOne: SketchCurve, curveTwo: SketchCurve): EqualConstraint | null
    /**
      Creates a new symmetry constraint.
      @param entityOne The first sketch entity to be symmetric.
      @param entityTwo The second sketch entity to be symmetric. It must be the same type as the first entity.
      @param symmetryLine The SketchLine that defines the axis of symmetry.
      @returns Returns the newly created SymmetryConstraint object or null if the creation failed.
    */
    addSymmetry(entityOne: SketchEntity, entityTwo: SketchEntity, symmetryLine: SketchLine): SymmetryConstraint | null
    /**
      Creates an offset constraint, which results in creating a new set of curves that are an offset of
      the input curves. The returned offset constraint provides access to the created curves and the
      parameter controlling the offset.
      The offset direction is implied by the flow direction of the provided curves. For example, if
      two connected lines are offset, the flow direction is from line 1 to line 2. A positive offset
      value creates the offset curve to the "right" of the lines and a negative offset goes to the "left".
      Left and right are evaluated with respect to the geometry. If you are standing on line 1 looking
      towards line 2 your left and right are the offset left and right. For closed single curves like
      circles and ellipses their flow direction is always counterclockwise so a positive offset is
      always to the outsides.
      @remarks
      To access the full capabilities supported by offset, you should use the createOffsetInput and
      addOffset2 methods.
      @param curves A set of end connected curves. The Sketch.FindConnectedCurves method is a convenient way to get
      this set of curves.
      @param offset The value that defines the offset. This is a ValueInput object so it can be a float value to define
      the offset in centimeters or it can be a string defining an expression that will be used by the
      dimension that controls the offset.
      @param basePoint The location on one of the curves where the offset dimension will be created.
      @returns The created OffsetConstraint. You can use properties on the constraint to get information about the offset.
      @deprecated
    */
    addOffset(curves: SketchCurve[], offset: core.ValueInput, basePoint: core.Point3D): OffsetConstraint
    /**
      Creates a new RectangularPatternConstraintInput object. Use this object to define the various settings
      associated with a rectangular pattern in a sketch. Once the pattern is defined you can call the addRectangularPattern
      method and pass in the input object to create the sketch rectangular pattern.
      @param entities An array of sketch entities to pattern. These can be sketch points and curves.
      @param distanceType Specifies if the distances defined for the pattern define the overall size of the pattern or the distance between the rows and columns.
      @returns Returns the created RectangularPatternsConstraintInput object or null in the case of failure.
    */
    createRectangularPatternInput(entities: SketchEntity[], distanceType: PatternDistanceType): RectangularPatternConstraintInput | null
    /**
      Creates a new rectangular pattern in the sketch.
      @param input A RectangularPatternConstraintInput object that defines all of inputs required to create
      the desired rectangular pattern. Use the createRectangularPatternInput method to create the
      input object.
    */
    addRectangularPattern(input: RectangularPatternConstraintInput): RectangularPatternConstraint
    /**
      Creates a CircularPatternConstraintInput object. Use properties and methods on this object
      to define the circular pattern you want to create and then use the Add method, passing in
      the CircularPatternConstraintInput object.
      @param inputEntities An array of sketch entities to be patterned.
      All of the entities must be from the current sketch.
      @param centerPoint A SketchPoint from the same sketch that defines the center of the pattern.
      @returns Returns the newly created CircularPatternConstraintInput object or null if the creation failed.
    */
    createCircularPatternInput(inputEntities: SketchEntity[], centerPoint: SketchPoint): CircularPatternConstraintInput | null
    /**
      Creates a new circular pattern in the sketch.
      @param input A CircularPatternConstraintInput object that defines the desired circular pattern. Use the
      createCircularPatternInput method to create a new CircularPatternConstraintInput
      object and then use methods on it to define the circular pattern.
      @returns Returns the newly created CircularPatternConstraint object or null if the creation failed.
    */
    addCircularPattern(input: CircularPatternConstraintInput): CircularPatternConstraint | null
    /**
      Creates a new coincident constraint between the sketch point and surface. This forces the point to
      lie on the surface.
      @param point The SketchPoint to constrain to the surface.
      @param surface The BRepFace or ConstructionPlane the point will be coincident to.
      @returns Returns the newly created CoincidentToSurfaceConstraint object or null if the creation failed.
    */
    addCoincidentToSurface(point: SketchPoint, surface: core.Base): CoincidentToSurfaceConstraint | null
    /**
      Creates a new parallel constraint between a sketch line and a planar surface that will constrain
      the line to lie on a plane parallel to the specified surface.
      @param line The SketchLine to constrain to the surface.
      @param planarSurface The planar BRepFace or CosntructionPlane the sketch line will be parallel to.
      @returns Returns the newly created LineParallelToPlanarSurfaceConstraint object or null if the creation failed.
    */
    addLineParallelToPlanarSurface(line: SketchLine, planarSurface: core.Base): LineParallelToPlanarSurfaceConstraint | null
    /**
      Creates a new constraint that forces the sketch line to lie on a planar surface.
      @param line The SketchLine to constrain to the surface.
      @param planarSurface The planar BRepFace or CosntructionPlane the sketch line will lie on.
      @returns Returns the newly created LineOnPlanarSurfaceConstraint object or null if the creation failed.
    */
    addLineOnPlanarSurface(line: SketchLine, planarSurface: core.Base): LineOnPlanarSurfaceConstraint | null
    /**
      Creates a new perpendicular constraint that forces the sketch curve to be perpendicular to the specified surface. Line and spline curves are supported.
      @param curve The SketchCurve to constrain to the surface.
      @param surface The BRepFace or ConstructionPlane the line will be perpendicular to.
      @returns Returns the newly created PerpendicularToSurfaceConstraint object or null if the creation failed.
    */
    addPerpendicularToSurface(curve: SketchCurve, surface: core.Base): PerpendicularToSurfaceConstraint | null
    /**
      Creates an OffsetConstraintInput object. Use properties and methods on this object to define the offset you
      want to create and then use the addOffset2 method, passing in the OffsetConstraintInput object, to create the offset.
      @param curves A set of end connected curves. The Sketch.FindConnectedCurves method is a convenient way to get
      this set of curves.
      @param offset The value that defines the offset. This is a ValueInput object so it can be a float value to define the offset
      in centimeters or it can be a string defining an expression that will be used by the parameter controlling the
      offset. A positive offset value creates the offset curve to the "right" and a negative offset value goes to the "left".
      The flow direction of the provided curves implies the offset direction. For example, if two connected lines
      are offset, the flow direction is from line 1 to line 2. Left and right are evaluated relative to the input
      geometry. If you are standing on line 1 and looking towards line 2, the offset's left side is on your left,
      and the right side is to your right. Closed single curves like circles and ellipses always have a counterclockwise
      flow, so a positive offset is always to the outside. For closed splines, the positive direction is based on
      the spline's parameterization.
      @returns Returns an OffsetConstraintInput object or null in the case of invalid input.
    */
    createOffsetInput(curves: SketchCurve[], offset: core.ValueInput): OffsetConstraintInput | null
    /**
      Creates an offset constraint, which results in creating a new set of curves that are an offset of
      the input curves. The returned offset constraint object provides access to the created curves and the
      parameter controlling the offset.
      @param input The OffsetConstraintInput object that defines the offset to create.
      @returns Returns the newly created OffsetConstraint object or null if the creation failed.
    */
    addOffset2(input: OffsetConstraintInput): OffsetConstraint | null
    /**
      Creates two offset constraints, which results in creating two new sets of curves that are an offset of
      the input curves on each side of the original set of curves. The returned offset constraint objects
      provide access to the created curves and the parameters controlling the offsets.
      @param input The OffsetConstraintInput object that defines the offset to create. The same definition applies to
      both offsets that are created.
      @param linkOffsets Defines if the parameter driving the offset of the second side should reference the parameter of
      the first side. This sets up the parameters so if the first side is edited, the second side will
      automatically update using the same value. A value of true will create the linked parameter.
      @returns Returns an array containing the two OffsetConstraint objects or errors if the creation failed.
    */
    addTwoSidesOffset(input: OffsetConstraintInput, linkOffsets: boolean): OffsetConstraint[]
    /**
      Creates a polygon constraint on existing lines in the sketch.
      @param lines An array of existing SketchLine objects in this sketch that define a valid polygon.
      They must be the same length, connect at their endpoints, have the same angle between them,
      and define a closed shape. The order of the lines within the array does not matter.
      @returns Returns the created PolygonConstraint or null if the creation failed.
    */
    addPolygon(lines: SketchLine[]): PolygonConstraint | null
  }

  /**
    The base class for all geometric constraints.
  */
  abstract class GeometricConstraint extends core.Base {
    /**
      Deletes this constraint. The IsDeletable property can be used to determine if this
      constraint can be deleted.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Indicates if this constraint is deletable.
    */
    readonly isDeletable: boolean
    /**
      Returns the parent sketch object.
    */
    readonly parentSketch: Sketch
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      Returns the collection of attributes associated with this geometric constraint.
    */
    readonly attributes: core.Attributes
    /**
      Returns a token for the GeometricConstraint object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same geometric constraint.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
  }

  /**
    A sketch constraint defining that a point is coincident to a surface.
  */
  abstract class CoincidentToSurfaceConstraint extends GeometricConstraint {
    /**
      Returns the sketch point that is constrained.
    */
    readonly point: SketchPoint
    /**
      Returns the BRepFace or ConstructionPlane the point is constrained to.
    */
    readonly surface: core.Base
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: CoincidentToSurfaceConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): CoincidentToSurfaceConstraint | null
  }

  /**
    A sketch constraint defining that a line is parallel to a planar face or construction plane.
  */
  abstract class LineParallelToPlanarSurfaceConstraint extends GeometricConstraint {
    /**
      Returns the SketchLine object that is constrained.
    */
    readonly line: SketchLine
    /**
      Returns the planar BRepFace or ConstructionPlane the line is parallel to.
    */
    readonly planarSurface: core.Base
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: LineParallelToPlanarSurfaceConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): LineParallelToPlanarSurfaceConstraint | null
  }

  /**
    A sketch constraint defining that a line that lies on a planar face or construction plane.
  */
  abstract class LineOnPlanarSurfaceConstraint extends GeometricConstraint {
    /**
      Returns the SketchLine object that is constrained.
    */
    readonly line: SketchLine
    /**
      Returns the planar BRepFace or ConstructionPlane the line is constrained to lie on.
    */
    readonly planarSurface: core.Base
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: LineOnPlanarSurfaceConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): LineOnPlanarSurfaceConstraint | null
  }

  /**
    A sketch constraint defining that a curve is perpendicular to a face or construction plane. Line and spline curves are supported.
  */
  abstract class PerpendicularToSurfaceConstraint extends GeometricConstraint {
    /**
      Returns the SketchCurve object that is constrained.
    */
    readonly curve: SketchCurve
    /**
      Returns the BRepFace or ConstructionPlane the line is constrained to be perpendicular to.
    */
    readonly surface: core.Base
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: PerpendicularToSurfaceConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): PerpendicularToSurfaceConstraint | null
  }

  /**
    Used to define the inputs needed to create an offset constraint.
  */
  abstract class OffsetConstraintInput extends core.Base {
    /**
      Gets and sets an array of SketchCurve objects that defines the connected curves that will be offset.
      The Sketch.FindConnectedCurves method is a convenient way to get this set of curves.
    */
    curves: SketchCurve[]
    /**
      Gets and sets the value that defines the offset. This is a ValueInput object so it can be a float value to
      define the offset in centimeters or it can be a string defining an expression that will be used by the parameter
      controlling the offset. A positive offset value creates the offset curve to the "right" and a negative offset
      value goes to the "left".
      The flow direction of the provided curves implies the offset direction. For example, if two connected lines
      are offset, the flow direction is from line 1 to line 2. Left and right are evaluated relative to the input
      geometry. If you are standing on line 1 and looking towards line 2, the offset's left side is on your left,
      and the right side is to your right. Closed single curves like circles and ellipses always have a counterclockwise
      flow, so a positive offset is always to the outside. For closed splines, the positive direction is based on
      the spline's parameterization.
    */
    offset: core.ValueInput
    /**
      A location on one of the curves where the offset dimension will be created. A value of null can be used to indicate
      that a default location should be used.
      When the OffsetContraintInput is created this property defaults to null.
    */
    dimensionPoint: core.Point3D
    /**
      Specifies if the offset curves must match the topology of the original curves. For example, if you have a sketch
      containing two lines with a fillet (arc) connecting them and offset them inward more than the arc radius, the
      resulting offset will be two lines. This is a change in topology because the original curves were line-arc-line,
      and the offset is line-line. An offset of less than the radius still results in a line-arc-line result. If this
      property is true, indicating the topology must match, creating the offset with a value greater than the arc radius
      will fail because the result will not have a matching topology.
      When the OffsetConstraintInput is created, this property default to true.
    */
    isTopologyMatched: boolean
  }

  /**
    An offset constraint in a sketch.
  */
  abstract class OffsetConstraint extends GeometricConstraint {
    /**
      Returns an array of sketch curves that are the set of parent curves.
      Nothing should be assumed about the order in how the curves are returned.
    */
    readonly parentCurves: SketchCurve[]
    /**
      Returns an array of sketch curves that are the set of child curves resulting from the offset.
      Nothing should be assumed about the order in how the curves are returned.
    */
    readonly childCurves: SketchCurve[]
    /**
      The current distance of the offset in centimeters. To change the offset you need to
      modify the value of the parameter associated with the dimension, which you can get
      using the dimension property.
    */
    readonly distance: number
    /**
      Returns the dimension controlling the offset distance. This can return null in the
      case where the dimension has been deleted. To change the offset distance you can use
      the parameter property of the returned dimension to get the parameter that controls the value and
      use properties on the parameter to change the value. This can return either a SketchOffsetCurvesDimension
      or a SketchOffsetDimension. A SketchOffsetCurvesDimension is created automatically when curves are
      offset but if it is deleted the offset can also be controlled by a SketchOffsetDimension.
    */
    readonly dimension: SketchDimension
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: OffsetConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): OffsetConstraint | null
    /**
      Gets the setting that controls if the offset curves match the topology of the original curves.
    */
    readonly isTopologyMatched: boolean
  }

  /**
    A coincident constraint in a sketch.
  */
  abstract class CoincidentConstraint extends GeometricConstraint {
    /**
      Returns the sketch point that is constrained.
    */
    readonly point: SketchPoint
    /**
      The sketch curve or point the point is constrained to.
    */
    readonly entity: SketchEntity
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: CoincidentConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): CoincidentConstraint | null
  }

  /**
    An object that is only used when a glyph representing a special type of coincident
    constraint is selected in the user interface. An example of its use is when two lines
    are connected at their endpoints. If you hover the mouse over the shared endpoint, a
    coincident constraint glyph is displayed and highlights the two lines. Selecting the
    glyph and deleting it will cause the lines to be separate. In this case, there isn't
    a real coincident constraint, but the two lines share the same sketch point. The UI
    uses this "fake" coincident constraint to indicate that the lines share the same point.
    It also supports separating them when the glyph is deleted by creating a new point and
    moving one of the lines to it.
    A selection returns this object when a glyph representing this special type of
    coincident constraint is selected. It is only used for selections and provides access
    to the highlighted entities when the glyph is selected.
  */
  abstract class SharedPointCoincident extends core.Base {
    /**
      Returns the sketch point that the sketch curves are connected to.
    */
    readonly point: SketchPoint
    /**
      Returns the first sketch curve that is highlighted when the glyph was selected.
    */
    readonly curveOne: SketchCurve
    /**
      Returns the second sketch curve that is highlighted when the glyph was selected.
    */
    readonly curveTwo: SketchCurve
  }

  /**
    A collinear constraint in a sketch.
  */
  abstract class CollinearConstraint extends GeometricConstraint {
    /**
      Returns the first line.
    */
    readonly lineOne: SketchLine
    /**
      Returns the second line.
    */
    readonly lineTwo: SketchLine
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: CollinearConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): CollinearConstraint | null
  }

  /**
    A concentric constraint in a sketch.
  */
  abstract class ConcentricConstraint extends GeometricConstraint {
    /**
      Returns the first curve.
    */
    readonly entityOne: SketchCurve
    /**
      Returns the second curve.
    */
    readonly entityTwo: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ConcentricConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ConcentricConstraint | null
  }

  /**
    A midpoint constraint in a sketch.
  */
  abstract class MidPointConstraint extends GeometricConstraint {
    /**
      Returns the sketch point being constrained.
    */
    readonly point: SketchPoint
    /**
      Returns the curve defining the midpoint.
    */
    readonly midPointCurve: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: MidPointConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): MidPointConstraint | null
  }

  /**
    A parallel constraint in a sketch.
  */
  abstract class ParallelConstraint extends GeometricConstraint {
    /**
      Returns the first line.
    */
    readonly lineOne: SketchLine
    /**
      Returns the second line.
    */
    readonly lineTwo: SketchLine
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: ParallelConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): ParallelConstraint | null
  }

  /**
    A perpendicular constraint in a sketch.
  */
  abstract class PerpendicularConstraint extends GeometricConstraint {
    /**
      Returns the first line.
    */
    readonly lineOne: SketchLine
    /**
      Returns the second line.
    */
    readonly lineTwo: SketchLine
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: PerpendicularConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): PerpendicularConstraint | null
  }

  /**
    A horizontal constraint in a sketch.
  */
  abstract class HorizontalConstraint extends GeometricConstraint {
    /**
      Returns the line being constrained.
    */
    readonly line: SketchLine
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: HorizontalConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): HorizontalConstraint | null
  }

  /**
    A horizontal constraint between two points in a sketch.
  */
  abstract class HorizontalPointsConstraint extends GeometricConstraint {
    /**
      Returns the first point.
    */
    readonly pointOne: SketchPoint
    /**
      Returns the second point.
    */
    readonly pointTwo: SketchPoint
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: HorizontalPointsConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): HorizontalPointsConstraint | null
  }

  /**
    A vertical constraint in a sketch.
  */
  abstract class VerticalConstraint extends GeometricConstraint {
    /**
      Returns the line being constrained.
    */
    readonly line: SketchLine
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: VerticalConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): VerticalConstraint | null
  }

  /**
    A vertical constraint between two points in a sketch.
  */
  abstract class VerticalPointsConstraint extends GeometricConstraint {
    /**
      Returns the first point.
    */
    readonly pointOne: SketchPoint
    /**
      Returns the second point.
    */
    readonly pointTwo: SketchPoint
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: VerticalPointsConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): VerticalPointsConstraint | null
  }

  /**
    A tangent constraint in a sketch.
  */
  abstract class TangentConstraint extends GeometricConstraint {
    /**
      Returns the first curve.
    */
    readonly curveOne: SketchCurve
    /**
      Returns the second curve.
    */
    readonly curveTwo: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: TangentConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): TangentConstraint | null
  }

  /**
    A smooth constraint in a sketch.
  */
  abstract class SmoothConstraint extends GeometricConstraint {
    /**
      Returns the first curve.
    */
    readonly curveOne: SketchCurve
    /**
      Returns the second curve.
    */
    readonly curveTwo: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SmoothConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SmoothConstraint | null
  }

  /**
    An equal constraint in a sketch.
  */
  abstract class EqualConstraint extends GeometricConstraint {
    /**
      Returns the first curve.
    */
    readonly curveOne: SketchCurve
    /**
      Returns the second curve.
    */
    readonly curveTwo: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: EqualConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): EqualConstraint | null
  }

  /**
    A symmetry constraint in a sketch.
  */
  abstract class SymmetryConstraint extends GeometricConstraint {
    /**
      Returns the first curve.
    */
    readonly entityOne: SketchEntity
    /**
      Returns the second curve.
    */
    readonly entityTwo: SketchEntity
    /**
      Returns the axis (SketchLine) that defines the symmetry.
    */
    readonly symmetryLine: SketchLine
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SymmetryConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SymmetryConstraint | null
  }

  /**
    This class defines the methods and properties that pertain to the definition of a circular pattern
    in a sketch.
  */
  abstract class CircularPatternConstraintInput extends core.Base {
    /**
      Gets and sets the entities to pattern. Sketch points and curves are valid
      entities to pattern.
    */
    entities: SketchEntity[]
    /**
      Gets and sets the sketch point that defines the center of the pattern.
    */
    centerPoint: SketchPoint
    /**
      Gets and sets quantity of the elements.
    */
    quantity: core.ValueInput
    /**
      Gets and sets total angle. A positive angle is a counter-clockwise direction and
      a negative angle can be used to reverse the direction.
      An angle of 360 degrees or 2 pi radians will create a full circular pattern.
    */
    totalAngle: core.ValueInput
    /**
      Gets and sets if the angle extent is in one direction or is symmetric.
    */
    isSymmetric: boolean
    /**
      Specifies which, if any, instances of the pattern are suppressed. This
      defaults to all instances being visible. This returns an array of Booleans
      that indicates if a particular instance in the pattern is suppressed or
      not. A value of true will result in the associated instance being
      suppressed.
    */
    isSuppressed: boolean[]
  }

  /**
    A circular pattern constraint in a sketch.
  */
  abstract class CircularPatternConstraint extends GeometricConstraint {
    /**
      Gets and sets the entities to pattern. Sketch points and curves are valid
      entities to pattern.
    */
    entities: SketchEntity[]
    /**
      Returns an array that contains all of the sketch entities that were created as a result
      of the pattern. This does not contain the original entities that were used as input to
      the pattern. The input entities can be obtained by using the entities property.
    */
    readonly createdEntities: SketchEntity[]
    /**
      Gets and sets the sketch point that defines the center of the pattern.
    */
    centerPoint: SketchPoint
    /**
      Returns the parameter that controls the number of instances in the pattern. To change
      the value, use the properties on the returned ModelParameter object.
    */
    readonly quantity: ModelParameter
    /**
      Returns the parameter that controls the number of instances in the pattern. A positive
      angle is a counter-clockwise direction and a negative angle can be used to reverse the direction.
      An angle of 360 degrees or 2 pi radians will create a full circular pattern.
    */
    readonly totalAngle: ModelParameter
    /**
      Gets and sets if the angle extent is in one direction or is symmetric.
    */
    isSymmetric: boolean
    /**
      Specifies which, if any, instances of the pattern are suppressed. This returns an
      array of Boolean values that indicates if a particular instance in the pattern is
      suppressed or not. A value of true will result in the associated instance being suppressed.
    */
    isSuppressed: boolean[]
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: CircularPatternConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): CircularPatternConstraint | null
  }

  /**
    Used to define the inputs need to create a rectangular pattern in a sketch.
  */
  abstract class RectangularPatternConstraintInput extends core.Base {
    /**
      Gets and sets the entities to pattern. Sketch points and curves are valid
      entities to pattern.
    */
    entities: SketchEntity[]
    /**
      Defines the first direction of the pattern. This can be null which indicates
      to use the default which is the X-axis of the sketch. Setting this property
      to null will automatically clear directionTwoEntity, if it has been set.
    */
    directionOneEntity: SketchLine
    /**
      Defines the second direction of the pattern. This can be null which indicates
      to use the default which is perpendicular to direction one. The directionOneEntity
      property must be set before setting this property.
    */
    directionTwoEntity: SketchLine
    /**
      Sets all of the input required to define the pattern in the first direction.
      @param directionOneEntity Specifies the SketchLine object used to define the first direction entity.
      This argument can be null to indicate that the default first direction is to be used, which is along the X axis of the sketch.
      @param quantityOne Specifies the number of instances in the first direction.
      @param distanceOne Specifies the distance in the first direction. How this value is used depends on the value of the PatternDistanceType property.
      If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
      If the value is SpacingPatternDistanceType then it defines the distance between each element.
      @returns Returns true if it was successful.
    */
    setDirectionOne(directionOneEntity: SketchLine, quantityOne: core.ValueInput, distanceOne: core.ValueInput): boolean
    /**
      Sets all of the input required to define the pattern in the second direction.
      @param directionTwoEntity Specifies the SketchLine object used to define the second direction entity.
      This argument can be null to indicate that the default second direction is to be used, which is 90 degrees to the first direction.
      @param quantityTwo Specifies the number of instances in the second direction.
      @param distanceTwo Specifies the distance in the second direction. How this value is used depends on the value of the PatternDistanceType property.
      If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
      If the value is SpacingPatternDistanceType then it defines the distance between each element.
      @returns Returns true if it was successful.
    */
    setDirectionTwo(directionTwoEntity: SketchLine, quantityTwo: core.ValueInput, distanceTwo: core.ValueInput): boolean
    /**
      Gets and sets the number of instances in the first direction.
    */
    quantityOne: core.ValueInput
    /**
      Gets and sets the number of instances in the second direction.
    */
    quantityTwo: core.ValueInput
    /**
      Gets and sets the distance in the first direction.
    */
    distanceOne: core.ValueInput
    /**
      Gets and sets the distance in the second direction.
    */
    distanceTwo: core.ValueInput
    /**
      Gets and sets if the pattern in direction one is in one direction or is symmetric.
    */
    isSymmetricInDirectionOne: boolean
    /**
      Gets and sets if the pattern in direction two is in one direction or is symmetric.
    */
    isSymmetricInDirectionTwo: boolean
    /**
      Gets and sets how the distance between elements is computed.
    */
    distanceType: PatternDistanceType
    /**
      Specifies which, if any, instances of the pattern are suppressed. This
      defaults to all instances being visible. This returns an array of Booleans
      that indicates if a particular instance in the pattern is suppressed or
      not. A value of true will result in the associated instance being
      suppressed.
      Both the quantityOne and quantityTwo properties must be set with valid
      values before using the isSuppressed property is valid. A quantity of
      one is a valid value.
      The indices represent the pattern instances in a row-column order, with the
      initial geometry not counting. For example, if you have a 4x4 pattern, the
      array will have 15 elements rather than 16 because the original geometry
      cannot be suppressed as part of the pattern. The first element in the array
      is the one next to the original in the first direction. The second element is
      the next one on the first row, and the third is the next one. The fourth element
      will be the first element in the row next to the first row that contains the
      original geometry.
    */
    isSuppressed: boolean[]
  }

  /**
    A rectangular pattern constraint in a sketch.
  */
  abstract class RectangularPatternConstraint extends GeometricConstraint {
    /**
      Gets and sets the entities that are patterned. Sketch points and curves are valid
      entities to pattern.
    */
    entities: SketchEntity[]
    /**
      Returns an array that contains all of the sketch entities that were created as a result
      of the pattern. This does not contain the original entities that were used as input to
      the pattern. The input entities can be obtained by using the entities property.
    */
    readonly createdEntities: SketchEntity[]
    /**
      Gets and sets the entity that defined the first direction of the pattern. This can
      be null which indicates to use the default which is the X-axis of the sketch. Setting
      this property to null will automatically clear directionTwoEntity, if it has been set.
    */
    directionOneEntity: SketchLine
    /**
      Gets and sets the entity that defines the second direction of the pattern. This can
      be null which indicates to use the default direction, which is perpendicular to direction
      one. The directionOneEntity property must be set before setting this property.
    */
    directionTwoEntity: SketchLine
    /**
      Sets all of the input required to define the pattern in the first direction.
      @param directionOneEntity Specifies the SketchLine object used to define the first direction entity.
      This argument can be null to indicate that the default first direction is to be used,
      which is along the X axis of the sketch.
      @param quantityOne Specifies the number of instances in the first direction.
      @param distanceOne Specifies the distance in the first direction. How this value is used depends on the value
      of the PatternDistanceType property. If the value is ExtentPatternDistanceType then it defines
      the total distance of the pattern. If the value is SpacingPatternDistanceType then it defines
      the distance between each element.
      @returns Returns true if it was successful.
    */
    setDirectionOne(directionOneEntity: SketchLine, quantityOne: core.ValueInput, distanceOne: core.ValueInput): boolean
    /**
      Sets all of the input required to define the pattern in the second direction.
      @param directionTwoEntity Specifies the SketchLine object used to define the second direction entity.
      This argument can be null to indicate that the default second direction is to be used, which is 90
      degrees to the first direction.
      @param quantityTwo Specifies the number of instances in the second direction.
      @param distanceTwo Specifies the distance in the second direction. How this value is used depends on the value of
      the PatternDistanceType property. If the value is ExtentPatternDistanceType then it defines the
      total distance of the pattern. If the value is SpacingPatternDistanceType then it defines the
      distance between each element.
      @returns Returns true if it was successful.
    */
    setDirectionTwo(directionTwoEntity: SketchLine, quantityTwo: core.ValueInput, distanceTwo: core.ValueInput): boolean
    /**
      Returns the parameter that controls the number of instances in the first direction. To change
      the value, use the properties on the returned ModelParameter.
    */
    readonly quantityOne: ModelParameter
    /**
      Returns the parameter that controls the number of instances in the second direction. To change
      the value, use the properties on the returned ModelParameter object.
    */
    readonly quantityTwo: ModelParameter
    /**
      Returns the parameter that controls the distance in first direction. To change the
      value, use the properties on the returned ModelParameter object.
    */
    readonly distanceOne: ModelParameter
    /**
      Returns the parameter that controls the distance in second direction. To change the
      value, use the properties on the returned ModelParameter object.
    */
    readonly distanceTwo: ModelParameter
    /**
      Gets and sets if the pattern in direction one is in one direction or is symmetric.
    */
    isSymmetricInDirectionOne: boolean
    /**
      Gets and sets if the pattern in direction two is in one direction or is symmetric.
    */
    isSymmetricInDirectionTwo: boolean
    /**
      Gets and sets how the distance between elements is computed.
    */
    distanceType: PatternDistanceType
    /**
      Specifies which, if any, instances of the pattern are suppressed. This returns an
      array of Boolean values that indicates if a particular instance in the pattern is
      suppressed or not. A value of true will result in the associated instance being suppressed.
      The indices represent the pattern instances in a row-column order, with the
      initial geometry not counting. For example, if you have a 4x4 pattern, the
      array will have 15 elements rather than 16 because the original geometry
      cannot be suppressed as part of the pattern. The first element in the array
      is the one next to the original in the first direction. The second element is
      the next one on the first row, and the third is the next one. The fourth element
      will be the first element in the row next to the first row that contains the
      original geometry.
    */
    isSuppressed: boolean[]
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: RectangularPatternConstraint
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): RectangularPatternConstraint | null
  }

  /**
    A polygon constraint in a sketch.
  */
  abstract class PolygonConstraint extends GeometricConstraint {
    /**
      This has been retired and you should use the points property instead.
      @deprecated
    */
    readonly lines: SketchLine[]
    /**
      Returns the sketch points that define the vertices of the polygon. The
      sketch lines that draw the shape of the polygon can be obtained from the points.
    */
    readonly points: SketchPoint[]
    /**
      Returns the SketchPoint that acts as the center point of the polygon.
    */
    readonly centerPoint: SketchPoint
  }

  /**
    The different dimension orientations.
  */
  const enum DimensionOrientations {
    /**
      The dimension is aligned to the entity being dimensioned.
    */
    AlignedDimensionOrientation,
    /**
      The dimension is horizontal.
    */
    HorizontalDimensionOrientation,
    /**
      The dimension is vertical.
    */
    VerticalDimensionOrientation,
  }

  /**
    A collection of the dimensions in a sketch. This object also supports the methods to add
    new sketch dimensions.
  */
  abstract class SketchDimensions extends core.Base {
    /**
      Function that returns the specified sketch dimension using an index into the
      collection.
      @param index The index of the item within the collection to return. The first item in the
      collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchDimension | null
    /**
      Returns the number of sketch dimensions in the sketch.
    */
    readonly count: number /*unsigned int*/
    /**
      Creates a new linear dimension constraint between the two input entities.
      @param pointOne The first SketchPoint to dimension to.
      @param pointTwo The second SketchPoint to dimension to..
      @param orientation The orientation of the dimension.
      @param textPoint A Point3D object that defines the position of the dimension text.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addDistanceDimension(pointOne: SketchPoint, pointTwo: SketchPoint, orientation: DimensionOrientations, textPoint: core.Point3D, isDriving?: boolean/* = true*/): SketchLinearDimension | null
    /**
      Creates a new linear dimension constraint between the two input entities. The first input
      entity must be a sketch line. The second entity can be a point or a line that is parallel
      to the first. The dimension controls the distance as measured perpendicular to the first
      input line.
      @param line The SketchLine to dimension to.
      @param entityTwo The parallel SketchLine or SketchPoint to dimension to. If a SketchLine is used it must be
      parallel to the first line.
      @param textPoint A Point3D object that defines the position of the dimension text.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addOffsetDimension(line: SketchLine, entityTwo: SketchEntity, textPoint: core.Point3D, isDriving?: boolean/* = true*/): SketchOffsetDimension | null
    /**
      Creates a new angular dimension constraint between the two input lines.
      The position of the text controls which of the four quadrants will be dimensioned.
      @param lineOne The first SketchLine to dimension to.
      @param lineTwo The second SketchLine to dimension to.
      @param textPoint A Point3D object that defines the position of the dimension text. The position of the
      text also defines which quadrant will be dimensioned.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addAngularDimension(lineOne: SketchLine, lineTwo: SketchLine, textPoint: core.Point3D, isDriving?: boolean/* = true*/): SketchAngularDimension | null
    /**
      Creates a new diameter dimension constraint on the arc or circle.
      @param entity The SketchCircle or SketchArc to dimension.
      @param textPoint A Point3D object that defines the position of the dimension text.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addDiameterDimension(entity: SketchCurve, textPoint: core.Point3D, isDriving?: boolean/* = true*/): SketchDiameterDimension | null
    /**
      Creates a new radial dimension constraint on the arc or circle.
      @param entity The SketchCircle or SketchArc to dimension.
      @param textPoint A Point3D object that defines the position of the dimension text.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addRadialDimension(entity: SketchCurve, textPoint: core.Point3D, isDriving?: boolean/* = true*/): SketchRadialDimension | null
    /**
      Creates a new dimension constraint on the major radius of an ellipse.
      @param ellipse The SketchEllipse to dimension.
      @param textPoint A Point3D object that defines the position of the dimension text.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addEllipseMajorRadiusDimension(ellipse: SketchCurve, textPoint: core.Point3D, isDriving?: boolean/* = true*/): SketchEllipseMajorRadiusDimension | null
    /**
      Creates a new dimension constraint on the minor radius of an ellipse.
      @param ellipse The SketchEllipse to dimension.
      @param textPoint A Point3D object that defines the position of the dimension text.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addEllipseMinorRadiusDimension(ellipse: SketchCurve, textPoint: core.Point3D, isDriving?: boolean/* = true*/): SketchEllipseMinorRadiusDimension | null
    /**
      Creates a new dimension constraint between to concentric circles or arcs.
      @param circleOne The first SketchCircle or SketchArc to dimension.
      @param circleTwo The second SketchCircle or SketchArc to dimension.
      @param textPoint A Point3D object that defines the position of the dimension text.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addConcentricCircleDimension(circleOne: SketchCurve, circleTwo: SketchCurve, textPoint: core.Point3D, isDriving?: boolean/* = true*/): SketchConcentricCircleDimension | null
    /**
      Creates a new linear dimension from between a line and circle or arc and a second circle or arc where
      the dimension is to the tangent on the edge of the circle or arc.
      @param entityOne The first entity to dimension to. This can be a SketchPoint, SketchLine, SketchCircle or SketchArc.
      If a circle or arc is provided then the tangentSideOne argument must be specified.
      @param isCloseToEnityTwo If entityOne is a circle or arc this specifies which side of the circle or arc the dimension will be tangent to.
      If true, it will be on the side that is closer to entityTwo. If a SketchLine or SketchPoint was input for the
      entityOne argument this argument is ignored and any value can be used.
      @param entityTwo A SketchCircle or SketchArc entity that you will dimension to.
      @param isCloseToEnityOne Specifies which side of the circle or arc input as the entityTwo argument the dimension will be tangent to.
      If true, it will be on the side that is closer to entityOne.
      @param textPoint A Point3D object that defines the position of the dimension text.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addTangentDistanceDimension(entityOne: SketchEntity, isCloseToEnityTwo: boolean, entityTwo: SketchCurve, isCloseToEnityOne: boolean, textPoint: core.Point3D, isDriving?: boolean/* = true*/): SketchTangentDistanceDimension | null
    /**
      Creates a new linear dimension showing the diameter where the first line acts as the center line
      and the second entity defines the size. The first input entity must be a sketch line. The second entity
      can be a point or a line that is parallel to the first. The dimension controls the distance as measured
      perpendicular to the first input line.
      @param centerLine The SketchLine to dimension to which acts as the center line.
      @param entityTwo The parallel SketchLine or SketchPoint to dimension to. If a SketchLine is used it must be
      parallel to the first line.
      @param textPoint A Point3D object that defines the position of the dimension text.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addLinearDiameterDimension(centerLine: SketchLine, entityTwo: SketchEntity, textPoint: core.Point3D, isDriving?: boolean/* = true*/): SketchLinearDiameterDimension | null
    /**
      Creates a new linear dimension controlling the distance between a sketch point and the specified surface or point. The text position is
      automatically chosen and is positioned so it is midway between the point and surface and the extension lines are a minimum length. You
      can modify the position by using functionality on the returned SketchDistanceBetweenPointAndSurfaceDimension object.
      @param point The SketchPoint being constrained by the dimension.
      @param surface The BRepFace or ConstructionPlane to which the dimension will anchor. Planar, cylindrical, spherical and conical faces are supported.
      If a cylindrical, spherical or conical face is used, the dimension is from the point to the nearest point on the surface.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addDistanceBetweenPointAndSurfaceDimension(point: SketchPoint, surface: core.Base, isDriving?: boolean/* = true*/): SketchDistanceBetweenPointAndSurfaceDimension | null
    /**
      Creates a new linear dimension controlling the distance between a sketch line and the specified planar face or construction plane. The sketch line
      must lie on a plane that is parallel to the planar surface. The text position is automatically chosen and is positioned so it is midway between
      the line and surface and the extension lines are a minimum length. You can modify the position by using functionality on the returned
      SketchDistanceBetweenLineAndPlanarSurfaceDimension object.
      @param line The SketchLine being constrained by the dimension.
      @param planarSurface The planar BRepFace or ConstructionPlane that the dimension will anchor to.
      @param isDriving Optional argument that specifies if a driving (the dimension controls the geometry)
      or a driven (the geometry controls the dimension) dimension is created. If not provided
      a driving dimension will be created.
      @returns Returns the newly created dimension or null if the creation failed.
    */
    addDistanceBetweenLineAndPlanarSurfaceDimension(line: SketchLine, planarSurface: core.Base, isDriving?: boolean/* = true*/): SketchDistanceBetweenLineAndPlanarSurfaceDimension | null
  }

  /**
    The base class for the all sketch dimensions.
  */
  abstract class SketchDimension extends core.Base {
    /**
      Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Indicates if this dimension is deletable.
    */
    readonly isDeletable: boolean
    /**
      Gets and sets position of the dimension text.
    */
    textPosition: core.Point3D
    /**
      Returns the parent sketch object.
    */
    readonly parentSketch: Sketch
    /**
      Returns the associated parameter or null if there is no associated parameter.
    */
    readonly parameter: ModelParameter
    /**
      Returns the assembly occurrence (i.e. the occurrence) of this object
      in an assembly. This is only valid in the case where this is acting
      as a proxy in an assembly. Returns null in the case where the object
      is not in the context of an assembly but is already the native object.
    */
    readonly assemblyContext: Occurrence
    /**
      Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension
      may fail if the result would over constrain the sketch. Fusion does not allow over-constrained sketches.
    */
    isDriving: boolean
    /**
      Returns the collection of attributes associated with this sketch dimension.
    */
    readonly attributes: core.Attributes
    /**
      Returns a token for the SketchDimension object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same sketch dimension.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Gets and sets the current value of the sketch dimension.
      In a parametric modeling design and the isDriving property is True, this is exactly equivalent
      to getting the parameter associated with the dimension and editing its value. Editing this
      property will result in the parameter value being changed. If isDriving is False, this acts
      as a read-only property and attempting to set it will fail.
      In a direct modeling design the parameter property will return null and this property can be
      used to get and set the value of the dimension because in this case, there isn't an associated
      parameter.
      The value is always in internal units which means that for dimensions that represent a distance, the value is in
      Centimeters and for dimensions representing an angle the value is in Radians.
    */
    value: number
  }

  /**
    A linear dimension in a sketch between a sketch point and a surface.
  */
  abstract class SketchDistanceBetweenPointAndSurfaceDimension extends SketchDimension {
    /**
      The sketch point being constrained.
    */
    readonly point: SketchPoint
    /**
      The BRepFace or ConstructionPlane to which the dimension is anchored. Planar, cylindrical, spherical and conical faces are supported.
    */
    readonly surface: core.Base
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchDistanceBetweenPointAndSurfaceDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchDistanceBetweenPointAndSurfaceDimension | null
  }

  /**
    A linear dimension in a sketch between a sketch line and a planar surface.
  */
  abstract class SketchDistanceBetweenLineAndPlanarSurfaceDimension extends SketchDimension {
    /**
      The sketch line being constrained.
    */
    readonly line: SketchLine
    /**
      The planar surface the dimension is anchored to. This can be a planar BRepFace or a ConstructionPlane.
    */
    readonly planarSurface: core.Base
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchDistanceBetweenLineAndPlanarSurfaceDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchDistanceBetweenLineAndPlanarSurfaceDimension | null
  }

  /**
    A linear dimension in a sketch.
  */
  abstract class SketchLinearDimension extends SketchDimension {
    /**
      The first entity being constrained.
    */
    readonly entityOne: SketchEntity
    /**
      The second entity being constrained.
    */
    readonly entityTwo: SketchEntity
    /**
      The orientation of this dimension.
    */
    readonly orientation: DimensionOrientations
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchLinearDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchLinearDimension | null
  }

  /**
    A distance dimension measuring to the tangent on one or two circles or arcs.
  */
  abstract class SketchTangentDistanceDimension extends SketchDimension {
    /**
      The first entity being constrained. This can be a SketchCircle, SketchArc,
      SketchLine, or SketchPoint.
    */
    readonly entityOne: SketchEntity
    /**
      The second entity being constrained which is always a SketchCircle or SketchArc.
    */
    readonly circleOrArc: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchTangentDistanceDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchTangentDistanceDimension | null
  }

  /**
    An offset dimension in a sketch.
  */
  abstract class SketchOffsetDimension extends SketchDimension {
    /**
      The first line being constrained.
    */
    readonly line: SketchLine
    /**
      The second entity being constrained. (a parallel SketchLine or a SketchPoint)
    */
    readonly entityTwo: SketchEntity
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchOffsetDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchOffsetDimension | null
  }

  /**
    A linear diameter dimension in a sketch.
  */
  abstract class SketchLinearDiameterDimension extends SketchDimension {
    /**
      The first line being constrained.
    */
    readonly line: SketchLine
    /**
      The second entity being constrained. (a parallel SketchLine or a SketchPoint)
    */
    readonly entityTwo: SketchEntity
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchLinearDiameterDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchLinearDiameterDimension | null
  }

  /**
    A SketchOffsetCurvesDimension object is created automatically whenever curves are offset.
  */
  abstract class SketchOffsetCurvesDimension extends SketchDimension {
    /**
      Returns the OffsetConstraint object that defines the curve offset. From the constraint
      you can get the original curves, the offset curves, and the dimension controlling the offset distance.
    */
    readonly offsetConstraint: OffsetConstraint
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchOffsetCurvesDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchOffsetCurvesDimension | null
  }

  /**
    An angular dimension in a sketch.
  */
  abstract class SketchAngularDimension extends SketchDimension {
    /**
      The first line being constrained.
    */
    readonly lineOne: SketchLine
    /**
      The second line being constrained.
    */
    readonly lineTwo: SketchLine
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchAngularDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchAngularDimension | null
  }

  /**
    An diameter dimension in a sketch.
  */
  abstract class SketchDiameterDimension extends SketchDimension {
    /**
      Returns the arc or circle being constrained.
    */
    readonly entity: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchDiameterDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchDiameterDimension | null
  }

  /**
    An radial dimension in a sketch.
  */
  abstract class SketchRadialDimension extends SketchDimension {
    /**
      The arc or circle being constrained.
    */
    readonly entity: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchRadialDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchRadialDimension | null
  }

  /**
    An ellipse major radius dimension in a sketch.
  */
  abstract class SketchEllipseMajorRadiusDimension extends SketchDimension {
    /**
      Returns the ellipse or elliptical arc being constrained.
    */
    readonly ellipse: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchEllipseMajorRadiusDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchEllipseMajorRadiusDimension | null
  }

  /**
    An ellipse minor radius dimension in a sketch.
  */
  abstract class SketchEllipseMinorRadiusDimension extends SketchDimension {
    /**
      Returns the ellipse or elliptical arc being constrained.
    */
    readonly ellipse: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchEllipseMinorRadiusDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchEllipseMinorRadiusDimension | null
  }

  /**
    A concentric circle dimension in a sketch.
  */
  abstract class SketchConcentricCircleDimension extends SketchDimension {
    /**
      Returns the first concentric circle or arc.
    */
    readonly circleOne: SketchCurve
    /**
      Returns the second concentric circle or arc.
    */
    readonly circleTwo: SketchCurve
    /**
      The NativeObject is the object outside the context of an assembly and
      in the context of it's parent component.
      Returns null in the case where this object is not in the context of
      an assembly but is already the native object.
    */
    readonly nativeObject: SketchConcentricCircleDimension
    /**
      Creates or returns a proxy for the native object
      - i.e. a new object that represents this object but adds the assembly context
      defined by the input occurrence.
      @param occurrence The occurrence that defines the context to create the proxy in.
      @returns Returns the proxy object or null if this isn't the NativeObject.
    */
    createForAssemblyContext(occurrence: Occurrence): SketchConcentricCircleDimension | null
  }

  /**
    A list of sketch dimensions.
  */
  abstract class SketchDimensionList extends core.Base {
    /**
      Function that returns the specified sketch dimension using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection
      has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): SketchDimension | null
    /**
      Returns the number of sketch dimensions in the sketch.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    A list of geometric constraints.
  */
  abstract class GeometricConstraintList extends core.Base {
    /**
      Function that returns the specified geometry constraint using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): GeometricConstraint | null
    /**
      Returns the number of constraints in the sketch.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The input object that defines the required input to create a spun profile when using the
    Sketch.createSpunProfile method. Created using the Sketch.createSpunProfileInput method.
  */
  abstract class SpunProfileInput extends core.Base {
    /**
      Gets and sets the entities (BRepBody or BRepFace) used to define the shape of the spun profile.
    */
    entities: core.Base[]
    /**
      Gets and sets the entity used to define the axis of revolution.
      The axis can be a sketch line, construction axis, or linear edge.
      The axis must not be perpendicular to the sketch plane.
    */
    axis: core.Base
    /**
      Specifies if the axis will be projected to the sketch plane before making the spun profile.
      Otherwise, the spun profile will be generated around the axis in space. Defaults to true.
    */
    isAxisProjected: boolean
    /**
      Gets and sets the linear tolerance in cm used for creating the spun profile. Defaults to 0.001cm.
    */
    tolerance: number
    /**
      Gets and sets whether the profile will be created on the opposite side of the axis.
    */
    flipResult: boolean
    /**
      Gets and sets whether a resulting spun profile that would be open, will be closed along the axis of rotation.
      This closes the sketch so it is ready for further design operations, like revolving the sketch for example.
      Defaults to true.
    */
    isCenterlineAdded: boolean
  }

  /**
    A collection of TSpline bodies.
  */
  abstract class TSplineBodies extends core.Base {
    /**
      Function that returns the specified T-Spline body using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): TSplineBody | null
    /**
      The number of bodies in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns a TSplineBody by specifying the name of the body as seen in the browser.
      @param name The name of the body, as seen in the browser. This is case sensitive.
      @returns Returns the specified item or null if a body with that name was not found.
    */
    itemByName(name: string): TSplineBody | null
    /**
      Creates a new TSplineBody by reading in a TSM file from disk.
      @param tsmFilename The full filename of the TSM file on disk.
      @returns Returns the newly created TSplineBody if successful or null in the case of failure.
    */
    addByTSMFile(tsmFilename: string): TSplineBody | null
    /**
      Creates a new TSplineBody using the T-Spline description provided by the input
      string which contains TSM formatted text.
      @param tsmDescription A string that contains a T-Spline description in TSM form.
      @returns Returns the newly created TSplineBody if successful or null in the case of failure.
    */
    addByTSMDescription(tsmDescription: string): TSplineBody | null
  }

  /**
    A TSpline body.
  */
  abstract class TSplineBody extends core.Base {
    /**
      Gets and sets the name of the body. If setting this property, there is the side-effect
      that the B-Rep body created from this T-Spline body is also renamed.
    */
    name: string
    /**
      Returns the T-Spline body as a string in the form of a TSM description.
      @returns Returns the string formatted using the TSM format.
    */
    getTSMDescription(): string
    /**
      Saves the body as a TSM file.
      @param filename The full filename of the file to save the body to. If the file already exists,
      it will be overwritten.
      @returns Returns true if the file was successfully created.
    */
    saveAsTSMFile(filename: string): boolean
    /**
      Returns the owning form feature.
    */
    readonly parentFormFeature: FormFeature
    /**
      Returns a token for the TSplineBody object. This can be saved and used at a later
      time with the Design.findEntityByToken method to get back the same T-Spline body.
      When using entity tokens it's important to understand that the token string returned for a
      specific entity can be different over time. However, even if you have two different token
      strings that were obtained from the same entity, when you use findEntityByToken they
      will both return the same entity. Because of that you should never compare entity tokens
      as way to determine what the token represents. Instead, you need to use the findEntityByToken
      method to get the two entities identified by the tokens and then compare them.
    */
    readonly entityToken: string
    /**
      Returns the TextureMapControl object associated with this body when there is an
      appearance assigned to the body that has a texture associated with it. If there
      isn't a texture, this property will return null. If there is a texture, you can
      use the returned object to query and modify how the texture is applied to the body.
    */
    readonly textureMapControl: core.TextureMapControl
  }
}

export declare namespace adsk.cam {

  /**
    The valid keyword card names for an AdditiveFEADeckBuilderCard in an AdditiveFEADeckBuilder.  Any cards not on this enum can still be made using createGenericCard
    @hidden
  */
  const enum AdditiveFEACard {
    /**
      The *TITL card sets the title
    */
    TitleCard,
    /**
      The *STOL card sets the STL gap tolerance
    */
    STLToleranceCard,
    /**
      The *PBPA card sets the number of layers per element
    */
    LayersPerElementCard,
    /**
      The *AMBI card sets the ambient temperature
    */
    AmbientTemperatureCard,
    /**
      The *FINT card sets the final temperature
    */
    FinalTemperatureCard,
    /**
      The *DDM! card sets the top and bottom z bounds of the build plate
    */
    BuildPlateZBoundsCard,
    /**
      The *STLM card maps STL files to configurations, PRMs, materials, and volume fractions
    */
    STLMapCard,
    /**
      The *CONV card sets the temperature-dependent convection coefficients
    */
    ConvectionCard,
    /**
      The *PBPF card sets the list of PRM file names.  Currently only one PRM file is supported by this API
    */
    PRMsCard,
    /**
      The *STLF card sets the list of STL files
    */
    STLsCard,
    /**
      The *SBXY card sets the extension of the build plate in the x and y directions relative to the overall parts bounding box
    */
    BuildPlateXYExtensionCard,
    /**
      The *ADAP card sets the number of adaptive mesh levels
    */
    AdaptivityCard,
    /**
      The *ANTP card sets the analysis type, either 2 for transient thermal or 4 for quasi-static mechanical
    */
    AnalysisTypeCard,
    /**
      The *BINA card enables binary file format output from a thermal model to be used by a subsequent mechanical model
    */
    BinaryOutputCard,
    /**
      The *ENSI card enables Ensigth gold case file output
    */
    EnsightOutputCard,
    /**
      The *NOFC card disables off-core memory management
    */
    NoOffCoreCard,
    /**
      The *OFC1 card enables on-core level 1 memory management
    */
    OnCore1Card,
    /**
      The *PBLR card sets the number of coarsening generations
    */
    CoarseningGenerationsCard,
    /**
      The *END card marks the end of the input file deck
    */
    EndCard,
  }

  /**
    The valid analysis types for an additive FEA simulation
    @hidden
  */
  const enum AdditiveFEAAnalysisType {
    /**
      The `Thermal` analysis type is for transient thermal conduction analyses
    */
    Thermal = 2,
    /**
      The `Mechanical` analysis type is for quasi-static mechanical analyses
    */
    Mechanical = 4,
  }

  /**
    The STL configuration IDs for the *STLM card
    @hidden
  */
  const enum AdditiveFEASTLConfiguration {
    /**
      A part geometry body
    */
    Part = 1,
    /**
      A custom non-rectangular build plate geometry.  Default rectangular build plates can be modeled without an explicit STL geometry
    */
    BuildPlate = 2,
    /**
      A support structure geometry
    */
    Support = 3,
    /**
      A ghost part input geometry
    */
    Ghost = 4,
  }

  /**
     Used to check the state and get back the results of an operation generation.
  */
  abstract class GenerateToolpathFuture extends core.Base {
    /**
      Returns the number of operations that need to be generated.
    */
    readonly numberOfOperations: number /*int*/
    /**
      Returns the number of operations whose generation is complete.
    */
    readonly numberOfCompleted: number /*int*/
    /**
      Returns a collection of all operations that need to be generated.
    */
    readonly operations: Operations
    /**
      Returns true if all operations are generated.
    */
    readonly isGenerationCompleted: boolean
    /**
      Returns the number of tasks of operations that need to be generated.
    */
    readonly numberOfTasks: number /*int*/
    /**
      Returns the number of tasks of operations whose generation is complete.
    */
    readonly numberOfCompletedTasks: number /*int*/
  }

  /**
    Object that represents the CAM environment of a Fusion document.
  */
  abstract class CAM extends core.Product {
    /**
      Returns the Setups collection that provides access to existing setups.
    */
    readonly setups: Setups
    /**
      This method is only valid for an additive setup and exports the default additive setup's models as a 3MF file. The 3MF also contains machine and support information.
      @remarks
      This property has been retired. Please use the ExportManager to export setups.
      @returns True on success, false on errors or wrong setup type
      @deprecated
    */
    export3MFForDefaultAdditiveSetup(filepath: string, addSimulationInfo?: boolean/* = false*/, simPostProcess?: boolean/* = false*/, simSplitSurrogates?: boolean/* = false*/, simKeepThickeningStructure?: boolean/* = false*/): boolean
    /**
      Generates or regenerates all the specified objects, including those nested in sub-folders or patterns.
      @param operations An Operation, Setup, Folder, or Pattern object. You can also use an ObjectCollection
      to specify multiple objects of any of the supported types.
      @returns Return GenerateToolpathFuture that includes the status of the operation generation.
    */
    generateToolpath(operations: core.Base): GenerateToolpathFuture
    /**
      Generates or regenerates all the operations in the document, including those nested in sub-folders or patterns.
      @param skipValid Option to skip valid operations and only regenerate invalid operations.
      @returns Return GenerateToolpathFuture that includes the status of operation generation.
    */
    generateAllToolpaths(skipValid: boolean): GenerateToolpathFuture
    /**
      Clears all the toolpaths for the specified objects, including those nested in sub-folders or patterns.
      @param operations An Operation, Setup, Folder, or Pattern object. You can also use and ObjectCollection
      to specify multiple objects of any combination of types.
      @returns Return true if successful.
    */
    clearToolpath(operations: core.Base): boolean
    /**
      Clears all the toolpaths in the document, including those nested in sub-folders or patterns.
      @returns Return true if successful.
    */
    clearAllToolpaths(): boolean
    /**
      Checks if the operations (including those nested in sub-folders or patterns) are valid and up to date.
      @param operations An Operation, Setup, Folder, or Pattern object. You can also use an ObjectCollection
      to specify multiple objects of any of the supported types.
      @returns Returns true if the operations are valid
    */
    checkToolpath(operations: core.Base): boolean
    /**
      Checks if all the operations (includes those nested in sub-folders or patterns) in the document are valid and up to date.
      @returns Returns true if the all operations are valid
    */
    checkAllToolpaths(): boolean
    /**
      Post all of the toolpaths (including those nested in sub-folders or patterns) for the specified objects.
      If post processing fails, an error message can be retrieved from the error log explaining the reason for the failure.
      @param operations An Operation, Setup, Folder, or Pattern object. You can also use an ObjectCollection
      to specify multiple objects of any of the supported types.
      @param input The PostProcessInput object that defines the post options and parameters.
      @returns Returns true if successful
      @deprecated
    */
    postProcess(operations: core.Base, input: PostProcessInput): boolean
    /**
      Post all of the toolpaths (includes those nested in sub-folders or patterns) in the document.
      If post processing fails, an error message can be retrieved from the error log explaining the reason for the failure.
      @param input The PostProcessInput object that defines the post options and parameters.
      @returns Returns true if successful.
      @deprecated
    */
    postProcessAll(input: PostProcessInput): boolean
    /**
      Generate the setup sheets for the specified objects
      @param operations An Operation, Setup, Folder, or Pattern object. You can also use an ObjectCollection
      to specify multiple objects of any of the supported types.
      @param format The document format for the setup sheet.  Valid options are HTMLFormat and ExcelFormat.
      Limitation: "ExcelFormat" can be used in windows OS only.
      @param folder The destination folder to locate the setup sheet documents in.
      @param openDocument An option to allow to open the document instantly after the generation. By default, the document is opened.
      @returns Returns true if successful
    */
    generateSetupSheet(operations: core.Base, format: SetupSheetFormats, folder: string, openDocument?: boolean/* = true*/): boolean
    /**
      Generates all of the setup sheets for all of the operations in the document
      @param format The document format for the setup sheet.  Valid options are HTMLFormat and ExcelFormat.
      Limitation: "ExcelFormat" can be used in windows OS only.
      @param folder The destination folder to locate the setup sheet documents in.
      @param openDocument An option to allow to open the document instantly after the generation. By default, the document is opened.
      @returns Returns true if successful
    */
    generateAllSetupSheets(format: SetupSheetFormats, folder: string, openDocument?: boolean/* = true*/): boolean
    /**
      Gets a collection containing all of the operations in the document.
      This includes all operations nested in folders and patterns.
    */
    readonly allOperations: core.ObjectCollection
    /**
      Gets the folder for temporary files.
    */
    readonly temporaryFolder: string
    /**
      Get the machining time for the specified objects.
      @param operations An Operation, Setup, Folder, or Pattern object. You can also use an ObjectCollection
      to specify multiple objects of any of the supported types.
      @param feedScale The feed scale value (%) to use.
      @param rapidFeed The rapid feed rate in centimeters per second.
      @param toolChangeTime The tool change time in seconds.
      @returns Returns a MachiningTime object that has properties holding the calculation results.
    */
    getMachiningTime(operations: core.Base, feedScale: number, rapidFeed: number, toolChangeTime: number): MachiningTime
    /**
      Returns the customGraphicsGroups object associated with the CAM product.
    */
    readonly customGraphicsGroups: fusion.CustomGraphicsGroups
    /**
      The CAM product has its own root component which has a single occurrence that
      references the Design root occurrence. This property returns this occurrence.
    */
    readonly designRootOccurrence: fusion.Occurrence
    /**
      Gets an array containing all the machines in the document.
    */
    readonly allMachines: Machine[]
    /**
      The SetupCreated event fires when a new setup is created.
    */
    readonly setupCreated: SetupEvent
    /**
      The setupDestroying event fires before a setup is destroyed.
    */
    readonly setupDestroying: SetupEvent
    /**
      The SetupChanged event fires when a setup is modified.
    */
    readonly setupChanged: SetupChangeEvent
    /**
      The SetupActivating event fires before a setup is activated.
    */
    readonly setupActivating: SetupEvent
    /**
      The SetupActivated event fires when a setup is activated.
    */
    readonly setupActivated: SetupEvent
    /**
      The SetupDeactivating event fires before a setup is deactivated.
    */
    readonly setupDeactivating: SetupEvent
    /**
      The SetupDeactivated event fires when a setup is deactivated.
    */
    readonly setupDeactivated: SetupEvent
    /**
      Returns the Export Manager which provides access to the functionality
      to export in various formats.
    */
    readonly exportManager: CAMExportManager
    /**
      Returns the collection of manufacturing models in the document.
    */
    readonly manufacturingModels: ManufacturingModels
    /**
      Generates a template for the specified Operations, Setups, or Folders and returns
      the template as an XML string.
      @param operations An Operation, Setup or Folder object from which to generate the template. You can also
      specify a collection of any combination of these object types.
      @returns Returns the template XML as a string.
    */
    generateTemplateXML(operations: core.Base): string
    /**
      Gets the document ToolLibrary. The ToolLibrary contains all tools used by any operation inside the document.
      Changes to the original ToolLibrary will not affect any operation because the document ToolLibrary is an
      independent copy.
    */
    readonly documentToolLibrary: DocumentToolLibrary
    /**
      Returns the collection of NC programs in the document.
    */
    readonly ncPrograms: NCPrograms
    /**
      Checks whether the models used by the operations have changed in the mean time
      and invalidates the affected operations if needed.
      Should be used for cases where the automatic detection does not work yet,
      for instance when design changes are expected before a Manufacture API call.
      Also recommended at the beginning of a script or the beginning of an event handler.
    */
    checkValidity(): void
    /**
      Gets the document StockMaterialLibrary. The StockMaterialLibrary contains all stock materials used by any setup inside the document.
      Changes to the original StockMaterialLibrary will not affect any setup because the document StockMaterialLibrary is an
      independent copy.
      You can only get a valid DocumentStockMaterialLibrary when you have access to Stock Materials private preview feature and enable the feature flag.
      @experimental
    */
    readonly documentStockMaterialLibrary: DocumentStockMaterialLibrary
  }

  /**
    Summarize state of measured inspection point.
    Compares the deviation from the nominal position, or the projected position
    (if using projection), to the contact position relative to the upper or lower tolerances.
    Further information can be found in the online help
    @hidden
  */
  const enum InspectionPointState {
    /**
      Within Tolerance. The deviation is between upper and lower tolerance.
    */
    WithinTolerance,
    /**
      Above Tolerance. The deviation is above the upper tolerance, possibly indicating that not
      enough material has been removed.
    */
    AboveTolerance,
    /**
      Below Tolerance. The deviation is below the lower tolerance, possibly indicating that too
      much material has been removed.
    */
    BelowTolerance,
    /**
      Point failed to project when using projection.
    */
    Unprojected,
  }

  /**
    Parent class for all ExportOptions objects giving access to the setup and file name used for the export.
  */
  abstract class CAMExportOptions extends core.Base {
    /**
      The file we want to export to. Needs to contain a valid path, as no intermediate folders are created.
    */
    fullFilename: string
    /**
      The export object we want to export. Depending on the actual export option, this might be geometry, an operation or a setup.
    */
    exportObject: core.Base
    /**
      Path to the thumbnail for the buildfile
    */
    thumbnailPath: string
    /**
      Method to check if the exporter implementation supports thumbnail
    */
    readonly isThumbnailSupported: boolean
    /**
      Gets the last encountered error message.
      When the CAMExportManager's executeWithExportFuture() method is used, this method only returns errors encoutered when setting up the export.
      Errors thrown afterwards can be retrieved via the CAMExportFuture object.
      When the CAMExportManager's execute() method is used, any error can be retrieved using this property.
      @returns Returns an empty string if no errors have been found.
    */
    readonly error: string
  }

  /**
    3MF export option. Available with all additive machines except Formlabs. Expects a setup as its export object.
  */
  abstract class CAM3MFExportOptions extends CAMExportOptions {
    /**
      Flag toggling if support information should be included in the exported file.
      Includes both support structures marked as open or closed support as well as meta data used in Netfabb.
      This option might not be available for all machine types.
      The default value is false.
      @remarks
      This property has been retired. Please use supportInclusion for setting how to include support.
      @deprecated
    */
    areSupportsIncluded: boolean
    /**
      Flag toggling if machine information should be included in the exported file.
      The machine information is only compatible with Netfabb.
      This option might not be available for all machine types.
      The default value is false.
    */
    isMachineInformationIncluded: boolean
    /**
      Flag toggling if simulation information should be included in the exported file.
      This option might not be available for all machine types.
      The default value is false.
    */
    isProcessSimulationDataIncluded: boolean
    /**
      Flag toggling if post processing of the simulation should be included.
      This option might not be available for all machine types.
      The default value is false.
    */
    isSimulationPostProcessingIncluded: boolean
    /**
      Flag toggling if surrogate supports used in the simulation should be split.
      This option might not be available for all machine types.
      The default value is false.
    */
    areSimulationSurrogatesSplit: boolean
    /**
      Flag toggling if thickening structures used for simulation should be kept.
      This option might not be available for all machine types.
      The default value is false.
    */
    areSimulationThickeningStructuresKept: boolean
    /**
      Class for setting the meta data options with in the 3mf export
    */
    readonly metadata: CAM3MFExportMetadataOptions
    /**
      Flag setting if support information should be included in the exported file.
      Includes both support structures marked as open or closed support as well as meta data used in Netfabb.
      This option might not be available for all machine types.
      The default value is NotIncluded.
    */
    supportInclusion: CAM3MFSupportInclusionType
    /**
      Flag toggling if volumetric data should be included in the exported file. The flag is only evaluated if the user has bought the product design extension.
      The default value is false.
    */
    isVolumetricDataIncluded: boolean
    /**
      Integer value representing the resolution of the volumetric data. The value is only evaluated if the user has bought the product design extension.
      The default value is 128.
    */
    volumetricDataResolution: number /*int*/
  }

  /**
    Export filter used by CAMAdditiveMachineBuildFileExportOptions.
  */
  abstract class CAMAdditiveBuildExportFilter extends core.Base {
    /**
      True if the export outputs multiple files.
      If so, fullFilename should point to a directory, not a file.
    */
    readonly isMultiFileExport: boolean
    /**
      The extension of the file format, including a leading "."
    */
    readonly extension: string
    /**
      The name of the file format. Might indicate whether a file format is binary or not.
    */
    readonly name: string
    /**
      The id of the file format.
    */
    readonly id: string
  }

  /**
    Additive buildfile export option. Available with all additive machines except for FFF and DED based machines.
    Currently picks the first export filter from the print setting's export filter list.
  */
  abstract class CAMAdditiveBuildExportOptions extends CAMExportOptions {
    /**
      Gets a list of available export filters from the setup's print setting.
      The export object must be set before using this function.
    */
    readonly exportFilters: CAMAdditiveBuildExportFilter[]
    /**
      Gets and sets the export filter to be used for the export.
      By default, this is the first entry in the print setting's filter list.
    */
    selectedExportFilterId: string
  }

  /**
    Export manager used to export the setup's models in one of the formats defined the ExportOptions objects.
    The export is currently restricted to additive setups only and the availability of the export option and its settings depends on the chosen machine.
  */
  abstract class CAMExportManager extends core.Base {
    /**
      Executes an export based on the export options.
      @param exportOptions The export options defining the export type and necessary meta data.
      @returns Returns true if the export finished successfully.
    */
    execute(exportOptions: CAMExportOptions): boolean
    /**
      Creates a new 3MF export option.
      @returns Returns new CAM3MFExportOptions.
    */
    create3MFOptions(): CAM3MFExportOptions
    /**
      Creates a new export option based on the print setting's export formats.
      FFF and DED machines are not supported, their export files are generated using posts.
      @returns Returns new CAMAdditiveBuildExportOptions.
    */
    createCAMAdditiveBuildExportOptions(): CAMAdditiveBuildExportOptions
    /**
      Executes an export based on the export options
      @param exportOptions The export options defining the export type and necessary meta data.
      @returns Returns a CAMExportFuture object if the export has started successfully.
    */
    executeWithExportFuture(exportOptions: CAMExportOptions): CAMExportFuture
  }

  /**
     Used to check the state and get back the results of an operation generation.
  */
  abstract class CAMExportFuture extends core.Base {
    /**
      Returns the export option used to define the export associated with this future object.
    */
    readonly exportOptions: CAMExportOptions
    /**
      Returns true if the export has finished generating.
    */
    readonly isGenerationCompleted: boolean
    /**
      Returns the progress as a percentage value between 0.0% and 100.0%.
    */
    readonly progress: number
    /**
      Gets the last encountered error message generated on the export thread.
      @returns Returns an empty string if no errors have been found.
    */
    readonly error: string
    /**
      Gets the last encountered warning message  generated on the export thread.
      @returns Returns an empty string if no warnings have been found.
    */
    readonly warning: string
  }

  /**
    Object returned when using the getMachiningTime method from the CAM class.
    Use the properties on this object to get the machining time results.
  */
  abstract class MachiningTime extends core.Base {
    /**
      Gets the feed distance in centimeters.
    */
    readonly feedDistance: number
    /**
      Get the total feed time in seconds.
    */
    readonly totalFeedTime: number
    /**
      Gets the calculated rapid distance in centimeters.
    */
    readonly rapidDistance: number
    /**
      Gets the total rapid feed time in seconds.
    */
    readonly totalRapidTime: number
    /**
      Gets the number of tool changes.
    */
    readonly toolChangeCount: number /*int*/
    /**
      Gets the total tool change time in seconds.
    */
    readonly totalToolChangeTime: number
    /**
      Gets the machining time in seconds.
    */
    readonly machiningTime: number
  }

  /**
    Collection that provides access to all of the existing setups in a document.
  */
  abstract class Setups extends core.Base {
    /**
      Function that returns the specified setup using an index into the collection.
      @param index The index of the item within the collection to return.  The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Setup | null
    /**
      Returns the setup with the specified name.
      @param name The name (as it appears in the browser) of the operation.
      @returns Returns the specified setup or null in the case where there is no setup with the specified name.
    */
    itemByName(name: string): Setup | null
    /**
      The number of setups in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the setup with the specified operation id.
      @param id The id of the operation.
      @returns Returns the specified setup or null in the case where there is no setup with the specified operation id.
    */
    itemByOperationId(id: number /*int*/): Setup | null
    /**
      Creates a new SetupInput object that is used to specify the input needed to create a new setup.
      @param type The type specifies the type of the setup that should be created.
      @returns Returns new SetupInput object.
    */
    createInput(type: OperationTypes): SetupInput
    /**
      Creates a new setup.
      @param input The input holds all the information needed to create a valid setup.
      @returns Returns newly created Setup instance.
    */
    add(input: SetupInput): Setup
  }

  /**
    Object that represents an setup creation parameters.
    The input-object can be used from the Setups.add method
    to instantiate a new setup
  */
  abstract class SetupInput extends core.Base {
    /**
      Name of the new setup.
      This is displayed in the browser tree and can be used to access the setup from Setups.
    */
    name: string
    /**
      Operation Type for the setup
    */
    readonly operationType: OperationTypes
    /**
      A list of models, where a model can be an Occurrence, BRepBody, or MeshBody.
      The returned array is connected to the SetupInput and can be added to directly
      without needing to create a new array, populate it, and assign it using this property,
      although, that is supported too.
    */
    models: core.Base[]
    /**
      StockMode for the setup.
    */
    stockMode: SetupStockModes
    /**
      An array of models, where a model can be an Occurrence, ManufacturingModel, BRepBody, or MeshBody.
      Setting this property, or adding the first object to the returned array will automatically
      set the stockMode to "SolidStock".
      The returned array is connected to the SetupInput and can be added to directly
      without needing to create a new array, populate it, and assign it using this property,
      although, that is supported too.
    */
    stockSolids: core.Base[]
    /**
      Set this value to enable the use of fixtures for this setup.
      To then set the fixture models themselves use the `fixtures` property.
    */
    fixtureEnabled: boolean
    /**
      An array of models that represent fixtures, where a model can be an Occurrence,
      BRepBody, or MeshBody.
      The returned array is connected to the SetupInput and can be added to directly
      without needing to create a new array, populate it, and assign using this property,
      although, that is supported too.
    */
    fixtures: core.Base[]
    /**
      Gets and sets the Machine associated with the setup.
    */
    machine: Machine
    /**
      Gets and sets the PrintSetting associated with the setup.
    */
    printSetting: PrintSetting
    /**
      Get all parameters for the setup to be created. Parameters are initialized by user defaults.
      Configure operation parameters before creation for a better performance.
    */
    readonly parameters: CAMParameters
    /**
      Get and set if data from the previous setup should be used when creating another setup.
      The data applied from the previous setup is machine information and the stock from the preceeding setup.
      By default this value is false.
    */
    isUsingPreviousSetupData: boolean
  }

  /**
    Object that represents an existing Setup.
  */
  abstract class Setup extends OperationBase {
    /**
      Gets the Operation Type.
      It can be MillingOperation, TurningOperation, JetOperation or AdditiveOperation.
    */
    readonly operationType: OperationTypes
    /**
      Gets if this setup is active.
    */
    readonly isActive: boolean
    /**
      Returns the Operations collection that provides access to existing operations
      in this setup.
    */
    readonly operations: Operations
    /**
      Returns the Folders collection that provides access to existing folders
      in this setup.
    */
    readonly folders: CAMFolders
    /**
      Returns the Patterns collection that provides access to existing patterns
      in this setup.
    */
    readonly patterns: CAMPatterns
    /**
      Returns a collection containing all of the immediate (top level) child operations, folders and patterns in this setup,
      in the order they appear in the browser.
    */
    readonly children: ChildOperationList
    /**
      Returns an ObjectCollection containing all of the operations in this setup.
      This includes all operations nested in folders and patterns.
    */
    readonly allOperations: core.ObjectCollection
    /**
      Gets and sets the input models associated with the setup. Passing in an empty ObjectCollection
      will remove all current inputs.  Valid collection items are Occurrence, BRepBody, or MeshBody.
    */
    models: core.ObjectCollection
    /**
      Gets and sets the fixtures associated with the setup, which are represented by an ObjectCollection
      of models, where a model can be an Occurrence, BRepBody, or MeshBody.
      To be able to set models as fixtures, the fixturesEnabled property has to be set first.
    */
    fixtures: core.ObjectCollection
    /**
      Gets and sets the stock solids associated with the setup, which are represented by an ObjectCollection
      of models, where a model can be an Occurrence, BRepBody, or MeshBody.
      StockMode has to be set to `SolidStock` otherwise this will throw an error.
    */
    stockSolids: core.ObjectCollection
    /**
      Gets and sets the Machine associated with the setup. The returned Machine is a transient copy, so the Machine needs to be set to the Setup again to apply any changes.
    */
    machine: Machine
    /**
      Create and add operations, folders or patterns from the specified template file to the end of this setup.
      @remarks
      This property has been retired. Please use createFromCAMTemplate2 in conjunction with a CreateFromCAMTemplateInput to create operations from a template file.
      @param templateFilePath The full path to the template file.
      @returns Returns the collection containing all of the operations, folders and patterns created from the template file.
      @deprecated
    */
    createFromTemplate(templateFilePath: string): core.ObjectCollection
    /**
      Create and add operations, folders or patterns from the specified template content XML to the end of this setup.
      @remarks
      This property has been retired. Please use createFromCAMTemplate2 in conjunction with a CreateFromCAMTemplateInput to create operations from a template file.
      @param templateXML The full XML content of the template.
      @returns Returns an array containing all of the operations, folders and patterns created from the template.
      @deprecated
    */
    createFromTemplateXML(templateXML: string): OperationBase[]
    /**
      Gets and sets the bodies associated with the setup.  Passing in an empty ObjectCollection
      will remove all current bodies.  Valid input is MeshBody and/or BRepBody objects.
    */
    stockMode: SetupStockModes
    /**
      Gets the Work Coordinate System associated with the setup as 4x4 matrix. From Matrix3D,
      Orientation and Origin data can be fetched.
    */
    readonly workCoordinateSystem: core.Matrix3D
    /**
      Sets this object as the default container.
      @returns Returns true if the activation was successful.
    */
    activate(): boolean
    /**
      Set this value to enable the use of fixtures for this setup.
      To then set the fixture models themselves use the `fixtures` property.
    */
    fixtureEnabled: boolean
    /**
      Create new operations, folders, or patterns from the specified CAMTemplate. They
      are added to the end of the parent setup.
      @remarks
      This property has been retired. Please use createFromCAMTemplate2 in conjunction with a CreateFromCAMTemplateInput to create operations from a template file.
      @param camTemplate The CAMTemplate object to use to create the new operation, folder, or pattern.
      @returns Returns an array containing all of the operations, folders and patterns created from the template.
      @deprecated
    */
    createFromCAMTemplate(camTemplate: CAMTemplate): cam.OperationBase[]
    /**
      Gets and sets the PrintSetting associated with the setup.
    */
    printSetting: PrintSetting
    /**
      Create new operations, folders, or patterns from the specified CAMTemplate. They
      are added to the end of the parent setup.
      @param input Input object that contains the template to create from and the generation mode.
      @returns Returns an array containing all of the operations, folders and patterns created from the template.
    */
    createFromCAMTemplate2(input: CreateFromCAMTemplateInput): cam.OperationBase[]
    /**
      Visibility manager for this setup.
    */
    readonly visibilityManager: SetupVisibilityManager
    /**
      Returns the additive container with the specified type.
      @param containerType The type of the container
      @returns Returns the specified container or null in the case where there is no container with the specified type.
    */
    additiveContainerByType(containerType: CAMAdditiveContainerTypes): CAMAdditiveContainer | null
    /**
      Gets/ and sets the Stock material associated with the setup.
      @experimental
    */
    stockMaterial: StockMaterial
  }

  /**
    List of locations representing folders in the library dialogs.
  */
  const enum LibraryLocations {
    /**
      Represents the local folder in the library.
    */
    LocalLibraryLocation,
    /**
      Represents the cloud folder in the library.
    */
    CloudLibraryLocation,
    /**
      Represents the network folder in the library.
      For internal use only.
    */
    NetworkLibraryLocation,
    /**
      Represents the online samples folder in the library.
      For internal use only.
    */
    OnlineSamplesLibraryLocation,
    /**
      Represents an external folder that is not in the library.
    */
    ExternalLibraryLocation,
    /**
      Represents the fusion 360 folder in the library.
    */
    Fusion360LibraryLocation,
  }

  /**
    Provides access to the collection of child operations, folders and patterns of an existing setup.
  */
  abstract class ChildOperationList extends core.Base {
    /**
      Returns the specified item using an index into the collection.
      @param index The index of the item within the collection to return.  The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): core.Base | null
    /**
      Returns the operation, folder or pattern with the specified name (the name seen in the browser).
      @param name The name of the operation, folder or pattern as seen in the browser.
      @returns Returns the specified item or null in the case where there is no item with the specified name.
    */
    itemByName(name: string): core.Base | null
    /**
      Gets the number of objects in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the operation, folder or pattern with the specified operation id.
      @param id The id of the operation, folder or pattern.
      @returns Returns the specified item or null in the case where there is no item with the specified operation id.
    */
    itemByOperationId(id: number /*int*/): core.Base | null
  }

  /**
    Collection that provides access to the folders within an existing setup, folder or pattern.
  */
  abstract class CAMFolders extends core.Base {
    /**
      Function that returns the specified folder using an index into the collection.
      @param index The index of the item within the collection to return.  The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CAMFolder | null
    /**
      Returns the folder with the specified name (as appears in the browser).
      @param name The name (as it appears in the browser) of the folder.
      @returns Returns the specified folder or null in the case where there is no folder with the specified name.
    */
    itemByName(name: string): CAMFolder | null
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the folder with the specified operation id.
      @param id The id of the folder.
      @returns Returns the specified folder or null in the case where there is no folder with the specified operation id.
    */
    itemByOperationId(id: number /*int*/): CAMFolder | null
    /**
      Creates a folder with the specified name and returns it as CAMFolder object.
      @param name The name (as it appears in the browser) of the folder.
      @returns Returns the newly created folder or null if folder can't be created.
    */
    addFolder(name: string): CAMFolder | null
  }

  /**
    Object that represents a folder in an existing Setup, Folder or Pattern.
  */
  abstract class CAMFolder extends OperationBase {
    /**
      Gets if this folder is active.
    */
    readonly isActive: boolean
    /**
      Returns the Operations collection that provides access to existing individual operations
      in this folder.
    */
    readonly operations: Operations
    /**
      Returns the Folders collection that provides access to existing folders
      in this folder.
    */
    readonly folders: CAMFolders
    /**
      Returns the Patterns collection that provides access to existing patterns
      in this folder.
    */
    readonly patterns: CAMPatterns
    /**
      Returns a collection containing all of the immediate (top level) child operations, folders and patterns in this folder
      in the order they appear in the browser.
    */
    readonly children: ChildOperationList
    /**
      Returns the parent Setup, Folder or Pattern for this Folder.
    */
    readonly parent: core.Base
    /**
      Gets a collection containing all of the operations in this folder.
      This includes all operations nested in folders and patterns.
    */
    readonly allOperations: core.ObjectCollection
    /**
      Creates and adds operations, folders or patterns from the specified template file to the end of this folder.
      @remarks
      This property has been retired. Please use createFromCAMTemplate2 in conjunction with a CreateFromCAMTemplateInput to create operations from a template file.
      @param templateFilePath The full path to the template file.
      @returns Returns the collection containing all of the operations, folders and patterns created from the template file.
      @deprecated
    */
    createFromTemplate(templateFilePath: string): core.ObjectCollection
    /**
      Creates and adds operations, folders or patterns from the specified template content XML to the end of this folder.
      @remarks
      This property has been retired. Please use createFromCAMTemplate2 in conjunction with a CreateFromCAMTemplateInput to create operations from a template file.
      @param templateXML The full XML content of the template.
      @returns Returns an array containing all of the operations, folders and patterns created from the template.
      @deprecated
    */
    createFromTemplateXML(templateXML: string): OperationBase[]
    /**
      Sets this object as the default container.
      @returns Returns true if the activation was successful.
    */
    activate(): boolean
    /**
      Creates and adds operations, folders or patterns from the specified CAMTemplate to the end of this folder.
      @remarks
      This property has been retired. Please use createFromCAMTemplate2 in conjunction with a CreateFromCAMTemplateInput to create operations from a template file.
      @param camTemplate The CAMTemplate object to apply
      @returns Returns an array containing all of the operations, folders and patterns created from the template.
      @deprecated
    */
    createFromCAMTemplate(camTemplate: CAMTemplate): cam.OperationBase[]
    /**
      Create new operations, folders, or patterns from the specified CAMTemplate. They
      are added to the end of the parent setup.
      @param input Input object that contains the template to create from and the generation mode.
      @returns Returns an array containing all of the operations, folders and patterns created from the template.
    */
    createFromCAMTemplate2(input: CreateFromCAMTemplateInput): cam.OperationBase[]
  }

  /**
    Collection that provides access to the patterns within an existing setup, folder or pattern.
  */
  abstract class CAMPatterns extends core.Base {
    /**
      Function that returns the specified pattern using an index into the collection.
      @param index The index of the item within the collection to return.  The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CAMPattern | null
    /**
      Returns the pattern with the specified name (as appears in the browser).
      @param name The name (as it appears in the browser) of the pattern.
      @returns Returns the specified pattern or null in the case where there is no pattern with the specified name.
    */
    itemByName(name: string): CAMPattern | null
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the pattern with the specified operation id.
      @param id The id of the pattern.
      @returns Returns the specified pattern or null in the case where there is no pattern with the specified operation id.
    */
    itemByOperationId(id: number /*int*/): CAMPattern | null
  }

  /**
    Object that represents a pattern in an existing Setup, Folder or Pattern.
  */
  abstract class CAMPattern extends CAMFolder {
  }

  /**
    Object that represents a hole recognition object in an existing Setup, Folder or Pattern.
  */
  abstract class CAMHoleRecognition extends OperationBase {
    /**
      Gets if this hole recognition is active.
    */
    readonly isActive: boolean
    /**
      Returns the Operations collection that provides access to existing individual operations
      in this hole recognition.
    */
    readonly operations: Operations
    /**
      Returns the Folders collection that provides access to existing folders
      in this hole recognition.
    */
    readonly folders: CAMFolders
    /**
      Returns a collection containing all of the immediate (top level) child operations, folders and patterns in this folder
      in the order they appear in the browser.
    */
    readonly children: ChildOperationList
    /**
      Returns the parent Setup, Folder or Pattern for this Folder.
    */
    readonly parent: core.Base
    /**
      Returns an array containing all of the operations in this hole recognition.
      This includes all operations nested in folders and patterns.
    */
    readonly allOperations: OperationBase[]
    /**
      Set this object as the default container.
      @returns Returns true if the activation was successful.
    */
    activate(): boolean
  }

  /**
    This class defines the properties that pertain to the settings and options required for posting a
    toolpath to generate a CNC file.  A PostProcessInput object is a required parameter for the
    postProcessAll() and postProcess() methods on the CAM class.
    @deprecated
  */
  abstract class PostProcessInput extends core.Base {
    /**
      Creates a new PostProcessInput object to be used as an input argument by the postProcess() and postProcessAll()
      methods on the CAM class for posting toolpaths and generating CNC files.
      @param programName The program name or number.
      If the post configuration specifies the parameter programNameIsInteger = true, then the program name must be a number.
      @param postConfiguration The full filename (including the path) to the post configuration file (.cps)
      The post config file can be stored in any path but for convenience you can use the genericPostFolder or the personalPostFolder property on the CAM class to specify
      the path if your .cps file is stored in either of those locations.  You must add a forward slash (this works for Mac or Windows) to the path defined by these folder
      properties before the filename (e.g. postConfiguration = cam.genericPostFolder + '/' + 'fanuc.cps')
      @param outputFolder The path for the existing output folder where the .cnc files will be located.  This method will create the specified output folder if it does not already exist.
      It is not necessary to add a slash to the end of the outputFolder path.  You should use forward slashes in your path definition if you want your script to run on both Mac and Windows.
      @param outputUnits The units option for the CNC output.
      Valid options are DocumentUnitsOutput, InchesOutput or MillimetersOutput
      @returns Returns the newly created PostProcessInput object or null if the creation failed.
    */
    static create(programName: string, postConfiguration: string, outputFolder: string, outputUnits: PostOutputUnitOptions): PostProcessInput | null
    /**
      Gets and sets the program name or number.
      If the post configuration specifies the parameter programNameIsInteger = true, then the program name must be a number.
    */
    programName: string
    /**
      Gets and sets the program comment.  The default value for this property is an empty string ("").
    */
    programComment: string
    /**
      Gets and sets the full filename (including the path) for the post configuration file (.cps)
    */
    postConfiguration: string
    /**
      Gets and sets the path for the output folder where the .cnc files will be located.
    */
    outputFolder: string
    /**
      Gets and sets the units option for the CNC output.
      Valid options are DocumentUnitsOutput, InchesOutput or MillimetersOutput
    */
    outputUnits: PostOutputUnitOptions
    /**
      Gets and sets the option if opening the CNC file with the editor after it is created.
      The default value for this property is true.
    */
    isOpenInEditor: boolean
    /**
      Gets and sets that operations may be reordered between setups to minimize the number of tool changes.
      Operations within each setup will still be executed in the programmed order.
      This is commonly used for tombstone machining where you have multiple setups.
      The default value for this property is false.
    */
    areToolChangesMinimized: boolean
    /**
      Gets and sets the list of post properties.
      Each property has a string name and a ValueInput object.
      The default value for this is an empty NamedValues.
    */
    postProperties: core.NamedValues
  }

  /**
    List of the valid options for the outputUnit property on a PostProcessInput object .
  */
  const enum PostOutputUnitOptions {
    /**
      Post the toolpath in the document units
    */
    DocumentUnitsOutput,
    /**
      Post the toolpath in inches
    */
    InchesOutput,
    /**
      Post the toolpath in millimeters
    */
    MillimetersOutput,
  }

  /**
    List of the formats to choose from when generating setup sheets
  */
  const enum SetupSheetFormats {
    /**
      Generates an HTML document
    */
    HTMLFormat,
    /**
      Generates an Excel document
    */
    ExcelFormat,
  }

  /**
    A SetupEvent represents a setup related event.  For example, SetupCreated or SetupDestroying.
  */
  abstract class SetupEvent extends core.Event {
    /**
      Add a handler to be notified when the file event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: SetupEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: SetupEventHandler): boolean
  }

  /**
    A SetupChangeEvent represents a setup related change event.  It is used for SetupChanged notifications.
  */
  abstract class SetupChangeEvent extends core.Event {
    /**
      Add a handler to be notified when the file event occurs.
      @param handler The handler object to be called when this event is fired.
      @returns Returns true if the addition of the handler was successful.
    */
    add(handler: SetupChangeEventHandler): boolean
    /**
      Removes a handler from the event.
      @param handler The handler object to be removed from the event.
      @returns Returns true if removal of the handler was successful.
    */
    remove(handler: SetupChangeEventHandler): boolean
  }

  /**
    The SetupEventArgs provides information associated with a setup event.
  */
  abstract class SetupEventArgs extends core.EventArgs {
    /**
      Provides access to the setup. Can be null in the case
      where the event is fired before the setup has been created or after it has been deleted.
    */
    readonly setup: Setup
  }

  /**
    List of setup change event types.
  */
  const enum SetupChangeEventType {
    /**
      Arbitrary change
    */
    Arbitrary,
    /**
      Selection of print setting
    */
    PrintSettingSelection,
  }

  /**
    The SetupChangeEventArgs provides information associated with a change event of a setup.
  */
  abstract class SetupChangeEventArgs extends core.EventArgs {
    /**
      Provides access to the setup. Can be null in the case
      where the event is fired before the setup has been created or after it has been deleted.
    */
    readonly setup: Setup
    /**
      Provides access to an information string.
      The optional string may contain additional information about the change.
    */
    readonly info: string
    /**
      The type specifies the actual change.
    */
    readonly type: SetupChangeEventType
  }

  /**
    The SetupEventHandler is a client implemented class that can be added as a handler to a
    SetupEvent.
  */
  abstract class SetupEventHandler extends core.EventHandler {
    /**
      The function called by CAM when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: SetupEventArgs): void
  }

  /**
    The SetupChangeEventHandler is a client implemented class that can be added as a handler to a
    SetupChangeEvent.
  */
  abstract class SetupChangeEventHandler extends core.EventHandler {
    /**
      The function called by CAM when the associated event is fired.
      @param eventArgs Returns an object that provides access to additional information associated with the event.
    */
    notify(eventArgs: SetupChangeEventArgs): void
  }

  /**
    List of setup stock modes.
  */
  const enum SetupStockModes {
    /**
      Fixed Size Box
    */
    FixedBoxStock,
    /**
      Relative Size Box
    */
    RelativeBoxStock,
    /**
      Fixed Size Cylinder
    */
    FixedCylinderStock,
    /**
      Relative Size Cylinder
    */
    RelativeCylinderStock,
    /**
      Fixed Size Tube
    */
    FixedTubeStock,
    /**
      Relative Size Tube
    */
    RelativeTubeStock,
    /**
      From Solid
    */
    SolidStock,
    /**
      From Preceding Setup
    */
    PreviousSetupStock,
  }

  /**
    Class providing read and write access to meta data of a 3MF file.
  */
  abstract class CAM3MFExportMetadataOptions extends core.Base {
  }

  /**
    Object that contains the settings used by createFromCAMTemplate.
  */
  abstract class CreateFromCAMTemplateInput extends core.Base {
    /**
      Creates an empty input object to be passed into createFromCAMTemplate
      @returns The newly created input object.
    */
    static create(): CreateFromCAMTemplateInput
    /**
      Gets and sets the template to be instantiated.
    */
    camTemplate: CAMTemplate
    /**
      Gets and sets the mode to be used for generation. Defaults to Skip Generation.
    */
    mode: AutomaticGenerationModes
  }

  /**
    Sets how the support should be included into the 3mf
    Options are not to be included, as 3mf support object or as 3mf model object
  */
  const enum CAM3MFSupportInclusionType {
    /**
      Don't include the support.
    */
    NotIncluded,
    /**
      Include the support as 3mf support object
    */
    IncludeAsSupportType,
    /**
      Include the support as 3mf model object
    */
    IncludeAsModelType,
  }

  /**
    Enum specifying the types of additive containers available in Fusion.
    Some additive containers not listed here are available via other API classes, i.e. PrintSetting
  */
  const enum CAMAdditiveContainerTypes {
    /**
      Contains all support operations.
    */
    SupportCAMAdditiveContainerType,
    /**
      Contains all optimized orientation operations.
    */
    OptimizedOrientationCAMAdditiveContainerType,
    /**
      Contains all body presets used in the setup. Containers of this type cannot be deleted.
    */
    BodyPresetCAMAdditiveContainerType,
    /**
      Contains all additive process simulation studies. Containers of this type cannot be deleted.
    */
    AdditiveProcessSimulationCAMAdditiveContainerType,
  }

  /**
    Object that represents an additive container in an existing Setup.
    Note: All additive containers cannot be duplicated and depending on the type, some cannot be deleted.
  */
  abstract class CAMAdditiveContainer extends OperationBase {
    /**
      Returns the parent Setup.
    */
    readonly parent: core.Base
    /**
      Gets a collection containing all of the operations in this container.
      This includes all operations nested in folders and patterns.
    */
    readonly allOperations: core.ObjectCollection
  }

  /**
    State of the event being raised.
    @hidden
  */
  const enum CAMEventState {
    CAMEventStateSuccessful = 0,
    CAMEventStateDeferred = 1,
    CAMEventStateErrorMissingOperation = 2,
    CAMEventStateErrorMissingDocument = 4,
    CAMEventStateErrorOther = 8,
  }

  /**
    Type of the event. This serves to distinguish between event types if users register the same handler for multiple events.
    @hidden
  */
  const enum OperationBaseEventTypes {
    ErrorOperationBaseEventType,
    CommandStartedOperationBaseEventType,
    GenerationStartedOperationBaseEventType,
    ChangeOperationBaseEventType,
    GenerationStartingOperationBaseEventType,
    CommandButtonPressedOperationBaseEventType,
  }

  /**
    CAMEventChangeType defining what kind of change API users can expect in the event.
    @hidden
  */
  const enum CAMEventChangeType {
    /**
      Error change type used in case an error occurs.
    */
    ErrorCAMEventChangeType = 0,
    /**
      Change type used if a change is triggered in the UI or API that exclusively affects the tool.
      I.e. a tool change via the "Edit Tool" command or while an Operation Command is open
    */
    ToolCAMEventChangeType = 1,
    /**
      Change type used if a change is triggered in the UI or API that exclusively affects the tool.
      I.e. a tool change via the "Edit Tool" command or while an Operation Command is open
    */
    ToolSwitchCAMEventChangeType = 2,
    /**
      Change type used if a change is triggered in the UI or API that exclusively affects the name of an OperationBase
    */
    NameCAMEventChangeType = 4,
    /**
      Change type used if a change is triggered in the UI or API that exclusively affects parameters.
    */
    ParameterCAMEventChangeType = 8,
  }

  /**
    The CAMTemplateLibrary provides access to templates. Using this object you can import templates
    and get existing templates using a URL.
  */
  abstract class CAMTemplateLibrary extends CAMLibrary {
    /**
      Import a given template at a specific location. The template will be stored in the library. Throws an error if the given URL is read-only.
      @param camTemplate The template that should be imported.
      @param destinationUrl The URL to the folder where to save the template.
      @returns Returns the URL of the newly imported template, or null if the import failed.
    */
    importTemplate(camTemplate: CAMTemplate, destinationUrl: core.URL): core.URL | null
    /**
      Update a template in the library. The library substitutes the existing template at the URL by given template. Throws an error if the URL does not already point to an existing template.
      If the name member of the CAMTemplate doesn't match the name portion of the URL then this will include a rename operation and the returned URL will reflect the new name.
      @param camTemplate The template that should be persisted.
      @param url The URL to the existing template in the library that should be updated.
      @returns Returns the URL of the updated template, or null if the update failed.
    */
    updateTemplate(camTemplate: CAMTemplate, url: core.URL): core.URL | null
    /**
      Gets a specific template specified by the given URL. Returns null if the specified template does not exist.
      @param url The URL to the template to be fetched.
      @returns Returns the template for a valid URL, returns null otherwise.
    */
    templateAtURL(url: core.URL): CAMTemplate | null
    /**
      Get all templates by the given parent folder URL. Returns null if there is no folder at the URL.
      @param url The URL of the folder to get the templates from.
      @returns Returns an array of templates contained within the specified folder URL. Returns null if the URL is not valid.
    */
    childTemplates(url: core.URL): CAMTemplate[] | null
  }

  /**
    A CAMTemplateOperationInput provides access to Operation Template parameters for editing, in much the same way as
    OperationInput provides access to Operation parameters for editing. Operation Template parameters are slightly different
    from Operation parameters, for instance in terms of how tools and geometry selections can be specified, so an OperationInput
    for a given strategy type has a slightly different set of parameters from a CAMTemplateOperationInput for that same strategy type.
    @experimental
  */
  abstract class CAMTemplateOperationInput extends core.Base {
    /**
      Get the current strategy
    */
    readonly strategy: string
    /**
      Get all parameters for the current strategy. Parameters are initialized by user defaults.
      Configure operation parameters before creation for a better performance.
    */
    readonly parameters: CAMParameters
    /**
      Optionally specify the tool used by the operation. The ToolLibraries allows the access to Local and Fusion tools.
    */
    tool: Tool
    /**
      Optionally specify the preset of the tool. If no preset is specified, the operation gets its default feed and speed.
      The Tool provides access to available presets. Use one of those presets to override the default.
      An invalid preset will cause a failure during the creation of the operation.
    */
    toolPreset: ToolPreset
    /**
      Optionally specify the display name that appears in the browser-tree to override the default.
    */
    displayName: string
    /**
      Get the number of geometry indices that can be selected.
    */
    readonly geometryIndexCount: number /*int*/
    /**
      Get whether a geometry index is selected.
    */
    isGeometryIndexEnabled(index: number /*int*/): boolean
    /**
      Set whether a geometry index is selected.
    */
    setGeometryIndexEnabled(index: number /*int*/, enabled: boolean): void
  }

  /**
    A list of CAMTemplateOperationInput.
    These are stored 'by value' -- get() returns a copy of the element at the given index,
    and set() will overwrite the element at the given index with a copy of the given element.
    @experimental
  */
  abstract class CAMTemplateOperations extends core.Base {
    /**
      The number of items in the list.
    */
    readonly count: number /*int*/
    /**
      Add an item to the list.
      @param input This element will be copied to the end of the list. Must come from get() or makeInput().
    */
    add(input: CAMTemplateOperationInput): void
    /**
      Return a copy of an element.
      @param operationIndex Index of the element to copy.
    */
    get(operationIndex: number /*int*/): CAMTemplateOperationInput
    /**
      Set the element at the given index.
      @param operationIndex Index of the element to overwrite
      @param input The element will be overwritten with a copy of this element. Must come from get() or makeInput().
    */
    set(operationIndex: number /*int*/, input: CAMTemplateOperationInput): void
    /**
      Make a CAMTemplateOperationInput of the given strategy type which is compatible with add() and set().
    */
    makeInput(strategyType: string): CAMTemplateOperationInput
  }

  /**
    Object that represents a template for a set of operations. These can be created from operations,
    optionally stored to files or in a library. The template can be used to re-create those operations
    in another document.
  */
  abstract class CAMTemplate extends core.Base {
    /**
      Creates a CAMTemplate from an XML string. Invalid template XML will produce errors
      @param xml The XML representation to act as a base for creating a template.
      @returns Returns the newly created template.
    */
    static createFromXML(xml: string): CAMTemplate
    /**
      Create a CAMTemplate from a list of Operations
      @param operations An array of operations to bundle into a template.
      @returns Returns the newly created template.
    */
    static createFromOperations(operations: Operation[]): CAMTemplate
    /**
      Create a hole CAMTemplate from a list of hole operations. Hole templates may be used in Hole Recognition
      @param operations A list of operations to bundle into a template. Only 2D Adaptive, 2D Chamfer, 2D Contour, 2D Pocket, Bore,
      Circular, Drill and Thread operations are allowed in hole templates. Passing in other operation types will throw an error.
      @returns Returns the newly created template.
    */
    static createHoleTemplateFromOperations(operations: Operation[]): CAMTemplate
    /**
      Create a CAMTemplate from a file on disk, i.e. Import the template file. Invalid files will produce errors
      @param filePath The path to a template file.
      @returns Returns the newly created template.
    */
    static createFromFile(filePath: string): CAMTemplate
    /**
      Save the CAMTemplate to a file
      @param filePath The path to the file you wish to save
      @returns Returns true if the template was saved successfully, false otherwise.
    */
    save(filePath: string): boolean
    /**
      Gets and sets the name of the template.
    */
    name: string
    /**
      Gets and sets the description of the template.
    */
    description: string
    /**
      Whether or not this is a hole template
    */
    readonly isHoleTemplate: boolean
    /**
      Convert hole signature to XML. This will be empty if this is not
      a hole template, or if there is no signature.
      @experimental
    */
    getHoleSignatureXML(): string
    /**
      Provide an XML snippet to specify a hole signature. This will
      have no effect if this is not a hole template. This will fail if
      the provided snippet is not valid.
      @returns This will return true on success, false on failure.
      @experimental
    */
    setHoleSignatureXML(xmlSnippet: string): boolean
    /**
       Expose operations.
      @experimental
    */
    operations: CAMTemplateOperations
    /**
      Create an empty CAMTemplate
      @returns Returns the newly created template.
      @experimental
    */
    static createEmpty(): CAMTemplate
  }

  /**
    The custom strategy command definitions to specify the entry points in the UI.
    @hidden
  */
  const enum StrategyRegistrationIssues {
    /**
      Skips all non critical issues by not adding conflicting and unsupported parameters.
    */
    SkipAll_StrategyRegistrationIssues,
    /**
      Skips all non critical issues, but cancels the registration when trying to add parameters with the same name.
    */
    CancelOnParameterCollisions_StrategyRegistrationIssues,
    /**
      Skips all non critical issues, but cancels the registration when trying to add metaparameters with the same name.
    */
    CancelOnMetaparameterCollisions_StrategyRegistrationIssues,
    /**
      Skips all non critical issues, but cancels the registration when trying to add unsuppored metaparameters.
    */
    CancelOnUnsupporedMetaparameters_StrategyRegistrationIssues,
    /**
      Cancels the registration on any detected issue.
    */
    CancelOnAll_StrategyRegistrationIssues,
  }

  /**
    Enum for the identifiers of generated results an OperationBase object can have
  */
  const enum GeneratedDataType {
    /**
      Optimized orientation identifier
    */
    OptimizedOrientationGeneratedDataType,
  }

  /**
    Collection can hold multiple GeneratedData results for a particular operation, setup or folder.
    In the case of folders and setups, the data associated with the child operations is not added to the collection.
    In most cases folders and setups will not have any items in the collection, whereas most operations will only have one.
  */
  abstract class GeneratedDataCollection extends core.Base {
    /**
      Gets the desired generated data at the given index.
    */
    item(index: number /*int*/): GeneratedData
    /**
      Gets the desired generated data. Generated result objects are unique for a given identifier, but may contain any number of child objects.
    */
    itemByIdentifier(resultType: GeneratedDataType): GeneratedData
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Parent class of all generated data classes. Acts like a void pointer for the entries in the OperationBase.GeneratedDataCollection property.
  */
  abstract class GeneratedData extends core.Base {
  }

  /**
    Collection of OptimizedOrientationResult instances associated with a given optimized orientation object inside an additive setup.
    The number of instances is the number of results given and the initial orientation result.
    The initial orientation will contain the orientation matrix, but not the other values calculated by the orientation operation.
    Setting an OptimizedOrientationResult as the currentOrientationResult will transform the Occurrence assigned to the orientation operation.
  */
  abstract class OptimizedOrientationResults extends GeneratedData {
    /**
      Gets the desired orientation result at the given index. The list is ordered given the orientation parameters of the parent orientation operation.
    */
    item(index: number /*int*/): OptimizedOrientationResult
    /**
      Gets the initial orientation of the component before any result has been applied.
    */
    readonly initialOrientationResult: OptimizedOrientationResult
    /**
      Gets or sets the desired OrientationResult.
      When setting, the orientation matrix is applied to the component selected in the parent orientation operation, possibly invalidating other operations.
    */
    currentOrientationResult: OptimizedOrientationResult
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The orientation result instance.
    Contains properties that can be used to create a custom ranking and the orientation matrix.
    The calculated ranking is based on the orientation operation's ranking priorities.
  */
  abstract class OptimizedOrientationResult extends core.Base {
    /**
      The volume of the support hull below the oriented part.
      The value is given in cubic centimeters
    */
    readonly supportVolume: number
    /**
      The shadow area of the support hull below the oriented part.
      The value is given in squared centimeters
    */
    readonly supportArea: number
    /**
      The volume of the bounding box aligned to the world coordinate system of the oriented part.
      The value is given in cubic centimeters
    */
    readonly boundingBoxVolume: number
    /**
      The resulting height of the oriented part.
      The value is given in centimeters
    */
    readonly partHeight: number
    /**
      The height of the center of gravity of the oriented part.
      The value is given in centimeters
    */
    readonly centerOfGravityHeight: number
    /**
      The value which the initial ordering is based on. Calculated based on the properties above by the orientation operation.
    */
    readonly rankingValue: number
    /**
      The transformation matrix to be applied onto the occurrence's existing transformation at the time of the calculation.
    */
    readonly transformation: core.Matrix3D
  }

  /**
    Collection for all curve selections to be passed to a CadContours2DParameterValue object.
    This is a read-only container. It returns the curve selections associated with the parent parameter value object, but does not write to it.
    To apply changes done to the collection and the selections it contains, CadContours2DParameterValue.applyCurveSelections() needs to be called.
  */
  abstract class CurveSelections extends core.Base {
    /**
      Function that returns the specified curve selection object using an index into the collection.
      @param index The index of the item within the collection to return.  The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CurveSelection | null
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Clears all entries.
    */
    clear(): void
    /**
      Creates a new chain selection and adds it to the end of the collection.
      @returns Returns newly created ChainSelection.
    */
    createNewChainSelection(): ChainSelection
    /**
      Creates a new face contour selection and adds it to the end of the collection.
      @returns Returns newly created FaceContourSelection.
    */
    createNewFaceContourSelection(): FaceContourSelection
    /**
      Creates a new silhouette selection and adds it to the end of the collection.
      @returns Returns newly created SilhouetteSelection.
    */
    createNewSilhouetteSelection(): SilhouetteSelection
    /**
      Creates a new pocket selection and adds it to the end of the collection.
      @returns Returns newly created PocketSelection.
    */
    createNewPocketSelection(): PocketSelection
    /**
      Creates a new sketch selection and adds it to the end of the collection.
    */
    createNewSketchSelection(): SketchSelection
    /**
      Creates a new pocket recognition selection and adds it to the end of the collection.
    */
    createNewPocketRecognitionSelection(): PocketRecognitionSelection
    /**
      Function that removes the specified curve selection object using an index in the collection.
      @param index The index of the item within the collection to remove.  The first item in the collection has an index of 0.
    */
    remove(index: number /*unsigned int*/): void
    /**
      Function that removes the specified curve selection object from the collection.
      @param selection The item within the collection to remove.  Throws an exception if the curve selection is not part of the given selection.
    */
    removeByObject(selection: CurveSelection): void
  }

  /**
    Base parent class for all selection classes. All selections are currently restricted to B-Rep entities or sketches.
  */
  abstract class GeometrySelection extends core.Base {
    /**
      Returns the resulting value of the selection. In general, this returns the input selection, but child classes can override the return value if needed.
      Refer to the child classes comments for further details. The collection may contain duplicates.
      For OperationInputs, the return value may not be the same as for Operations, as additional geometry selected by child classes is not evaluated for OperationInputs.
    */
    readonly value: core.Base[]
    /**
      Gets if warnings were encountered when applying the selection to a parent.
    */
    readonly hasWarning: boolean
    /**
      Gets if errors were encountered when applying the selection to a a parent.
    */
    readonly hasError: boolean
    /**
      Gets the last warning string encountered after the selection was applied to a parent.
    */
    readonly warning: string
    /**
      Gets the last warning string encountered after the selection was applied to a parent.
    */
    readonly error: string
  }

  /**
    Base class of all curve based geometry selections.
  */
  abstract class CurveSelection extends GeometrySelection {
    /**
      Get or set the value of the input geometry.
      If the value originates from a component instead of an occurrence, or an occurrence outside of the CAM environment, then the subpath is checked against the CAM model tree.
      For some child classes, this may be the same as the value property, but might also consist of fewer elements.
      Valid elements depend on the capabilities of the derived class. An exception is thrown if the matching fails or the given entity does not match the expected type.
    */
    inputGeometry: core.Base[]
  }

  /**
    Enum for the types of extension methods for a chain selection. It defines how open curves are extended on their open end.
  */
  const enum ExtensionMethods {
    /**
      Tangent type of extension.
    */
    TangentExtensionMethod,
    /**
      Closest boundary type of extension.
    */
    ClosestBoundaryExtensionMethod,
    /**
      Parallel type of extension.
    */
    ParallelExtensionMethod,
  }

  /**
    Enum for types of extension capping.
  */
  const enum ExtensionTypes {
    /**
      Caps the extended curves at the stock.
    */
    BoundaryExtensionType,
    /**
      Caps the extended curves depending on the startExtensionLength and endExtensionLength properties.
    */
    DistanceExtensionType,
  }

  /**
    Represents a chain type of curve selection. Allows B-Rep edges and sketch geometry for the inputGeometry property.
    The automatic tool side detection is currently disabled when using the API, thus the side is determined
    based on the direction of the first edge and the z-axis of the tool orientation.
    This class overrides the value property of its GeometrySelection parent to return the result edge selection.
    The result may contain more edges than the input if gaps between the desired start and end edge were automatically filled.
  */
  abstract class ChainSelection extends CurveSelection {
    /**
      Property to get or set if an open contour should be closed or not.
      If true and the input does not specify a closed contour, additional curve segments will be generated to close the contour.
    */
    isOpen: boolean
    /**
      Property to specify if the underlying CadContours2DParameterValue allows open contours.
      Some examples of some open contours are adaptive clearing 3d and swarf. And, some examples
      of closed contours are face and machining boundary.
    */
    readonly isOpenAllowed: boolean
    /**
      Property to control if the curve is reverted or not. The curve needs to be reverted,
      if Fusion's guess does not match the user's expectation.
      The initial tool placement depends on the first input edge or sketch line and the height
      of the bordering faces or sketch boundaries, with the tool being placed outside of the higher face or sketch boundary.
    */
    isReverted: boolean
    /**
      Property that gets and sets extension method to use. The default is TangentExtension.
      Only applicable to open contours.
    */
    extensionMethod: ExtensionMethods
    /**
      Property that gets and sets the desired extension type method. The default is DistanceCap.
      This is only applicable to open contours.
    */
    extensionType: ExtensionTypes
    /**
      Property that gets and sets the length of the extension of an open curve at the start of the chain.
      This is only applicable to open contours and when DistanceCap is chosen as the extension cap.
    */
    startExtensionLength: number
    /**
      Property that gets and sets the length of the extension of an open curve at the end of the chain.
      The value is specified in centimeters. This is only applicable to open contours and when DistanceCap
      is chosen as the extension cap.
    */
    endExtensionLength: number
  }

  /**
    Enum to define the type of loop for a face contour selection.
  */
  const enum LoopTypes {
    /**
      Specifies inside and outside loops of the selected geometry.
    */
    AllLoops,
    /**
      Specifies only the outer contours of the loop. There is only one outer contour per entity.
    */
    OnlyOutsideLoops,
    /**
      Specifies only the inner contours. There can be none or any number of inner contours per entity.
    */
    OnlyInsideLoops,
  }

  /**
    Enum for the order of loops.
  */
  const enum SideTypes {
    /**
      AlwaysOutside
    */
    AlwaysOutsideSideType,
    /**
      AlwaysInside
    */
    AlwaysInsideSideType,
    /**
      StartOutside has the order outside - inside - outside ...
    */
    StartOutsideSideType,
    /**
      StartInside has the order inside - outside - inside ...
    */
    StartInsideSideType,
  }

  /**
    Represents a silhouette type of curve selection. Allows BRepBody selections for the input geometry.
    Overrides the GeometrySelection's the value property to include setup bodies if isSetupModelSelected is set to true and the selection has been applied.
    The results may contain duplicates.
  */
  abstract class SilhouetteSelection extends CurveSelection {
    /**
      Desired loop type. The default is AllLoops.
    */
    loopType: LoopTypes
    /**
      Desired side type. The default is StartOutside.
    */
    sideType: SideTypes
    /**
      Flag to include all B-Rep bodies set as the setup models.
    */
    isSetupModelSelected: boolean
    /**
      The distance the silhouette can differ from the model.
      This helps in creating a silhouette in situations where one cannot be created because of open contours.Generally, the tolerance value you use should be smaller than or equal to the machining tolerance.
    */
    silhouetteTolerance: number
  }

  /**
    Represents a face type of curve selection. It allows BRepFace objects for the input geometry.
    Overrides the GeometrySelection's value method to include other faces if the isSelectingSamePlaneFaces property is true and the selection has been applied.
    The result of the value property call may contain duplicates.
  */
  abstract class FaceContourSelection extends CurveSelection {
    /**
      Property to get and set the desired loop type. The default is AllLoops.
    */
    loopType: LoopTypes
    /**
      Property to get and set the desired side type. The default is StartOutside.
    */
    sideType: SideTypes
    /**
      Property to get and set if all planar faces lying in the same plane as the selected face should be automatically selected as well.
    */
    isSelectingSamePlaneFaces: boolean
  }

  /**
    Pocket type for a curve selection. Allows planar BREP face selections for the input geometry.
    Overrides the GeometrySelection's the value property to include other faces if isSelectingSamePlaneFaces is set to true and the selection has been applied.
    The result of the value property call may contain duplicates.
    Note: selecting arbitrary faces, only planar faces are actually added to the list of faces to work with.
  */
  abstract class PocketSelection extends CurveSelection {
    /**
      The desired extension method. TangentExtension by default.
    */
    extensionMethod: ExtensionMethods
    /**
      True if all planar faces lying in the same plane as the selected face should be automatically selected as well.
      False by default.
    */
    isSelectingSamePlaneFaces: boolean
  }

  /**
    Represents a sketch curve selection. It allows entire sketches for the input geometry.
    The result of the value property call may contain duplicates.
  */
  abstract class SketchSelection extends CurveSelection {
    /**
      Property to get and set the desired loop type. The default is AllLoops.
    */
    loopType: LoopTypes
    /**
      Property to get and set the desired side type. The default is StartOutside.
    */
    sideType: SideTypes
  }

  /**
    Pocket type curve selection. It searches for pockets matching the criteria on the selected bodies
    The result of the value property call may contain duplicates.
    See also RecognizedPockets for the ability to analyze the pockets
  */
  abstract class PocketRecognitionSelection extends CurveSelection {
    /**
      Flag to include all B-Rep bodies set as the setup models.
    */
    isSetupModelSelected: boolean
    /**
      Flag to interpret holes as pockets.
    */
    areHolesIncluded: boolean
    /**
      Lower bound for the diameter for the hole detection. It can only be set if areHoldeIncluded is set to true.
    */
    minimumHoleDiameter: number
    /**
      The smallest corner radius that can appear in a pocket to machine.
    */
    minimumCornerRadius: number
    /**
      The largest corner radius that can appear in a pocket to machine.
    */
    maximumCornerRadius: number
    /**
      The shallowest pocket (measured from top to bottom) to machine.
    */
    minimumPocketDepth: number
    /**
      The deepest pocket (measured from top to bottom) to machine.
    */
    maximumPocketDepth: number
  }

  /**
    Collection for all arrange selections to be passed to a CAMArrangeParameterValue object.
    This is a read-only container. It returns the arrange selections associated with the parent parameter value object, but does not write to it.
    To apply changes done to the collection and the selections it contains, CAMArrangeParameterValue.applyArrangeSelections() needs to be called.
  */
  abstract class ArrangeSelections extends core.Base {
    /**
      Function that returns the specified arrange selection object using an index into the collection.
      @param index The index of the item within the collection to return.  The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): ArrangeSelection | null
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Clears all entries.
    */
    clear(): void
    /**
      Function that removes the specified arrange selection object using an index in the collection.
      @param index The index of the item within the collection to remove.  The first item in the collection has an index of 0.
    */
    remove(index: number /*unsigned int*/): void
    /**
      Function that removes the specified arrange selection object from the collection.
      @param selection The item within the collection to remove.  Throws an exception if the arrange selection is not part of the given selection.
    */
    removeByObject(selection: ArrangeSelection): void
    /**
      Creates a new occurrence selection meant for arrange operations and adds it to the end of the collection.
      @returns Returns newly created ArrangeSelection.
    */
    createNewArrangeSelection(): ArrangeSelection
  }

  /**
    Enum for the types of priority for an arrange selection.
  */
  const enum ArrangePriorityTypes {
    /**
      Very high arrange priority
    */
    VeryHighArrangePriorityType,
    /**
      High arrange priority
    */
    HighArrangePriorityType,
    /**
      Medium arrange priority
    */
    MediumArrangePriorityType,
    /**
      Low arrange priority
    */
    LowArrangePriorityType,
    /**
      Very low arrange priority
    */
    VeryLowArrangePriorityType,
  }

  /**
    Class for arrange selections. Provides access to the selected geometry and its properties.
  */
  abstract class ArrangeSelection extends GeometrySelection {
    /**
      Gets and sets the value of the input geometry.
      If the value originates from a component instead of an occurrence, or an occurrence outside of the CAM environment, then the subpath is checked against the CAM model tree.
      For some child classes, this may be the same as the value property, but might also consist of fewer elements.
      Valid elements depend on the capabilities of the derived class. An exception is thrown if the matching fails or the given entity does not match the expected type.
    */
    inputGeometry: core.Base
    /**
      Gets and sets the priority value for each element in the selection list.
      This function is not available in Fusion for Personal Use.
      Throws an exception when calling this function in Fusion for Personal Use.
      The default value for this property is MediumArrangePriorityType.
    */
    priorityType: ArrangePriorityTypes
    /**
      Gets and sets the rotation increments (in degrees) for the x-axis.
      This function is not available in Fusion for Personal Use.
      Throws an exception when calling this function in Fusion for Personal Use.
      To enable any rotation the parameter "arrange_rotation_group" of the operation must be set to true.
      To disable x-axis rotation for this selection, customRotationX must be set to 0.
      The default value for this property is 45 degrees.
      Note: If customRotationX is called, isUsingCustomRotationX will be set to true automatically.
    */
    customRotationX: number
    /**
      Gets and sets if custom rotation is used for the x-axis.
      This function is not available in Fusion for Personal Use.
      Throws an exception when calling this function in Fusion for Personal Use.
      To enable any rotation the parameter "arrange_rotation_group" of the operation must be set to true.
      If isUsingCustomRotationX is false, the rotation of the operation's parameter "arrange_rotation_x" is used.
      The default value for this property false.
    */
    isUsingCustomRotationX: boolean
    /**
      Gets and sets the rotation increments (in degrees) for the y-axis.
      This function is not available in Fusion for Personal Use.
      Throws an exception when calling this function in Fusion for Personal Use.
      To enable any rotation the parameter "arrange_rotation_group" of the operation must be set to true.
      To disable y-axis rotation for this selection, customRotationY must be set to 0.
      The default value for this property is 45 degrees.
      Note: If customRotationY is called, isUsingCustomRotationY will be set to true automatically.
    */
    customRotationY: number
    /**
      Gets and sets if custom rotation is used for the y-axis.
      This function is not available in Fusion for Personal Use.
      Throws an exception when calling this function in Fusion for Personal Use.
      To enable any rotation the parameter "arrange_rotation_group" of the operation must be set to true.
      If isUsingCustomRotationY is false, the rotation of the operation's parameter "arrange_rotation_y" is used.
      The default value for this property false.
    */
    isUsingCustomRotationY: boolean
    /**
      Gets and sets the rotation increments (in degrees) for the z-axis.
      This function is not available in Fusion for Personal Use.
      Throws an exception when calling this function in Fusion for Personal Use.
      To enable any rotation the parameter "arrange_rotation_group" of the operation must be set to true.
      To disable z-axis rotation for this selection, customRotationZ must be set to 0.
      The default value for this property is 45 degrees.
      Note: If customRotationZ is called, isUsingCustomRotationZ will be set to true automatically.
    */
    customRotationZ: number
    /**
      Gets and sets if custom rotation is used for the z-axis.
      This function is not available in Fusion for Personal Use.
      Throws an exception when calling this function in Fusion for Personal Use.
      To enable any rotation the parameter "arrange_rotation_group" of the operation must be set to true.
      If isUsingCustomRotationZ is false, the rotation of the operation's parameter "arrange_rotation_z" is used.
      The default value for this property true.
    */
    isUsingCustomRotationZ: boolean
    /**
      Gets and sets the custom quantity.
      This function is not available in Fusion for Personal Use.
      Throws an exception when calling this function in Fusion for Personal Use.
      The default value for this property is 1.
      Note: If customQuantity is called, isUsingCustomQuantity will be set to true automatically.
    */
    customQuantity: number /*unsigned int*/
    /**
      Gets and sets if custom quantity is used for this element.
      This function is not available in Fusion for Personal Use.
      Throws an exception when calling this function in Fusion for Personal Use.
      If isUsingCustomQuantity is false, the global quantity of the operation's parameter "arrange_global_quantity" is used.
      The default value for this property false.
    */
    isUsingCustomQuantity: boolean
  }

  /**
    This singleton object provides access to application-level events and properties
    that relate to the CAM (Manufacture) workspace in Fusion.
  */
  abstract class CAMManager extends core.Base {
    /**
      Access to the root CAMManager object.
      @returns Return the root CAMManager object or null if it failed.
    */
    static get(): CAMManager | null
    /**
      CAMLibraryManager provides access to properties related to various libraries in the
      Fusion Manufacture workspace, such as the post library and machine library.
      @returns Return a CAMLibraryManager object or null if it failed.
    */
    readonly libraryManager: CAMLibraryManager
  }

  /**
    CAMLibraryManager provides access to properties related to various libraries in the
    Fusion Manufacture workspace, such as the post library and machine library.
  */
  abstract class CAMLibraryManager extends core.Base {
    /**
      Gets the absolute path to the folder containing Fusion posts. Fusion posts
      appear in the post library under the Fusion tab.
      @remarks
      This property has been retired. Please use the post library to access posts instead.
      @deprecated
    */
    readonly fusion360PostFolder: string
    /**
      Gets the absolute path to the folder containing local posts. Local posts appear
      in post library under the local tab.
      @remarks
      This property has been retired. Please use the post library to access posts instead.
      @deprecated
    */
    readonly localPostFolder: string
    /**
      Gets the absolute path to the folder containing Fusion machines. Fusion
      machines appear in the machine library under the Fusion tab.
      @remarks
      This property has been retired. Please use the machine library to access machines instead.
      @deprecated
    */
    readonly fusion360MachineFolder: string
    /**
      Gets the absolute path to the folder containing local machines. Local Machines appear
      in machine library under the local tab.
      @remarks
      This property has been retired. Please use the machine library to access machines instead.
      @deprecated
    */
    readonly localMachineFolder: string
    /**
      Gets the absolute path to the folder containing network machines. Network machines
      appear in the machine library under the network tab.
    */
    readonly networkMachineFolder: string
    /**
      The MachineLibrary provides access to machines.
    */
    readonly machineLibrary: MachineLibrary
    /**
      The ToolLibraries provides access to tools.
    */
    readonly toolLibraries: ToolLibraries
    /**
      The CAMTemplateLibrary provides access to templates
    */
    readonly templateLibrary: CAMTemplateLibrary
    /**
      The PrintSettingLibrary provides access to print settings.
    */
    readonly printSettingLibrary: PrintSettingLibrary
    /**
      The PostLibrary provides access to postConfigurations.
    */
    readonly postLibrary: PostLibrary
    /**
      The StockMaterialLibrary provides access to stock materials.
      You can only get a valid StockMaterialLibrary when you have access to Stock Materials private preview feature and enable the feature flag.
      @experimental
    */
    readonly stockMaterialLibrary: StockMaterialLibrary
  }

  /**
    The CAMLibrary is the base-class for all other asset-specific libraries.
  */
  abstract class CAMLibrary extends core.Base {
    /**
      Get the name of the asset type which can be accessed by the library.
    */
    readonly assetTypeName: string
    /**
      Get the URL for a given LibraryLocations.
      @param location The LibraryLocations to be converted into an URL.
      @returns Returns the URL for given location.
    */
    urlByLocation(location: LibraryLocations): core.URL
    /**
      Get the localized display name for a given URL. The URL must point to a folder.
      @param url The URL that defines the path to a folder.
      @returns Returns localized display name for the folder. Returns empty string for invalid URL.
    */
    displayName(url: core.URL): string
    /**
      Get all library folders under given URL.
      @param url The URL to the parent folder.
      @returns Returns list of folder URLs at given location.
    */
    childFolderURLs(url: core.URL): core.URL[]
    /**
      Get all assets under given URL.
      @param url The URL to the parent folder.
      @returns Returns list of asset URLs at given location.
    */
    childAssetURLs(url: core.URL): core.URL[]
    /**
      Delete folder by URL from the library. Any content of the folder will also be deleted.
      Throw an error if given URL does not point to a valid folder or the URL is read-only.
      @param url The URL to the folder that should be removed.
      @returns Returns true if folder was deleted successfully, false otherwise
    */
    deleteFolder(url: core.URL): boolean
    /**
      Delete asset by URL from the library.
      Throw an error if given URL does not point to a valid asset or the URL is read-only.
      @param url The URL to the asset that should be removed.
      @returns Returns true if asset was deleted successfully, false otherwise
    */
    deleteAsset(url: core.URL): boolean
    /**
      Create a new folder in the library. Create the folder under given parent URL with given folder name. Add counting suffix, in case a folder with given name already exists.
      Throw an error if given URL does not point to a valid folder or the URL is read-only. Also throws an error if given folder name is empty.
      @param parentUrl The parent URL for the folder to be created.
      @param folderName Name of the new folder to be created. Must not be empty.
      @returns Returns the URL to the newly created folder
    */
    createFolder(parentUrl: core.URL, folderName: string): core.URL
  }

  /**
    Represents the recognized geometric shape of a hole segment.
  */
  const enum HoleSegmentType {
    /**
      Hole segment is cylindrical in shape.
    */
    HoleSegmentTypeCylinder,
    /**
      Hole segment is conical in shape.
    */
    HoleSegmentTypeCone,
    /**
      Hole segment is flat in shape, i.e. planar and perpendicular to the hole axis.
    */
    HoleSegmentTypeFlat,
    /**
      Hole segment is toroidal in shape.
    */
    HoleSegmentTypeTorus,
  }

  /**
    Object that represents a hole segment, i.e. a single geometric shape like a cylinder or cone within the context of a hole.
    A segment represents a hole face.
  */
  abstract class RecognizedHoleSegment extends core.Base {
    /**
      Returns whether this segment represents a cylinder, cone, flat, or torus geometry type
    */
    readonly holeSegmentType: HoleSegmentType
    /**
      Returns the model face this segment references.
      @remarks
      This property has been retired. Please use "RecognizedHoleSegment.faces()"
      @deprecated
    */
    readonly face: core.Base
    /**
      Returns the diameter of the top of this segment.
    */
    readonly topDiameter: number
    /**
      Returns the diameter of the bottom of this segment.
    */
    readonly bottomDiameter: number
    /**
      Returns the height of this segment from top to bottom.
    */
    readonly height: number
    /**
      Returns the unit vector that points straight up out of the segment in the global coordinate system.
    */
    readonly axis: core.Vector3D
    /**
      Returns true if this segment is threaded, i.e. associated with a thread feature.
    */
    readonly isThreaded: boolean
    /**
      Returns the thread features associated with this segment, or null if none exist for this segment.
    */
    readonly threadFeatures: fusion.ThreadFeature[]
    /**
      For hole segments of type Cone, returns the cone's half angle,
      i.e. the angle between the axis of the cone and its surface. Returns 0 for other segment types.
    */
    readonly halfAngle: number
    /**
      Returns the model faces this segment references.
    */
    readonly faces: core.Base[]
  }

  /**
    Object that represents a hole, a hole is made of one or more segments.
  */
  abstract class RecognizedHole extends core.Base {
    /**
      Returns a collection of all recognized holes.
      @remarks
      This property has been retired. Please use recognizeHolesWithInput instead.
      @param bodies Model bodies on which to recognize holes.
      @deprecated
    */
    static recognizeHoles(bodies: core.Base[]): RecognizedHoles
    /**
      Returns the unit vector that points straight up out of the hole in the global coordinate system.
    */
    readonly axis: core.Vector3D
    /**
      Returns true if at least one segment of this hole is threaded, i.e. associated with a thread feature.
    */
    readonly isThreaded: boolean
    /**
      Returns the segment at the specified index from this hole. The collection of segments that comprise this hole
      are in order. The first segment is at the top of this hole and the last segment is at the bottom.
      @param index The index of the segment within this hole to return. The first segment in this hole has an index of 0.
    */
    segment(index: number /*unsigned int*/): RecognizedHoleSegment
    /**
      Returns the number of segments contained in this hole.
    */
    readonly segmentCount: number /*unsigned int*/
    /**
      Returns a point at the center of the hole top.
    */
    readonly top: core.Point3D
    /**
      Returns a point at the center of the hole bottom.
    */
    readonly bottom: core.Point3D
    /**
      Returns the diameter of the top of this hole (top diameter of the first segment contained in this hole).
    */
    readonly topDiameter: number
    /**
      Returns the diameter of the bottom of this hole (bottom diameter of the last segment contained in this hole).
    */
    readonly bottomDiameter: number
    /**
      Returns the total length of all segments contained in this hole.
    */
    readonly totalLength: number
    /**
      Returns true if there are any warnings associated with this hole.
    */
    readonly hasWarnings: boolean
    /**
      Returns true if there are any errors associated with this hole.
    */
    readonly hasErrors: boolean
    /**
      Returns true if this is a through hole, i.e. if the bottom is open.
    */
    readonly isThrough: boolean
    /**
      Returns a collection of all recognized holes.
      @param bodies Model bodies on which to recognize holes.
      @param input Input object that contains filtering settings
    */
    static recognizeHolesWithInput(bodies: core.Base[], input: RecognizedHolesInput): RecognizedHoles
  }

  /**
    Object that represents a collection of holes.
  */
  abstract class RecognizedHoles extends core.Base {
    /**
      Returns the hole at the specified index from this collection of holes.
      @param index The index of the hole within this hole collection to return. The first hole in this collection has an index of 0.
    */
    item(index: number /*unsigned int*/): RecognizedHole
    /**
      Returns the number of holes contained in this hole collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that represents a collection of holes that contain similar geometry. Holes have similar geometry if they contain the same segment types with the same segment heights, diameters, etc...
  */
  abstract class RecognizedHoleGroup extends core.Base {
    /**
      Gets all recognized holes and returns them as hole groupings based on similar geometry.
      @remarks
      This property has been retired. Please use recognizeHoleGroupsWithInput instead.
      @param bodies Model bodies on which to recognize holes.
      @deprecated
    */
    static recognizeHoleGroups(bodies: core.Base[]): RecognizedHoleGroups
    /**
      Returns the hole at the specified index from this hole group.
      @param index The index of the hole within this hole group to return. The first hole in this hole group has an index of 0.
    */
    item(index: number /*unsigned int*/): RecognizedHole
    /**
      Returns the number of holes contained in this hole group.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns true if there are any warnings associated with this hole group.
    */
    readonly hasWarnings: boolean
    /**
      Returns true if there are any errors associated with this hole group.
    */
    readonly hasErrors: boolean
    /**
      Gets all recognized holes and returns them as hole groupings based on similar geometry.
      @param bodies Model bodies on which to recognize holes.
      @param input Input object that contains filtering settings
    */
    static recognizeHoleGroupsWithInput(bodies: core.Base[], input: RecognizedHolesInput): RecognizedHoleGroups
  }

  /**
    Object that represents a collection of hole groups.
  */
  abstract class RecognizedHoleGroups extends core.Base {
    /**
      Returns the hole group at the specified index from this collection of hole groups.
      @param index The index of the hole group within this hole group collection to return. The first hole group in this collection has an index of 0.
    */
    item(index: number /*unsigned int*/): RecognizedHoleGroup
    /**
      Returns the number of hole groups contained in this hole group collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object that contains the settings used by recognizedHoles and recognizedHoleGroups.
  */
  abstract class RecognizedHolesInput extends core.Base {
    /**
      Creates an empty input object to be passed into recognizedHoles or recognizedHoleGroups
      @returns The newly created input object.
    */
    static create(): RecognizedHolesInput
    /**
      Partial holes will not be included in recognized holes when set to true.
      Holes that intersect edges are considered partial holes.
      If a hole has multiple segments, such as a counterbore hole, all the segments inside the hole must intersect an edge for the hole to be considered a partial hole.
    */
    filterPartialHoles: boolean
  }

  /**
    The MachineLibrary provides access to machines. Using this object you can import machines
    and get existing machines using either URL or query to find specific Machines.
  */
  abstract class MachineLibrary extends CAMLibrary {
    /**
      Creates a new MachineQuery that is used to query the library for machines matching
      the query.
      @param location The location specifies the LibraryLocations where to search for in the machine library.
      @param vendor The vendor specifies the vendor of the machine. The default empty vendor applies to all machines.
      @param model The model specifies the model of the machine. The default empty model applies to all machines.
      @returns Returns a new MachineQuery. The query is predefined by given parameter.
    */
    createQuery(location: LibraryLocations, vendor?: string/* = ""*/, model?: string/* = ""*/): MachineQuery
    /**
      Import a given machine at a specific location. The machine will be stored in the library. Throws an error, if the given URL is read-only.
      @param machine The machine that should be imported.
      @param destinationUrl The URL to the folder where to save the machine.
      @param machineName The name of the machine that should be created due to the import. The name can be extended if the asset already exists at given location to ensure a unique name.
      @returns Returns the URL of the newly imported machine, or null if the import failed.
    */
    importMachine(machine: Machine, destinationUrl: core.URL, machineName: string): core.URL | null
    /**
      Update a machine in the library. The library overrides the URL by given machine. Throws an error if the URL does not already point to an existing machine.
      @param url The URL to the existing asset in the library that should be updated.
      @param machine The machine that should be persisted.
      @returns Returns true if asset was updated successfully, false otherwise.
    */
    updateMachine(url: core.URL, machine: Machine): boolean
    /**
      Get a specific machine by the given URL. Returns null, if the URL does not exist.
      @param url The URL to the machine to be loaded.
      @returns Returns the machine for a valid URL, returns null otherwise.
    */
    machineAtURL(url: core.URL): Machine | null
    /**
      Get all machines by the given parent folder URL. Returns null, if the URL does not exist.
      @param url The URL of the folder to get machines from.
      @returns Returns the machine for a valid URL, returns null otherwise.
    */
    childMachines(url: core.URL): Machine[] | null
  }

  /**
    MachineQuery defines the query to access Machines.
  */
  abstract class MachineQuery extends core.Base {
    /**
      The case-insensitive vendor specifies the vendor of the machine. The default empty vendor applies to all machines.
    */
    vendor: string
    /**
      The case-insensitive model specifies the model of the machine. The default empty model applies to all machines.
    */
    model: string
    /**
      The URL specifies the location and folder to search for in the machine library.
      Setting the URL updates the location.
    */
    url: core.URL
    /**
      The location specifies the location to search in the machine library.
      Setting the location clears any previous specified URL.
    */
    location: LibraryLocations
    /**
      Executes the query for specific machines based on the query's properties.
      @returns Returns a list of `Machine`. Each returned machine matches this query.
    */
    execute(): Machine[]
  }

  /**
    Object that represents a machine.
  */
  abstract class Machine extends core.Base {
    /**
      Gets and sets the vendor name of the machine.
    */
    vendor: string
    /**
      Gets and sets the model name of the machine.
    */
    model: string
    /**
      Gets and sets the description of the machine.
    */
    description: string
    /**
      Gets the unique identifier of the machine.
      Can be used for comparing machines within the document.
    */
    readonly id: string
    /**
      Gets the capabilities of the machine.
    */
    readonly capabilities: MachineCapabilities
    /**
      Checks if the machine has a post.
      @returns Returns a boolean telling if the Machine has a post assigned.
    */
    readonly hasPost: boolean
    /**
      Gets or sets the URL of the post assigned to the machine.
      @returns Returns a string with the URL of the post assigned to the machine.
    */
    postURL: core.URL
    /**
      Checks if the machine is equivalent to this one.
      @param machine The machine to compare this one to
      @returns True if the machines are equivalent
    */
    equivalentTo(machine: Machine): boolean
    /**
      Creates a machine from a "MachineInput" input object
      @remarks
      "MachineFromFileInput" and "MachineFromLibraryInput"
      can be used to create valid input objects.
      @param machineInput Input object that is used to hold the details needed for creating a machine.
      @returns Returns the newly created machine in a valid state.
    */
    static create(machineInput: MachineInput): Machine
    /**
      Gets the list of elements that make up this machine.
    */
    readonly elements: MachineElements
    /**
      Returns true if the machine has a simulation model attached.
      @experimental
    */
    readonly hasSimulationModel: boolean
    /**
      Clears the simulation model from the machine.
      @experimental
    */
    clearSimulationModel(): void
  }

  /**
    Object that represents the capabilities of the machine.
  */
  abstract class MachineCapabilities extends core.Base {
    /**
      Gets and sets if the machine is capable of subtractive milling.
    */
    isMillingSupported: boolean
    /**
      Gets and sets if the machine is capable of subtractive turning.
    */
    isTurningSupported: boolean
    /**
      Gets and sets if the machine is capable of subtractive cutting.
    */
    isCuttingSupported: boolean
    /**
      Gets and sets if the machine is capable of additive operations.
    */
    isAdditiveSupported: boolean
    /**
      Gets which additive technology the machine supports.
      Return "NA" if the machine does not support Additive
    */
    readonly additiveTechnology: AdditiveTechnologies
  }

  /**
    Base class for objects that compose a machine.
  */
  abstract class MachineElement extends core.Base {
    /**
      Identifier for this element. Unique within an element type.
    */
    readonly elementId: string
    /**
      Identifier for this type of machine element.
    */
    readonly typeId: string
  }

  /**
    Collection of machine elements.
    These elements contain the properties that define the machine.
  */
  abstract class MachineElements extends core.Base {
    /**
      Get the element at a particular index in the collection.
      @param index Index of element.
      @returns Returns the element at the given index.
    */
    item(index: number /*int*/): MachineElement
    /**
      Returns the default item of the given type.
      In most cases this will be the element with an element ID of "default".
      @param typeId Element typeId to get the default for. See staticTypeId for the desired element type.
      @returns Returns the specified Element or null if no matching type ID is found.
    */
    defaultItemByType(typeId: string): MachineElement | null
    /**
      Gets the element of specified type.
      @param typeId Element typeId to filter. See staticTypeId for the desired element type.
      @returns Returns a list of elements filtered to the specified type or an empty array if there is no match with the specified typeId.
    */
    itemsByType(typeId: string): MachineElement[]
    /**
      Gets an element of a specific type by ID.
      @param typeId Element typeId to filter. See staticTypeId for the desired element type.
      @param elementId Element ID to select.
      @returns Returns an element of the desired type with the specified ID or null in the case where no match is found.
    */
    itemById(typeId: string, elementId: string): MachineElement | null
    /**
      Total number of elements in collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Number of elements of specified type.
      @param typeId Element typeId to filter. See staticTypeId for the desired element type.
      @returns Returns the number of elements of the requested type. Returns zero if no elements match the specified type ID.
    */
    countByType(typeId: string): number /*unsigned int*/
  }

  /**
    Enumeration of the types of machine element inputs that can be created.
    @experimental
  */
  const enum MachineElementInputType {
    MultiAxisElement,
    ToolingCapabilityElement,
  }

  /**
    Machine element representing the machine's kinematics tree.
  */
  abstract class KinematicsMachineElement extends MachineElement {
    /**
      Identifying name for all elements of this type.
      Pass this to the itemByType or itemById methods of MachineElements to filter to elements of this type.
      @returns Returns identifier of this type.
    */
    static staticTypeId(): string
    /**
      Get the root parts collection.
    */
    readonly parts: MachineParts
  }

  /**
    Object that represents a collection of machine parts.
    These parts are the children of another part or the collection of base parts from MachineKinematics.
  */
  abstract class MachineParts extends core.Base {
    /**
      Add a new part to this collection. The part's parent will be set to the owner of
      this collection, or null if this is the root parts collection.
      If the passed MachinePartInput has a MachineAxisInput a new MachineAxis will be created.
      @param partInput Part input object used to create the new MachinePart.
      @returns Returns the newly created MachinePart or null if creation failed.
    */
    add(partInput: MachinePartInput): MachinePart | null
    /**
      Create a new MachinePartInput.
      @param partType The type of part to create.
      When this parameter is Axis, you must set a value for axisInput.
      @returns Returns the new MachinePartInput or null if creation failed.
    */
    createPartInput(partType: MachinePartTypes): MachinePartInput | null
    /**
      Get the part at index in this collection.
      @param index The index of the part.
      @returns The MachinePart at index.
    */
    item(index: number /*int*/): MachinePart
    /**
      Get the part with the given ID.
      @param id The ID for the part to get.
      @returns Returns the MachinePart with the given ID, or null if the given ID does not
      match any part in the collection.
    */
    itemById(id: string): MachinePart | null
    /**
      Get the number of parts in this collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Object representing some part of a machine, such as the static base of the machine, an
    axis, or the attachment points for tools and fixtures.
  */
  abstract class MachinePart extends core.Base {
    /**
      Delete this part and its children from the kinematics tree.
    */
    deleteMe(): void
    /**
      Get the collection of child parts.
    */
    readonly children: MachineParts
    /**
      Get or set the parent of this part.
      Returns null if this part is a root part.
      Setting the parent will add this part to the end of the parent's children
      collection. Setting the parent will throw an error if the new parent is this
      part or a child of this part.
    */
    parent: MachinePart
    /**
      Get the type of this part.
    */
    readonly partType: MachinePartTypes
    /**
      Get the internal ID of the part.
      This is unique with respect to other MachineParts in the Machine.
    */
    readonly id: string
    /**
      Get the axis object for this part used to reference this part for other
      operations.
      Only valid when partType is Axis, otherwise returns null
    */
    readonly axis: MachineAxis
    /**
      Get the spindle object for this part used to reference this part for other
      operations.
      Will return null if the part has no spindle assigned.
    */
    readonly spindle: MachineSpindle
    /**
      Get the tool station object for this part.
      Will return null if the part has no tool station assigned.
      @experimental
    */
    readonly toolStation: MachineToolStation
  }

  /**
    Object representing the set of inputs required to create a new MachinePart.
    Set an MachineAxisInput object on this object's axisInput parameter to create
    a new MachineAxis with this part.
  */
  abstract class MachinePartInput extends core.Base {
    /**
      Gets or sets the internal ID of the part, used to reference this part for other
      operations. This ID can be any string.
      This must be unique with respect to other MachineParts in the Machine.
    */
    id: string
    /**
      Get the type of part this input will create.
    */
    readonly partType: MachinePartTypes
    /**
      Creates a new MachineAxisInput object to be used to create a new MachineAxis.
      Set this object on to an axis type MachinePartInput to create a new MachineAxis
      with that part.
      @param axisType The type of MachineAxisInput to create.
      @returns Returns a LinearMachineAxisInput or RotaryMachineAxisInput, or null if the creation failed.
    */
    createAxisInput(axisType: MachineAxisTypes): MachineAxisInput | null
    /**
      Gets or sets an axis input object to create a new MachineAxis with this part.
      Only valid when partType is Axis.
    */
    axisInput: MachineAxisInput
    /**
      Gets or sets an spindle input object to create a new MachineSpindle with this part.
      Only valid when partType is not Axis.
    */
    spindleInput: MachineSpindleInput
    /**
      Creates a new MachineSpindleInput object to be used to create a new MachineSpindle.
      @returns Returns new MachineSpindleInput object.
    */
    createSpindleInput(): MachineSpindleInput
    /**
      Gets or sets an tool station input object to create a new MachineToolStation with this part.
      Only valid when partType is not Axis.
      @experimental
    */
    toolStationInput: MachineToolStationInput
    /**
      Creates a new MachineToolStationInput object to be used to create a new MachineToolStation.
      @returns Returns new MachineToolStationInput object.
      @experimental
    */
    createToolStationInput(): MachineToolStationInput
  }

  /**
    Object that defines the properties required to create a machine axis object.
  */
  abstract class MachineAxisInput extends core.Base {
    /**
      The type of axis.
      This axis type determines which parameters of this object are valid to be accessed
      or modified.
    */
    readonly axisType: MachineAxisTypes
    /**
      The user facing name of this axis.
    */
    name: string
    /**
      Specifies the value that this axis returns to when the machine is homed.
      Units are cm for linear axes or radians for rotary axes.
    */
    homePosition: number
    /**
      Range of possible values for this axis.
      Units are cm for linear axes or radians for rotary axes.
    */
    physicalRange: MachineAxisRange
    /**
      Specifies the value that this axis returns to, prior to a tool change.
      Units are cm for linear axes or radians for rotary axes.
      @experimental
    */
    toolChangePosition: number
  }

  /**
    Object that defines the properties required to create a new linear machine axis object.
  */
  abstract class LinearMachineAxisInput extends MachineAxisInput {
    /**
      The unit vector that represents the direction along which the linear axis will move.
      This vector is in the machine's coordinate system (e.g. the X axis is always (1,0,0)).
    */
    direction: core.Vector3D
  }

  /**
    Object that defines the properties required to create a new rotary machine axis object.
  */
  abstract class RotaryMachineAxisInput extends MachineAxisInput {
    /**
      The infinite line that defines the direction and location of the axis of rotation.
      This direction is in the machine's coordinate system (e.g. an A axis would
      typically use (1,0,0) for the direction), and follows the right-hand rule.
    */
    rotationAxis: core.InfiniteLine3D
  }

  /**
    Abstract base class representing a single machine axis.
  */
  abstract class MachineAxis extends core.Base {
    /**
      The name of this axis.
    */
    name: string
    /**
      The type of axis.
    */
    readonly axisType: MachineAxisTypes
    /**
      Does this axis have a limited range of motion.
    */
    readonly hasLimits: boolean
    /**
      Specifies the value that this axis returns to when the machine is homed.
      Units are cm for linear axes or radians for rotary axes.
      Will return NaN if home position isn't set.
    */
    homePosition: number
    /**
      Range of possible values for this axis.
      Units are cm for linear axes or radians for rotary axes.
    */
    physicalRange: MachineAxisRange
    /**
      Specifies the value that this axis returns to, prior to a tool change.
      Units are cm for linear axes or radians for rotary axes.
      Will return NaN if tool change position isn't set.
      @experimental
    */
    toolChangePosition: number
  }

  /**
    Object that represents an axis with linear motion (e.g. X, Y, and Z).
  */
  abstract class LinearMachineAxis extends MachineAxis {
    /**
      The unit vector that represents the direction along which the axis will move.
    */
    direction: core.Vector3D
  }

  /**
    Object that represents an axis with rotary motion (e.g. A, B, and C).
  */
  abstract class RotaryMachineAxis extends MachineAxis {
    /**
      The infinite line that defines the direction and location of the axis of rotation.
    */
    rotationAxis: core.InfiniteLine3D
  }

  /**
    Object representing the set of inputs required to create a new MachineSpindle.
  */
  abstract class MachineSpindleInput extends core.Base {
    /**
      The description of this spindle.
    */
    description: string
    /**
      Specifies the maximum speed (rpm) for this spindle.
    */
    maxSpeed: number
    /**
      Specifies the minimum speed (rpm) for this spindle.
    */
    minSpeed: number
    /**
      Specifies the power for this spindle.
      @experimental
    */
    power: number
    /**
      Specifies the peak torque for this spindle.
      @experimental
    */
    peakTorque: number
    /**
      Specifies the peak torque speed for this spindle.
      @experimental
    */
    peakTorqueSpeed: number
  }

  /**
    Object representing a spindle on the machine
  */
  abstract class MachineSpindle extends core.Base {
    /**
      The description of this spindle.
    */
    description: string
    /**
      Specifies the maximum speed (rpm) for this spindle.
    */
    maxSpeed: number
    /**
      Specifies the minimum speed (rpm) for this spindle.
    */
    minSpeed: number
    /**
      Specifies the power (kW) for this spindle.
      @experimental
    */
    power: number
    /**
      Specifies the peak torque (Nm) for this spindle.
      @experimental
    */
    peakTorque: number
    /**
      Specifies the speed (rpm) at which this spindle reaches peak torque (Nm).
      @experimental
    */
    peakTorqueSpeed: number
  }

  /**
    Object representing the set of inputs required to create a new MachineToolStation.
    @experimental
  */
  abstract class MachineToolStationInput extends core.Base {
    /**
      The maximum diameter in cm of the tool that can be held by this tool station.
    */
    maxToolDiameter: number
    /**
      The maximum length in cm of the tool that can be held by this tool station.
    */
    maxToolLength: number
    /**
      The type of interface that this tool station uses.
      (e.g. BT40, CAPTO C5, HSK A100, SK50, etc.)
      Note: All newline characters will be removed, and if the string contains only ASCII characters, it will be converted to uppercase.
    */
    toolInterface: string
    /**
      The coolants that this tool station can use.
      See MachineToolStationCoolant for possible values.
    */
    coolants: number[] /*int[]*/
  }

  /**
    Object representing a tool station on the machine
    @experimental
  */
  abstract class MachineToolStation extends core.Base {
    /**
      The maximum diameter in cm of the tool that can be held by this tool station.
    */
    maxToolDiameter: number
    /**
      The maximum length in cm of the tool that can be held by this tool station.
    */
    maxToolLength: number
    /**
      The type of interface that this tool station uses.
      (e.g. BT40, CAPTO C5, HSK A100, SK50, etc.)
      Note: All newline characters will be removed, and if the string contains only ASCII characters, it will be converted to uppercase.
    */
    toolInterface: string
    /**
      The coolants that this tool station can use.
      See MachineToolStationCoolant for possible values.
    */
    coolants: number[] /*int[]*/
  }

  /**
    Enumeration of possible coolants that a machine can use.
    @experimental
  */
  const enum MachineCoolant {
    MachineCoolant_FLOOD,
    MachineCoolant_MIST,
    MachineCoolant_THROUGH_TOOL,
    MachineCoolant_AIR,
    MachineCoolant_AIR_THROUGH_TOOL,
    MachineCoolant_SUCTION,
    MachineCoolant_FLOOD_MIST,
    MachineCoolant_FLOOD_THROUGH_TOOL,
  }

  /**
    Machine element representing controller settings for kinematics.
  */
  abstract class ControllerConfigurationMachineElement extends MachineElement {
    /**
      Identifying name for all elements of this type.
      Pass this to the itemByType or itemById methods of MachineElements to filter to elements of this type.
      @returns Returns identifier of this type.
    */
    static staticTypeId(): string
    /**
      Gets the collection of axis configuration objects.
    */
    readonly axisConfigurations: MachineAxisConfigurations
    /**
      Global maximum non-rapid linear motion speed.
      Units are cm/s.
    */
    maxNormalSpeed: number
    /**
      Maximum block processing rate for the controller.
    */
    maxBlockProcessingSpeed: number /*unsigned int*/
  }

  /**
    Interpolation modes available for TCP motions.
    @experimental
  */
  const enum MachineTCPInterpolationMode {
    /**
      Moves the axes independently at maximum speed,
      potentially resulting in different completion times for each axis
    */
    MachineTCPInterpolationMode_SynchronizedAxes,
    /**
      Moves the axes together, completing the motion simultaneously,
      although the tool's tip may deviate from the direct line between the start and finish points.
    */
    MachineTCPInterpolationMode_IndependentAxes,
    /**
      Adjusts the linear axes to keep the tool's tip positioned along the direct line between the start and finish points.
    */
    MachineTCPInterpolationMode_ToolTip,
  }

  /**
    Interpolation modes available for non-TCP motions.
    @experimental
  */
  const enum MachineNonTCPInterpolationMode {
    /**
      Moves the axes independently at maximum speed,
      potentially resulting in different completion times for each axis
    */
    MachineNonTCPInterpolationMode_SynchronizedAxes,
    /**
      Moves the axes together, completing the motion simultaneously,
      although the tool's tip may deviate from the direct line between the start and finish points.
    */
    MachineNonTCPInterpolationMode_IndependentAxes,
  }

  /**
    Collection of axis configuration objects.
  */
  abstract class MachineAxisConfigurations extends core.Base {
    /**
      Add a new linear axis configuration for a kinematics part.
      @param partId ID used to label this axis configuration and link to a part in the kinematics tree.
      partID must match a part of type AxisMachinePartType in the kinematics tree and the part must be a linear axis.
      @returns Returns the newly created LinearMachineAxisConfiguration or null if creation failed.
    */
    addLinear(partId: string): LinearMachineAxisConfiguration | null
    /**
      Add a new rotary axis configuration for a kinematics part.
      @param partId ID used to label this axis configuration and link to a part in the kinematics tree.
      partID must match a part of type AxisMachinePartType in the kinematics tree and the part must be a rotary axis.
      @returns Returns the newly created RotaryMachineAxisConfiguration or null if creation failed.
    */
    addRotary(partId: string): RotaryMachineAxisConfiguration | null
    /**
      Get the configuration at index in this collection
      @param index Index of configuration.
      @returns Returns the MachineAxisConfiguration at index.
    */
    item(index: number /*int*/): MachineAxisConfiguration
    /**
      Get the configuration with the given ID
      @param id The ID for the configuration to get.
      @returns Return the MachineAxisConfiguration with the given ID, or null if the given ID does not
      match any configuration in the collection.
    */
    itemById(id: string): MachineAxisConfiguration | null
    /**
      Get the number of configurations in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    MachineAxisConfiguration holds controller settings that differ for each axis.
  */
  abstract class MachineAxisConfiguration extends core.Base {
    /**
      Delete this axis configuration from the controller configuration.
    */
    deleteMe(): void
    /**
      ID of the part in the KinematicsMachineElement that this axis configuration modifies.
    */
    readonly partId: string
    /**
      The type of this axis configuration. Use this to inform a cast to the derived types.
    */
    readonly type: MachineAxisTypes
    /**
      Does the axis move in the opposite direction to usual. For rotary axes this would mean it
      uses the left hand rule, and for linear axes is moves in the opposite direction.
    */
    isReversed: boolean
    /**
      Specifies the maximum normal speed for this axis.
      This would be called feedrate for a linear axis or rotary speed for a rotary axis.
      Units are cm/s for linear axes or rad/s for rotary axes.
    */
    maxNormalSpeed: number
    /**
      Specifies the maximum rapid speed for this axis.
      This would be called feedrate for a linear axis or rotary speed for a rotary axis.
      Units are cm/s for linear axes or rad/s for rotary axes.
    */
    maxRapidSpeed: number
    /**
      Coordinate to use for post processing.
    */
    coordinate: MachineAxisCoordinates
  }

  /**
    A MachineAxisConfiguration holding settings specific to linear axes.
    This class currently has no members.
  */
  abstract class LinearMachineAxisConfiguration extends MachineAxisConfiguration {
  }

  /**
    A MachineAxisConfiguration holding settings specific to rotary axes.
  */
  abstract class RotaryMachineAxisConfiguration extends MachineAxisConfiguration {
    /**
      Specify the range that the axis value wraps around for unlimited axes.
      If there are no wrap around limits then wrapAroundAtRange is infinite.
      Units are radians.
    */
    wrapAroundAtRange: MachineAxisRange
    /**
      Specify when to reset the initial axis position.
    */
    reset: MachineResetOptions
    /**
      Specify if the axis supports Tool Center Point Control (TCP).
    */
    useToolCenterPointControl: boolean
    /**
      Specify the preferred angle direction at the beginning of an operation.
    */
    rotaryPreference: MachineAnglePreferences
  }

  /**
    Class representing limits of motion for a machine axis.
  */
  abstract class MachineAxisRange extends core.Base {
    /**
      Creates a new range object with limited extents.
      Requires min to be less than or equal to max.
      Types of the fields depend on where this range is being used. Centimeters are used for distances and radians for angles.
      @param min New minimum value for range.
      @param max New maximum value for range.
      @returns A new range object. Returns null if validation fails.
    */
    static create(min: number, max: number): MachineAxisRange | null
    /**
      Creates a new unbounded range object.
      @returns A new range object.
    */
    static createInfinite(): MachineAxisRange
    /**
      Minimum value of range.
      Type depends on where this range is being used. Centimeters are used for distances and radians for angles.
      Returns -infinity if this range is infinite.
    */
    readonly min: number
    /**
      Maximum value of range
      Type depends on where this range is being used. Centimeters are used for distances and radians for angles.
      Returns infinity if this range is infinite.
    */
    readonly max: number
    /**
      Is the range infinite.
    */
    readonly isInfinite: boolean
  }

  /**
    Machine element representing the additive platform settings.
  */
  abstract class AdditivePlatformMachineElement extends MachineElement {
    /**
      Identifying name for all elements of this type.
      Pass this to the itemByType or itemById methods of MachineElements to filter to elements of this type.
      @returns Returns identifier of this type.
    */
    static staticTypeId(): string
    /**
      Usable platform size.
      Units are cm.
    */
    size: core.Point3D
    /**
      Origin point specifying the platform coordinates that correspond to the origin of the platform mesh.
      Units are cm.
    */
    origin: core.Point3D
    /**
      Clearance height used for automatically arranging parts and suggested height for positioning part on the build platform.
      Units are cm.
    */
    clearance: number
    /**
      Clearance width used for automatically arranging parts which is the distance from the edges of the build platform.
      Units are cm.
    */
    frameWidth: number
    /**
      Clearance height used for automatically arranging parts which is the distance from the top of the build platform.
      Units are cm.
    */
    ceilingClearance: number
  }

  /**
    Machine element representing limits for fused filament fabrication (FFF) machine motion and temperatures.
  */
  abstract class AdditiveFFFLimitsMachineElement extends MachineElement {
    /**
      Identifying name for all elements of this type.
      Pass this to the itemByType or itemById methods of MachineElements to filter to elements of this type.
      @returns Returns identifier of this type.
    */
    static staticTypeId(): string
    /**
      Position of the machine home location.
    */
    homePosition: core.Point3D
    /**
      Position machine moves to when "parked".
    */
    parkPosition: core.Point3D
    /**
      Maximum bed temperature in degrees C.
    */
    maximumBedTemperature: number
    /**
      Maximum supported speed for motion in the X or Y axes in cm/s.
    */
    maximumXYSpeed: number
    /**
      Maximum supported speed for motion in the Z axis in cm/s.
    */
    maximumZSpeed: number
    /**
      Maximum supported acceleration for motion in the X or Y axes in cm/s^2.
    */
    maximumXYAcceleration: number
    /**
      Maximum supported acceleration for motion in the Z axis in cm/s^2.
    */
    maximumZAcceleration: number
  }

  /**
    List of the machine templates to create a machine from.
  */
  const enum MachineTemplate {
    /**
      Represents a generic 2 axis turning machine.
    */
    GenericLathe,
    /**
      Represents a generic 3 axis machine with 3 linear axes.
    */
    Generic3Axis,
    /**
      Represents a generic 4 axis machine with 3 linear axes and 1 rotary.
      Default rotary axis is A.
    */
    Generic4Axis,
    /**
      Represents a generic 5 axis machine with 3 linear axes and 2 rotary.
      Default rotary axes are A and C in a Head-Head configuration.
    */
    Generic5AxisHeadHead,
    /**
      Represents a generic 5 axis machine with 3 linear axes and 2 rotary.
      Default rotary axes are A and C in a Head-Table configuration.
    */
    Generic5AxisHeadTable,
    /**
      Represents a generic 5 axis machine with 3 linear axes and 2 rotary.
      Default rotary axes are A and C in a Table-Table configuration.
    */
    Generic5AxisTableTable,
    /**
      Represents a generic FFF machine with two extruders.
      The default build room dimension is 300mm by 300mm by 300mm.
    */
    GenericFFF,
  }

  /**
    List of part types for MachinePart
  */
  const enum MachinePartTypes {
    /**
      Basic type for machine parts. Can be used to represent non-moving elements of the
      machine such as the machine's base or an enclosure.
    */
    BasicMachinePartType,
    /**
      Part type for a part that represents a machine axis.
    */
    AxisMachinePartType,
    /**
      Part type for a part that represents the attachment point and orientation for a
      tool or tool holder.
    */
    ToolAttachmentMachinePartType,
    /**
      Part type for a part that represents the attachment point and orientation for
      work holding.
    */
    FixtureAttachmentMachinePartType,
  }

  /**
    List of machine axis types for MachineAxis
  */
  const enum MachineAxisTypes {
    /**
      An axis that moves in a straight line
    */
    LinearMachineAxisType,
    /**
      An axis that rotates about a point
    */
    RotaryMachineAxisType,
  }

  /**
    Options to control which coordinate is used for post processing, independent of the axis direction.
    Instructs the post processor to treat the axis as X, Y, or Z for linear and A, B, or C for rotary.
  */
  const enum MachineAxisCoordinates {
    /**
      Axis has no coordinate set.
    */
    MachineCoordinate_None,
    /**
      Axis coordinate Linear X, Rotary A
    */
    MachineCoordinate_X_A,
    /**
      Axis coordinate Linear Y, Rotary B
    */
    MachineCoordinate_Y_B,
    /**
      Axis coordinate Linear X, Rotary C
    */
    MachineCoordinate_Z_C,
  }

  /**
    Axis reset preference options for MachineAxisConfiguration.whenToReset.
  */
  const enum MachineResetOptions {
    /**
      Remember axis position from previous operation
    */
    MachineResetNever,
    /**
      Reset axis to zero before each operation begins.
    */
    MachineResetBeforeEveryOperation,
    /**
      Reset axis to zero during automated rewinds.
    */
    MachineResetOnRewind,
    /**
      Reset axis to zero before each operation begins and during automated rewinds.
    */
    MachineResetBeforeOpAndOnRewind,
  }

  /**
    Preference for rotary axis starting angles.
  */
  const enum MachineAnglePreferences {
    /**
      No preference, use any solution.
    */
    MachineAngleNoPreference,
    /**
      Prefer starting rotary axis with a negative tilt.
    */
    MachineAnglePreferNegative,
    /**
      Prefer starting rotary axis with a positive tilt.
    */
    MachineAnglePreferPositive,
  }

  /**
    List of technologies a additive machine could have
  */
  const enum AdditiveTechnologies {
    /**
      Fused filament fabrication additive manufacturing process.
    */
    FFFTechnology,
    /**
      Directed energy deposition additive manufacturing process.
    */
    DEDTechnology,
    /**
      Machine powder bed fusion additive manufacturing process.
    */
    MPBFTechnology,
    /**
      Multi fusion jet additive manufacturing process
    */
    MFJTechnology,
    /**
      Multi fusion jet additive manufacturing process
    */
    BinderJettingTechnology,
    /**
      Stereo lithographic apparatus additive manufacturing process
    */
    SLATechnology,
    /**
      Selective laser sintering additive manufacturing process
    */
    SLSTechnology,
    /**
      Non Additive Technology, meaning this is not a additive machine
    */
    NATechnology,
    /**
      Every other additive manufacturing process not covered by the types above
    */
    OtherTechnology,
    /**
      Electron Beam Technology
    */
    EbeamTechnology,
  }

  /**
    Type of the realized input object
    @hidden
  */
  const enum MachineInputTypes {
    MachineInputFromTemplate,
    MachineInputFromFile,
    MachineInputFromLibrary,
  }

  /**
    Base abstract class for inputs to be used when creating machines.
    Used by Machine.create(MachineInput) method.
    Implemented by "MachineFromFileInput" and "MachineFromLibraryinput" classes.
  */
  abstract class MachineInput extends core.Base {
  }

  /**
    Object used as input to create a machine from a given template.
    Used by "Machine.create(MachineInput)" method.
    The object holds the data needed to create a machine based on the specified template.
  */
  abstract class MachineFromTemplateInput extends MachineInput {
    /**
      Create a "MachineFromTemplateInput" object to be used as
      input for "Machine.create(MachineInput)" method.
      @param machineTemplate The template to act as a base for creating a machine from.
      @returns The newly created "MachineFromTemplateInput" object in a valid state.
    */
    static create(machineTemplate: MachineTemplate): MachineFromTemplateInput
    /**
      Machine template identifier used to generate a certain type of machine.
    */
    readonly machineTemplate: MachineTemplate
  }

  /**
    Object used as input to create a machine from library URL.
  */
  abstract class MachineFromLibraryInput extends MachineInput {
    /**
      Creates a MachineFromLibraryInput object to be used as
      input for Machine.create method, in order to create
      a machine from a library location.
      @param url The URL path to the library machine.
      @returns Returns newly created MachineFromLibraryInput object in a valid state.
    */
    static create(url: core.URL): MachineFromLibraryInput
    /**
      The URL path to the library machine.
    */
    readonly url: core.URL
    /**
      Gets and sets whether or not to ignore the simulation model
      when creating or loading the machine.
      @remarks
      This can be useful if you don't have write access to the simulation machine.
      This can be the case if:
      - The simulation machine is not in your local library.
      - The simulation machine is not saved in your hub.
      - You don't have write access to the hub or location where it was saved.
    */
    ignoreSimulationModel: boolean
  }

  /**
    Machine element representing the post processor and post properties.
    @experimental
  */
  abstract class PostProcessingMachineElement extends MachineElement {
    /**
      Identifying name for all elements of this type.
      Pass this to the itemByType or itemById methods of MachineElements to filter to elements of this type.
      @returns Returns identifier of this type.
    */
    static staticTypeId(): string
    /**
      Gets or sets the URL of the post assigned to the machine.
      @returns Returns a string with the URL of the post assigned to the machine.
    */
    postURL: core.URL
    /**
      Gets and sets the path for the output folder where the .nc files will be located.
      @returns Returns a string of the output folder path for the post processing result.
    */
    outputFolder: string
    /**
      Gets the machine scope post properties as parameters.
    */
    readonly postParameters: CAMParameters
    /**
      Overrides the default post parameters with the given user's input.
      @returns Returns true if the update was successful. False otherwise.
    */
    updatePostParameters(parameters: CAMParameters): boolean
  }

  /**
    Enumeration of possible MachineItem types.
    @experimental
  */
  const enum MachineItemType {
    MachineItemType_TOOL,
    MachineItemType_TOOL_CUTTER,
    MachineItemType_TOOL_NONCUTTER,
    MachineItemType_STOCK,
    MachineItemType_FIXTURE,
    MachineItemType_MODEL,
    MachineItemType_MACHINE_PART,
    MachineItemType_TURRET_ACTIVE_TOOL,
    MachineItemType_TURRET_INACTIVE_TOOL,
    MachineItemType_INVALID,
  }

  /**
    The linearization method the MultiAxisSingularitySettings should use.
    Different values will be used in different MultiAxisSingularitySettings specializations.
    @experimental
  */
  const enum MultiAxisSingularityLinearizeMethod {
    /**
      Moves the tool end point along the straight line by adding points to the toolpath. It keeps the tool within the specified Linearization Tolerance.
    */
    MultiAxisSingularityLinearize_Linear,
    /**
      Applies a linear shape to the moves around the singularity by adding points to the toolpath. It keeps the tool within the specified Linearization Tolerance.
      The rotary linearization optimizes the tool for revolved movement as if the tool were moving around a cylinder or other object created by revolution.
    */
    MultiAxisSingularityLinearize_Rotary,
  }

  /**
    Enumeration of the multi-axis feed modes that can be used in MultiAxisFeedrateSettings and its specializations.
    @experimental
  */
  const enum MultiAxisFeedMode {
    /**
      Sets the time for completing a move as an inverse of the feedrate. The smaller the value, the faster the move.
    */
    MultiAxisFeedMode_InverseTime,
    /**
      Sets the feedrate based on the diameter of the cutting operation and calculates the degrees of the move. Used for most rotary axes.
    */
    MultiAxisFeedMode_DegreesPerMinute,
    /**
      Applies the programmed feedrates without adjustments.
    */
    MultiAxisFeedMode_ProgrammerdFeedrate,
  }

  /**
    The time unit used to calculate the feedrate for the MultiAxisInverseTimeFeedrateSettings
    @experimental
  */
  const enum MultiAxisInverseTimeUnit {
    MultiAxisInverseTimeUnit_Seconds,
    MultiAxisInverseTimeUnit_Minutes,
  }

  /**
    Enumeration of the multi-axis degrees per minute types that can be used in MultiAxisDPMFeedrateSettings and its specializations.
    @experimental
  */
  const enum MultiAxisDegreesPerMinuteType {
    /**
      Sets the feedrate based on the diameter of the cutting operation and calculates the degrees of the move. Used for most rotary axes.
    */
    MultiAxisDegreesPerMinuteType_Standard,
    /**
      Sets the feedrate as a combination of degrees per minute and linear feed per minute. Used typically for machines that require a form of degrees per minute feedrates.
    */
    MultiAxisDegreesPerMinuteType_Combination,
  }

  /**
    Enumeration of the multi-axis rewind preferences that can be used in MultiAxisRetractAndReconfigureSettings.
    @experimental
  */
  const enum MultiAxisRewindPreference {
    /**
      It can retract at any point, including cutting moves.
    */
    MultiAxisRewindPreference_RewindAtLinear,
    /**
      Allows the retract and rewind to occur at a rapid (non-cutting) move instead of at the limits of the rotary axis when possible.
      It may not be possible in all cases to retract and rewind at a rapid move, in this case the rewind occurs at a cutting move.
    */
    MultiAxisRewindPreference_RewindAtRapid,
  }

  /**
    Enumeration of the multi-axis retract preferences that can be used in MultiAxisRetractAndReconfigureSettings.
    @experimental
  */
  const enum MultiAxisRetractPreference {
    /**
      Always retract when repositioning rotary axes.
    */
    MultiAxisRetractPreference_RetractAtApex,
    /**
      Allows the tool to stay down without retracting when the rotary axes are repositioned.
      The tool must be perpendicular to the rotary axis rotational vector (so that only one rotary axis will move) and TCP must be enabled for this axis.
    */
    MultiAxisRetractPreference_StayAtApex,
  }

  /**
    Collection of all the mutually exclusive surface groups to be passed to a toolpath with stock to leave and avoid clearances associated to them.
    This is a read-only container that gets passed to CadMachineAvoidGroupsParameterValue object.
    It returns the groups associated with the parent parameter value object, but does not write to it.
    To apply changes done to the collection and the selections it contains, CadMachineAvoidGroupsParameterValue.applyMachineAvoidGroups() needs to be called.
  */
  abstract class MachineAvoidGroups extends core.Base {
    /**
      Function that returns the specified machine/avoid group selection object using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): MachineAvoidSelectionBase | null
    /**
      Function that returns the specified machine/avoid default group selection object using the group type.
      Default groups contain surfaces that have a specific meaning within the toolpath operation, for example Model, Fixture, Drive etc.
      @param type The type of the default group within the collection to return. There can be only one default group of a given type
      @returns Returns the specified item or null if there isn't a group of the specified type
    */
    defaultGroup(type: DefaultGroupType): MachineAvoidSelectionBase | null
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Clears all entries.
    */
    clear(): void
    /**
      Creates a new machine avoid group and adds it to the end of the collection.
      @returns Returns newly created MachineAvoidDirectSelection.
    */
    createNewMachineAvoidDirectSelectionGroup(): MachineAvoidDirectSelection
    /**
      Function that removes the specified group object using an index in the collection.
      @param index The index of the item within the collection to remove. The first item in the collection has an index of 0.
    */
    remove(index: number /*unsigned int*/): void
    /**
      Function that removes the specified group object from the collection.
      @param selection The item within the collection to remove. Throws an exception if the machine avoid group is not part of the given selection.
    */
    removeByObject(group: MachineAvoidSelectionBase): void
    /**
      Function that synchronizes the selections and properties of the default groups from the current operation.
      This is needed when there are changes made to parameters that drive the default groups (e.g. Setup model or fixture
      selection changes to be reflected in the MachineAvoidGroups object on the API side).
      WARNING: This function must not be called before applyMachineAvoidGroups, because temporary
      group settings and selections will not have been stored in the operation object and will
      be overwritten.
    */
    sync(): void
  }

  /**
    Base parent class for all machine/avoid selection classes.
  */
  abstract class MachineAvoidSelectionBase extends GeometrySelection {
    /**
      Desired machining mode. The default is Avoid.
      The current machining mode will determine which value the radial and axial offset functions
      refer to. When set to Machine, the radial and axial offset methods will read/set the stock to leave parameter.
      When set to Avoid, the radial and axial offset methods will read/set the clearance value,
      and the Fixture mode will map to the relative fixture clearance value.
    */
    machineMode: MachiningMode
    /**
      Radial offset - sets the corresponding radial offset value based on the machine mode
    */
    radialOffset: number
    /**
      Axial offset - sets the corresponding axial offset value based on the machine mode
    */
    axialOffset: number
    /**
      Combined offset - clearance and stock to leave based on the machine mode
      This only applies to strategies that use a single offset value (Advanced Swarf,
      Multi-Axis Clearing, Multi-Axis Finishing, Deburr and Geodesic)
    */
    combinedOffset: number
  }

  /**
    Machine/avoid direct selection class. Represents a group of direct selections that
    the users can make (faces, bodies, components and higher level entities).
    Provides access to the stored selections.
  */
  abstract class MachineAvoidDirectSelection extends MachineAvoidSelectionBase {
    /**
      Get or set the value of the input geometry.
    */
    inputGeometry: core.Base[]
  }

  /**
    Machine/avoid default selection class. Represents a group of selections that are parameter
    driven. Provides access to the stored selections.
  */
  abstract class MachineAvoidDefaultSelection extends MachineAvoidSelectionBase {
    /**
      Get the value of the input geometry.
    */
    readonly inputGeometry: core.Base[]
  }

  /**
    Specifies how to treat a surface group
  */
  const enum MachiningMode {
    /**
      The tool avoids these surfaces while it machines nearby surfaces. The tool stays clear from the avoid surfaces by the specified clearances.
    */
    Avoid_MachiningMode,
    /**
      The tool machines the selected surfaces leaving stock on them according to the stock to leave value.
    */
    Machine_MachiningMode,
    /**
      The tool does not actively avoid or machine these surfaces. However, if these surfaces are on the path of the tool then it may gouge and cut through them.
    */
    Gouge_MachiningMode,
    /**
      The tool avoids these surfaces by the specified clearances.
    */
    Fixture_MachiningMode,
  }

  /**
    Types of default groups. Used to specify which default group to be retrieved by defaultGroup method.
  */
  const enum DefaultGroupType {
    /**
      Group containing surfaces belonging to the fixture. Some of these may have been defined in the setup.
    */
    Fixture_GroupType,
    /**
      Group containing surfaces belonging to the model. These have been defined in the setup or using the model override selector.
    */
    Model_GroupType,
    /**
      Group containing Drive surfaces.
    */
    Drive_GroupType,
    /**
      Group containing Floor surfaces.
    */
    Floor_GroupType,
    /**
      Group containing Wall surfaces.
    */
    Wall_GroupType,
    /**
      Group containing Adjacent surfaces.
    */
    Adjacent_GroupType,
  }

  /**
    Referenced from CAM product to access manufacturing models in document.
  */
  abstract class ManufacturingModels extends core.Base {
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Get ManufacturingModel by index in collection.
      @returns Returns ManufacturingModel at given index.
    */
    item(index: number /*unsigned int*/): ManufacturingModel
    /**
      Returns all ManufacturingModel with given name (as appears in the browser).
      @param name The name (as it appears in the browser) of the ManufacturingModel.
      @returns Returns all ManufacturingModel with the specified name.
    */
    itemByName(name: string): ManufacturingModel[]
    /**
      Returns ManufacturingModel with given id.
      @param id The id of the ManufacturingModel.
      @returns Returns ManufacturingModel with the specified id or null if no ManufacturingModel has that id.
    */
    itemById(id: string): ManufacturingModel | null
    /**
      Create a new ManufacturingModelInput object. Use properties and methods on this object
      to define the ManufacturingModel you want to create and then use the Add method, passing in
      the ManufacturingModelInput object.
      @returns Returns new ManufacturingModelInput object.
    */
    createInput(): ManufacturingModelInput
    /**
      Create a new ManufacturingModel.
      @param input A ManufacturingModelInput object that defines the desired ManufacturingModel. Use the createInput
      method to create a new ManufacturingModelInput object and then use methods on it to define the ManufacturingModel.
      @returns Returns the newly created ManufacturingModel.
    */
    add(input: ManufacturingModelInput): ManufacturingModel
    /**
      Checks wether changes to the original design have been made. If so, all manufacturing models are synchronized with their sources.
      @returns Returns true if any manufacturing model needed an update.
    */
    syncAllManufacturingModels(): boolean
  }

  /**
    This class defines the methods and properties that pertain to the definition of a ManufacturingModel.
  */
  abstract class ManufacturingModelInput extends core.Base {
    /**
      Name of the new ManufacturingModel.
      The name is displayed in the browser tree.
    */
    name: string
  }

  /**
    Represents a ManufacturingModel within a CAM design. A Manufacturing Model is a derive of the Design scene, which can be augmented without any effects of the original Design.
  */
  abstract class ManufacturingModel extends core.Base {
    /**
      Gets or sets the display name of the ManufacturingModel.
      This is the name that will be shown in the browser and other locations.
    */
    name: string
    /**
      Gets the unique identifier of the ManufacturingModel within the document.
    */
    readonly id: string
    /**
      Gets whether this ManufacturingModel is active in the user interface.
      This is the same as checking the state of the radio button next to the ManufacturingModel in the browser.
      To activate the ManufacturingModel use the Activate method.
    */
    readonly isActive: boolean
    /**
      Makes the ManufacturingModel the active edit target in the user interface. This is the same
      as enabling the radio button next to the occurrence in the browser.
      @returns Returns true if the activation was successful.
    */
    activate(): boolean
    /**
      Creates and returns a copy of the ManufacturingModel, within its parent collection.
      The newly created ManufacturingModel will have a new unique name assigned.
      @returns Returns the newly created ManufacturingModel copy.
    */
    duplicate(): ManufacturingModel
    /**
      Deletes this ManufacturingModel. If this is part of a setup, the reference to this will be lost. The deletion makes that reference invalid.
      @returns Returns true if the delete is successful.
    */
    deleteMe(): boolean
    /**
      Returns the occurrence for that ManufacturingModel.
      @returns Returns true Occurrence for the current ManufacturingModel.
    */
    readonly occurrence: fusion.Occurrence
    /**
      Checks whether changes to the original design have been made. If so, the given manufacturing model is synchronized with its source.
      @returns Returns true if the manufacturing model needed an update.
    */
    syncManufacturingModel(): boolean
  }

  /**
    Base class for all modify utilities.
  */
  abstract class ModifyUtility extends core.Base {
  }

  /**
    Types of provided ModifyUtility.
  */
  const enum ModifyUtilityTypes {
    /**
      Utility for modifications of additive setups. Corresponds to AdditiveSetupUtility.
    */
    AdditiveSetupModifyUtility,
  }

  /**
    AdditiveSetupUtility provides functionality for modifications of additive setups.
  */
  abstract class AdditiveSetupUtility extends ModifyUtility {
    /**
      Splits support structure of given target bodies into separate mesh body.
      @param targets Targets contain any input bodies whose support is to be inserted into a new mesh body.
      Input target must belong to the setup and must be part of the associated manufacturing model.
      Raises an error if any input target is not part of the setup or is not part of the associated manufacturing model.
      @param splitType The splitType defines the behavior for support that contains solid and open mesh geometry.
      @returns True on success, false on errors
    */
    splitSupport(targets: core.Base[], splitType: SplitSupportTypes): boolean
    /**
      Remove components from setups, that are outside of the buildroom.
      @returns Returns count of removed parts on success and -1 on failure.
    */
    removeExcessParts(): number /*int*/
    /**
      Assigns an array of parts to the body preset operation corresponding to the chosen PrintSettingItem in the PrintSetting. If a part has been previously assigned to a different preset (i.e. the default preset), it will be removed from its previous owner to ensure a body can only be mapped to one preset. If the previous owner preset ends up being empty, it will be removed from the setup.
      @param parts Parts to be assigned to a preset. The array may contain BRepBody, MeshBody or Occurrence objects. If occurrences are passed in, the preset will contain their resolved bodies or meshes. If the array is empty, the preset will be removed from the setup, but the PrintSettingItem will stay in the PrintSetting.
      @param presetName The name of the PrintSettingItem defined in the PrintSetting, which serves as the basis for the to be created operation.
      @returns The preset corresponding to the preset name. Returns null if the preset has been removed from the setup due to passing an empty or invalid array.
    */
    assignPartsToBodyPreset(parts: adsk.core.Base[], presetName: string): Operation | null
  }

  /**
    Split support behavior depending on the type of support.
  */
  const enum SplitSupportTypes {
    /**
      Solid and open support into one single mesh body.
    */
    SolidOpenMergedSplitSupportType,
    /**
      Solid and open support into two separate mesh bodies.
    */
    SolidOpenSeparateSplitSupportType,
  }

  /**
    Container for all NC programs. Referenced from CAM product to access NC programs in a document, similar to what Setups is for all setup objects.
  */
  abstract class NCPrograms extends core.Base {
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Function that returns the specified NC program using an index into the collection.
      @param index The index of the item within the collection to return. The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): NCProgram | null
    /**
      Returns the NC program with the specified name.
      @param name The name (as it appears in the browser) of the operation.
      @returns Returns the specified NC program or null in the case where there is no NC program with the specified name.
      If there are multiple NC programs with the same name, the first item in the tree will be returned.
    */
    itemByName(name: string): NCProgram | null
    /**
      Returns the NC program with the specified operation id.
      @param id The id of the NC program.
      @returns Returns the specified NC program or null in the case where there is no NC program with the specified operation id.
    */
    itemByOperationId(id: number /*int*/): NCProgram | null
    /**
      Create a new NCProgramInput object. Use properties and methods on this object
      to define the NC program you want to create and then use the Add method, passing in
      the NCProgramInput object.
      @returns Returns a new NCProgramInput object.
    */
    createInput(): NCProgramInput
    /**
      Creates a new NC program.
      @param input NCProgramInput which will be used to create the NC program.
      @returns Returns the created NC program.
    */
    add(input: NCProgramInput): NCProgram
  }

  /**
    The NCProgramInput holds all necessary information to create a new NC program.
    It is needed for the NCPrograms.add method to instantiate a new NC program.
  */
  abstract class NCProgramInput extends core.Base {
    /**
      Get all parameters for the current NC program. Parameters are initialized by user defaults.
      Configure operation parameters before creation for a better performance.
    */
    readonly parameters: CAMParameters
    /**
      Gets and sets the operations which will be included in the NC program.
      Valid input contains any number of operations, setups or folders.
      For setups and folders all child operations will be added.
      Operations will be post processed in setup order, with operations from the same setup grouped together.
      Setting the nc_program_orderByTool BooleanParameterValue on the parameters property to true will reorder operations across multiple setups to reduce the number of tool changes.
      When the list of operations is associated to one setup and the setup has defined its job_programName or job_programComment parameters,
      then those values are applied to the nc_program_name and nc_program_comment parameters accordingly.
    */
    operations: OperationBase[]
    /**
      Optionally specify the display name that appears in the browser-tree to override the default.
    */
    displayName: string
  }

  /**
    The NCProgramPostProcessOptions provides settings to control the post processing of NC programs.
    It is needed for the NCPrograms.postProcess method for posting toolpaths and generating CNC files and setup sheets.
  */
  abstract class NCProgramPostProcessOptions extends core.Base {
    /**
      Creates a new NCProgramPostProcessOptions object to be used as an input argument by the postProcess()
      method.
      @returns Returns the newly created NCProgramPostProcessOptions object or null if the creation failed.
    */
    static create(): NCProgramPostProcessOptions | null
    /**
      Toggles whether the post processing should abort if two tools with the same tool number have been detected.
      True by default. If true, an exception will be thrown if at least two tools map to the same tool number.
      If false, the post processor will not perform a tool change if the tool number is the same, which may mean that the wrong tool is used for an operation.
    */
    isFailOnToolNumberDuplication: boolean
    /**
      Gets and sets the post process behavior with regards to the operations' error or out of date states.
      Uses PostProcessExecutionBehavior_OmitInvalidAndEmptyOperations by default.
    */
    postProcessExecutionBehavior: PostProcessExecutionBehaviors
    /**
      Gets and sets the post process behavior for exporting to Fusion Hub.
      Uses fusionHubExecutionBehavior_ExportWithRelationship by default.
    */
    fusionHubExecutionBehavior: FusionHubExecutionBehaviors
  }

  const enum PostProcessExecutionBehaviors {
    /**
      Default value, post process only valid operations containing toolpath data.
    */
    PostProcessExecutionBehavior_OmitInvalidAndEmptyOperations,
    /**
      If any issue with an operation arises, the post processing should throw an exception.
    */
    PostProcessExecutionBehavior_Fail,
    /**
      Post process all operations disregarding their state.
    */
    PostProcessExecutionBehavior_PostAll,
  }

  /**
    Enum to define the behavior when posting to Fusion hub.
  */
  const enum FusionHubExecutionBehaviors {
    /**
      Post to Fusion Hub while setting the parent document as a relationship.
      In the UI this will raise a "save document" dialog if the parent document's save state is not up to date. Cancelling the dialog, or if none is shown, will result in the document not being saved and the post result not being exported.
    */
    FusionHubExecutionBehavior_ForceExportWithRelationship,
    /**
      Post to Fusion Hub while setting the parent document as a relationship.
      The document and post result are both saved in the Fusion Hub folder specified. If the document has not been saved before, then a new document named "NCProgramPostProcess_YYYYMMDD_HH:MM:SS" will be created with YYYYMMDD_HH:MM:SS being substituted with the current date time.
    */
    FusionHubExecutionBehavior_SilentForceExportWithRelationship,
    /**
      Post to Fusion Hub while setting the parent document as a relationship.
      In the UI this will raise a "save document" dialog if the parent document's save state is not up to date. Cancelling the dialog, or if none is shown, will result in the document not being saved and the post result being exported without setting the relationship in Fusion Hub. This is the default value.
    */
    FusionHubExecutionBehavior_ExportWithRelationship,
    /**
      Post to Fusion Hub without setting the parent document as a relationship. The parent document does not need to be saved to post to Fusion Hub.
    */
    FusionHubExecutionBehavior_SkipRelationship,
  }

  /**
    Object that represents an existing NC program.
  */
  abstract class NCProgram extends OperationBase {
    /**
      Gets and sets the operations which will be included in the NC program.
      Valid input contains any number of operations, setups or folders.
      For setups and folders all child operations will be added.
      Operations will be post processed in setup order, with operations from the same setup grouped together.
      Setting the nc_program_orderByTool BooleanParameterValue on the parameters property to true will reorder operations across multiple setups to reduce the number of tool changes.
    */
    operations: OperationBase[]
    /**
      Gets all valid operations derived from the operations property. The list is ordered with respect to the nc_program_oderByTool parameter and considers the number of instances in a setup.
    */
    readonly filteredOperations: OperationBase[]
    /**
      Gets and sets the post configuration of this NC program.
    */
    postConfiguration: PostConfiguration
    /**
      Gets and sets the machine of this NC program.
      When a machine is set, "use machine configuration" is automatically set to true.
      If this machine has a default post assigned, this post will be set for the NC program as well.
    */
    machine: Machine
    /**
      Gets the post parameters of this NC program.
    */
    readonly postParameters: CAMParameters
    /**
      Overrides the default post parameters of this NC program with the given user's input.
      @returns Returns true if the update was successful. False otherwise.
    */
    updatePostParameters(parameters: CAMParameters): boolean
    /**
      Creates machine-specific NC code for this NC program.
      @param options NCProgramPostProcessOptions to speficy the behavior on internal warning.
      Can be null if the default values should be used.
      If needed it can be created by its static create() method.
      @returns Returns true if the post process was successful.
    */
    postProcess(options: NCProgramPostProcessOptions): boolean
    /**
      Gets and sets the DataFolder to which the exported files should be uploaded to if the parameter nc_program_postToFusionTeam is set to true.
      When a DataFolder is set, nc_program_postToFusionTeam is automatically set to true.
      An exception will be thrown if the DataFolder to set is not valid or not accessible.
      Depending on the FusionHubExecutionBehaviors used for the export the design may be saved at this location as well.
    */
    fusionHubFolder: core.DataFolder
  }

  /**
    Base class object representing all operations, folders, patterns and setups.
  */
  abstract class OperationBase extends core.Base {
    /**
      Gets and sets the name of the operation as seen in the browser.  This name is unique as compared
      to the names of all other operations in the document.
    */
    name: string
    /**
      Gets and sets the "protected" property value of the operation.
      Gets/sets true if the operation is protected.
    */
    isProtected: boolean
    /**
      Gets and sets the "Optional" property value of the operation.
      Gets/sets true if the operation is optional.
    */
    isOptional: boolean
    /**
      Gets and sets the "Suppressed" property value of the operation.
      Gets/sets true if the operation is suppressed.
    */
    isSuppressed: boolean
    /**
      Gets the Setup this operation belongs to.
    */
    readonly parentSetup: Setup
    /**
      Gets if this operation is selected in the 'Setups' browser.
    */
    readonly isSelected: boolean
    /**
      Gets and sets the notes of the operation.
    */
    notes: string
    /**
      Returns the id of the operation.  This id is unique as compared
      to the ids of all other operations in the document.
      This id will not change when changing the order or parent of the operation.
      This id will remain valid when the document is saved and reloaded.
    */
    readonly operationId: number /*int*/
    /**
      Gets the CAMParameters collection for this operation.
    */
    readonly parameters: CAMParameters
    /**
      Returns the collection of attributes associated with this object.
    */
    readonly attributes: core.Attributes
    /**
      Gets the name of the strategy associated with this operation.
    */
    readonly strategy: string
    /**
      Gets if problems were encountered when generating the operation.
    */
    readonly hasWarning: boolean
    /**
      Gets if errors were encountered when generating the operation.
    */
    readonly hasError: boolean
    /**
      Returns a message corresponding to any active error associated with the value of this parameter.
    */
    readonly error: string
    /**
      Returns a message corresponding to any active warning associated with the value of this parameter.
    */
    readonly warning: string
    /**
      Deletes the operation from the document.
      In case of a setup or folder, all containing child operations will be deleted as well.
      Note: Child classes may overwrite this function and throw an exception if the object cannot be deleted.
      @returns Returns true if the delete was successful.
    */
    deleteMe(): boolean
    /**
      Gets if this operation is currently visible in the graphics window. Use the
      isLightBulbOn to change if the eye icon beside the operation node in the
      browser is on or not. Parent nodes in the browser can have their light
      bulb off which affects all of their children so this property does not
      indicate if the operation is actually visible, just that it should be visible
      if all of its parent nodes are also visible. Use the isVisible property
      to determine if it's actually visible.
    */
    isLightBulbOn: boolean
    /**
      Gets if this operation is currently visible in the graphics window. Use the
      isLightBulbOn to change if the eye icon beside the operation node in the
      browser is on or not. Parent nodes in the browser can have their light
      bulb off which affects all of their children. This property indicates
      the final result and whether this operation is actually visible or not.
    */
    readonly isVisible: boolean
    /**
      Get the generated data associated with a given operation base instance. The type of data depends on the strategy type and might not be available for all strategy types.
      The available types can be found in GeneratedData.cs
      @returns null if the given object does not have available generated data, an instance in one of the child classes otherwise.
    */
    readonly generatedDataCollection: GeneratedDataCollection
    /**
      Get ModifyUtility for the current operation by given utility type.
      @param utility Defines the specific ModifyUtility.
      @returns Returns ModifyUtility for specific type or null if the type is not compatible with the operation.
    */
    modifyUtility(utility: ModifyUtilityTypes): ModifyUtility | null
    /**
      Move operation in tree before the given operation.
      Throws an exception if a not allowed move is made for example moving a operation out of a setup.
      @param operation Operation to move targeted operation before.
      @returns Returns if move operation was successful.
    */
    moveBefore(operation: OperationBase): boolean
    /**
      Move operation in tree after the given operation.
      Throws an exception if a not allowed move is made for example moving a operation out of a setup.
      @param operation Operation to move targeted operation after.
      @returns Returns if move operation was successful.
    */
    moveAfter(operation: OperationBase): boolean
    /**
      Move operation in tree into the given container. This only works with setups, patterns and folders.
      Moved operation will be moved at the end of all operations already in the container.
      Throws an exception if a not allowed move is made for example moving a setup into a setup.
      @param container Container to move targeted operation into.
      @returns Returns if move operation was successful.
    */
    moveInto(container: OperationBase): boolean
    /**
      Creates a duplicate of the operation in the tree before the given operation.
      Throws an exception if a not allowed copy operation is made for example copying a operation out of a setup.
      @param operation Operation to copy targeted operation before.
      @returns Returns if copy command was successful.
    */
    copyBefore(operation: OperationBase): boolean
    /**
      Creates a duplicate of the operation in the tree after the given operation.
      Throws an exception if a not allowed copy operation is made for example copying a operation out of a setup.
      @param operation Operation to copy targeted operation after.
      @returns Returns if copy command was successful.
    */
    copyAfter(operation: OperationBase): boolean
    /**
      Creates a duplicate of the operation into the given container. You can only copy into containers, such as setups or folders.
      Copied operation will be copied at the end of all operations already in the container.
      Throws an exception if a not allowed copy operation is made for example copying a setup into a setup.
      @param container Container to copy targeted operation into.
      @returns Returns if copy command was successful.
    */
    copyInto(container: OperationBase): boolean
    /**
      Creates a duplicate of the operation in the tree after the itself.
      @returns Returns if duplicate command was successful.
    */
    duplicate(): boolean
  }

  /**
    The valid options for the Operation Type of a Setup.
  */
  const enum OperationTypes {
    /**
      Specifies a milling type operation
    */
    MillingOperation,
    /**
      Specifies a turning type operation
    */
    TurningOperation,
    /**
      Specifies a Jet type operation
    */
    JetOperation,
    /**
      Specifies an additive type operation
    */
    AdditiveOperation,
  }

  /**
    Collection that provides access to the individual operations within an existing setup, folder or pattern.
  */
  abstract class Operations extends core.Base {
    /**
      Function that returns the specified operation using an index into the collection.
      @param index The index of the item within the collection to return.  The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): Operation | null
    /**
      Returns the operation with the specified name (as appears in the browser).
      @param name The name (as it appears in the browser) of the operation.
      @returns Returns the specified operation or null in the case where there is no operation with the specified name.
    */
    itemByName(name: string): Operation | null
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Returns the operation with the specified operation id.
      @param id The id of the operation.
      @returns Returns the specified operation or null in the case where there is no operation with the specified operation id.
    */
    itemByOperationId(id: number /*int*/): Operation | null
    /**
      Creates a new OperationInput object, which is used to define the operation you want to create.
      Use properties and methods on the returned OperationInput object to define the desired operation
      and then pass it into the add method to create the operation.
      @param strategy The name of the strategy type that you want to create. Use the compatibleStrategies property of
      Operations object to get a list of the names of the strategies.
      @returns Returns a new OperationInput object or will fail if an invalid strategy is specified.
    */
    createInput(strategy: string): OperationInput
    /**
      Create a new Operation.
      @param input The OperationInput object defines the desired Operation. Use the createInput
      method to create a new OperationInput object and then use methods on it to define the Operation.
      The new Operation will be appended at the end of the current list of Operations.
      Throws an error if the strategy type is incompatible with the setup.
      @returns Returns the newly created Operation.
    */
    add(input: OperationInput): OperationBase
    /**
      Gets a list of the strategies that are compatible with the parent setup.
      This only returns strategies that are allowed to be added based on the active Setup or CAMFolder.
      Note: There may be cases where a compatible strategy might not be allowed to be created
      due to licensing or other issues like disabled preview features.
      @returns Returns an array of compatible strategies.
    */
    readonly compatibleStrategies: OperationStrategy[]
  }

  /**
    The OperationStrategy contains information about a strategy such as its name, title and description.
  */
  abstract class OperationStrategy extends core.Base {
    /**
      Create an OperationStrategy for a given name.
      @param name The name of the strategy.
      Throws an error if the strategy name is unknown.
      @returns Returns the OperationStrategy for given strategy name.
    */
    static createFromString(name: string): OperationStrategy
    /**
      Get the name of the strategy. This is equivalent to the Operation's strategy property.
      Use as strategy parameter when creating a OperationInput.
    */
    readonly name: string
    /**
      Get the localized title of the strategy.
    */
    readonly title: string
    /**
      Get the localized description of the strategy.
    */
    readonly description: string
    /**
      Returns true if the strategy is allowed to be generated due to licensing and enabled preview features.
      Some strategies also require Active machining extension to be generated.
      Returns false otherwise.
    */
    readonly isGenerationAllowed: boolean
  }

  /**
    Defines the automatic generation during the creation of an operation using OperationInput or createFromCAMTemplate2.
  */
  const enum AutomaticGenerationModes {
    /**
      Generate newly created operations.
    */
    ForceGeneration,
    /**
      Do not generate newly created operations.
      
    */
    SkipGeneration,
    /**
      Generate operations based on the preference set in the options UI.
    */
    UserPreference,
  }

  /**
    The OperationInput holds all necessary informations to create a new Operation.
    Can be added to the Operations instance for creation.
  */
  abstract class OperationInput extends core.Base {
    /**
      Get the current strategy
    */
    readonly strategy: string
    /**
      Get all parameters for the current strategy. Parameters are initialized by user defaults.
      Configure operation parameters before creation for a better performance.
    */
    readonly parameters: CAMParameters
    /**
      Optionally specify the tool used by the operation. The ToolLibraries allows the access to Local and Fusion tools.
      Setting the tool will overwrite tool parameters in the parameters property.
    */
    tool: Tool
    /**
      Optionally specify the preset of the tool. If no preset is specified, the operation gets its default feed and speed.
      The Tool provides access to available presets. Use one of those presets to override the default.
      Setting the tool will overwrite a subset of tool parameters in the parameters property.
      An invalid preset will cause a failure during the creation of the operation.
    */
    toolPreset: ToolPreset
    /**
      Optionally specify the display name that appears in the browser-tree to override the default.
    */
    displayName: string
    /**
      Defines the automatic generation during the creation of the operation.
      Can be used to force or skip the generation of the new operation.
      By default the newly created operation will not be generated.
      The default value is SkipGeneration.
    */
    generationMode: AutomaticGenerationModes
  }

  /**
    Object that represents an operation in an existing Setup, Folder or Pattern.
  */
  abstract class Operation extends OperationBase {
    /**
      Gets the strategy type for this operation.
      @remarks
      This property has been retired. Please use the strategy property instead.
      @deprecated
    */
    readonly strategyType: OperationStrategyTypes
    /**
      Gets if the toolpath for this operation is currently valid. (has not become invalidated by model changes).
    */
    readonly isToolpathValid: boolean
    /**
      Gets if the operation is being generated.
    */
    readonly isGenerating: boolean
    /**
      Returns the parent Setup, Folder or Pattern for this operation.
    */
    readonly parent: core.Base
    /**
      Gets if a toolpath currently exists (has been generated) for this operation.
    */
    readonly hasToolpath: boolean
    /**
      Gets the current state of this operation.
    */
    readonly operationState: OperationStates
    /**
      Gets the generation progress value for this operation.
    */
    readonly generatingProgress: string
    /**
      Get or set the tool for this operation. The document's tool library will be updated accordingly.
      The tool instance returned is a copy and therefore is not referenced by the operation.
      To change the tool of the operation, the new tool must be assigned to the operation.
      Setting a tool will override the current preset and will fall back to the default preset of the new tool.
    */
    tool: Tool
    /**
      Get or set the tool preset to be used. Must be a valid preset of the already assigned tool. Returns null if the operation has no tool or preset.
    */
    toolPreset: ToolPreset
  }

  /**
    The valid options for the Strategy Type of an operation.
    @remarks
    This type is retired. Use the strategy property of an operation to get its strategy name.
    To get a list of available strategies, the Operations object has a property that returns compatible strategies.
    @deprecated
  */
  const enum OperationStrategyTypes {
    /**
      A 2D strategy that creates a roughing operation that uses a more optimized toolpath that avoids abrupt direction changes.
    */
    AdaptiveClearing2D,
    /**
      A 2D strategy that creates a roughing operation that uses toolpaths parallel to selected geometry.
    */
    Pocket2D,
    /**
      A 2D strategy that produces quick part facing to prepare raw stock for machining.
    */
    Face,
    /**
      A 2D strategy that creates toolpaths based on a 2D contour.  Contours can be open or closed and can be on
      different Z-levels, but each contour is flat (2D).
    */
    Contour2D,
    /**
      A 2D strategy that mills a slot by following the center line of the slot.
    */
    Slot,
    /**
      A 2D strategy that machines along contours with varying Z values and with, or without,
      left and right side compensation.
    */
    Trace,
    /**
      A 2D strategy for thread milling cylindrical pockets and islands.
    */
    Thread,
    /**
      A 2D strategy for milling cylindrical pockets and islands by selecting the cylindrical geometry directly.
    */
    Bore,
    /**
      A 2D strategy for milling cylindrical pockets and islands.
    */
    Circular,
    /**
      A 2D strategy that machines along contours with V-shaped chamfered walls.
    */
    Engrave,
    /**
      A 3D roughing strategy for clearing large quantities of material effectively.
    */
    AdaptiveClearing,
    /**
      A 3D conventional roughing strategy for clearing large quantities of material effectively.
    */
    PocketClearing,
    /**
      A 3D finishing strategy.  The passes are parallel in the XY-plane and follow the surface in the Z-direction.
    */
    Parallel,
    /**
      A 3D strategy for finishing steep walls, but can be used for semi-finish and finish machining on the more
      vertical areas of a part.
    */
    Contour,
    /**
      A 3D finishing strategy intended for steep areas similar to the contour strategy.
      However, this strategy ramps down walls rather than machining them with a constant Z, as contour does.
    */
    Ramp,
    /**
      A 3D strategy that automatically detects all the flat areas of the part and clears them with an offsetting path.
    */
    Horizontal,
    /**
      A 3D strategy that creates toolpaths along internal corners and fillets with small radii,
      removing material that no other tool can reach.
    */
    Pencil,
    /**
      A 3D strategy that creates passes at a constant distance from one another by offsetting them inwards along the
      surface.  The passes follow sloping and vertical walls to maintain the stepover.
    */
    Scallop,
    /**
      A 3D strategy that creates a spiral toolpath from a given center point, generating a constant contact as it machines
      within a given boundary.
    */
    Spiral,
    /**
      A 3D strategy similar to Spiral machining.  This operation also starts from a center point, providing the ability to
      machine radial parts.  It also provides the option to stop short of the center of the radial passes, where they become
      very dense.
    */
    Radial,
    /**
      A 3D strategy similar to Spiral except that this operation generates the spiral from the selected boundary as
      opposed to Spiral which trims the generated passes to the machining boundary.
    */
    MorphedSpiral,
    /**
      A finishing strategy that allows you to machine along contours with the center of the tool.
      The provided contours are automatically projected onto the surface, so they do not have to actually lie on the surface.
    */
    Projection,
    /**
      A strategy that supports a wide range of drilling, tapping and hole making operations such as counterbores and
      countersinks.
    */
    Drilling,
    /**
      A strategy that creates a 2D toolpath for waterjet, laser, and plasma cutting processes.
    */
    Jet2D,
    /**
      The turning chamfer strategy is used for chamfering sharp corners that have not been chamfered in the design.
    */
    TurningChamfer,
    /**
      The face strategy is used for machining the front side of the part.
    */
    TurningFace,
    /**
      The turning groove strategy is used for grooving at selected positions only. This can for instance be used to make a groove on the backside before threading.
    */
    TurningGroove,
    /**
      This strategy is used for cutting off the part once the part has been fully machined or for machining it on another spindle.
    */
    TurningPart,
    /**
      The turning profile strategy is used for both roughing and finishing of the part using general turning tools.
    */
    TurningProfile,
    /**
      The turning groove strategy is used for both roughing and finishing of the part using groove tools.
    */
    TurningProfileGroove,
    /**
      The turning stock transfer strategy is intended for automatic stock transfer between the two spindles. No toolpath is associated with this strategy.
      The post is responsible for outputting the desired NC code.
    */
    TurningStockTransfer,
    /**
      This strategy is used for turning threads. Both cylindrical and conical threads are supported.
      The CNC control must have built-in support for synchronizing the spindle and feed.
    */
    TurningThread,
    /**
      A 3D finishing strategy that uses Contour passes for steep areas and Parallel or Scallop passes for
      shallow areas.
    */
    SteepAndShallow,
    /**
      A 3D finishing strategy which follows the isocurves of a surface to machine parts with curved surfaces.
      Flow is a 3-Axis toolpath by default but can be used in multi-axis modes.
    */
    Flow,
    /**
      A 3D finishing strategy which follows the isocurves of a surface to machine parts with curved surfaces.
      Flow is a 3-Axis toolpath by default but can be used in multi-axis modes.
    */
    Flow2,
    /**
      A multi-axis machining strategy that lets you machine along and around a rotating axis.
      Rotary Finishing can be used for parts that are machined most efficiently when utilizing the 4th Machine Axis.
    */
    RotaryFinishing,
    /**
      A 2D machining strategy that machines along contours creating a chamfered surface.
    */
    Chamfer2D,
    /**
      A 3D finishing strategy for machining shallow areas between selected contours with a consistent cutting direction.
    */
    Morph,
    /**
      A multi-axis strategy for machining with the tip of the tool along a given contact curve.
    */
    MultiAxisContour,
    /**
      A multi-axis strategy for machining shallow areas between selected contours with a consistent cutting direction.
    */
    MultiAxisMorph,
    /**
      A finishing operation to machine any remaining stock left from previous operations.
    */
    RestFinishing,
    /**
      A multi-axis strategy for machining with the side of the tool.
    */
    Swarf,
    /**
      A strategy for the inspection of geometry using probe.
    */
    SurfaceInspection,
    /**
      Manual inspection.
    */
    ManualInspection,
    /**
      Probe WCS operation
    */
    ProbeWCS,
    /**
      Probe Geometry operation
    */
    ProbeGeometry,
    /**
      Part alignment.
    */
    PartAlignment,
    /**
      A surface inspection measurement with a results folder.
    */
    PathMeasure,
    /**
      Recorded results of a manual inspection.
    */
    ManualMeasure,
  }

  /**
    The possible states of an operation. Some operations do not generate toolpaths, their state ignores the potential toolpath states.
  */
  const enum OperationStates {
    /**
      Indicates the state where the operation is valid and is up to date and the toolpath exists if applicable.
    */
    IsValidOperationState,
    /**
      Indicates the state where the operation or its toolpath is invalid.
    */
    IsInvalidOperationState,
    /**
      Indicates the state where the operation is suppressed. Toolpaths do not exist for suppressed operations.
    */
    SuppressedOperationState,
    /**
      Indicates the state where the toolpath does not exist for an operation. Not applicable for operations that do not generate toolpaths.
    */
    NoToolpathOperationState,
  }

  /**
    Collection that provides access to the parameters of an existing operation.
  */
  abstract class CAMParameters extends core.Base {
    /**
      Function that returns the specified parameter using an index into the collection.
      @param index The index of the item within the collection to return.  The first item in the collection has an index of 0.
      @returns Returns the specified item or null if an invalid index was specified.
    */
    item(index: number /*unsigned int*/): CAMParameter | null
    /**
      Returns the parameter of the specified id (internal name).
      @param internalName The id (internal name) of the parameter.
      @returns Returns the specified parameter or null in the case where there is no parameter with the specified id.
    */
    itemByName(internalName: string): CAMParameter | null
    /**
      The number of items in the collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    Base class for representing parameter of an operation.
  */
  abstract class CAMParameter extends core.Base {
    /**
      Gets the name (internal name) of the parameter.
    */
    readonly name: string
    /**
      Returns the title of this parameter as seen in the user interface.
      This title is localized and can change based on the current language
    */
    readonly title: string
    /**
      Gets and sets the value expression of the parameter.
    */
    expression: string
    /**
      Gets if this parameter is enabled.  Some parameters are enabled/disabled depending on the values
      set for other parameters.
    */
    readonly isEnabled: boolean
    /**
      Returns a message corresponding to any active error associated with the value of this parameter.
    */
    readonly error: string
    /**
      Returns a message corresponding to any active warning associated with the value of this parameter.
    */
    readonly warning: string
    /**
      Returns whether or not the parameter's expression or value can be modified.
    */
    readonly isEditable: boolean
    /**
      Returns an object that allows you to get and set the value associated with the parameter.
      @remarks
      Within CAM operations, floating point values (via FloatParameterValue) are returned
      and set using a standardized set of "internal" units, rather than using the document units.
      The units used depend on the type of parameter. For reference, the units used are:
      - Length - centimeters (cm)
      - Angle - radians (rad)
      - Linear velocity - millimeters/minute (mm/min)
      - Rotational velocity - revolutions per minute (rpm)
      - Time - seconds (s)
      - Weight - kilograms (kg)
      - Power - Watts (W)
      - Flow rate - liters/minute (l/min)
      - Area - square centimeters (cm)
      - Volume - cubic centimeters (cm)
      - Temperature - degrees Celsius (C)
    */
    readonly value: ParameterValue
    /**
      Gets if this parameter is deprecated. Some parameters are deprecated when their usage becomes obsolete.
      Reading deprecated parameters is allowed, but setting deprecated parameters will throw an error.
    */
    readonly isDeprecated: boolean
  }

  /**
    Base class for representing the value of a parameter.
    Subclasses implement value handling for available parameter types.
  */
  abstract class ParameterValue extends core.Base {
    /**
      Get the parameter object that the value is associated with.
    */
    readonly parent: core.Base
  }

  /**
    A parameter value that is an integer.
  */
  abstract class IntegerParameterValue extends ParameterValue {
    /**
      Get or set the value of the parameter.
    */
    value: number /*int*/
  }

  /**
    Defines the type of a FloatParameterValue.
  */
  const enum FloatParameterValueTypes {
    /**
      Unspecified type can reprecent any type
    */
    UnspecifiedValueType,
    /**
      Length in centimeters (cm)
    */
    LengthValueType,
    /**
      Angle in radians (rad)
    */
    AngleValueType,
    /**
      Linear velocity in millimeters/minute (mm/min)
    */
    LinearVelocityValueType,
    /**
      Rotational velocity in revolutions per minute (rpm)
    */
    RotationalVelocityValueType,
    /**
      Time in seconds (s)
    */
    TimeValueType,
    /**
      Weight in kilograms (kg)
    */
    WeightValueType,
    /**
      Power in Watts (W)
    */
    PowerValueType,
    /**
      Flow rate in liters/minute (l/min)
    */
    FlowRateValueType,
    /**
      Area in square centimeters (cm)
    */
    AreaValueType,
    /**
      Volume in cubic centimeters (cm)
    */
    VolumeValueType,
    /**
      Temperature in degrees Celsius (C)
    */
    TemperatureValueType,
  }

  /**
    A parameter value that is a floating point value.
  */
  abstract class FloatParameterValue extends ParameterValue {
    /**
      Get or set the value of the parameter.
    */
    value: number
    /**
      Get the type of the float parameter.
    */
    readonly type: FloatParameterValueTypes
  }

  /**
    A parameter value that is a boolean.
  */
  abstract class BooleanParameterValue extends ParameterValue {
    /**
      Get or set the value of the parameter.
    */
    value: boolean
  }

  /**
    A parameter value that is a string.
  */
  abstract class StringParameterValue extends ParameterValue {
    /**
      Get or set the value of the parameter.
    */
    value: string
  }

  /**
    A parameter value that is a list of choices.
  */
  abstract class ChoiceParameterValue extends ParameterValue {
    /**
      Method that returns the list of available choices.
      @param names An array of the names of the choices. These coincide with the array of possible values returned by the values argument.
      @param values An array of the possible values. These coincide with the array of names returned by the names argument.
      @returns Returns true if the call was successful.
    */
    getChoices(): [names: string[], values: string[]]
    /**
      Get or set the value of the parameter.
      This value will correspond to one of the available values of the parameter.
    */
    value: string
  }

  /**
    A parameter value that is a collection of cad objects.
  */
  abstract class CadObjectParameterValue extends ParameterValue {
    /**
      Get or set the value of the parameter.
      If the value originates from a component instead of an occurrence, or an occurrence outside of the CAM environment, then the subpath is checked against the CAM model tree.
      An exception is thrown if the matching fails or the given entity does not match the expected type.
    */
    value: core.Base[]
  }

  /**
    A parameter value that is a CadContours2dParameterValue.
    The user needs to set the parameter anew via the API after a model update or after the CurveSelections returned by getCurveSelections() has been edited.
  */
  abstract class CadContours2dParameterValue extends ParameterValue {
    /**
      Get the values of the parameter as a collection of CadCurves, which might consist of chains, pockets, silhouettes and face countours.
      @returns Returns current CurveSelections of the value.
    */
    getCurveSelections(): cam.CurveSelections
    /**
      Set the values of the parameter as a collection of CadCurves.
      If the input does not define continuous contours, the contour is amended and calculated, but only if used on Operations, not OperationInputs
      When used with OperationInputs, the contours are calculated when creating an operation out of the input.
    */
    applyCurveSelections(curveSelections: cam.CurveSelections): void
  }

  /**
    A parameter value that is a CAMArrangeParameterValue.
    The user needs to set the parameter anew via the API after a model update or after the ArrangeSelections returned by getArrangeSelections() have been edited.
  */
  abstract class CAMArrangeParameterValue extends ParameterValue {
    /**
      Get the values of the parameter as a collection of CadObjects, which currently consist of occurrences.
      @returns Returns current ArrangeSelections of the value.
    */
    getArrangeSelections(): cam.ArrangeSelections
    /**
      Set the values of the parameter as a collection of CadObjects.
    */
    applyArrangeSelections(arrangeSelections: cam.ArrangeSelections): void
  }

  /**
    A parameter value that is a CadMachineAvoidGroupsParameterValue.
  */
  abstract class CadMachineAvoidGroupsParameterValue extends ParameterValue {
    /**
      Get the values of the parameter as a collection of objects of type MachineAvoidSelectionGroup
    */
    getMachineAvoidGroups(): cam.MachineAvoidGroups
    /**
      Set the values of the parameter as a collection of MachineAvoidSelectionGroup.
      This can throw an exception when the combination of group type and machining mode is not allowed
      by the current toolpath strategy.
    */
    applyMachineAvoidGroups(machineAvoidSelectionGroups: cam.MachineAvoidGroups): void
  }

  /**
    Object that represents a single pocket (an outer boundary with depth and optional islands)
    which has been recognized on the model.
    See PocketRecognitionSelection for making a selection as in the UI
  */
  abstract class RecognizedPocket extends core.Base {
    /**
      Gets all recognized pockets from the given body and returns them
      @param body Model body on which to recognize pockets
      @param attackVector A vector defining the orientation in which to search for pockets. This should be the
      vector pointing down along the tool towards its tip and the pocket floors.
    */
    static recognizePockets(body: core.Base, attackVector: core.Vector3D): RecognizedPockets
    /**
      Returns the outside boundaries of this pocket (in cm).
    */
    readonly boundaries: core.Curve3DPath[]
    /**
      Returns each island inside this pocket as a separate ProfileLoop object (in cm).
    */
    readonly islands: core.Curve3DPath[]
    /**
      Returns the depth of the pocket in centimeters, i.e. the positive distance from top to bottom
    */
    readonly depth: number
    /**
      Returns true if this is a through pocket, i.e. if the bottom is open.
    */
    readonly isThrough: boolean
    /**
      Returns true if this pocket is closed, i.e. if its boundary is a single closed curve.
    */
    readonly isClosed: boolean
    /**
      Returns the type of bottom edge this pocket has.
    */
    readonly bottomType: RecognizedPocketBottomType
    /**
      Returns all faces making up the pocket.
    */
    readonly faces: fusion.BRepFace[]
    /**
      Returns all faces making up the pocket, which are shared with other pockets.
    */
    readonly sharedFaces: fusion.BRepFace[]
  }

  /**
    Types of pocket bottoms that can exist. Flat represents a standard flat bottom with sharp
    edges at the walls. (Flat may also have some portions that are through, but may not have any
    portions that are chamfered or filleted.) Through represents a pocket with no bottom
    anywhere along the boundary and sharp edges at the walls. Chamfer and fillet represent pockets
    where that type of feature goes around all edges of the boundary and islands, between the bottom
    and the walls.  Other represents any other cases, such as a mix of different bottom types for
    different edges.
  */
  const enum RecognizedPocketBottomType {
    RecognizedPocketBottomTypeFlat,
    RecognizedPocketBottomTypeThrough,
    RecognizedPocketBottomTypeChamfer,
    RecognizedPocketBottomTypeFillet,
    RecognizedPocketBottomTypeOther,
  }

  /**
    Object that represents a collection of pockets.
  */
  abstract class RecognizedPockets extends core.Base {
    /**
      Returns the pocket at the specified index from this collection of pockets.
      @param index The index of the pocket within this pocket collection to return. The first pocket in this collection has an index of 0.
    */
    item(index: number /*unsigned int*/): RecognizedPocket
    /**
      Returns the number of pockets contained in this pocket collection.
    */
    readonly count: number /*unsigned int*/
  }

  /**
    The PostLibrary provides access to post configurations. Using this object you can import post configurations
    and get existing post configurations using either a URL or query to find specific post configurations.
  */
  abstract class PostLibrary extends CAMLibrary {
    /**
      Creates a new PostConfigurationQuery that is used to query the library for post configurations matching
      the query.
      @param location The location specifies the LibraryLocations where to search for in the post library.
      @returns Returns a new PostConfigurationQuery. The query is predefined by given parameter.
    */
    createQuery(location: LibraryLocations): PostConfigurationQuery
    /**
      Import a given post configuration at a specific location. The post configuration will be stored in the library. Throws an error, if the given URL is read-only.
      @param postConfig The post configuration that should be imported.
      @param destinationUrl The URL to the folder where to save the post configuration.
      @param postName The name of the post configuration that should be created due to the import. The name can be extended if the name already exists at given location to ensure a unique name.
      @returns Returns the URL of the newly imported post configuration, or null if the import failed.
    */
    importPostConfiguration(postConfig: PostConfiguration, destinationUrl: core.URL, postName: string): core.URL | null
    /**
      Get a specific post configuration by the given URL. Returns null, if the URL does not exist.
      @param url The URL to the post configuration to be loaded.
      @returns Returns the post configuration for a valid URL, returns null otherwise.
    */
    postConfigurationAtURL(url: core.URL): PostConfiguration | null
    /**
      Get all posts by the given parent folder URL. Returns null, if the URL does not exist.
      @param url The URL of the folder to get post configurations from.
      @returns Returns all children posts for a valid URL, returns null otherwise.
    */
    childPostConfigurations(url: core.URL): PostConfiguration[] | null
  }

  /**
    A PostConfigurationQuery can be used to search a LibraryLocation for a set of PostConfiguration objects matching the required properties.
  */
  abstract class PostConfigurationQuery extends core.Base {
    /**
      The case-insensitive vendor specifies the vendor of the post configuration. The default empty vendor applies to all post configurations.
    */
    vendor: string
    /**
      The URL specifies the location and folder to search for in the post library.
      Setting the URL updates the location.
    */
    url: core.URL
    /**
      Specifies the capability to search for in the post library.
    */
    capability: PostCapabilities
    /**
      The location specifies the location to search in the post library.
      Setting the location clears any previous specified URL.
    */
    location: LibraryLocations
    /**
      Query for specific posts. This PostConfiguration query.
      @returns Returns a list of posts. Each returned post matches this query.
    */
    execute(): PostConfiguration[]
  }

  /**
    Object that represents a post configuration.
  */
  abstract class PostConfiguration extends core.Base {
    /**
      Gets the name of the vendor of the machine tool or controller this post configuration supports.
    */
    readonly vendor: string
    /**
      Gets the description of the post.
    */
    readonly description: string
    /**
      Gets the capabilities supported by the post.
      Capabilities define what types of operations can be post processed using this configuration.
    */
    readonly capability: PostCapabilities
    /**
      Gets the version of the post.
    */
    readonly version: string
    /**
      Gets the extension of the output file created by the post.
    */
    readonly extension: string
  }

  /**
    List of capabilities a post configuration can support.
    These capabilities represent either a class of operations (milling, turning, etc.) or some additional functionality (e.g. machine simulation).
  */
  const enum PostCapabilities {
    /**
      Undefined, default when query is created.
    */
    Undefined = 0,
    /**
      Post supports milling operations.
    */
    Milling = 1,
    /**
      Post supports turning operations.
    */
    Turning = 2,
    /**
      Post creates a setup sheet rather than NC code.
    */
    SetupSheet = 4,
    /**
      Post outputs data in an intermediate format intended for processing by another application rather than NC code for a machine.
    */
    Intermediate = 8,
    /**
      Post supports jet cutting operations (e.g. water jet, plasma, or laser).
    */
    Jet = 16,
    /**
      Post configuration is intended to run as a complement to another post that produces NC code to pass additional data to an external application.
    */
    Cascading = 32,
    /**
      Post supports additive operations.
    */
    Additive = 64,
    /**
      Post supports surface inspection operations.
    */
    Inspection = 128,
    /**
      Post configuration provides additional data to support machine simulation.
    */
    MachineSimulation = 256,
  }

  /**
    The PrintSettingLibrary provides access to PrintSettings. Using this object you can import PrintSettings
    and get existing PrintSettings using either URL or query to find specific PrintSetting.
  */
  abstract class PrintSettingLibrary extends CAMLibrary {
    /**
      Creates a new PrintSettingQuery that is used to query the library for PrintSettings matching
      the query.
      @param location The location specifies the LibraryLocations where to search for in the PrintSetting library.
      @returns Returns a new PrintSettingQuery. The query is predefined by given parameter.
    */
    createQuery(location: LibraryLocations): PrintSettingQuery
    /**
      Import a given PrintSetting at a specific location. The PrintSetting will be stored in the library. Throws an error if the given URL is read-only.
      @param printSetting The PrintSetting that should be imported.
      @param destinationUrl The URL to the folder where to save the PrintSetting.
      @param printSettingName The name that should be assigned to imported PrintSetting. The name can be extended if there already exists a PrintSetting at given location to ensure a unique name.
      @returns Returns the URL of the newly imported PrintSetting, or null if the import failed.
    */
    importPrintSetting(printSetting: PrintSetting, destinationUrl: core.URL, printSettingName: string): core.URL | null
    /**
      Update a PrintSetting in the library. The library overrides the URL by given PrintSetting. Throws an error if the URL does not already point to an existing printSetting.
      @param url The URL to the existing asset in the library that should be updated.
      @param printSetting The PrintSetting that should be persisted.
      @returns Returns true if asset was updated successfully, false otherwise.
    */
    updatePrintSetting(url: core.URL, printSetting: PrintSetting): boolean
    /**
      Get a specific PrintSetting by the given URL. Returns null if the URL does not exist.
      @param url The URL to the PrintSetting to be loaded.
      @returns Returns the PrintSetting for a valid URL, returns null otherwise.
    */
    printSettingAtURL(url: core.URL): PrintSetting | null
    /**
      Get all PrintSettings by the given parent folder URL. Returns null, if the URL does not exist.
      @param url The URL of the folder to get PrintSettings from.
      @returns Returns the PrintSetting for a valid URL, returns null otherwise.
    */
    childPrintSettings(url: core.URL): PrintSetting[] | null
  }

  /**
    A PrintSettingQuery can be used to search a LibraryLocation for a set of PrintSetting objects matching the required properties.
  */
  abstract class PrintSettingQuery extends core.Base {
    /**
      The case-insensitive name specifies the name of the PrintSetting.
    */
    name: string
    /**
      The case-insensitive technology specifies technology of the PrintSetting.
    */
    technology: string
    /**
      The case-insensitive vendor specifies vendor of the PrintSetting. Generic FFF PrintSetting doesnt have a vendor.
    */
    vendor: string
    /**
      The case-insensitive material specifies material of the MPBF PrintSetting.
    */
    material: string
    /**
      The filament diameter specifies filament diameter for FFF Printer. This should match the FFF PrintSetting filament diameter in cm.
      @remarks
      This property has been retired. The machine now contains the filament diameter(s) in the extruder(s).
      @deprecated
    */
    filamentDiameter: number
    /**
      The layer height specifies layer height of the PrintSetting. This should match the PrintSetting layer height in cm.
    */
    layerHeight: number
    /**
      The URL specifies the location and folder to search for in the PrintSetting library.
      Setting the URL updates the location.
    */
    url: core.URL
    /**
      The location specifies the location to search in the PrintSetting library.
      Setting the location clears any previous specified URL.
    */
    location: LibraryLocations
    /**
      Query for specific PrintSettings. This PrintSettingQuery query.
      @returns Returns a list of PrintSetting. Each returned PrintSetting matches this query.
    */
    execute(): PrintSetting[]
    /**
      The machine specifies which machine the found print setting are compatible with.
    */
    machine: Machine
  }

  /**
    Object that represents a PrintSetting.
  */
  abstract class PrintSetting extends core.Base {
    /**
      Gets and sets the name of the PrintSetting.
    */
    name: string
    /**
      Gets and sets the description of the PrintSetting.
    */
    description: string
    /**
      Gets the technology of the PrintSetting.
    */
    readonly technology: string
    /**
      Gets the unique identifier of the PrintSetting.
      Can be used for comparing PrintSettings within the document.
    */
    readonly id: string
    /**
      Creates a PrintSetting from a xml content.
      @param xmlContent The xml content string of a PrintSetting file to act as a base for creating a PrintSetting from.
      @returns Returns the newly created PrintSetting.
    */
    static createFromXML(xmlContent: string): PrintSetting
    /**
      Function that returns the specified parameterTable using an enum into the collection.
      @param type The type of the item within the collection to return.
      @returns Returns the specified type of parameters or null if an invalid type was specified.
    */
    parameters(type: PrintSettingItemTypes): CAMParameters | null
    /**
      Returns the PrintSetting item of the specified body preset.
      @param name The body preset id of the parameters.
      @returns Returns the specified parameters or  throws exception in the case where there is no parameters with the specified id.
    */
    itemByName(name: string): PrintSettingItem
    /**
      Duplicates the PrintSetting item of the specified body preset.
      @param name The body preset id of the parameters that has to be duplicated.
      @returns Returns the specified parameters or throws exception in the case where there is no parameters with the specified id.
    */
    duplicatePrintSettingItem(name: string): PrintSettingItem
    /**
      Deletes the PrintSettingItem of the specified body preset.
      Throws an exception when the name does not match any available PrintSettingItems or when trying to delete the default PrintSettingItem.
      @param name The body preset id of the parameters that has to be deleted.
    */
    deletePrintSettingItem(name: string): void
    /**
      Defaults the PrintSetting item of the specified body preset. Throws exception when name not found.
      @param name The body preset id of the parameters that has to be defaulted.
    */
    setDefaultPrintSettingItem(name: string): void
    /**
      Gets the default PrintSetting item of the specified body preset. Throws exception when name not found.
      @returns Returns the default parameters.
    */
    getDefaultPrintSettingItem(): PrintSettingItem
    /**
      Get the PrintSettingItem at index in PrintSetting.
      @param index The index of the PrintSettingItem.
      @returns The PrintSettingItem at index.
    */
    item(index: number /*int*/): PrintSettingItem
    /**
      Get the number of PrintSettingItems in this collection.
    */
    readonly count: number /*unsigned int*/
    /**
      Synchronizes the print setting with the given machine, making extruder parameter options dependent on the available extruders in the machine.
    */
    syncWithMachine(machine: Machine): boolean
    /**
      Checks whether the print setting is usable with the given machine.
    */
    isCompatibleWithMachine(machine: Machine): boolean
  }

  /**
    Collection that provides access to the print setting parameters.
  */
  abstract class PrintSettingItem extends core.Base {
    /**
      Body Preset get and set name.
    */
    name: string
    /**
      Body Preset get and set description.
    */
    description: string
    /**
      Function that returns the parameters for reading and editing values.
      @returns Returns the parameters of specified item.
    */
    readonly parameters: CAMParameters
  }

  /**
    Enum that represents the types of CAMParameters.
    Represents the General and Exporter parameters type in PrintSetting.
  */
  const enum PrintSettingItemTypes {
    GENERAL,
    EXPORTER,
  }

  /**
    The StockMaterialLibraries object provides utilities to access, import and update stock material by URL.
    @experimental
  */
  abstract class StockMaterialLibrary extends CAMLibrary {
    /**
      Import a given stockMaterial at a specific location. The stockMaterial will be stored in the library. Throws an error, if the given URL is read-only.
      @param stockMaterial The stockMaterial that should be imported.
      @param destinationUrl The URL to the folder where to save the stockMaterial.
      @param stockMaterialName The name of the stockMaterial that should be created due to the import. The name can be extended if the asset already exists at given location to ensure a unique name.
      @returns Returns the URL of the newly imported stockMaterial, or null if the import failed.
    */
    importStockMaterial(stockMaterial: StockMaterial, destinationUrl: core.URL, stockMaterialName: string): core.URL | null
    /**
      Update a stockMaterial in the library. The library overrides the URL by given stockMaterial. Throws an error if the URL does not already point to an existing stockMaterial.
      @param url The URL to the existing asset in the library that should be updated.
      @param stockMaterial The stockMaterial that should be persisted.
      @returns Returns true if asset was updated successfully, false otherwise.
    */
    updateStockMaterial(url: core.URL, stockMaterial: StockMaterial): boolean
    /**
      Get a specific stockMaterial by the given URL. Returns null, if the URL does not exist.
      @param url The URL to the stockMaterial to be loaded.
      @returns Returns the stockMaterial for a valid URL, returns null otherwise.
    */
    stockMaterialAtURL(url: core.URL): StockMaterial | null
    /**
      Get all stockMaterials by the given parent folder URL. Returns null, if the URL does not exist.
      @param url The URL of the folder to get stockMaterials from.
      @returns Returns the stockMaterials for a valid URL, returns null otherwise.
    */
    childStockMaterials(url: core.URL): StockMaterial[] | null
  }

  /**
    Represents a StockMaterial.
    @experimental
  */
  abstract class StockMaterial extends core.Base {
    /**
      Creates a StockMaterial object from given JSON string.
      @param json The JSON should fully define the StockMaterial and contain all StockMaterial parameters.
      If the JSON contains more than one StockMaterial, only the first StockMaterial is loaded.
      @returns Returns the newly created StockMaterial.
    */
    static createFromJson(json: string): StockMaterial
    /**
      Generates and returns a JSON string that contains a description of this StockMaterial.
      @returns Returns a JSON string that contains a description of this StockMaterial.
    */
    toJson(): string
    /**
      Gets and sets the category of the stock material.
    */
    category: string
    /**
      Gets and sets the name of the stock material.
    */
    name: string
    /**
      Gets a list of designators of the stock material.
    */
    designators: string[]
    /**
      Get and sets the hardness of the stock materials.
      NOTE: the hardness can be NaN if not set. and user can set the hardness to NaN.
    */
    hardness: number
  }

  /**
    DocumentStockMaterialLibrary provides access to stock materials used by the document.
    @experimental
  */
  abstract class DocumentStockMaterialLibrary extends core.Base {
    /**
      The number of StockMaterial in the DocumentStockMaterialLibrary.
    */
    readonly count: number /*unsigned int*/
    /**
      Get StockMaterial by index in DocumentStockMaterialLibrary.
      @param index Index of the StockMaterial in the DocumentStockMaterialLibrary.
      @returns Returns the StockMaterial in the DocumentStockMaterialLibrary by given index.
    */
    item(index: number /*unsigned int*/): StockMaterial
    /**
      Returns all setups that use the given StockMaterial. The StockMaterial must exist in the document StockMaterial library.
      Raises an error if the StockMaterial is not in the document.
      @param stockMaterial The StockMaterial to search for setups. The StockMaterial must exist in the document.
      @returns Returns setups using a specific StockMaterial.
    */
    setupsByStockMaterial(stockMaterial: StockMaterial): Setup[]
    /**
      Update the given StockMaterial in the document StockMaterial library. The update applies all changes to the
      stockMaterial in the document stockMaterial library and therefore on all setups that use the stockMaterial.
      Will error if the stockMaterial does not exist in the document stockMaterial library.
      @param stockMaterial The StockMaterial that should be updated.
      @returns Returns true if the update was successful.
    */
    update(stockMaterial: StockMaterial): boolean
  }

  /**
    The ToolLibraries object provides utilities to access, import and update tool libraries.
  */
  abstract class ToolLibraries extends CAMLibrary {
    /**
      Import a given ToolLibrary from a specific location. The imported ToolLibrary can be accessed
      through this ToolLibraries object. Throws an error, if the given URL is read-only.
      @param toolLibrary The ToolLibrary that should be imported.
      @param destinationUrl The URL to the parent folder where the imported tool library will be saved.
      @param libraryName The name of the library that should be created due to the import. If the specified name already
      exists, a number will be added to the name to ensure it is unique.
      @returns Returns the URL of the newly imported tool library, or null if the import failed.
    */
    importToolLibrary(toolLibrary: ToolLibrary, destinationUrl: core.URL, libraryName: string): core.URL | null
    /**
      Update ToolLibrary in ToolLibraries. Overrides the URL by given ToolLibrary.
      Throws an error if the URL does not already point to an existing ToolLibrary.
      @param url The URL to the existing asset in the ToolLibraries that should be updated.
      @param toolLibrary The ToolLibrary that should be persisted.
      @returns Returns true if asset was updated successfully, false otherwise.
    */
    updateToolLibrary(url: core.URL, toolLibrary: ToolLibrary): boolean
    /**
      Get a specific ToolLibrary by given URL. Returns null, if the URL does not exist.
      @param url The URL to the ToolLibrary to be loaded.
      @returns Returns the ToolLibrary for a valid URL, returns null otherwise.
    */
    toolLibraryAtURL(url: core.URL): ToolLibrary | null
    /**
      Creates a new ToolQuery that is used to query the library for tools matching
      the query.
      @param location The location specifies the LibraryLocations where to search.
      @returns Returns a new ToolQuery. The query is predefined by given parameter.
    */
    createQuery(location: LibraryLocations): ToolQuery
  }

  /**
    ToolLibrary represents a collection of Tool objects.
  */
  abstract class ToolLibrary extends core.Base {
    /**
      Creates a ToolLibrary by given JSON-string. Raises an error if the given JSON is invalid.
      @param json The JSON contains all tools that should be added to the new ToolLibrary
      @returns Returns the newly created ToolLibrary.
    */
    static createFromJson(json: string): ToolLibrary
    /**
      Creates an empty ToolLibrary.
      @returns Returns the newly created ToolLibrary.
    */
    static createEmpty(): ToolLibrary
    /**
      The number of tools in the ToolLibrary.
    */
    readonly count: number /*unsigned int*/
    /**
      Get Tool by index in ToolLibrary.
      @param index Index of the Tool in the ToolLibrary.
      @returns Returns the Tool in the ToolLibrary by given index.
    */
    item(index: number /*unsigned int*/): Tool
    /**
      Inserts a Tool at the end of the ToolLibrary.
      @param tool The Tool that should be added.
      @returns Returns true for successful insertion, false otherwise
    */
    add(tool: Tool): boolean
    /**
      Remove Tool by index from ToolLibrary.
      @param index Index of the Tool in the ToolLibrary that should be removed.
      @returns Returns true for successful deletion, false otherwise
    */
    remove(index: number /*unsigned int*/): boolean
    /**
      Generate and return JSON string that contains all tools of that list.
      @returns Returns JSON string that contains all tools of that list.
    */
    toJson(): string
    /**
      Creates a new ToolQuery that is used to query the library for tools matching
      the query.
      @returns Returns a new ToolQuery. The query is predefined by given parameter.
    */
    createQuery(): ToolQuery
  }

  /**
    DocumentToolLibrary provides access to tools used by the document. It supports
    adding, updating and deleting tools in the document tool library.
  */
  abstract class DocumentToolLibrary extends ToolLibrary {
    /**
      Returns all operations that use the given tool. The tool must exist in the document tool library.
      Raises an error if the tool is not in the document.
      @param tool The tool to search for in operations. The tool must exist in the document.
      @returns Returns operations using a specific tool.
    */
    operationsByTool(tool: Tool): Operation[]
    /**
      Update the given tool in the document tool library. The update applies all changes to the
      tool in the document tool library and therefore on all operations that use the tool.
      Will error if the tool does not exist in the document tool library.
      @param tool The tool that should be updated.
      @param updateFeedAndSpeed Setting updateFeedAndSpeed to true will override the feed and speed parameters of operations within the document which use the given tool.
      @returns Returns true if the update was successful.
    */
    update(tool: Tool, updateFeedAndSpeed: boolean): boolean
    /**
      Returns all tools used in a given setup or folder. Given setup or folder must belong to the document of the DocumentToolLibrary.
      Raises an error if given operation is not in the document.
      @param setupOrFolder The setup or folder to get tools from. Must belong to the document.
      @returns Returns tools used by a specific setup or folder.
    */
    toolsBySetupOrFolder(setupOrFolder: OperationBase): Tool[]
  }

  /**
    ToolQuery objects are used to search for a set of Tools or ToolLibrary objects inside of the ToolLibraries collection or for a set of Tools inside of a particular ToolLibrary.
  */
  abstract class ToolQuery extends core.Base {
    /**
      The case-insensitive vendor specifies the vendor of the tool. The default empty vendor applies to all tools.
    */
    vendor: string
    /**
      The URL specifies the location and folder to search for in the Tool library.
      Setting the URL updates the location.
      When searching inside a ToolLibrary the URL will be ignored.
    */
    url: core.URL
    /**
      Specifies the location to search in the Tool library.
      Setting the location clears any previous specified URL.
      When searching inside a ToolLibrary the location will be ignored.
    */
    location: LibraryLocations
    /**
      List of all criteria a tool must fulfill. Use the suffix '.min' and '.max', to define a upper and / or lower boundary for a particular value.
    */
    readonly criteria: core.NamedValues
    /**
      Query for specific a Tool or ToolLbrary.
      @returns Returns a list of `ToolQueryResult`. Each result references a Tool that matches this query.
    */
    execute(): ToolQueryResult[]
  }

  /**
    The ToolQueryResult represents one result item of a ToolQuery.
  */
  abstract class ToolQueryResult extends core.Base {
    /**
      The URL defines the location of the ToolLibrary asset in ToolLibraries.
    */
    readonly toolLibraryURL: core.URL
    /**
      The ToolLibrary contains a Tool that matches the query.
    */
    readonly toolLibrary: ToolLibrary
    /**
      The Tool that matches the query.
    */
    readonly tool: Tool
    /**
      The index specifies the index of the Tool inside the ToolLibrary.
    */
    readonly toolItemIndex: number /*int*/
  }

  /**
    Represents a Tool.
  */
  abstract class Tool extends core.Base {
    /**
      Creates a Tool object from given JSON string.
      @param json The JSON should fully define the tool and contain all tool parameters.
      If the JSON contains more than one tool, only the first Tool is loaded.
      @returns Returns the newly created Tool.
    */
    static createFromJson(json: string): Tool
    /**
      Gets the CAMParameters collection associated with this tool. This
      defines all of the settings that describe the details of the tool.
    */
    readonly parameters: CAMParameters
    /**
      Gets the ToolPresets collection associated with this tool.
    */
    readonly presets: ToolPresets
    /**
      Generates and returns a JSON string that contains a description of this tool.
      @returns Returns a JSON string that contains a description of this tool.
    */
    toJson(): string
    /**
      Creates a Tool object given a string containing a tool defined using the P21 format.
      Throws an error if the given string does not conform to the P21 format.
      @param p21 Creates a Tool object from the given P21 string.
      @returns Returns the newly created Tool.
    */
    static createFromP21(p21: string): Tool
  }

  /**
    ToolPresets represents a collection of ToolPreset.
    It provides access and allows the manipulation like removing and extending the list.
  */
  abstract class ToolPresets extends core.Base {
    /**
      The number of Presets of the owning Tool.
    */
    readonly count: number /*unsigned int*/
    /**
      Get Preset by index.
      @param index Index of the Preset in the owning Tool that should be returned.
      @returns Returns Preset at by given index, null otherwise
    */
    item(index: number /*unsigned int*/): ToolPreset | null
    /**
      Search presets by name. Returns all presets for which the name matches the given pattern.
      Compare is case insensitive and characters * and ? are used for wild-card matching.
      @param name Name of the Preset to search for. The string can define a pattern with wild-card matching.
      '*' represents an arbitrary sequence including the empty sequence and '?' represents one arbitrary character.
      @returns Returns all presets with matching name.
    */
    itemsByName(name: string): ToolPreset[]
    /**
      Creates and inserts a new Preset at the end of the Preset collection of the owning Tool.
      The new Preset will have the same values as the owning Tool.
      @returns Returns the newly created Preset
    */
    add(): ToolPreset
    /**
      Remove Preset by index from the owning Tool.
      @param index Index of the Preset in the Tool that should be removed.
      @returns Returns true for successful deletion, false otherwise
    */
    remove(index: number /*unsigned int*/): boolean
  }

  /**
    A Preset defines the material specific properties of a Tool.
  */
  abstract class ToolPreset extends core.Base {
    /**
      Gets and sets the name of that Preset.
    */
    name: string
    /**
      Gets and sets the identifier of that Preset. The id can be used to select a Preset for a Operation.
    */
    id: string
    /**
      Gets the CAMParameters collection for this Preset.
    */
    readonly parameters: CAMParameters
  }

  /**
    Class to manage the visibility of various elements of the setup.
  */
  abstract class SetupVisibilityManager extends core.Base {
    /**
      Controls the visibility of the setup's machine.
    */
    machineVisible: boolean
    /**
      Controls the visibility of the setup's machine base where it exists.
      This is always disabled for additive setups.
    */
    machineBaseVisible: boolean
  }
}

